// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: DSMessages.proto

#ifndef PROTOBUF_DSMessages_2eproto__INCLUDED
#define PROTOBUF_DSMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace ds_msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_DSMessages_2eproto();
void protobuf_AssignDesc_DSMessages_2eproto();
void protobuf_ShutdownFile_DSMessages_2eproto();

class SatInfo;
class Detection;
class DopplerTip;
class GeoRequest;
class GeoResponse;
class GeoPoint;
class ActiveList;
class InitiateGeo;
class SignalStatus;
class StatusRequest;

enum GeoRequest_Action {
  GeoRequest_Action_STOP = 0,
  GeoRequest_Action_START = 1,
  GeoRequest_Action_QUERY = 2,
  GeoRequest_Action_UPDATE = 3
};
bool GeoRequest_Action_IsValid(int value);
const GeoRequest_Action GeoRequest_Action_Action_MIN = GeoRequest_Action_STOP;
const GeoRequest_Action GeoRequest_Action_Action_MAX = GeoRequest_Action_UPDATE;
const int GeoRequest_Action_Action_ARRAYSIZE = GeoRequest_Action_Action_MAX + 1;

const ::google::protobuf::EnumDescriptor* GeoRequest_Action_descriptor();
inline const ::std::string& GeoRequest_Action_Name(GeoRequest_Action value) {
  return ::google::protobuf::internal::NameOfEnum(
    GeoRequest_Action_descriptor(), value);
}
inline bool GeoRequest_Action_Parse(
    const ::std::string& name, GeoRequest_Action* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GeoRequest_Action>(
    GeoRequest_Action_descriptor(), name, value);
}
enum GeoResponse_Status {
  GeoResponse_Status_FAILURE = 0,
  GeoResponse_Status_SUCCESS = 1,
  GeoResponse_Status_QUERY = 2,
  GeoResponse_Status_TRACKDOWN = 3
};
bool GeoResponse_Status_IsValid(int value);
const GeoResponse_Status GeoResponse_Status_Status_MIN = GeoResponse_Status_FAILURE;
const GeoResponse_Status GeoResponse_Status_Status_MAX = GeoResponse_Status_TRACKDOWN;
const int GeoResponse_Status_Status_ARRAYSIZE = GeoResponse_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* GeoResponse_Status_descriptor();
inline const ::std::string& GeoResponse_Status_Name(GeoResponse_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    GeoResponse_Status_descriptor(), value);
}
inline bool GeoResponse_Status_Parse(
    const ::std::string& name, GeoResponse_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GeoResponse_Status>(
    GeoResponse_Status_descriptor(), name, value);
}
// ===================================================================

class SatInfo : public ::google::protobuf::Message {
 public:
  SatInfo();
  virtual ~SatInfo();

  SatInfo(const SatInfo& from);

  inline SatInfo& operator=(const SatInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SatInfo& default_instance();

  void Swap(SatInfo* other);

  // implements Message ----------------------------------------------

  SatInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SatInfo& from);
  void MergeFrom(const SatInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ssc = 1;
  inline bool has_ssc() const;
  inline void clear_ssc();
  static const int kSscFieldNumber = 1;
  inline ::google::protobuf::int32 ssc() const;
  inline void set_ssc(::google::protobuf::int32 value);

  // optional string polarization = 2;
  inline bool has_polarization() const;
  inline void clear_polarization();
  static const int kPolarizationFieldNumber = 2;
  inline const ::std::string& polarization() const;
  inline void set_polarization(const ::std::string& value);
  inline void set_polarization(const char* value);
  inline void set_polarization(const char* value, size_t size);
  inline ::std::string* mutable_polarization();
  inline ::std::string* release_polarization();
  inline void set_allocated_polarization(::std::string* polarization);

  // optional string band = 3;
  inline bool has_band() const;
  inline void clear_band();
  static const int kBandFieldNumber = 3;
  inline const ::std::string& band() const;
  inline void set_band(const ::std::string& value);
  inline void set_band(const char* value);
  inline void set_band(const char* value, size_t size);
  inline ::std::string* mutable_band();
  inline ::std::string* release_band();
  inline void set_allocated_band(::std::string* band);

  // optional string satName = 4 [default = ""];
  inline bool has_satname() const;
  inline void clear_satname();
  static const int kSatNameFieldNumber = 4;
  inline const ::std::string& satname() const;
  inline void set_satname(const ::std::string& value);
  inline void set_satname(const char* value);
  inline void set_satname(const char* value, size_t size);
  inline ::std::string* mutable_satname();
  inline ::std::string* release_satname();
  inline void set_allocated_satname(::std::string* satname);

  // optional int32 rfSwitchIn = 5 [default = -1];
  inline bool has_rfswitchin() const;
  inline void clear_rfswitchin();
  static const int kRfSwitchInFieldNumber = 5;
  inline ::google::protobuf::int32 rfswitchin() const;
  inline void set_rfswitchin(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ds_msg.SatInfo)
 private:
  inline void set_has_ssc();
  inline void clear_has_ssc();
  inline void set_has_polarization();
  inline void clear_has_polarization();
  inline void set_has_band();
  inline void clear_has_band();
  inline void set_has_satname();
  inline void clear_has_satname();
  inline void set_has_rfswitchin();
  inline void clear_has_rfswitchin();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* polarization_;
  ::std::string* band_;
  ::google::protobuf::int32 ssc_;
  ::google::protobuf::int32 rfswitchin_;
  ::std::string* satname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_DSMessages_2eproto();
  friend void protobuf_AssignDesc_DSMessages_2eproto();
  friend void protobuf_ShutdownFile_DSMessages_2eproto();

  void InitAsDefaultInstance();
  static SatInfo* default_instance_;
};
// -------------------------------------------------------------------

class Detection : public ::google::protobuf::Message {
 public:
  Detection();
  virtual ~Detection();

  Detection(const Detection& from);

  inline Detection& operator=(const Detection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Detection& default_instance();

  void Swap(Detection* other);

  // implements Message ----------------------------------------------

  Detection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Detection& from);
  void MergeFrom(const Detection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double frequency = 1;
  inline bool has_frequency() const;
  inline void clear_frequency();
  static const int kFrequencyFieldNumber = 1;
  inline double frequency() const;
  inline void set_frequency(double value);

  // optional double bandwidth = 2;
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandwidthFieldNumber = 2;
  inline double bandwidth() const;
  inline void set_bandwidth(double value);

  // optional double snr = 3;
  inline bool has_snr() const;
  inline void clear_snr();
  static const int kSnrFieldNumber = 3;
  inline double snr() const;
  inline void set_snr(double value);

  // optional string firstTime = 4;
  inline bool has_firsttime() const;
  inline void clear_firsttime();
  static const int kFirstTimeFieldNumber = 4;
  inline const ::std::string& firsttime() const;
  inline void set_firsttime(const ::std::string& value);
  inline void set_firsttime(const char* value);
  inline void set_firsttime(const char* value, size_t size);
  inline ::std::string* mutable_firsttime();
  inline ::std::string* release_firsttime();
  inline void set_allocated_firsttime(::std::string* firsttime);

  // optional string lastTime = 5;
  inline bool has_lasttime() const;
  inline void clear_lasttime();
  static const int kLastTimeFieldNumber = 5;
  inline const ::std::string& lasttime() const;
  inline void set_lasttime(const ::std::string& value);
  inline void set_lasttime(const char* value);
  inline void set_lasttime(const char* value, size_t size);
  inline ::std::string* mutable_lasttime();
  inline ::std::string* release_lasttime();
  inline void set_allocated_lasttime(::std::string* lasttime);

  // optional int64 numDetects = 6;
  inline bool has_numdetects() const;
  inline void clear_numdetects();
  static const int kNumDetectsFieldNumber = 6;
  inline ::google::protobuf::int64 numdetects() const;
  inline void set_numdetects(::google::protobuf::int64 value);

  // optional string sigType = 7 [default = "UNK"];
  inline bool has_sigtype() const;
  inline void clear_sigtype();
  static const int kSigTypeFieldNumber = 7;
  inline const ::std::string& sigtype() const;
  inline void set_sigtype(const ::std::string& value);
  inline void set_sigtype(const char* value);
  inline void set_sigtype(const char* value, size_t size);
  inline ::std::string* mutable_sigtype();
  inline ::std::string* release_sigtype();
  inline void set_allocated_sigtype(::std::string* sigtype);

  // optional string sigUUID = 8;
  inline bool has_siguuid() const;
  inline void clear_siguuid();
  static const int kSigUUIDFieldNumber = 8;
  inline const ::std::string& siguuid() const;
  inline void set_siguuid(const ::std::string& value);
  inline void set_siguuid(const char* value);
  inline void set_siguuid(const char* value, size_t size);
  inline ::std::string* mutable_siguuid();
  inline ::std::string* release_siguuid();
  inline void set_allocated_siguuid(::std::string* siguuid);

  // optional bool ignore = 9 [default = false];
  inline bool has_ignore() const;
  inline void clear_ignore();
  static const int kIgnoreFieldNumber = 9;
  inline bool ignore() const;
  inline void set_ignore(bool value);

  // @@protoc_insertion_point(class_scope:ds_msg.Detection)
 private:
  inline void set_has_frequency();
  inline void clear_has_frequency();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();
  inline void set_has_snr();
  inline void clear_has_snr();
  inline void set_has_firsttime();
  inline void clear_has_firsttime();
  inline void set_has_lasttime();
  inline void clear_has_lasttime();
  inline void set_has_numdetects();
  inline void clear_has_numdetects();
  inline void set_has_sigtype();
  inline void clear_has_sigtype();
  inline void set_has_siguuid();
  inline void clear_has_siguuid();
  inline void set_has_ignore();
  inline void clear_has_ignore();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double frequency_;
  double bandwidth_;
  double snr_;
  ::std::string* firsttime_;
  ::std::string* lasttime_;
  ::google::protobuf::int64 numdetects_;
  ::std::string* sigtype_;
  static ::std::string* _default_sigtype_;
  ::std::string* siguuid_;
  bool ignore_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_DSMessages_2eproto();
  friend void protobuf_AssignDesc_DSMessages_2eproto();
  friend void protobuf_ShutdownFile_DSMessages_2eproto();

  void InitAsDefaultInstance();
  static Detection* default_instance_;
};
// -------------------------------------------------------------------

class DopplerTip : public ::google::protobuf::Message {
 public:
  DopplerTip();
  virtual ~DopplerTip();

  DopplerTip(const DopplerTip& from);

  inline DopplerTip& operator=(const DopplerTip& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DopplerTip& default_instance();

  void Swap(DopplerTip* other);

  // implements Message ----------------------------------------------

  DopplerTip* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DopplerTip& from);
  void MergeFrom(const DopplerTip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "DOPPLER_TIP"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional double dopplershift = 2;
  inline bool has_dopplershift() const;
  inline void clear_dopplershift();
  static const int kDopplershiftFieldNumber = 2;
  inline double dopplershift() const;
  inline void set_dopplershift(double value);

  // optional string timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  inline void set_allocated_timestamp(::std::string* timestamp);

  // optional double lat = 4;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 4;
  inline double lat() const;
  inline void set_lat(double value);

  // optional double lon = 5;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 5;
  inline double lon() const;
  inline void set_lon(double value);

  // optional double majoraxis = 6;
  inline bool has_majoraxis() const;
  inline void clear_majoraxis();
  static const int kMajoraxisFieldNumber = 6;
  inline double majoraxis() const;
  inline void set_majoraxis(double value);

  // optional double minoraxis = 7;
  inline bool has_minoraxis() const;
  inline void clear_minoraxis();
  static const int kMinoraxisFieldNumber = 7;
  inline double minoraxis() const;
  inline void set_minoraxis(double value);

  // optional double orientation = 8;
  inline bool has_orientation() const;
  inline void clear_orientation();
  static const int kOrientationFieldNumber = 8;
  inline double orientation() const;
  inline void set_orientation(double value);

  // optional string sigUUID = 9;
  inline bool has_siguuid() const;
  inline void clear_siguuid();
  static const int kSigUUIDFieldNumber = 9;
  inline const ::std::string& siguuid() const;
  inline void set_siguuid(const ::std::string& value);
  inline void set_siguuid(const char* value);
  inline void set_siguuid(const char* value, size_t size);
  inline ::std::string* mutable_siguuid();
  inline ::std::string* release_siguuid();
  inline void set_allocated_siguuid(::std::string* siguuid);

  // optional string classification = 10 [default = ""];
  inline bool has_classification() const;
  inline void clear_classification();
  static const int kClassificationFieldNumber = 10;
  inline const ::std::string& classification() const;
  inline void set_classification(const ::std::string& value);
  inline void set_classification(const char* value);
  inline void set_classification(const char* value, size_t size);
  inline ::std::string* mutable_classification();
  inline ::std::string* release_classification();
  inline void set_allocated_classification(::std::string* classification);

  // optional string msgID = 11 [default = ""];
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgIDFieldNumber = 11;
  inline const ::std::string& msgid() const;
  inline void set_msgid(const ::std::string& value);
  inline void set_msgid(const char* value);
  inline void set_msgid(const char* value, size_t size);
  inline ::std::string* mutable_msgid();
  inline ::std::string* release_msgid();
  inline void set_allocated_msgid(::std::string* msgid);

  // @@protoc_insertion_point(class_scope:ds_msg.DopplerTip)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_dopplershift();
  inline void clear_has_dopplershift();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_majoraxis();
  inline void clear_has_majoraxis();
  inline void set_has_minoraxis();
  inline void clear_has_minoraxis();
  inline void set_has_orientation();
  inline void clear_has_orientation();
  inline void set_has_siguuid();
  inline void clear_has_siguuid();
  inline void set_has_classification();
  inline void clear_has_classification();
  inline void set_has_msgid();
  inline void clear_has_msgid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  double dopplershift_;
  ::std::string* timestamp_;
  double lat_;
  double lon_;
  double majoraxis_;
  double minoraxis_;
  double orientation_;
  ::std::string* siguuid_;
  ::std::string* classification_;
  ::std::string* msgid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_DSMessages_2eproto();
  friend void protobuf_AssignDesc_DSMessages_2eproto();
  friend void protobuf_ShutdownFile_DSMessages_2eproto();

  void InitAsDefaultInstance();
  static DopplerTip* default_instance_;
};
// -------------------------------------------------------------------

class GeoRequest : public ::google::protobuf::Message {
 public:
  GeoRequest();
  virtual ~GeoRequest();

  GeoRequest(const GeoRequest& from);

  inline GeoRequest& operator=(const GeoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GeoRequest& default_instance();

  void Swap(GeoRequest* other);

  // implements Message ----------------------------------------------

  GeoRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GeoRequest& from);
  void MergeFrom(const GeoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GeoRequest_Action Action;
  static const Action STOP = GeoRequest_Action_STOP;
  static const Action START = GeoRequest_Action_START;
  static const Action QUERY = GeoRequest_Action_QUERY;
  static const Action UPDATE = GeoRequest_Action_UPDATE;
  static inline bool Action_IsValid(int value) {
    return GeoRequest_Action_IsValid(value);
  }
  static const Action Action_MIN =
    GeoRequest_Action_Action_MIN;
  static const Action Action_MAX =
    GeoRequest_Action_Action_MAX;
  static const int Action_ARRAYSIZE =
    GeoRequest_Action_Action_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Action_descriptor() {
    return GeoRequest_Action_descriptor();
  }
  static inline const ::std::string& Action_Name(Action value) {
    return GeoRequest_Action_Name(value);
  }
  static inline bool Action_Parse(const ::std::string& name,
      Action* value) {
    return GeoRequest_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "GEO_REQUEST"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional .ds_msg.GeoRequest.Action reqAction = 2 [default = STOP];
  inline bool has_reqaction() const;
  inline void clear_reqaction();
  static const int kReqActionFieldNumber = 2;
  inline ::ds_msg::GeoRequest_Action reqaction() const;
  inline void set_reqaction(::ds_msg::GeoRequest_Action value);

  // optional .ds_msg.Detection det = 3;
  inline bool has_det() const;
  inline void clear_det();
  static const int kDetFieldNumber = 3;
  inline const ::ds_msg::Detection& det() const;
  inline ::ds_msg::Detection* mutable_det();
  inline ::ds_msg::Detection* release_det();
  inline void set_allocated_det(::ds_msg::Detection* det);

  // optional .ds_msg.SatInfo sat = 4;
  inline bool has_sat() const;
  inline void clear_sat();
  static const int kSatFieldNumber = 4;
  inline const ::ds_msg::SatInfo& sat() const;
  inline ::ds_msg::SatInfo* mutable_sat();
  inline ::ds_msg::SatInfo* release_sat();
  inline void set_allocated_sat(::ds_msg::SatInfo* sat);

  // optional double lat = 5 [default = 1000];
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 5;
  inline double lat() const;
  inline void set_lat(double value);

  // optional double lon = 6 [default = 1000];
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 6;
  inline double lon() const;
  inline void set_lon(double value);

  // optional double alt = 7 [default = -1];
  inline bool has_alt() const;
  inline void clear_alt();
  static const int kAltFieldNumber = 7;
  inline double alt() const;
  inline void set_alt(double value);

  // optional string locTime = 8;
  inline bool has_loctime() const;
  inline void clear_loctime();
  static const int kLocTimeFieldNumber = 8;
  inline const ::std::string& loctime() const;
  inline void set_loctime(const ::std::string& value);
  inline void set_loctime(const char* value);
  inline void set_loctime(const char* value, size_t size);
  inline ::std::string* mutable_loctime();
  inline ::std::string* release_loctime();
  inline void set_allocated_loctime(::std::string* loctime);

  // optional int32 priority = 9 [default = 0];
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 9;
  inline ::google::protobuf::int32 priority() const;
  inline void set_priority(::google::protobuf::int32 value);

  // optional string classification = 10 [default = ""];
  inline bool has_classification() const;
  inline void clear_classification();
  static const int kClassificationFieldNumber = 10;
  inline const ::std::string& classification() const;
  inline void set_classification(const ::std::string& value);
  inline void set_classification(const char* value);
  inline void set_classification(const char* value, size_t size);
  inline ::std::string* mutable_classification();
  inline ::std::string* release_classification();
  inline void set_allocated_classification(::std::string* classification);

  // @@protoc_insertion_point(class_scope:ds_msg.GeoRequest)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_reqaction();
  inline void clear_has_reqaction();
  inline void set_has_det();
  inline void clear_has_det();
  inline void set_has_sat();
  inline void clear_has_sat();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_alt();
  inline void clear_has_alt();
  inline void set_has_loctime();
  inline void clear_has_loctime();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_classification();
  inline void clear_has_classification();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::ds_msg::Detection* det_;
  ::ds_msg::SatInfo* sat_;
  double lat_;
  int reqaction_;
  ::google::protobuf::int32 priority_;
  double lon_;
  double alt_;
  ::std::string* loctime_;
  ::std::string* classification_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_DSMessages_2eproto();
  friend void protobuf_AssignDesc_DSMessages_2eproto();
  friend void protobuf_ShutdownFile_DSMessages_2eproto();

  void InitAsDefaultInstance();
  static GeoRequest* default_instance_;
};
// -------------------------------------------------------------------

class GeoResponse : public ::google::protobuf::Message {
 public:
  GeoResponse();
  virtual ~GeoResponse();

  GeoResponse(const GeoResponse& from);

  inline GeoResponse& operator=(const GeoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GeoResponse& default_instance();

  void Swap(GeoResponse* other);

  // implements Message ----------------------------------------------

  GeoResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GeoResponse& from);
  void MergeFrom(const GeoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GeoResponse_Status Status;
  static const Status FAILURE = GeoResponse_Status_FAILURE;
  static const Status SUCCESS = GeoResponse_Status_SUCCESS;
  static const Status QUERY = GeoResponse_Status_QUERY;
  static const Status TRACKDOWN = GeoResponse_Status_TRACKDOWN;
  static inline bool Status_IsValid(int value) {
    return GeoResponse_Status_IsValid(value);
  }
  static const Status Status_MIN =
    GeoResponse_Status_Status_MIN;
  static const Status Status_MAX =
    GeoResponse_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    GeoResponse_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return GeoResponse_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return GeoResponse_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return GeoResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "GEO_RESPONSE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional .ds_msg.GeoResponse.Status outcome = 2;
  inline bool has_outcome() const;
  inline void clear_outcome();
  static const int kOutcomeFieldNumber = 2;
  inline ::ds_msg::GeoResponse_Status outcome() const;
  inline void set_outcome(::ds_msg::GeoResponse_Status value);

  // repeated string sigUUID = 3;
  inline int siguuid_size() const;
  inline void clear_siguuid();
  static const int kSigUUIDFieldNumber = 3;
  inline const ::std::string& siguuid(int index) const;
  inline ::std::string* mutable_siguuid(int index);
  inline void set_siguuid(int index, const ::std::string& value);
  inline void set_siguuid(int index, const char* value);
  inline void set_siguuid(int index, const char* value, size_t size);
  inline ::std::string* add_siguuid();
  inline void add_siguuid(const ::std::string& value);
  inline void add_siguuid(const char* value);
  inline void add_siguuid(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& siguuid() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_siguuid();

  // optional string classification = 4 [default = ""];
  inline bool has_classification() const;
  inline void clear_classification();
  static const int kClassificationFieldNumber = 4;
  inline const ::std::string& classification() const;
  inline void set_classification(const ::std::string& value);
  inline void set_classification(const char* value);
  inline void set_classification(const char* value, size_t size);
  inline ::std::string* mutable_classification();
  inline ::std::string* release_classification();
  inline void set_allocated_classification(::std::string* classification);

  // @@protoc_insertion_point(class_scope:ds_msg.GeoResponse)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_outcome();
  inline void clear_has_outcome();
  inline void set_has_classification();
  inline void clear_has_classification();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::RepeatedPtrField< ::std::string> siguuid_;
  ::std::string* classification_;
  int outcome_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_DSMessages_2eproto();
  friend void protobuf_AssignDesc_DSMessages_2eproto();
  friend void protobuf_ShutdownFile_DSMessages_2eproto();

  void InitAsDefaultInstance();
  static GeoResponse* default_instance_;
};
// -------------------------------------------------------------------

class GeoPoint : public ::google::protobuf::Message {
 public:
  GeoPoint();
  virtual ~GeoPoint();

  GeoPoint(const GeoPoint& from);

  inline GeoPoint& operator=(const GeoPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GeoPoint& default_instance();

  void Swap(GeoPoint* other);

  // implements Message ----------------------------------------------

  GeoPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GeoPoint& from);
  void MergeFrom(const GeoPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "GEO_POINT"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional double lat = 2;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 2;
  inline double lat() const;
  inline void set_lat(double value);

  // optional double lon = 3;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 3;
  inline double lon() const;
  inline void set_lon(double value);

  // optional double majoraxis = 4;
  inline bool has_majoraxis() const;
  inline void clear_majoraxis();
  static const int kMajoraxisFieldNumber = 4;
  inline double majoraxis() const;
  inline void set_majoraxis(double value);

  // optional double minoraxis = 5;
  inline bool has_minoraxis() const;
  inline void clear_minoraxis();
  static const int kMinoraxisFieldNumber = 5;
  inline double minoraxis() const;
  inline void set_minoraxis(double value);

  // optional double orientation = 6;
  inline bool has_orientation() const;
  inline void clear_orientation();
  static const int kOrientationFieldNumber = 6;
  inline double orientation() const;
  inline void set_orientation(double value);

  // optional double altitude = 7;
  inline bool has_altitude() const;
  inline void clear_altitude();
  static const int kAltitudeFieldNumber = 7;
  inline double altitude() const;
  inline void set_altitude(double value);

  // optional int32 altConf = 8;
  inline bool has_altconf() const;
  inline void clear_altconf();
  static const int kAltConfFieldNumber = 8;
  inline ::google::protobuf::int32 altconf() const;
  inline void set_altconf(::google::protobuf::int32 value);

  // optional double velocity = 9;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 9;
  inline double velocity() const;
  inline void set_velocity(double value);

  // optional int32 vConf = 10;
  inline bool has_vconf() const;
  inline void clear_vconf();
  static const int kVConfFieldNumber = 10;
  inline ::google::protobuf::int32 vconf() const;
  inline void set_vconf(::google::protobuf::int32 value);

  // optional double heading = 11;
  inline bool has_heading() const;
  inline void clear_heading();
  static const int kHeadingFieldNumber = 11;
  inline double heading() const;
  inline void set_heading(double value);

  // optional int32 headConf = 12;
  inline bool has_headconf() const;
  inline void clear_headconf();
  static const int kHeadConfFieldNumber = 12;
  inline ::google::protobuf::int32 headconf() const;
  inline void set_headconf(::google::protobuf::int32 value);

  // optional string covariance = 13;
  inline bool has_covariance() const;
  inline void clear_covariance();
  static const int kCovarianceFieldNumber = 13;
  inline const ::std::string& covariance() const;
  inline void set_covariance(const ::std::string& value);
  inline void set_covariance(const char* value);
  inline void set_covariance(const char* value, size_t size);
  inline ::std::string* mutable_covariance();
  inline ::std::string* release_covariance();
  inline void set_allocated_covariance(::std::string* covariance);

  // optional string sigUUID = 14;
  inline bool has_siguuid() const;
  inline void clear_siguuid();
  static const int kSigUUIDFieldNumber = 14;
  inline const ::std::string& siguuid() const;
  inline void set_siguuid(const ::std::string& value);
  inline void set_siguuid(const char* value);
  inline void set_siguuid(const char* value, size_t size);
  inline ::std::string* mutable_siguuid();
  inline ::std::string* release_siguuid();
  inline void set_allocated_siguuid(::std::string* siguuid);

  // optional string geoTime = 15;
  inline bool has_geotime() const;
  inline void clear_geotime();
  static const int kGeoTimeFieldNumber = 15;
  inline const ::std::string& geotime() const;
  inline void set_geotime(const ::std::string& value);
  inline void set_geotime(const char* value);
  inline void set_geotime(const char* value, size_t size);
  inline ::std::string* mutable_geotime();
  inline ::std::string* release_geotime();
  inline void set_allocated_geotime(::std::string* geotime);

  // optional string classification = 16 [default = ""];
  inline bool has_classification() const;
  inline void clear_classification();
  static const int kClassificationFieldNumber = 16;
  inline const ::std::string& classification() const;
  inline void set_classification(const ::std::string& value);
  inline void set_classification(const char* value);
  inline void set_classification(const char* value, size_t size);
  inline ::std::string* mutable_classification();
  inline ::std::string* release_classification();
  inline void set_allocated_classification(::std::string* classification);

  // @@protoc_insertion_point(class_scope:ds_msg.GeoPoint)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_majoraxis();
  inline void clear_has_majoraxis();
  inline void set_has_minoraxis();
  inline void clear_has_minoraxis();
  inline void set_has_orientation();
  inline void clear_has_orientation();
  inline void set_has_altitude();
  inline void clear_has_altitude();
  inline void set_has_altconf();
  inline void clear_has_altconf();
  inline void set_has_velocity();
  inline void clear_has_velocity();
  inline void set_has_vconf();
  inline void clear_has_vconf();
  inline void set_has_heading();
  inline void clear_has_heading();
  inline void set_has_headconf();
  inline void clear_has_headconf();
  inline void set_has_covariance();
  inline void clear_has_covariance();
  inline void set_has_siguuid();
  inline void clear_has_siguuid();
  inline void set_has_geotime();
  inline void clear_has_geotime();
  inline void set_has_classification();
  inline void clear_has_classification();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  double lat_;
  double lon_;
  double majoraxis_;
  double minoraxis_;
  double orientation_;
  double altitude_;
  double velocity_;
  ::google::protobuf::int32 altconf_;
  ::google::protobuf::int32 vconf_;
  double heading_;
  ::std::string* covariance_;
  ::std::string* siguuid_;
  ::std::string* geotime_;
  ::std::string* classification_;
  ::google::protobuf::int32 headconf_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_DSMessages_2eproto();
  friend void protobuf_AssignDesc_DSMessages_2eproto();
  friend void protobuf_ShutdownFile_DSMessages_2eproto();

  void InitAsDefaultInstance();
  static GeoPoint* default_instance_;
};
// -------------------------------------------------------------------

class ActiveList : public ::google::protobuf::Message {
 public:
  ActiveList();
  virtual ~ActiveList();

  ActiveList(const ActiveList& from);

  inline ActiveList& operator=(const ActiveList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActiveList& default_instance();

  void Swap(ActiveList* other);

  // implements Message ----------------------------------------------

  ActiveList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActiveList& from);
  void MergeFrom(const ActiveList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ACTIVE_LIST"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional .ds_msg.SatInfo sat = 2;
  inline bool has_sat() const;
  inline void clear_sat();
  static const int kSatFieldNumber = 2;
  inline const ::ds_msg::SatInfo& sat() const;
  inline ::ds_msg::SatInfo* mutable_sat();
  inline ::ds_msg::SatInfo* release_sat();
  inline void set_allocated_sat(::ds_msg::SatInfo* sat);

  // optional string msgID = 3 [default = ""];
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgIDFieldNumber = 3;
  inline const ::std::string& msgid() const;
  inline void set_msgid(const ::std::string& value);
  inline void set_msgid(const char* value);
  inline void set_msgid(const char* value, size_t size);
  inline ::std::string* mutable_msgid();
  inline ::std::string* release_msgid();
  inline void set_allocated_msgid(::std::string* msgid);

  // optional string classification = 4 [default = ""];
  inline bool has_classification() const;
  inline void clear_classification();
  static const int kClassificationFieldNumber = 4;
  inline const ::std::string& classification() const;
  inline void set_classification(const ::std::string& value);
  inline void set_classification(const char* value);
  inline void set_classification(const char* value, size_t size);
  inline ::std::string* mutable_classification();
  inline ::std::string* release_classification();
  inline void set_allocated_classification(::std::string* classification);

  // repeated .ds_msg.Detection det = 5;
  inline int det_size() const;
  inline void clear_det();
  static const int kDetFieldNumber = 5;
  inline const ::ds_msg::Detection& det(int index) const;
  inline ::ds_msg::Detection* mutable_det(int index);
  inline ::ds_msg::Detection* add_det();
  inline const ::google::protobuf::RepeatedPtrField< ::ds_msg::Detection >&
      det() const;
  inline ::google::protobuf::RepeatedPtrField< ::ds_msg::Detection >*
      mutable_det();

  // @@protoc_insertion_point(class_scope:ds_msg.ActiveList)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_sat();
  inline void clear_has_sat();
  inline void set_has_msgid();
  inline void clear_has_msgid();
  inline void set_has_classification();
  inline void clear_has_classification();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::ds_msg::SatInfo* sat_;
  ::std::string* msgid_;
  ::std::string* classification_;
  ::google::protobuf::RepeatedPtrField< ::ds_msg::Detection > det_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_DSMessages_2eproto();
  friend void protobuf_AssignDesc_DSMessages_2eproto();
  friend void protobuf_ShutdownFile_DSMessages_2eproto();

  void InitAsDefaultInstance();
  static ActiveList* default_instance_;
};
// -------------------------------------------------------------------

class InitiateGeo : public ::google::protobuf::Message {
 public:
  InitiateGeo();
  virtual ~InitiateGeo();

  InitiateGeo(const InitiateGeo& from);

  inline InitiateGeo& operator=(const InitiateGeo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InitiateGeo& default_instance();

  void Swap(InitiateGeo* other);

  // implements Message ----------------------------------------------

  InitiateGeo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InitiateGeo& from);
  void MergeFrom(const InitiateGeo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "INITIATE_GEO"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string sigUUID = 2;
  inline bool has_siguuid() const;
  inline void clear_siguuid();
  static const int kSigUUIDFieldNumber = 2;
  inline const ::std::string& siguuid() const;
  inline void set_siguuid(const ::std::string& value);
  inline void set_siguuid(const char* value);
  inline void set_siguuid(const char* value, size_t size);
  inline ::std::string* mutable_siguuid();
  inline ::std::string* release_siguuid();
  inline void set_allocated_siguuid(::std::string* siguuid);

  // optional int32 priority = 3 [default = 0];
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 3;
  inline ::google::protobuf::int32 priority() const;
  inline void set_priority(::google::protobuf::int32 value);

  // optional double duration = 4 [default = 300];
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 4;
  inline double duration() const;
  inline void set_duration(double value);

  // optional bool force = 5 [default = false];
  inline bool has_force() const;
  inline void clear_force();
  static const int kForceFieldNumber = 5;
  inline bool force() const;
  inline void set_force(bool value);

  // @@protoc_insertion_point(class_scope:ds_msg.InitiateGeo)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_siguuid();
  inline void clear_has_siguuid();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_force();
  inline void clear_has_force();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* siguuid_;
  double duration_;
  ::google::protobuf::int32 priority_;
  bool force_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_DSMessages_2eproto();
  friend void protobuf_AssignDesc_DSMessages_2eproto();
  friend void protobuf_ShutdownFile_DSMessages_2eproto();

  void InitAsDefaultInstance();
  static InitiateGeo* default_instance_;
};
// -------------------------------------------------------------------

class SignalStatus : public ::google::protobuf::Message {
 public:
  SignalStatus();
  virtual ~SignalStatus();

  SignalStatus(const SignalStatus& from);

  inline SignalStatus& operator=(const SignalStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignalStatus& default_instance();

  void Swap(SignalStatus* other);

  // implements Message ----------------------------------------------

  SignalStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignalStatus& from);
  void MergeFrom(const SignalStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SIGNAL_STATUS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string sigUUID = 2;
  inline bool has_siguuid() const;
  inline void clear_siguuid();
  static const int kSigUUIDFieldNumber = 2;
  inline const ::std::string& siguuid() const;
  inline void set_siguuid(const ::std::string& value);
  inline void set_siguuid(const char* value);
  inline void set_siguuid(const char* value, size_t size);
  inline ::std::string* mutable_siguuid();
  inline ::std::string* release_siguuid();
  inline void set_allocated_siguuid(::std::string* siguuid);

  // optional string sigType = 3;
  inline bool has_sigtype() const;
  inline void clear_sigtype();
  static const int kSigTypeFieldNumber = 3;
  inline const ::std::string& sigtype() const;
  inline void set_sigtype(const ::std::string& value);
  inline void set_sigtype(const char* value);
  inline void set_sigtype(const char* value, size_t size);
  inline ::std::string* mutable_sigtype();
  inline ::std::string* release_sigtype();
  inline void set_allocated_sigtype(::std::string* sigtype);

  // optional bool proc = 4;
  inline bool has_proc() const;
  inline void clear_proc();
  static const int kProcFieldNumber = 4;
  inline bool proc() const;
  inline void set_proc(bool value);

  // optional string geoStatus = 5;
  inline bool has_geostatus() const;
  inline void clear_geostatus();
  static const int kGeoStatusFieldNumber = 5;
  inline const ::std::string& geostatus() const;
  inline void set_geostatus(const ::std::string& value);
  inline void set_geostatus(const char* value);
  inline void set_geostatus(const char* value, size_t size);
  inline ::std::string* mutable_geostatus();
  inline ::std::string* release_geostatus();
  inline void set_allocated_geostatus(::std::string* geostatus);

  // optional bool telemAvail = 6;
  inline bool has_telemavail() const;
  inline void clear_telemavail();
  static const int kTelemAvailFieldNumber = 6;
  inline bool telemavail() const;
  inline void set_telemavail(bool value);

  // optional string telemLastTime = 7;
  inline bool has_telemlasttime() const;
  inline void clear_telemlasttime();
  static const int kTelemLastTimeFieldNumber = 7;
  inline const ::std::string& telemlasttime() const;
  inline void set_telemlasttime(const ::std::string& value);
  inline void set_telemlasttime(const char* value);
  inline void set_telemlasttime(const char* value, size_t size);
  inline ::std::string* mutable_telemlasttime();
  inline ::std::string* release_telemlasttime();
  inline void set_allocated_telemlasttime(::std::string* telemlasttime);

  // optional int64 geoPri = 8;
  inline bool has_geopri() const;
  inline void clear_geopri();
  static const int kGeoPriFieldNumber = 8;
  inline ::google::protobuf::int64 geopri() const;
  inline void set_geopri(::google::protobuf::int64 value);

  // optional string eventID = 9;
  inline bool has_eventid() const;
  inline void clear_eventid();
  static const int kEventIDFieldNumber = 9;
  inline const ::std::string& eventid() const;
  inline void set_eventid(const ::std::string& value);
  inline void set_eventid(const char* value);
  inline void set_eventid(const char* value, size_t size);
  inline ::std::string* mutable_eventid();
  inline ::std::string* release_eventid();
  inline void set_allocated_eventid(::std::string* eventid);

  // optional string sigName = 10;
  inline bool has_signame() const;
  inline void clear_signame();
  static const int kSigNameFieldNumber = 10;
  inline const ::std::string& signame() const;
  inline void set_signame(const ::std::string& value);
  inline void set_signame(const char* value);
  inline void set_signame(const char* value, size_t size);
  inline ::std::string* mutable_signame();
  inline ::std::string* release_signame();
  inline void set_allocated_signame(::std::string* signame);

  // @@protoc_insertion_point(class_scope:ds_msg.SignalStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_siguuid();
  inline void clear_has_siguuid();
  inline void set_has_sigtype();
  inline void clear_has_sigtype();
  inline void set_has_proc();
  inline void clear_has_proc();
  inline void set_has_geostatus();
  inline void clear_has_geostatus();
  inline void set_has_telemavail();
  inline void clear_has_telemavail();
  inline void set_has_telemlasttime();
  inline void clear_has_telemlasttime();
  inline void set_has_geopri();
  inline void clear_has_geopri();
  inline void set_has_eventid();
  inline void clear_has_eventid();
  inline void set_has_signame();
  inline void clear_has_signame();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* siguuid_;
  ::std::string* sigtype_;
  ::std::string* geostatus_;
  ::std::string* telemlasttime_;
  ::google::protobuf::int64 geopri_;
  ::std::string* eventid_;
  ::std::string* signame_;
  bool proc_;
  bool telemavail_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_DSMessages_2eproto();
  friend void protobuf_AssignDesc_DSMessages_2eproto();
  friend void protobuf_ShutdownFile_DSMessages_2eproto();

  void InitAsDefaultInstance();
  static SignalStatus* default_instance_;
};
// -------------------------------------------------------------------

class StatusRequest : public ::google::protobuf::Message {
 public:
  StatusRequest();
  virtual ~StatusRequest();

  StatusRequest(const StatusRequest& from);

  inline StatusRequest& operator=(const StatusRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusRequest& default_instance();

  void Swap(StatusRequest* other);

  // implements Message ----------------------------------------------

  StatusRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatusRequest& from);
  void MergeFrom(const StatusRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "STAT_REQ"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string sigUUID = 2;
  inline bool has_siguuid() const;
  inline void clear_siguuid();
  static const int kSigUUIDFieldNumber = 2;
  inline const ::std::string& siguuid() const;
  inline void set_siguuid(const ::std::string& value);
  inline void set_siguuid(const char* value);
  inline void set_siguuid(const char* value, size_t size);
  inline ::std::string* mutable_siguuid();
  inline ::std::string* release_siguuid();
  inline void set_allocated_siguuid(::std::string* siguuid);

  // @@protoc_insertion_point(class_scope:ds_msg.StatusRequest)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_siguuid();
  inline void clear_has_siguuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* siguuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_DSMessages_2eproto();
  friend void protobuf_AssignDesc_DSMessages_2eproto();
  friend void protobuf_ShutdownFile_DSMessages_2eproto();

  void InitAsDefaultInstance();
  static StatusRequest* default_instance_;
};
// ===================================================================


// ===================================================================

// SatInfo

// optional int32 ssc = 1;
inline bool SatInfo::has_ssc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SatInfo::set_has_ssc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SatInfo::clear_has_ssc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SatInfo::clear_ssc() {
  ssc_ = 0;
  clear_has_ssc();
}
inline ::google::protobuf::int32 SatInfo::ssc() const {
  return ssc_;
}
inline void SatInfo::set_ssc(::google::protobuf::int32 value) {
  set_has_ssc();
  ssc_ = value;
}

// optional string polarization = 2;
inline bool SatInfo::has_polarization() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SatInfo::set_has_polarization() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SatInfo::clear_has_polarization() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SatInfo::clear_polarization() {
  if (polarization_ != &::google::protobuf::internal::kEmptyString) {
    polarization_->clear();
  }
  clear_has_polarization();
}
inline const ::std::string& SatInfo::polarization() const {
  return *polarization_;
}
inline void SatInfo::set_polarization(const ::std::string& value) {
  set_has_polarization();
  if (polarization_ == &::google::protobuf::internal::kEmptyString) {
    polarization_ = new ::std::string;
  }
  polarization_->assign(value);
}
inline void SatInfo::set_polarization(const char* value) {
  set_has_polarization();
  if (polarization_ == &::google::protobuf::internal::kEmptyString) {
    polarization_ = new ::std::string;
  }
  polarization_->assign(value);
}
inline void SatInfo::set_polarization(const char* value, size_t size) {
  set_has_polarization();
  if (polarization_ == &::google::protobuf::internal::kEmptyString) {
    polarization_ = new ::std::string;
  }
  polarization_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SatInfo::mutable_polarization() {
  set_has_polarization();
  if (polarization_ == &::google::protobuf::internal::kEmptyString) {
    polarization_ = new ::std::string;
  }
  return polarization_;
}
inline ::std::string* SatInfo::release_polarization() {
  clear_has_polarization();
  if (polarization_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = polarization_;
    polarization_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SatInfo::set_allocated_polarization(::std::string* polarization) {
  if (polarization_ != &::google::protobuf::internal::kEmptyString) {
    delete polarization_;
  }
  if (polarization) {
    set_has_polarization();
    polarization_ = polarization;
  } else {
    clear_has_polarization();
    polarization_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string band = 3;
inline bool SatInfo::has_band() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SatInfo::set_has_band() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SatInfo::clear_has_band() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SatInfo::clear_band() {
  if (band_ != &::google::protobuf::internal::kEmptyString) {
    band_->clear();
  }
  clear_has_band();
}
inline const ::std::string& SatInfo::band() const {
  return *band_;
}
inline void SatInfo::set_band(const ::std::string& value) {
  set_has_band();
  if (band_ == &::google::protobuf::internal::kEmptyString) {
    band_ = new ::std::string;
  }
  band_->assign(value);
}
inline void SatInfo::set_band(const char* value) {
  set_has_band();
  if (band_ == &::google::protobuf::internal::kEmptyString) {
    band_ = new ::std::string;
  }
  band_->assign(value);
}
inline void SatInfo::set_band(const char* value, size_t size) {
  set_has_band();
  if (band_ == &::google::protobuf::internal::kEmptyString) {
    band_ = new ::std::string;
  }
  band_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SatInfo::mutable_band() {
  set_has_band();
  if (band_ == &::google::protobuf::internal::kEmptyString) {
    band_ = new ::std::string;
  }
  return band_;
}
inline ::std::string* SatInfo::release_band() {
  clear_has_band();
  if (band_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = band_;
    band_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SatInfo::set_allocated_band(::std::string* band) {
  if (band_ != &::google::protobuf::internal::kEmptyString) {
    delete band_;
  }
  if (band) {
    set_has_band();
    band_ = band;
  } else {
    clear_has_band();
    band_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string satName = 4 [default = ""];
inline bool SatInfo::has_satname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SatInfo::set_has_satname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SatInfo::clear_has_satname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SatInfo::clear_satname() {
  if (satname_ != &::google::protobuf::internal::kEmptyString) {
    satname_->clear();
  }
  clear_has_satname();
}
inline const ::std::string& SatInfo::satname() const {
  return *satname_;
}
inline void SatInfo::set_satname(const ::std::string& value) {
  set_has_satname();
  if (satname_ == &::google::protobuf::internal::kEmptyString) {
    satname_ = new ::std::string;
  }
  satname_->assign(value);
}
inline void SatInfo::set_satname(const char* value) {
  set_has_satname();
  if (satname_ == &::google::protobuf::internal::kEmptyString) {
    satname_ = new ::std::string;
  }
  satname_->assign(value);
}
inline void SatInfo::set_satname(const char* value, size_t size) {
  set_has_satname();
  if (satname_ == &::google::protobuf::internal::kEmptyString) {
    satname_ = new ::std::string;
  }
  satname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SatInfo::mutable_satname() {
  set_has_satname();
  if (satname_ == &::google::protobuf::internal::kEmptyString) {
    satname_ = new ::std::string;
  }
  return satname_;
}
inline ::std::string* SatInfo::release_satname() {
  clear_has_satname();
  if (satname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = satname_;
    satname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SatInfo::set_allocated_satname(::std::string* satname) {
  if (satname_ != &::google::protobuf::internal::kEmptyString) {
    delete satname_;
  }
  if (satname) {
    set_has_satname();
    satname_ = satname;
  } else {
    clear_has_satname();
    satname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 rfSwitchIn = 5 [default = -1];
inline bool SatInfo::has_rfswitchin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SatInfo::set_has_rfswitchin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SatInfo::clear_has_rfswitchin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SatInfo::clear_rfswitchin() {
  rfswitchin_ = -1;
  clear_has_rfswitchin();
}
inline ::google::protobuf::int32 SatInfo::rfswitchin() const {
  return rfswitchin_;
}
inline void SatInfo::set_rfswitchin(::google::protobuf::int32 value) {
  set_has_rfswitchin();
  rfswitchin_ = value;
}

// -------------------------------------------------------------------

// Detection

// optional double frequency = 1;
inline bool Detection::has_frequency() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Detection::set_has_frequency() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Detection::clear_has_frequency() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Detection::clear_frequency() {
  frequency_ = 0;
  clear_has_frequency();
}
inline double Detection::frequency() const {
  return frequency_;
}
inline void Detection::set_frequency(double value) {
  set_has_frequency();
  frequency_ = value;
}

// optional double bandwidth = 2;
inline bool Detection::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Detection::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Detection::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Detection::clear_bandwidth() {
  bandwidth_ = 0;
  clear_has_bandwidth();
}
inline double Detection::bandwidth() const {
  return bandwidth_;
}
inline void Detection::set_bandwidth(double value) {
  set_has_bandwidth();
  bandwidth_ = value;
}

// optional double snr = 3;
inline bool Detection::has_snr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Detection::set_has_snr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Detection::clear_has_snr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Detection::clear_snr() {
  snr_ = 0;
  clear_has_snr();
}
inline double Detection::snr() const {
  return snr_;
}
inline void Detection::set_snr(double value) {
  set_has_snr();
  snr_ = value;
}

// optional string firstTime = 4;
inline bool Detection::has_firsttime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Detection::set_has_firsttime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Detection::clear_has_firsttime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Detection::clear_firsttime() {
  if (firsttime_ != &::google::protobuf::internal::kEmptyString) {
    firsttime_->clear();
  }
  clear_has_firsttime();
}
inline const ::std::string& Detection::firsttime() const {
  return *firsttime_;
}
inline void Detection::set_firsttime(const ::std::string& value) {
  set_has_firsttime();
  if (firsttime_ == &::google::protobuf::internal::kEmptyString) {
    firsttime_ = new ::std::string;
  }
  firsttime_->assign(value);
}
inline void Detection::set_firsttime(const char* value) {
  set_has_firsttime();
  if (firsttime_ == &::google::protobuf::internal::kEmptyString) {
    firsttime_ = new ::std::string;
  }
  firsttime_->assign(value);
}
inline void Detection::set_firsttime(const char* value, size_t size) {
  set_has_firsttime();
  if (firsttime_ == &::google::protobuf::internal::kEmptyString) {
    firsttime_ = new ::std::string;
  }
  firsttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Detection::mutable_firsttime() {
  set_has_firsttime();
  if (firsttime_ == &::google::protobuf::internal::kEmptyString) {
    firsttime_ = new ::std::string;
  }
  return firsttime_;
}
inline ::std::string* Detection::release_firsttime() {
  clear_has_firsttime();
  if (firsttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = firsttime_;
    firsttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Detection::set_allocated_firsttime(::std::string* firsttime) {
  if (firsttime_ != &::google::protobuf::internal::kEmptyString) {
    delete firsttime_;
  }
  if (firsttime) {
    set_has_firsttime();
    firsttime_ = firsttime;
  } else {
    clear_has_firsttime();
    firsttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string lastTime = 5;
inline bool Detection::has_lasttime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Detection::set_has_lasttime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Detection::clear_has_lasttime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Detection::clear_lasttime() {
  if (lasttime_ != &::google::protobuf::internal::kEmptyString) {
    lasttime_->clear();
  }
  clear_has_lasttime();
}
inline const ::std::string& Detection::lasttime() const {
  return *lasttime_;
}
inline void Detection::set_lasttime(const ::std::string& value) {
  set_has_lasttime();
  if (lasttime_ == &::google::protobuf::internal::kEmptyString) {
    lasttime_ = new ::std::string;
  }
  lasttime_->assign(value);
}
inline void Detection::set_lasttime(const char* value) {
  set_has_lasttime();
  if (lasttime_ == &::google::protobuf::internal::kEmptyString) {
    lasttime_ = new ::std::string;
  }
  lasttime_->assign(value);
}
inline void Detection::set_lasttime(const char* value, size_t size) {
  set_has_lasttime();
  if (lasttime_ == &::google::protobuf::internal::kEmptyString) {
    lasttime_ = new ::std::string;
  }
  lasttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Detection::mutable_lasttime() {
  set_has_lasttime();
  if (lasttime_ == &::google::protobuf::internal::kEmptyString) {
    lasttime_ = new ::std::string;
  }
  return lasttime_;
}
inline ::std::string* Detection::release_lasttime() {
  clear_has_lasttime();
  if (lasttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lasttime_;
    lasttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Detection::set_allocated_lasttime(::std::string* lasttime) {
  if (lasttime_ != &::google::protobuf::internal::kEmptyString) {
    delete lasttime_;
  }
  if (lasttime) {
    set_has_lasttime();
    lasttime_ = lasttime;
  } else {
    clear_has_lasttime();
    lasttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 numDetects = 6;
inline bool Detection::has_numdetects() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Detection::set_has_numdetects() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Detection::clear_has_numdetects() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Detection::clear_numdetects() {
  numdetects_ = GOOGLE_LONGLONG(0);
  clear_has_numdetects();
}
inline ::google::protobuf::int64 Detection::numdetects() const {
  return numdetects_;
}
inline void Detection::set_numdetects(::google::protobuf::int64 value) {
  set_has_numdetects();
  numdetects_ = value;
}

// optional string sigType = 7 [default = "UNK"];
inline bool Detection::has_sigtype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Detection::set_has_sigtype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Detection::clear_has_sigtype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Detection::clear_sigtype() {
  if (sigtype_ != _default_sigtype_) {
    sigtype_->assign(*_default_sigtype_);
  }
  clear_has_sigtype();
}
inline const ::std::string& Detection::sigtype() const {
  return *sigtype_;
}
inline void Detection::set_sigtype(const ::std::string& value) {
  set_has_sigtype();
  if (sigtype_ == _default_sigtype_) {
    sigtype_ = new ::std::string;
  }
  sigtype_->assign(value);
}
inline void Detection::set_sigtype(const char* value) {
  set_has_sigtype();
  if (sigtype_ == _default_sigtype_) {
    sigtype_ = new ::std::string;
  }
  sigtype_->assign(value);
}
inline void Detection::set_sigtype(const char* value, size_t size) {
  set_has_sigtype();
  if (sigtype_ == _default_sigtype_) {
    sigtype_ = new ::std::string;
  }
  sigtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Detection::mutable_sigtype() {
  set_has_sigtype();
  if (sigtype_ == _default_sigtype_) {
    sigtype_ = new ::std::string(*_default_sigtype_);
  }
  return sigtype_;
}
inline ::std::string* Detection::release_sigtype() {
  clear_has_sigtype();
  if (sigtype_ == _default_sigtype_) {
    return NULL;
  } else {
    ::std::string* temp = sigtype_;
    sigtype_ = const_cast< ::std::string*>(_default_sigtype_);
    return temp;
  }
}
inline void Detection::set_allocated_sigtype(::std::string* sigtype) {
  if (sigtype_ != _default_sigtype_) {
    delete sigtype_;
  }
  if (sigtype) {
    set_has_sigtype();
    sigtype_ = sigtype;
  } else {
    clear_has_sigtype();
    sigtype_ = const_cast< ::std::string*>(_default_sigtype_);
  }
}

// optional string sigUUID = 8;
inline bool Detection::has_siguuid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Detection::set_has_siguuid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Detection::clear_has_siguuid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Detection::clear_siguuid() {
  if (siguuid_ != &::google::protobuf::internal::kEmptyString) {
    siguuid_->clear();
  }
  clear_has_siguuid();
}
inline const ::std::string& Detection::siguuid() const {
  return *siguuid_;
}
inline void Detection::set_siguuid(const ::std::string& value) {
  set_has_siguuid();
  if (siguuid_ == &::google::protobuf::internal::kEmptyString) {
    siguuid_ = new ::std::string;
  }
  siguuid_->assign(value);
}
inline void Detection::set_siguuid(const char* value) {
  set_has_siguuid();
  if (siguuid_ == &::google::protobuf::internal::kEmptyString) {
    siguuid_ = new ::std::string;
  }
  siguuid_->assign(value);
}
inline void Detection::set_siguuid(const char* value, size_t size) {
  set_has_siguuid();
  if (siguuid_ == &::google::protobuf::internal::kEmptyString) {
    siguuid_ = new ::std::string;
  }
  siguuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Detection::mutable_siguuid() {
  set_has_siguuid();
  if (siguuid_ == &::google::protobuf::internal::kEmptyString) {
    siguuid_ = new ::std::string;
  }
  return siguuid_;
}
inline ::std::string* Detection::release_siguuid() {
  clear_has_siguuid();
  if (siguuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = siguuid_;
    siguuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Detection::set_allocated_siguuid(::std::string* siguuid) {
  if (siguuid_ != &::google::protobuf::internal::kEmptyString) {
    delete siguuid_;
  }
  if (siguuid) {
    set_has_siguuid();
    siguuid_ = siguuid;
  } else {
    clear_has_siguuid();
    siguuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool ignore = 9 [default = false];
inline bool Detection::has_ignore() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Detection::set_has_ignore() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Detection::clear_has_ignore() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Detection::clear_ignore() {
  ignore_ = false;
  clear_has_ignore();
}
inline bool Detection::ignore() const {
  return ignore_;
}
inline void Detection::set_ignore(bool value) {
  set_has_ignore();
  ignore_ = value;
}

// -------------------------------------------------------------------

// DopplerTip

// optional string msgName = 1 [default = "DOPPLER_TIP"];
inline bool DopplerTip::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DopplerTip::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DopplerTip::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DopplerTip::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& DopplerTip::msgname() const {
  return *msgname_;
}
inline void DopplerTip::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void DopplerTip::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void DopplerTip::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DopplerTip::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* DopplerTip::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void DopplerTip::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional double dopplershift = 2;
inline bool DopplerTip::has_dopplershift() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DopplerTip::set_has_dopplershift() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DopplerTip::clear_has_dopplershift() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DopplerTip::clear_dopplershift() {
  dopplershift_ = 0;
  clear_has_dopplershift();
}
inline double DopplerTip::dopplershift() const {
  return dopplershift_;
}
inline void DopplerTip::set_dopplershift(double value) {
  set_has_dopplershift();
  dopplershift_ = value;
}

// optional string timestamp = 3;
inline bool DopplerTip::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DopplerTip::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DopplerTip::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DopplerTip::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& DopplerTip::timestamp() const {
  return *timestamp_;
}
inline void DopplerTip::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void DopplerTip::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void DopplerTip::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DopplerTip::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* DopplerTip::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DopplerTip::set_allocated_timestamp(::std::string* timestamp) {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    delete timestamp_;
  }
  if (timestamp) {
    set_has_timestamp();
    timestamp_ = timestamp;
  } else {
    clear_has_timestamp();
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double lat = 4;
inline bool DopplerTip::has_lat() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DopplerTip::set_has_lat() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DopplerTip::clear_has_lat() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DopplerTip::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline double DopplerTip::lat() const {
  return lat_;
}
inline void DopplerTip::set_lat(double value) {
  set_has_lat();
  lat_ = value;
}

// optional double lon = 5;
inline bool DopplerTip::has_lon() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DopplerTip::set_has_lon() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DopplerTip::clear_has_lon() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DopplerTip::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline double DopplerTip::lon() const {
  return lon_;
}
inline void DopplerTip::set_lon(double value) {
  set_has_lon();
  lon_ = value;
}

// optional double majoraxis = 6;
inline bool DopplerTip::has_majoraxis() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DopplerTip::set_has_majoraxis() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DopplerTip::clear_has_majoraxis() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DopplerTip::clear_majoraxis() {
  majoraxis_ = 0;
  clear_has_majoraxis();
}
inline double DopplerTip::majoraxis() const {
  return majoraxis_;
}
inline void DopplerTip::set_majoraxis(double value) {
  set_has_majoraxis();
  majoraxis_ = value;
}

// optional double minoraxis = 7;
inline bool DopplerTip::has_minoraxis() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DopplerTip::set_has_minoraxis() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DopplerTip::clear_has_minoraxis() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DopplerTip::clear_minoraxis() {
  minoraxis_ = 0;
  clear_has_minoraxis();
}
inline double DopplerTip::minoraxis() const {
  return minoraxis_;
}
inline void DopplerTip::set_minoraxis(double value) {
  set_has_minoraxis();
  minoraxis_ = value;
}

// optional double orientation = 8;
inline bool DopplerTip::has_orientation() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DopplerTip::set_has_orientation() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DopplerTip::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DopplerTip::clear_orientation() {
  orientation_ = 0;
  clear_has_orientation();
}
inline double DopplerTip::orientation() const {
  return orientation_;
}
inline void DopplerTip::set_orientation(double value) {
  set_has_orientation();
  orientation_ = value;
}

// optional string sigUUID = 9;
inline bool DopplerTip::has_siguuid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DopplerTip::set_has_siguuid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DopplerTip::clear_has_siguuid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DopplerTip::clear_siguuid() {
  if (siguuid_ != &::google::protobuf::internal::kEmptyString) {
    siguuid_->clear();
  }
  clear_has_siguuid();
}
inline const ::std::string& DopplerTip::siguuid() const {
  return *siguuid_;
}
inline void DopplerTip::set_siguuid(const ::std::string& value) {
  set_has_siguuid();
  if (siguuid_ == &::google::protobuf::internal::kEmptyString) {
    siguuid_ = new ::std::string;
  }
  siguuid_->assign(value);
}
inline void DopplerTip::set_siguuid(const char* value) {
  set_has_siguuid();
  if (siguuid_ == &::google::protobuf::internal::kEmptyString) {
    siguuid_ = new ::std::string;
  }
  siguuid_->assign(value);
}
inline void DopplerTip::set_siguuid(const char* value, size_t size) {
  set_has_siguuid();
  if (siguuid_ == &::google::protobuf::internal::kEmptyString) {
    siguuid_ = new ::std::string;
  }
  siguuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DopplerTip::mutable_siguuid() {
  set_has_siguuid();
  if (siguuid_ == &::google::protobuf::internal::kEmptyString) {
    siguuid_ = new ::std::string;
  }
  return siguuid_;
}
inline ::std::string* DopplerTip::release_siguuid() {
  clear_has_siguuid();
  if (siguuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = siguuid_;
    siguuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DopplerTip::set_allocated_siguuid(::std::string* siguuid) {
  if (siguuid_ != &::google::protobuf::internal::kEmptyString) {
    delete siguuid_;
  }
  if (siguuid) {
    set_has_siguuid();
    siguuid_ = siguuid;
  } else {
    clear_has_siguuid();
    siguuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string classification = 10 [default = ""];
inline bool DopplerTip::has_classification() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DopplerTip::set_has_classification() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DopplerTip::clear_has_classification() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DopplerTip::clear_classification() {
  if (classification_ != &::google::protobuf::internal::kEmptyString) {
    classification_->clear();
  }
  clear_has_classification();
}
inline const ::std::string& DopplerTip::classification() const {
  return *classification_;
}
inline void DopplerTip::set_classification(const ::std::string& value) {
  set_has_classification();
  if (classification_ == &::google::protobuf::internal::kEmptyString) {
    classification_ = new ::std::string;
  }
  classification_->assign(value);
}
inline void DopplerTip::set_classification(const char* value) {
  set_has_classification();
  if (classification_ == &::google::protobuf::internal::kEmptyString) {
    classification_ = new ::std::string;
  }
  classification_->assign(value);
}
inline void DopplerTip::set_classification(const char* value, size_t size) {
  set_has_classification();
  if (classification_ == &::google::protobuf::internal::kEmptyString) {
    classification_ = new ::std::string;
  }
  classification_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DopplerTip::mutable_classification() {
  set_has_classification();
  if (classification_ == &::google::protobuf::internal::kEmptyString) {
    classification_ = new ::std::string;
  }
  return classification_;
}
inline ::std::string* DopplerTip::release_classification() {
  clear_has_classification();
  if (classification_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classification_;
    classification_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DopplerTip::set_allocated_classification(::std::string* classification) {
  if (classification_ != &::google::protobuf::internal::kEmptyString) {
    delete classification_;
  }
  if (classification) {
    set_has_classification();
    classification_ = classification;
  } else {
    clear_has_classification();
    classification_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string msgID = 11 [default = ""];
inline bool DopplerTip::has_msgid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DopplerTip::set_has_msgid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DopplerTip::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DopplerTip::clear_msgid() {
  if (msgid_ != &::google::protobuf::internal::kEmptyString) {
    msgid_->clear();
  }
  clear_has_msgid();
}
inline const ::std::string& DopplerTip::msgid() const {
  return *msgid_;
}
inline void DopplerTip::set_msgid(const ::std::string& value) {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::kEmptyString) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(value);
}
inline void DopplerTip::set_msgid(const char* value) {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::kEmptyString) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(value);
}
inline void DopplerTip::set_msgid(const char* value, size_t size) {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::kEmptyString) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DopplerTip::mutable_msgid() {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::kEmptyString) {
    msgid_ = new ::std::string;
  }
  return msgid_;
}
inline ::std::string* DopplerTip::release_msgid() {
  clear_has_msgid();
  if (msgid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msgid_;
    msgid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DopplerTip::set_allocated_msgid(::std::string* msgid) {
  if (msgid_ != &::google::protobuf::internal::kEmptyString) {
    delete msgid_;
  }
  if (msgid) {
    set_has_msgid();
    msgid_ = msgid;
  } else {
    clear_has_msgid();
    msgid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GeoRequest

// optional string msgName = 1 [default = "GEO_REQUEST"];
inline bool GeoRequest::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GeoRequest::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GeoRequest::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GeoRequest::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& GeoRequest::msgname() const {
  return *msgname_;
}
inline void GeoRequest::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GeoRequest::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GeoRequest::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoRequest::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* GeoRequest::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void GeoRequest::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional .ds_msg.GeoRequest.Action reqAction = 2 [default = STOP];
inline bool GeoRequest::has_reqaction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GeoRequest::set_has_reqaction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GeoRequest::clear_has_reqaction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GeoRequest::clear_reqaction() {
  reqaction_ = 0;
  clear_has_reqaction();
}
inline ::ds_msg::GeoRequest_Action GeoRequest::reqaction() const {
  return static_cast< ::ds_msg::GeoRequest_Action >(reqaction_);
}
inline void GeoRequest::set_reqaction(::ds_msg::GeoRequest_Action value) {
  assert(::ds_msg::GeoRequest_Action_IsValid(value));
  set_has_reqaction();
  reqaction_ = value;
}

// optional .ds_msg.Detection det = 3;
inline bool GeoRequest::has_det() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GeoRequest::set_has_det() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GeoRequest::clear_has_det() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GeoRequest::clear_det() {
  if (det_ != NULL) det_->::ds_msg::Detection::Clear();
  clear_has_det();
}
inline const ::ds_msg::Detection& GeoRequest::det() const {
  return det_ != NULL ? *det_ : *default_instance_->det_;
}
inline ::ds_msg::Detection* GeoRequest::mutable_det() {
  set_has_det();
  if (det_ == NULL) det_ = new ::ds_msg::Detection;
  return det_;
}
inline ::ds_msg::Detection* GeoRequest::release_det() {
  clear_has_det();
  ::ds_msg::Detection* temp = det_;
  det_ = NULL;
  return temp;
}
inline void GeoRequest::set_allocated_det(::ds_msg::Detection* det) {
  delete det_;
  det_ = det;
  if (det) {
    set_has_det();
  } else {
    clear_has_det();
  }
}

// optional .ds_msg.SatInfo sat = 4;
inline bool GeoRequest::has_sat() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GeoRequest::set_has_sat() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GeoRequest::clear_has_sat() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GeoRequest::clear_sat() {
  if (sat_ != NULL) sat_->::ds_msg::SatInfo::Clear();
  clear_has_sat();
}
inline const ::ds_msg::SatInfo& GeoRequest::sat() const {
  return sat_ != NULL ? *sat_ : *default_instance_->sat_;
}
inline ::ds_msg::SatInfo* GeoRequest::mutable_sat() {
  set_has_sat();
  if (sat_ == NULL) sat_ = new ::ds_msg::SatInfo;
  return sat_;
}
inline ::ds_msg::SatInfo* GeoRequest::release_sat() {
  clear_has_sat();
  ::ds_msg::SatInfo* temp = sat_;
  sat_ = NULL;
  return temp;
}
inline void GeoRequest::set_allocated_sat(::ds_msg::SatInfo* sat) {
  delete sat_;
  sat_ = sat;
  if (sat) {
    set_has_sat();
  } else {
    clear_has_sat();
  }
}

// optional double lat = 5 [default = 1000];
inline bool GeoRequest::has_lat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GeoRequest::set_has_lat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GeoRequest::clear_has_lat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GeoRequest::clear_lat() {
  lat_ = 1000;
  clear_has_lat();
}
inline double GeoRequest::lat() const {
  return lat_;
}
inline void GeoRequest::set_lat(double value) {
  set_has_lat();
  lat_ = value;
}

// optional double lon = 6 [default = 1000];
inline bool GeoRequest::has_lon() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GeoRequest::set_has_lon() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GeoRequest::clear_has_lon() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GeoRequest::clear_lon() {
  lon_ = 1000;
  clear_has_lon();
}
inline double GeoRequest::lon() const {
  return lon_;
}
inline void GeoRequest::set_lon(double value) {
  set_has_lon();
  lon_ = value;
}

// optional double alt = 7 [default = -1];
inline bool GeoRequest::has_alt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GeoRequest::set_has_alt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GeoRequest::clear_has_alt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GeoRequest::clear_alt() {
  alt_ = -1;
  clear_has_alt();
}
inline double GeoRequest::alt() const {
  return alt_;
}
inline void GeoRequest::set_alt(double value) {
  set_has_alt();
  alt_ = value;
}

// optional string locTime = 8;
inline bool GeoRequest::has_loctime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GeoRequest::set_has_loctime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GeoRequest::clear_has_loctime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GeoRequest::clear_loctime() {
  if (loctime_ != &::google::protobuf::internal::kEmptyString) {
    loctime_->clear();
  }
  clear_has_loctime();
}
inline const ::std::string& GeoRequest::loctime() const {
  return *loctime_;
}
inline void GeoRequest::set_loctime(const ::std::string& value) {
  set_has_loctime();
  if (loctime_ == &::google::protobuf::internal::kEmptyString) {
    loctime_ = new ::std::string;
  }
  loctime_->assign(value);
}
inline void GeoRequest::set_loctime(const char* value) {
  set_has_loctime();
  if (loctime_ == &::google::protobuf::internal::kEmptyString) {
    loctime_ = new ::std::string;
  }
  loctime_->assign(value);
}
inline void GeoRequest::set_loctime(const char* value, size_t size) {
  set_has_loctime();
  if (loctime_ == &::google::protobuf::internal::kEmptyString) {
    loctime_ = new ::std::string;
  }
  loctime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoRequest::mutable_loctime() {
  set_has_loctime();
  if (loctime_ == &::google::protobuf::internal::kEmptyString) {
    loctime_ = new ::std::string;
  }
  return loctime_;
}
inline ::std::string* GeoRequest::release_loctime() {
  clear_has_loctime();
  if (loctime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = loctime_;
    loctime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeoRequest::set_allocated_loctime(::std::string* loctime) {
  if (loctime_ != &::google::protobuf::internal::kEmptyString) {
    delete loctime_;
  }
  if (loctime) {
    set_has_loctime();
    loctime_ = loctime;
  } else {
    clear_has_loctime();
    loctime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 priority = 9 [default = 0];
inline bool GeoRequest::has_priority() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GeoRequest::set_has_priority() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GeoRequest::clear_has_priority() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GeoRequest::clear_priority() {
  priority_ = 0;
  clear_has_priority();
}
inline ::google::protobuf::int32 GeoRequest::priority() const {
  return priority_;
}
inline void GeoRequest::set_priority(::google::protobuf::int32 value) {
  set_has_priority();
  priority_ = value;
}

// optional string classification = 10 [default = ""];
inline bool GeoRequest::has_classification() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GeoRequest::set_has_classification() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GeoRequest::clear_has_classification() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GeoRequest::clear_classification() {
  if (classification_ != &::google::protobuf::internal::kEmptyString) {
    classification_->clear();
  }
  clear_has_classification();
}
inline const ::std::string& GeoRequest::classification() const {
  return *classification_;
}
inline void GeoRequest::set_classification(const ::std::string& value) {
  set_has_classification();
  if (classification_ == &::google::protobuf::internal::kEmptyString) {
    classification_ = new ::std::string;
  }
  classification_->assign(value);
}
inline void GeoRequest::set_classification(const char* value) {
  set_has_classification();
  if (classification_ == &::google::protobuf::internal::kEmptyString) {
    classification_ = new ::std::string;
  }
  classification_->assign(value);
}
inline void GeoRequest::set_classification(const char* value, size_t size) {
  set_has_classification();
  if (classification_ == &::google::protobuf::internal::kEmptyString) {
    classification_ = new ::std::string;
  }
  classification_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoRequest::mutable_classification() {
  set_has_classification();
  if (classification_ == &::google::protobuf::internal::kEmptyString) {
    classification_ = new ::std::string;
  }
  return classification_;
}
inline ::std::string* GeoRequest::release_classification() {
  clear_has_classification();
  if (classification_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classification_;
    classification_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeoRequest::set_allocated_classification(::std::string* classification) {
  if (classification_ != &::google::protobuf::internal::kEmptyString) {
    delete classification_;
  }
  if (classification) {
    set_has_classification();
    classification_ = classification;
  } else {
    clear_has_classification();
    classification_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GeoResponse

// optional string msgName = 1 [default = "GEO_RESPONSE"];
inline bool GeoResponse::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GeoResponse::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GeoResponse::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GeoResponse::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& GeoResponse::msgname() const {
  return *msgname_;
}
inline void GeoResponse::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GeoResponse::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GeoResponse::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoResponse::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* GeoResponse::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void GeoResponse::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional .ds_msg.GeoResponse.Status outcome = 2;
inline bool GeoResponse::has_outcome() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GeoResponse::set_has_outcome() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GeoResponse::clear_has_outcome() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GeoResponse::clear_outcome() {
  outcome_ = 0;
  clear_has_outcome();
}
inline ::ds_msg::GeoResponse_Status GeoResponse::outcome() const {
  return static_cast< ::ds_msg::GeoResponse_Status >(outcome_);
}
inline void GeoResponse::set_outcome(::ds_msg::GeoResponse_Status value) {
  assert(::ds_msg::GeoResponse_Status_IsValid(value));
  set_has_outcome();
  outcome_ = value;
}

// repeated string sigUUID = 3;
inline int GeoResponse::siguuid_size() const {
  return siguuid_.size();
}
inline void GeoResponse::clear_siguuid() {
  siguuid_.Clear();
}
inline const ::std::string& GeoResponse::siguuid(int index) const {
  return siguuid_.Get(index);
}
inline ::std::string* GeoResponse::mutable_siguuid(int index) {
  return siguuid_.Mutable(index);
}
inline void GeoResponse::set_siguuid(int index, const ::std::string& value) {
  siguuid_.Mutable(index)->assign(value);
}
inline void GeoResponse::set_siguuid(int index, const char* value) {
  siguuid_.Mutable(index)->assign(value);
}
inline void GeoResponse::set_siguuid(int index, const char* value, size_t size) {
  siguuid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoResponse::add_siguuid() {
  return siguuid_.Add();
}
inline void GeoResponse::add_siguuid(const ::std::string& value) {
  siguuid_.Add()->assign(value);
}
inline void GeoResponse::add_siguuid(const char* value) {
  siguuid_.Add()->assign(value);
}
inline void GeoResponse::add_siguuid(const char* value, size_t size) {
  siguuid_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GeoResponse::siguuid() const {
  return siguuid_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GeoResponse::mutable_siguuid() {
  return &siguuid_;
}

// optional string classification = 4 [default = ""];
inline bool GeoResponse::has_classification() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GeoResponse::set_has_classification() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GeoResponse::clear_has_classification() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GeoResponse::clear_classification() {
  if (classification_ != &::google::protobuf::internal::kEmptyString) {
    classification_->clear();
  }
  clear_has_classification();
}
inline const ::std::string& GeoResponse::classification() const {
  return *classification_;
}
inline void GeoResponse::set_classification(const ::std::string& value) {
  set_has_classification();
  if (classification_ == &::google::protobuf::internal::kEmptyString) {
    classification_ = new ::std::string;
  }
  classification_->assign(value);
}
inline void GeoResponse::set_classification(const char* value) {
  set_has_classification();
  if (classification_ == &::google::protobuf::internal::kEmptyString) {
    classification_ = new ::std::string;
  }
  classification_->assign(value);
}
inline void GeoResponse::set_classification(const char* value, size_t size) {
  set_has_classification();
  if (classification_ == &::google::protobuf::internal::kEmptyString) {
    classification_ = new ::std::string;
  }
  classification_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoResponse::mutable_classification() {
  set_has_classification();
  if (classification_ == &::google::protobuf::internal::kEmptyString) {
    classification_ = new ::std::string;
  }
  return classification_;
}
inline ::std::string* GeoResponse::release_classification() {
  clear_has_classification();
  if (classification_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classification_;
    classification_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeoResponse::set_allocated_classification(::std::string* classification) {
  if (classification_ != &::google::protobuf::internal::kEmptyString) {
    delete classification_;
  }
  if (classification) {
    set_has_classification();
    classification_ = classification;
  } else {
    clear_has_classification();
    classification_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GeoPoint

// optional string msgName = 1 [default = "GEO_POINT"];
inline bool GeoPoint::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GeoPoint::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GeoPoint::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GeoPoint::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& GeoPoint::msgname() const {
  return *msgname_;
}
inline void GeoPoint::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GeoPoint::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GeoPoint::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoPoint::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* GeoPoint::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void GeoPoint::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional double lat = 2;
inline bool GeoPoint::has_lat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GeoPoint::set_has_lat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GeoPoint::clear_has_lat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GeoPoint::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline double GeoPoint::lat() const {
  return lat_;
}
inline void GeoPoint::set_lat(double value) {
  set_has_lat();
  lat_ = value;
}

// optional double lon = 3;
inline bool GeoPoint::has_lon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GeoPoint::set_has_lon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GeoPoint::clear_has_lon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GeoPoint::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline double GeoPoint::lon() const {
  return lon_;
}
inline void GeoPoint::set_lon(double value) {
  set_has_lon();
  lon_ = value;
}

// optional double majoraxis = 4;
inline bool GeoPoint::has_majoraxis() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GeoPoint::set_has_majoraxis() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GeoPoint::clear_has_majoraxis() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GeoPoint::clear_majoraxis() {
  majoraxis_ = 0;
  clear_has_majoraxis();
}
inline double GeoPoint::majoraxis() const {
  return majoraxis_;
}
inline void GeoPoint::set_majoraxis(double value) {
  set_has_majoraxis();
  majoraxis_ = value;
}

// optional double minoraxis = 5;
inline bool GeoPoint::has_minoraxis() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GeoPoint::set_has_minoraxis() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GeoPoint::clear_has_minoraxis() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GeoPoint::clear_minoraxis() {
  minoraxis_ = 0;
  clear_has_minoraxis();
}
inline double GeoPoint::minoraxis() const {
  return minoraxis_;
}
inline void GeoPoint::set_minoraxis(double value) {
  set_has_minoraxis();
  minoraxis_ = value;
}

// optional double orientation = 6;
inline bool GeoPoint::has_orientation() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GeoPoint::set_has_orientation() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GeoPoint::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GeoPoint::clear_orientation() {
  orientation_ = 0;
  clear_has_orientation();
}
inline double GeoPoint::orientation() const {
  return orientation_;
}
inline void GeoPoint::set_orientation(double value) {
  set_has_orientation();
  orientation_ = value;
}

// optional double altitude = 7;
inline bool GeoPoint::has_altitude() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GeoPoint::set_has_altitude() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GeoPoint::clear_has_altitude() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GeoPoint::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline double GeoPoint::altitude() const {
  return altitude_;
}
inline void GeoPoint::set_altitude(double value) {
  set_has_altitude();
  altitude_ = value;
}

// optional int32 altConf = 8;
inline bool GeoPoint::has_altconf() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GeoPoint::set_has_altconf() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GeoPoint::clear_has_altconf() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GeoPoint::clear_altconf() {
  altconf_ = 0;
  clear_has_altconf();
}
inline ::google::protobuf::int32 GeoPoint::altconf() const {
  return altconf_;
}
inline void GeoPoint::set_altconf(::google::protobuf::int32 value) {
  set_has_altconf();
  altconf_ = value;
}

// optional double velocity = 9;
inline bool GeoPoint::has_velocity() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GeoPoint::set_has_velocity() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GeoPoint::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GeoPoint::clear_velocity() {
  velocity_ = 0;
  clear_has_velocity();
}
inline double GeoPoint::velocity() const {
  return velocity_;
}
inline void GeoPoint::set_velocity(double value) {
  set_has_velocity();
  velocity_ = value;
}

// optional int32 vConf = 10;
inline bool GeoPoint::has_vconf() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GeoPoint::set_has_vconf() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GeoPoint::clear_has_vconf() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GeoPoint::clear_vconf() {
  vconf_ = 0;
  clear_has_vconf();
}
inline ::google::protobuf::int32 GeoPoint::vconf() const {
  return vconf_;
}
inline void GeoPoint::set_vconf(::google::protobuf::int32 value) {
  set_has_vconf();
  vconf_ = value;
}

// optional double heading = 11;
inline bool GeoPoint::has_heading() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GeoPoint::set_has_heading() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GeoPoint::clear_has_heading() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GeoPoint::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline double GeoPoint::heading() const {
  return heading_;
}
inline void GeoPoint::set_heading(double value) {
  set_has_heading();
  heading_ = value;
}

// optional int32 headConf = 12;
inline bool GeoPoint::has_headconf() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GeoPoint::set_has_headconf() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GeoPoint::clear_has_headconf() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GeoPoint::clear_headconf() {
  headconf_ = 0;
  clear_has_headconf();
}
inline ::google::protobuf::int32 GeoPoint::headconf() const {
  return headconf_;
}
inline void GeoPoint::set_headconf(::google::protobuf::int32 value) {
  set_has_headconf();
  headconf_ = value;
}

// optional string covariance = 13;
inline bool GeoPoint::has_covariance() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GeoPoint::set_has_covariance() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GeoPoint::clear_has_covariance() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GeoPoint::clear_covariance() {
  if (covariance_ != &::google::protobuf::internal::kEmptyString) {
    covariance_->clear();
  }
  clear_has_covariance();
}
inline const ::std::string& GeoPoint::covariance() const {
  return *covariance_;
}
inline void GeoPoint::set_covariance(const ::std::string& value) {
  set_has_covariance();
  if (covariance_ == &::google::protobuf::internal::kEmptyString) {
    covariance_ = new ::std::string;
  }
  covariance_->assign(value);
}
inline void GeoPoint::set_covariance(const char* value) {
  set_has_covariance();
  if (covariance_ == &::google::protobuf::internal::kEmptyString) {
    covariance_ = new ::std::string;
  }
  covariance_->assign(value);
}
inline void GeoPoint::set_covariance(const char* value, size_t size) {
  set_has_covariance();
  if (covariance_ == &::google::protobuf::internal::kEmptyString) {
    covariance_ = new ::std::string;
  }
  covariance_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoPoint::mutable_covariance() {
  set_has_covariance();
  if (covariance_ == &::google::protobuf::internal::kEmptyString) {
    covariance_ = new ::std::string;
  }
  return covariance_;
}
inline ::std::string* GeoPoint::release_covariance() {
  clear_has_covariance();
  if (covariance_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = covariance_;
    covariance_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeoPoint::set_allocated_covariance(::std::string* covariance) {
  if (covariance_ != &::google::protobuf::internal::kEmptyString) {
    delete covariance_;
  }
  if (covariance) {
    set_has_covariance();
    covariance_ = covariance;
  } else {
    clear_has_covariance();
    covariance_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sigUUID = 14;
inline bool GeoPoint::has_siguuid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GeoPoint::set_has_siguuid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GeoPoint::clear_has_siguuid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GeoPoint::clear_siguuid() {
  if (siguuid_ != &::google::protobuf::internal::kEmptyString) {
    siguuid_->clear();
  }
  clear_has_siguuid();
}
inline const ::std::string& GeoPoint::siguuid() const {
  return *siguuid_;
}
inline void GeoPoint::set_siguuid(const ::std::string& value) {
  set_has_siguuid();
  if (siguuid_ == &::google::protobuf::internal::kEmptyString) {
    siguuid_ = new ::std::string;
  }
  siguuid_->assign(value);
}
inline void GeoPoint::set_siguuid(const char* value) {
  set_has_siguuid();
  if (siguuid_ == &::google::protobuf::internal::kEmptyString) {
    siguuid_ = new ::std::string;
  }
  siguuid_->assign(value);
}
inline void GeoPoint::set_siguuid(const char* value, size_t size) {
  set_has_siguuid();
  if (siguuid_ == &::google::protobuf::internal::kEmptyString) {
    siguuid_ = new ::std::string;
  }
  siguuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoPoint::mutable_siguuid() {
  set_has_siguuid();
  if (siguuid_ == &::google::protobuf::internal::kEmptyString) {
    siguuid_ = new ::std::string;
  }
  return siguuid_;
}
inline ::std::string* GeoPoint::release_siguuid() {
  clear_has_siguuid();
  if (siguuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = siguuid_;
    siguuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeoPoint::set_allocated_siguuid(::std::string* siguuid) {
  if (siguuid_ != &::google::protobuf::internal::kEmptyString) {
    delete siguuid_;
  }
  if (siguuid) {
    set_has_siguuid();
    siguuid_ = siguuid;
  } else {
    clear_has_siguuid();
    siguuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string geoTime = 15;
inline bool GeoPoint::has_geotime() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GeoPoint::set_has_geotime() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GeoPoint::clear_has_geotime() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GeoPoint::clear_geotime() {
  if (geotime_ != &::google::protobuf::internal::kEmptyString) {
    geotime_->clear();
  }
  clear_has_geotime();
}
inline const ::std::string& GeoPoint::geotime() const {
  return *geotime_;
}
inline void GeoPoint::set_geotime(const ::std::string& value) {
  set_has_geotime();
  if (geotime_ == &::google::protobuf::internal::kEmptyString) {
    geotime_ = new ::std::string;
  }
  geotime_->assign(value);
}
inline void GeoPoint::set_geotime(const char* value) {
  set_has_geotime();
  if (geotime_ == &::google::protobuf::internal::kEmptyString) {
    geotime_ = new ::std::string;
  }
  geotime_->assign(value);
}
inline void GeoPoint::set_geotime(const char* value, size_t size) {
  set_has_geotime();
  if (geotime_ == &::google::protobuf::internal::kEmptyString) {
    geotime_ = new ::std::string;
  }
  geotime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoPoint::mutable_geotime() {
  set_has_geotime();
  if (geotime_ == &::google::protobuf::internal::kEmptyString) {
    geotime_ = new ::std::string;
  }
  return geotime_;
}
inline ::std::string* GeoPoint::release_geotime() {
  clear_has_geotime();
  if (geotime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = geotime_;
    geotime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeoPoint::set_allocated_geotime(::std::string* geotime) {
  if (geotime_ != &::google::protobuf::internal::kEmptyString) {
    delete geotime_;
  }
  if (geotime) {
    set_has_geotime();
    geotime_ = geotime;
  } else {
    clear_has_geotime();
    geotime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string classification = 16 [default = ""];
inline bool GeoPoint::has_classification() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GeoPoint::set_has_classification() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GeoPoint::clear_has_classification() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GeoPoint::clear_classification() {
  if (classification_ != &::google::protobuf::internal::kEmptyString) {
    classification_->clear();
  }
  clear_has_classification();
}
inline const ::std::string& GeoPoint::classification() const {
  return *classification_;
}
inline void GeoPoint::set_classification(const ::std::string& value) {
  set_has_classification();
  if (classification_ == &::google::protobuf::internal::kEmptyString) {
    classification_ = new ::std::string;
  }
  classification_->assign(value);
}
inline void GeoPoint::set_classification(const char* value) {
  set_has_classification();
  if (classification_ == &::google::protobuf::internal::kEmptyString) {
    classification_ = new ::std::string;
  }
  classification_->assign(value);
}
inline void GeoPoint::set_classification(const char* value, size_t size) {
  set_has_classification();
  if (classification_ == &::google::protobuf::internal::kEmptyString) {
    classification_ = new ::std::string;
  }
  classification_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoPoint::mutable_classification() {
  set_has_classification();
  if (classification_ == &::google::protobuf::internal::kEmptyString) {
    classification_ = new ::std::string;
  }
  return classification_;
}
inline ::std::string* GeoPoint::release_classification() {
  clear_has_classification();
  if (classification_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classification_;
    classification_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeoPoint::set_allocated_classification(::std::string* classification) {
  if (classification_ != &::google::protobuf::internal::kEmptyString) {
    delete classification_;
  }
  if (classification) {
    set_has_classification();
    classification_ = classification;
  } else {
    clear_has_classification();
    classification_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ActiveList

// optional string msgName = 1 [default = "ACTIVE_LIST"];
inline bool ActiveList::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActiveList::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActiveList::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActiveList::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ActiveList::msgname() const {
  return *msgname_;
}
inline void ActiveList::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ActiveList::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ActiveList::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActiveList::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ActiveList::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ActiveList::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional .ds_msg.SatInfo sat = 2;
inline bool ActiveList::has_sat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActiveList::set_has_sat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActiveList::clear_has_sat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActiveList::clear_sat() {
  if (sat_ != NULL) sat_->::ds_msg::SatInfo::Clear();
  clear_has_sat();
}
inline const ::ds_msg::SatInfo& ActiveList::sat() const {
  return sat_ != NULL ? *sat_ : *default_instance_->sat_;
}
inline ::ds_msg::SatInfo* ActiveList::mutable_sat() {
  set_has_sat();
  if (sat_ == NULL) sat_ = new ::ds_msg::SatInfo;
  return sat_;
}
inline ::ds_msg::SatInfo* ActiveList::release_sat() {
  clear_has_sat();
  ::ds_msg::SatInfo* temp = sat_;
  sat_ = NULL;
  return temp;
}
inline void ActiveList::set_allocated_sat(::ds_msg::SatInfo* sat) {
  delete sat_;
  sat_ = sat;
  if (sat) {
    set_has_sat();
  } else {
    clear_has_sat();
  }
}

// optional string msgID = 3 [default = ""];
inline bool ActiveList::has_msgid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActiveList::set_has_msgid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActiveList::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActiveList::clear_msgid() {
  if (msgid_ != &::google::protobuf::internal::kEmptyString) {
    msgid_->clear();
  }
  clear_has_msgid();
}
inline const ::std::string& ActiveList::msgid() const {
  return *msgid_;
}
inline void ActiveList::set_msgid(const ::std::string& value) {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::kEmptyString) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(value);
}
inline void ActiveList::set_msgid(const char* value) {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::kEmptyString) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(value);
}
inline void ActiveList::set_msgid(const char* value, size_t size) {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::kEmptyString) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActiveList::mutable_msgid() {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::kEmptyString) {
    msgid_ = new ::std::string;
  }
  return msgid_;
}
inline ::std::string* ActiveList::release_msgid() {
  clear_has_msgid();
  if (msgid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msgid_;
    msgid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActiveList::set_allocated_msgid(::std::string* msgid) {
  if (msgid_ != &::google::protobuf::internal::kEmptyString) {
    delete msgid_;
  }
  if (msgid) {
    set_has_msgid();
    msgid_ = msgid;
  } else {
    clear_has_msgid();
    msgid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string classification = 4 [default = ""];
inline bool ActiveList::has_classification() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ActiveList::set_has_classification() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ActiveList::clear_has_classification() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ActiveList::clear_classification() {
  if (classification_ != &::google::protobuf::internal::kEmptyString) {
    classification_->clear();
  }
  clear_has_classification();
}
inline const ::std::string& ActiveList::classification() const {
  return *classification_;
}
inline void ActiveList::set_classification(const ::std::string& value) {
  set_has_classification();
  if (classification_ == &::google::protobuf::internal::kEmptyString) {
    classification_ = new ::std::string;
  }
  classification_->assign(value);
}
inline void ActiveList::set_classification(const char* value) {
  set_has_classification();
  if (classification_ == &::google::protobuf::internal::kEmptyString) {
    classification_ = new ::std::string;
  }
  classification_->assign(value);
}
inline void ActiveList::set_classification(const char* value, size_t size) {
  set_has_classification();
  if (classification_ == &::google::protobuf::internal::kEmptyString) {
    classification_ = new ::std::string;
  }
  classification_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActiveList::mutable_classification() {
  set_has_classification();
  if (classification_ == &::google::protobuf::internal::kEmptyString) {
    classification_ = new ::std::string;
  }
  return classification_;
}
inline ::std::string* ActiveList::release_classification() {
  clear_has_classification();
  if (classification_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classification_;
    classification_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActiveList::set_allocated_classification(::std::string* classification) {
  if (classification_ != &::google::protobuf::internal::kEmptyString) {
    delete classification_;
  }
  if (classification) {
    set_has_classification();
    classification_ = classification;
  } else {
    clear_has_classification();
    classification_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .ds_msg.Detection det = 5;
inline int ActiveList::det_size() const {
  return det_.size();
}
inline void ActiveList::clear_det() {
  det_.Clear();
}
inline const ::ds_msg::Detection& ActiveList::det(int index) const {
  return det_.Get(index);
}
inline ::ds_msg::Detection* ActiveList::mutable_det(int index) {
  return det_.Mutable(index);
}
inline ::ds_msg::Detection* ActiveList::add_det() {
  return det_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ds_msg::Detection >&
ActiveList::det() const {
  return det_;
}
inline ::google::protobuf::RepeatedPtrField< ::ds_msg::Detection >*
ActiveList::mutable_det() {
  return &det_;
}

// -------------------------------------------------------------------

// InitiateGeo

// optional string msgName = 1 [default = "INITIATE_GEO"];
inline bool InitiateGeo::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitiateGeo::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitiateGeo::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitiateGeo::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& InitiateGeo::msgname() const {
  return *msgname_;
}
inline void InitiateGeo::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void InitiateGeo::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void InitiateGeo::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InitiateGeo::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* InitiateGeo::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void InitiateGeo::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string sigUUID = 2;
inline bool InitiateGeo::has_siguuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InitiateGeo::set_has_siguuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InitiateGeo::clear_has_siguuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InitiateGeo::clear_siguuid() {
  if (siguuid_ != &::google::protobuf::internal::kEmptyString) {
    siguuid_->clear();
  }
  clear_has_siguuid();
}
inline const ::std::string& InitiateGeo::siguuid() const {
  return *siguuid_;
}
inline void InitiateGeo::set_siguuid(const ::std::string& value) {
  set_has_siguuid();
  if (siguuid_ == &::google::protobuf::internal::kEmptyString) {
    siguuid_ = new ::std::string;
  }
  siguuid_->assign(value);
}
inline void InitiateGeo::set_siguuid(const char* value) {
  set_has_siguuid();
  if (siguuid_ == &::google::protobuf::internal::kEmptyString) {
    siguuid_ = new ::std::string;
  }
  siguuid_->assign(value);
}
inline void InitiateGeo::set_siguuid(const char* value, size_t size) {
  set_has_siguuid();
  if (siguuid_ == &::google::protobuf::internal::kEmptyString) {
    siguuid_ = new ::std::string;
  }
  siguuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InitiateGeo::mutable_siguuid() {
  set_has_siguuid();
  if (siguuid_ == &::google::protobuf::internal::kEmptyString) {
    siguuid_ = new ::std::string;
  }
  return siguuid_;
}
inline ::std::string* InitiateGeo::release_siguuid() {
  clear_has_siguuid();
  if (siguuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = siguuid_;
    siguuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InitiateGeo::set_allocated_siguuid(::std::string* siguuid) {
  if (siguuid_ != &::google::protobuf::internal::kEmptyString) {
    delete siguuid_;
  }
  if (siguuid) {
    set_has_siguuid();
    siguuid_ = siguuid;
  } else {
    clear_has_siguuid();
    siguuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 priority = 3 [default = 0];
inline bool InitiateGeo::has_priority() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InitiateGeo::set_has_priority() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InitiateGeo::clear_has_priority() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InitiateGeo::clear_priority() {
  priority_ = 0;
  clear_has_priority();
}
inline ::google::protobuf::int32 InitiateGeo::priority() const {
  return priority_;
}
inline void InitiateGeo::set_priority(::google::protobuf::int32 value) {
  set_has_priority();
  priority_ = value;
}

// optional double duration = 4 [default = 300];
inline bool InitiateGeo::has_duration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InitiateGeo::set_has_duration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InitiateGeo::clear_has_duration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InitiateGeo::clear_duration() {
  duration_ = 300;
  clear_has_duration();
}
inline double InitiateGeo::duration() const {
  return duration_;
}
inline void InitiateGeo::set_duration(double value) {
  set_has_duration();
  duration_ = value;
}

// optional bool force = 5 [default = false];
inline bool InitiateGeo::has_force() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InitiateGeo::set_has_force() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InitiateGeo::clear_has_force() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InitiateGeo::clear_force() {
  force_ = false;
  clear_has_force();
}
inline bool InitiateGeo::force() const {
  return force_;
}
inline void InitiateGeo::set_force(bool value) {
  set_has_force();
  force_ = value;
}

// -------------------------------------------------------------------

// SignalStatus

// optional string msgName = 1 [default = "SIGNAL_STATUS"];
inline bool SignalStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignalStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignalStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignalStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SignalStatus::msgname() const {
  return *msgname_;
}
inline void SignalStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SignalStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SignalStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SignalStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SignalStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string sigUUID = 2;
inline bool SignalStatus::has_siguuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignalStatus::set_has_siguuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignalStatus::clear_has_siguuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignalStatus::clear_siguuid() {
  if (siguuid_ != &::google::protobuf::internal::kEmptyString) {
    siguuid_->clear();
  }
  clear_has_siguuid();
}
inline const ::std::string& SignalStatus::siguuid() const {
  return *siguuid_;
}
inline void SignalStatus::set_siguuid(const ::std::string& value) {
  set_has_siguuid();
  if (siguuid_ == &::google::protobuf::internal::kEmptyString) {
    siguuid_ = new ::std::string;
  }
  siguuid_->assign(value);
}
inline void SignalStatus::set_siguuid(const char* value) {
  set_has_siguuid();
  if (siguuid_ == &::google::protobuf::internal::kEmptyString) {
    siguuid_ = new ::std::string;
  }
  siguuid_->assign(value);
}
inline void SignalStatus::set_siguuid(const char* value, size_t size) {
  set_has_siguuid();
  if (siguuid_ == &::google::protobuf::internal::kEmptyString) {
    siguuid_ = new ::std::string;
  }
  siguuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalStatus::mutable_siguuid() {
  set_has_siguuid();
  if (siguuid_ == &::google::protobuf::internal::kEmptyString) {
    siguuid_ = new ::std::string;
  }
  return siguuid_;
}
inline ::std::string* SignalStatus::release_siguuid() {
  clear_has_siguuid();
  if (siguuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = siguuid_;
    siguuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignalStatus::set_allocated_siguuid(::std::string* siguuid) {
  if (siguuid_ != &::google::protobuf::internal::kEmptyString) {
    delete siguuid_;
  }
  if (siguuid) {
    set_has_siguuid();
    siguuid_ = siguuid;
  } else {
    clear_has_siguuid();
    siguuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sigType = 3;
inline bool SignalStatus::has_sigtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignalStatus::set_has_sigtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignalStatus::clear_has_sigtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignalStatus::clear_sigtype() {
  if (sigtype_ != &::google::protobuf::internal::kEmptyString) {
    sigtype_->clear();
  }
  clear_has_sigtype();
}
inline const ::std::string& SignalStatus::sigtype() const {
  return *sigtype_;
}
inline void SignalStatus::set_sigtype(const ::std::string& value) {
  set_has_sigtype();
  if (sigtype_ == &::google::protobuf::internal::kEmptyString) {
    sigtype_ = new ::std::string;
  }
  sigtype_->assign(value);
}
inline void SignalStatus::set_sigtype(const char* value) {
  set_has_sigtype();
  if (sigtype_ == &::google::protobuf::internal::kEmptyString) {
    sigtype_ = new ::std::string;
  }
  sigtype_->assign(value);
}
inline void SignalStatus::set_sigtype(const char* value, size_t size) {
  set_has_sigtype();
  if (sigtype_ == &::google::protobuf::internal::kEmptyString) {
    sigtype_ = new ::std::string;
  }
  sigtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalStatus::mutable_sigtype() {
  set_has_sigtype();
  if (sigtype_ == &::google::protobuf::internal::kEmptyString) {
    sigtype_ = new ::std::string;
  }
  return sigtype_;
}
inline ::std::string* SignalStatus::release_sigtype() {
  clear_has_sigtype();
  if (sigtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sigtype_;
    sigtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignalStatus::set_allocated_sigtype(::std::string* sigtype) {
  if (sigtype_ != &::google::protobuf::internal::kEmptyString) {
    delete sigtype_;
  }
  if (sigtype) {
    set_has_sigtype();
    sigtype_ = sigtype;
  } else {
    clear_has_sigtype();
    sigtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool proc = 4;
inline bool SignalStatus::has_proc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignalStatus::set_has_proc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignalStatus::clear_has_proc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignalStatus::clear_proc() {
  proc_ = false;
  clear_has_proc();
}
inline bool SignalStatus::proc() const {
  return proc_;
}
inline void SignalStatus::set_proc(bool value) {
  set_has_proc();
  proc_ = value;
}

// optional string geoStatus = 5;
inline bool SignalStatus::has_geostatus() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SignalStatus::set_has_geostatus() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SignalStatus::clear_has_geostatus() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SignalStatus::clear_geostatus() {
  if (geostatus_ != &::google::protobuf::internal::kEmptyString) {
    geostatus_->clear();
  }
  clear_has_geostatus();
}
inline const ::std::string& SignalStatus::geostatus() const {
  return *geostatus_;
}
inline void SignalStatus::set_geostatus(const ::std::string& value) {
  set_has_geostatus();
  if (geostatus_ == &::google::protobuf::internal::kEmptyString) {
    geostatus_ = new ::std::string;
  }
  geostatus_->assign(value);
}
inline void SignalStatus::set_geostatus(const char* value) {
  set_has_geostatus();
  if (geostatus_ == &::google::protobuf::internal::kEmptyString) {
    geostatus_ = new ::std::string;
  }
  geostatus_->assign(value);
}
inline void SignalStatus::set_geostatus(const char* value, size_t size) {
  set_has_geostatus();
  if (geostatus_ == &::google::protobuf::internal::kEmptyString) {
    geostatus_ = new ::std::string;
  }
  geostatus_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalStatus::mutable_geostatus() {
  set_has_geostatus();
  if (geostatus_ == &::google::protobuf::internal::kEmptyString) {
    geostatus_ = new ::std::string;
  }
  return geostatus_;
}
inline ::std::string* SignalStatus::release_geostatus() {
  clear_has_geostatus();
  if (geostatus_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = geostatus_;
    geostatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignalStatus::set_allocated_geostatus(::std::string* geostatus) {
  if (geostatus_ != &::google::protobuf::internal::kEmptyString) {
    delete geostatus_;
  }
  if (geostatus) {
    set_has_geostatus();
    geostatus_ = geostatus;
  } else {
    clear_has_geostatus();
    geostatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool telemAvail = 6;
inline bool SignalStatus::has_telemavail() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SignalStatus::set_has_telemavail() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SignalStatus::clear_has_telemavail() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SignalStatus::clear_telemavail() {
  telemavail_ = false;
  clear_has_telemavail();
}
inline bool SignalStatus::telemavail() const {
  return telemavail_;
}
inline void SignalStatus::set_telemavail(bool value) {
  set_has_telemavail();
  telemavail_ = value;
}

// optional string telemLastTime = 7;
inline bool SignalStatus::has_telemlasttime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SignalStatus::set_has_telemlasttime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SignalStatus::clear_has_telemlasttime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SignalStatus::clear_telemlasttime() {
  if (telemlasttime_ != &::google::protobuf::internal::kEmptyString) {
    telemlasttime_->clear();
  }
  clear_has_telemlasttime();
}
inline const ::std::string& SignalStatus::telemlasttime() const {
  return *telemlasttime_;
}
inline void SignalStatus::set_telemlasttime(const ::std::string& value) {
  set_has_telemlasttime();
  if (telemlasttime_ == &::google::protobuf::internal::kEmptyString) {
    telemlasttime_ = new ::std::string;
  }
  telemlasttime_->assign(value);
}
inline void SignalStatus::set_telemlasttime(const char* value) {
  set_has_telemlasttime();
  if (telemlasttime_ == &::google::protobuf::internal::kEmptyString) {
    telemlasttime_ = new ::std::string;
  }
  telemlasttime_->assign(value);
}
inline void SignalStatus::set_telemlasttime(const char* value, size_t size) {
  set_has_telemlasttime();
  if (telemlasttime_ == &::google::protobuf::internal::kEmptyString) {
    telemlasttime_ = new ::std::string;
  }
  telemlasttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalStatus::mutable_telemlasttime() {
  set_has_telemlasttime();
  if (telemlasttime_ == &::google::protobuf::internal::kEmptyString) {
    telemlasttime_ = new ::std::string;
  }
  return telemlasttime_;
}
inline ::std::string* SignalStatus::release_telemlasttime() {
  clear_has_telemlasttime();
  if (telemlasttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = telemlasttime_;
    telemlasttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignalStatus::set_allocated_telemlasttime(::std::string* telemlasttime) {
  if (telemlasttime_ != &::google::protobuf::internal::kEmptyString) {
    delete telemlasttime_;
  }
  if (telemlasttime) {
    set_has_telemlasttime();
    telemlasttime_ = telemlasttime;
  } else {
    clear_has_telemlasttime();
    telemlasttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 geoPri = 8;
inline bool SignalStatus::has_geopri() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SignalStatus::set_has_geopri() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SignalStatus::clear_has_geopri() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SignalStatus::clear_geopri() {
  geopri_ = GOOGLE_LONGLONG(0);
  clear_has_geopri();
}
inline ::google::protobuf::int64 SignalStatus::geopri() const {
  return geopri_;
}
inline void SignalStatus::set_geopri(::google::protobuf::int64 value) {
  set_has_geopri();
  geopri_ = value;
}

// optional string eventID = 9;
inline bool SignalStatus::has_eventid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SignalStatus::set_has_eventid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SignalStatus::clear_has_eventid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SignalStatus::clear_eventid() {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    eventid_->clear();
  }
  clear_has_eventid();
}
inline const ::std::string& SignalStatus::eventid() const {
  return *eventid_;
}
inline void SignalStatus::set_eventid(const ::std::string& value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void SignalStatus::set_eventid(const char* value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void SignalStatus::set_eventid(const char* value, size_t size) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalStatus::mutable_eventid() {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  return eventid_;
}
inline ::std::string* SignalStatus::release_eventid() {
  clear_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventid_;
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignalStatus::set_allocated_eventid(::std::string* eventid) {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    delete eventid_;
  }
  if (eventid) {
    set_has_eventid();
    eventid_ = eventid;
  } else {
    clear_has_eventid();
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sigName = 10;
inline bool SignalStatus::has_signame() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SignalStatus::set_has_signame() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SignalStatus::clear_has_signame() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SignalStatus::clear_signame() {
  if (signame_ != &::google::protobuf::internal::kEmptyString) {
    signame_->clear();
  }
  clear_has_signame();
}
inline const ::std::string& SignalStatus::signame() const {
  return *signame_;
}
inline void SignalStatus::set_signame(const ::std::string& value) {
  set_has_signame();
  if (signame_ == &::google::protobuf::internal::kEmptyString) {
    signame_ = new ::std::string;
  }
  signame_->assign(value);
}
inline void SignalStatus::set_signame(const char* value) {
  set_has_signame();
  if (signame_ == &::google::protobuf::internal::kEmptyString) {
    signame_ = new ::std::string;
  }
  signame_->assign(value);
}
inline void SignalStatus::set_signame(const char* value, size_t size) {
  set_has_signame();
  if (signame_ == &::google::protobuf::internal::kEmptyString) {
    signame_ = new ::std::string;
  }
  signame_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalStatus::mutable_signame() {
  set_has_signame();
  if (signame_ == &::google::protobuf::internal::kEmptyString) {
    signame_ = new ::std::string;
  }
  return signame_;
}
inline ::std::string* SignalStatus::release_signame() {
  clear_has_signame();
  if (signame_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signame_;
    signame_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignalStatus::set_allocated_signame(::std::string* signame) {
  if (signame_ != &::google::protobuf::internal::kEmptyString) {
    delete signame_;
  }
  if (signame) {
    set_has_signame();
    signame_ = signame;
  } else {
    clear_has_signame();
    signame_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// StatusRequest

// optional string msgName = 1 [default = "STAT_REQ"];
inline bool StatusRequest::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatusRequest::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StatusRequest::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StatusRequest::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& StatusRequest::msgname() const {
  return *msgname_;
}
inline void StatusRequest::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void StatusRequest::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void StatusRequest::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatusRequest::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* StatusRequest::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void StatusRequest::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string sigUUID = 2;
inline bool StatusRequest::has_siguuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StatusRequest::set_has_siguuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StatusRequest::clear_has_siguuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StatusRequest::clear_siguuid() {
  if (siguuid_ != &::google::protobuf::internal::kEmptyString) {
    siguuid_->clear();
  }
  clear_has_siguuid();
}
inline const ::std::string& StatusRequest::siguuid() const {
  return *siguuid_;
}
inline void StatusRequest::set_siguuid(const ::std::string& value) {
  set_has_siguuid();
  if (siguuid_ == &::google::protobuf::internal::kEmptyString) {
    siguuid_ = new ::std::string;
  }
  siguuid_->assign(value);
}
inline void StatusRequest::set_siguuid(const char* value) {
  set_has_siguuid();
  if (siguuid_ == &::google::protobuf::internal::kEmptyString) {
    siguuid_ = new ::std::string;
  }
  siguuid_->assign(value);
}
inline void StatusRequest::set_siguuid(const char* value, size_t size) {
  set_has_siguuid();
  if (siguuid_ == &::google::protobuf::internal::kEmptyString) {
    siguuid_ = new ::std::string;
  }
  siguuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatusRequest::mutable_siguuid() {
  set_has_siguuid();
  if (siguuid_ == &::google::protobuf::internal::kEmptyString) {
    siguuid_ = new ::std::string;
  }
  return siguuid_;
}
inline ::std::string* StatusRequest::release_siguuid() {
  clear_has_siguuid();
  if (siguuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = siguuid_;
    siguuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StatusRequest::set_allocated_siguuid(::std::string* siguuid) {
  if (siguuid_ != &::google::protobuf::internal::kEmptyString) {
    delete siguuid_;
  }
  if (siguuid) {
    set_has_siguuid();
    siguuid_ = siguuid;
  } else {
    clear_has_siguuid();
    siguuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ds_msg

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ds_msg::GeoRequest_Action>() {
  return ::ds_msg::GeoRequest_Action_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ds_msg::GeoResponse_Status>() {
  return ::ds_msg::GeoResponse_Status_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_DSMessages_2eproto__INCLUDED
