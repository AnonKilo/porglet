// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PodCommsMessages.proto

#ifndef PROTOBUF_PodCommsMessages_2eproto__INCLUDED
#define PROTOBUF_PodCommsMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "ThunderbirdMessages.pb.h"
#include "ServiceInfrastructureCommon.pb.h"
#include "ServiceInfrastructureExclusive.pb.h"
#include "BitMessages.pb.h"
#include "DebugMessages.pb.h"
// @@protoc_insertion_point(includes)

namespace fv {
namespace podcomms {
namespace protos {
namespace PodCommsProtos {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_PodCommsMessages_2eproto();
void protobuf_AssignDesc_PodCommsMessages_2eproto();
void protobuf_ShutdownFile_PodCommsMessages_2eproto();

class NetworkLayout;
class KeplerGroundToAirEnvelope;
class KeplerAirToGroundEnvelope;
class KeplerBiDirectionalEnvelope;
class PodCommsICDVersion;

// ===================================================================

class NetworkLayout : public ::google::protobuf::Message {
 public:
  NetworkLayout();
  virtual ~NetworkLayout();

  NetworkLayout(const NetworkLayout& from);

  inline NetworkLayout& operator=(const NetworkLayout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NetworkLayout& default_instance();

  void Swap(NetworkLayout* other);

  // implements Message ----------------------------------------------

  NetworkLayout* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NetworkLayout& from);
  void MergeFrom(const NetworkLayout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 base_port = 1 [default = 8070];
  inline bool has_base_port() const;
  inline void clear_base_port();
  static const int kBasePortFieldNumber = 1;
  inline ::google::protobuf::int64 base_port() const;
  inline void set_base_port(::google::protobuf::int64 value);

  // optional int64 infrastructure_port_offset = 2 [default = 17];
  inline bool has_infrastructure_port_offset() const;
  inline void clear_infrastructure_port_offset();
  static const int kInfrastructurePortOffsetFieldNumber = 2;
  inline ::google::protobuf::int64 infrastructure_port_offset() const;
  inline void set_infrastructure_port_offset(::google::protobuf::int64 value);

  // optional int64 service_port_offset = 3 [default = 19];
  inline bool has_service_port_offset() const;
  inline void clear_service_port_offset();
  static const int kServicePortOffsetFieldNumber = 3;
  inline ::google::protobuf::int64 service_port_offset() const;
  inline void set_service_port_offset(::google::protobuf::int64 value);

  // optional int64 air_port_offset = 4 [default = 21];
  inline bool has_air_port_offset() const;
  inline void clear_air_port_offset();
  static const int kAirPortOffsetFieldNumber = 4;
  inline ::google::protobuf::int64 air_port_offset() const;
  inline void set_air_port_offset(::google::protobuf::int64 value);

  // optional int64 ground_port_offset = 5 [default = 23];
  inline bool has_ground_port_offset() const;
  inline void clear_ground_port_offset();
  static const int kGroundPortOffsetFieldNumber = 5;
  inline ::google::protobuf::int64 ground_port_offset() const;
  inline void set_ground_port_offset(::google::protobuf::int64 value);

  // optional int64 sub_port = 6 [default = 8186];
  inline bool has_sub_port() const;
  inline void clear_sub_port();
  static const int kSubPortFieldNumber = 6;
  inline ::google::protobuf::int64 sub_port() const;
  inline void set_sub_port(::google::protobuf::int64 value);

  // optional int64 pub_port = 7 [default = 8185];
  inline bool has_pub_port() const;
  inline void clear_pub_port();
  static const int kPubPortFieldNumber = 7;
  inline ::google::protobuf::int64 pub_port() const;
  inline void set_pub_port(::google::protobuf::int64 value);

  // optional int64 air_port = 8 [default = 8184];
  inline bool has_air_port() const;
  inline void clear_air_port();
  static const int kAirPortFieldNumber = 8;
  inline ::google::protobuf::int64 air_port() const;
  inline void set_air_port(::google::protobuf::int64 value);

  // optional int64 ground_port = 9 [default = 8183];
  inline bool has_ground_port() const;
  inline void clear_ground_port();
  static const int kGroundPortFieldNumber = 9;
  inline ::google::protobuf::int64 ground_port() const;
  inline void set_ground_port(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:fv.podcomms.protos.PodCommsProtos.NetworkLayout)
 private:
  inline void set_has_base_port();
  inline void clear_has_base_port();
  inline void set_has_infrastructure_port_offset();
  inline void clear_has_infrastructure_port_offset();
  inline void set_has_service_port_offset();
  inline void clear_has_service_port_offset();
  inline void set_has_air_port_offset();
  inline void clear_has_air_port_offset();
  inline void set_has_ground_port_offset();
  inline void clear_has_ground_port_offset();
  inline void set_has_sub_port();
  inline void clear_has_sub_port();
  inline void set_has_pub_port();
  inline void clear_has_pub_port();
  inline void set_has_air_port();
  inline void clear_has_air_port();
  inline void set_has_ground_port();
  inline void clear_has_ground_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 base_port_;
  ::google::protobuf::int64 infrastructure_port_offset_;
  ::google::protobuf::int64 service_port_offset_;
  ::google::protobuf::int64 air_port_offset_;
  ::google::protobuf::int64 ground_port_offset_;
  ::google::protobuf::int64 sub_port_;
  ::google::protobuf::int64 pub_port_;
  ::google::protobuf::int64 air_port_;
  ::google::protobuf::int64 ground_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_PodCommsMessages_2eproto();
  friend void protobuf_AssignDesc_PodCommsMessages_2eproto();
  friend void protobuf_ShutdownFile_PodCommsMessages_2eproto();

  void InitAsDefaultInstance();
  static NetworkLayout* default_instance_;
};
// -------------------------------------------------------------------

class KeplerGroundToAirEnvelope : public ::google::protobuf::Message {
 public:
  KeplerGroundToAirEnvelope();
  virtual ~KeplerGroundToAirEnvelope();

  KeplerGroundToAirEnvelope(const KeplerGroundToAirEnvelope& from);

  inline KeplerGroundToAirEnvelope& operator=(const KeplerGroundToAirEnvelope& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeplerGroundToAirEnvelope& default_instance();

  void Swap(KeplerGroundToAirEnvelope* other);

  // implements Message ----------------------------------------------

  KeplerGroundToAirEnvelope* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeplerGroundToAirEnvelope& from);
  void MergeFrom(const KeplerGroundToAirEnvelope& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional .service_infrastructure.HandshakeTopic handshake = 4;
  inline bool has_handshake() const;
  inline void clear_handshake();
  static const int kHandshakeFieldNumber = 4;
  inline const ::service_infrastructure::HandshakeTopic& handshake() const;
  inline ::service_infrastructure::HandshakeTopic* mutable_handshake();
  inline ::service_infrastructure::HandshakeTopic* release_handshake();
  inline void set_allocated_handshake(::service_infrastructure::HandshakeTopic* handshake);

  // optional .service_infrastructure.EWRequestTopic ew_request = 5;
  inline bool has_ew_request() const;
  inline void clear_ew_request();
  static const int kEwRequestFieldNumber = 5;
  inline const ::service_infrastructure::EWRequestTopic& ew_request() const;
  inline ::service_infrastructure::EWRequestTopic* mutable_ew_request();
  inline ::service_infrastructure::EWRequestTopic* release_ew_request();
  inline void set_allocated_ew_request(::service_infrastructure::EWRequestTopic* ew_request);

  // optional .service_infrastructure.ProductRequestTopic product_request = 6;
  inline bool has_product_request() const;
  inline void clear_product_request();
  static const int kProductRequestFieldNumber = 6;
  inline const ::service_infrastructure::ProductRequestTopic& product_request() const;
  inline ::service_infrastructure::ProductRequestTopic* mutable_product_request();
  inline ::service_infrastructure::ProductRequestTopic* release_product_request();
  inline void set_allocated_product_request(::service_infrastructure::ProductRequestTopic* product_request);

  // optional .bit_protos.BitRequestTopic bit_test_request = 8;
  inline bool has_bit_test_request() const;
  inline void clear_bit_test_request();
  static const int kBitTestRequestFieldNumber = 8;
  inline const ::bit_protos::BitRequestTopic& bit_test_request() const;
  inline ::bit_protos::BitRequestTopic* mutable_bit_test_request();
  inline ::bit_protos::BitRequestTopic* release_bit_test_request();
  inline void set_allocated_bit_test_request(::bit_protos::BitRequestTopic* bit_test_request);

  // @@protoc_insertion_point(class_scope:fv.podcomms.protos.PodCommsProtos.KeplerGroundToAirEnvelope)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_handshake();
  inline void clear_has_handshake();
  inline void set_has_ew_request();
  inline void clear_has_ew_request();
  inline void set_has_product_request();
  inline void clear_has_product_request();
  inline void set_has_bit_test_request();
  inline void clear_has_bit_test_request();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::service_infrastructure::HandshakeTopic* handshake_;
  ::service_infrastructure::EWRequestTopic* ew_request_;
  ::service_infrastructure::ProductRequestTopic* product_request_;
  ::bit_protos::BitRequestTopic* bit_test_request_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_PodCommsMessages_2eproto();
  friend void protobuf_AssignDesc_PodCommsMessages_2eproto();
  friend void protobuf_ShutdownFile_PodCommsMessages_2eproto();

  void InitAsDefaultInstance();
  static KeplerGroundToAirEnvelope* default_instance_;
};
// -------------------------------------------------------------------

class KeplerAirToGroundEnvelope : public ::google::protobuf::Message {
 public:
  KeplerAirToGroundEnvelope();
  virtual ~KeplerAirToGroundEnvelope();

  KeplerAirToGroundEnvelope(const KeplerAirToGroundEnvelope& from);

  inline KeplerAirToGroundEnvelope& operator=(const KeplerAirToGroundEnvelope& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeplerAirToGroundEnvelope& default_instance();

  void Swap(KeplerAirToGroundEnvelope* other);

  // implements Message ----------------------------------------------

  KeplerAirToGroundEnvelope* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeplerAirToGroundEnvelope& from);
  void MergeFrom(const KeplerAirToGroundEnvelope& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional .service_infrastructure.HandshakeTopic handshake = 4;
  inline bool has_handshake() const;
  inline void clear_handshake();
  static const int kHandshakeFieldNumber = 4;
  inline const ::service_infrastructure::HandshakeTopic& handshake() const;
  inline ::service_infrastructure::HandshakeTopic* mutable_handshake();
  inline ::service_infrastructure::HandshakeTopic* release_handshake();
  inline void set_allocated_handshake(::service_infrastructure::HandshakeTopic* handshake);

  // optional .service_infrastructure.EWResponseTopic ew_response = 6;
  inline bool has_ew_response() const;
  inline void clear_ew_response();
  static const int kEwResponseFieldNumber = 6;
  inline const ::service_infrastructure::EWResponseTopic& ew_response() const;
  inline ::service_infrastructure::EWResponseTopic* mutable_ew_response();
  inline ::service_infrastructure::EWResponseTopic* release_ew_response();
  inline void set_allocated_ew_response(::service_infrastructure::EWResponseTopic* ew_response);

  // optional .service_infrastructure.ProductResponseTopic product_response = 7;
  inline bool has_product_response() const;
  inline void clear_product_response();
  static const int kProductResponseFieldNumber = 7;
  inline const ::service_infrastructure::ProductResponseTopic& product_response() const;
  inline ::service_infrastructure::ProductResponseTopic* mutable_product_response();
  inline ::service_infrastructure::ProductResponseTopic* release_product_response();
  inline void set_allocated_product_response(::service_infrastructure::ProductResponseTopic* product_response);

  // optional .bit_protos.BitResponseTopic bit_test_response = 9;
  inline bool has_bit_test_response() const;
  inline void clear_bit_test_response();
  static const int kBitTestResponseFieldNumber = 9;
  inline const ::bit_protos::BitResponseTopic& bit_test_response() const;
  inline ::bit_protos::BitResponseTopic* mutable_bit_test_response();
  inline ::bit_protos::BitResponseTopic* release_bit_test_response();
  inline void set_allocated_bit_test_response(::bit_protos::BitResponseTopic* bit_test_response);

  // optional .service_infrastructure.DebugTopic debug_topic = 10;
  inline bool has_debug_topic() const;
  inline void clear_debug_topic();
  static const int kDebugTopicFieldNumber = 10;
  inline const ::service_infrastructure::DebugTopic& debug_topic() const;
  inline ::service_infrastructure::DebugTopic* mutable_debug_topic();
  inline ::service_infrastructure::DebugTopic* release_debug_topic();
  inline void set_allocated_debug_topic(::service_infrastructure::DebugTopic* debug_topic);

  // optional .service_infrastructure.SensorTopic sensor_topic = 11;
  inline bool has_sensor_topic() const;
  inline void clear_sensor_topic();
  static const int kSensorTopicFieldNumber = 11;
  inline const ::service_infrastructure::SensorTopic& sensor_topic() const;
  inline ::service_infrastructure::SensorTopic* mutable_sensor_topic();
  inline ::service_infrastructure::SensorTopic* release_sensor_topic();
  inline void set_allocated_sensor_topic(::service_infrastructure::SensorTopic* sensor_topic);

  // @@protoc_insertion_point(class_scope:fv.podcomms.protos.PodCommsProtos.KeplerAirToGroundEnvelope)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_handshake();
  inline void clear_has_handshake();
  inline void set_has_ew_response();
  inline void clear_has_ew_response();
  inline void set_has_product_response();
  inline void clear_has_product_response();
  inline void set_has_bit_test_response();
  inline void clear_has_bit_test_response();
  inline void set_has_debug_topic();
  inline void clear_has_debug_topic();
  inline void set_has_sensor_topic();
  inline void clear_has_sensor_topic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::service_infrastructure::HandshakeTopic* handshake_;
  ::service_infrastructure::EWResponseTopic* ew_response_;
  ::service_infrastructure::ProductResponseTopic* product_response_;
  ::bit_protos::BitResponseTopic* bit_test_response_;
  ::service_infrastructure::DebugTopic* debug_topic_;
  ::service_infrastructure::SensorTopic* sensor_topic_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_PodCommsMessages_2eproto();
  friend void protobuf_AssignDesc_PodCommsMessages_2eproto();
  friend void protobuf_ShutdownFile_PodCommsMessages_2eproto();

  void InitAsDefaultInstance();
  static KeplerAirToGroundEnvelope* default_instance_;
};
// -------------------------------------------------------------------

class KeplerBiDirectionalEnvelope : public ::google::protobuf::Message {
 public:
  KeplerBiDirectionalEnvelope();
  virtual ~KeplerBiDirectionalEnvelope();

  KeplerBiDirectionalEnvelope(const KeplerBiDirectionalEnvelope& from);

  inline KeplerBiDirectionalEnvelope& operator=(const KeplerBiDirectionalEnvelope& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeplerBiDirectionalEnvelope& default_instance();

  void Swap(KeplerBiDirectionalEnvelope* other);

  // implements Message ----------------------------------------------

  KeplerBiDirectionalEnvelope* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeplerBiDirectionalEnvelope& from);
  void MergeFrom(const KeplerBiDirectionalEnvelope& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional .service_infrastructure.SignalEventTopic signal_event = 8;
  inline bool has_signal_event() const;
  inline void clear_signal_event();
  static const int kSignalEventFieldNumber = 8;
  inline const ::service_infrastructure::SignalEventTopic& signal_event() const;
  inline ::service_infrastructure::SignalEventTopic* mutable_signal_event();
  inline ::service_infrastructure::SignalEventTopic* release_signal_event();
  inline void set_allocated_signal_event(::service_infrastructure::SignalEventTopic* signal_event);

  // optional .service_infrastructure.SigFramesTopic sigframes_topic = 12;
  inline bool has_sigframes_topic() const;
  inline void clear_sigframes_topic();
  static const int kSigframesTopicFieldNumber = 12;
  inline const ::service_infrastructure::SigFramesTopic& sigframes_topic() const;
  inline ::service_infrastructure::SigFramesTopic* mutable_sigframes_topic();
  inline ::service_infrastructure::SigFramesTopic* release_sigframes_topic();
  inline void set_allocated_sigframes_topic(::service_infrastructure::SigFramesTopic* sigframes_topic);

  // @@protoc_insertion_point(class_scope:fv.podcomms.protos.PodCommsProtos.KeplerBiDirectionalEnvelope)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_signal_event();
  inline void clear_has_signal_event();
  inline void set_has_sigframes_topic();
  inline void clear_has_sigframes_topic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::service_infrastructure::SignalEventTopic* signal_event_;
  ::service_infrastructure::SigFramesTopic* sigframes_topic_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_PodCommsMessages_2eproto();
  friend void protobuf_AssignDesc_PodCommsMessages_2eproto();
  friend void protobuf_ShutdownFile_PodCommsMessages_2eproto();

  void InitAsDefaultInstance();
  static KeplerBiDirectionalEnvelope* default_instance_;
};
// -------------------------------------------------------------------

class PodCommsICDVersion : public ::google::protobuf::Message {
 public:
  PodCommsICDVersion();
  virtual ~PodCommsICDVersion();

  PodCommsICDVersion(const PodCommsICDVersion& from);

  inline PodCommsICDVersion& operator=(const PodCommsICDVersion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PodCommsICDVersion& default_instance();

  void Swap(PodCommsICDVersion* other);

  // implements Message ----------------------------------------------

  PodCommsICDVersion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PodCommsICDVersion& from);
  void MergeFrom(const PodCommsICDVersion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 major = 1 [default = 0];
  inline bool has_major() const;
  inline void clear_major();
  static const int kMajorFieldNumber = 1;
  inline ::google::protobuf::int32 major() const;
  inline void set_major(::google::protobuf::int32 value);

  // optional int32 minor = 2 [default = 0];
  inline bool has_minor() const;
  inline void clear_minor();
  static const int kMinorFieldNumber = 2;
  inline ::google::protobuf::int32 minor() const;
  inline void set_minor(::google::protobuf::int32 value);

  // optional int32 patch = 3 [default = 2];
  inline bool has_patch() const;
  inline void clear_patch();
  static const int kPatchFieldNumber = 3;
  inline ::google::protobuf::int32 patch() const;
  inline void set_patch(::google::protobuf::int32 value);

  // optional string date = 4 [default = "2020-05-22"];
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 4;
  inline const ::std::string& date() const;
  inline void set_date(const ::std::string& value);
  inline void set_date(const char* value);
  inline void set_date(const char* value, size_t size);
  inline ::std::string* mutable_date();
  inline ::std::string* release_date();
  inline void set_allocated_date(::std::string* date);

  // optional string commit = 5;
  inline bool has_commit() const;
  inline void clear_commit();
  static const int kCommitFieldNumber = 5;
  inline const ::std::string& commit() const;
  inline void set_commit(const ::std::string& value);
  inline void set_commit(const char* value);
  inline void set_commit(const char* value, size_t size);
  inline ::std::string* mutable_commit();
  inline ::std::string* release_commit();
  inline void set_allocated_commit(::std::string* commit);

  // @@protoc_insertion_point(class_scope:fv.podcomms.protos.PodCommsProtos.PodCommsICDVersion)
 private:
  inline void set_has_major();
  inline void clear_has_major();
  inline void set_has_minor();
  inline void clear_has_minor();
  inline void set_has_patch();
  inline void clear_has_patch();
  inline void set_has_date();
  inline void clear_has_date();
  inline void set_has_commit();
  inline void clear_has_commit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 major_;
  ::google::protobuf::int32 minor_;
  ::std::string* date_;
  static ::std::string* _default_date_;
  ::std::string* commit_;
  ::google::protobuf::int32 patch_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_PodCommsMessages_2eproto();
  friend void protobuf_AssignDesc_PodCommsMessages_2eproto();
  friend void protobuf_ShutdownFile_PodCommsMessages_2eproto();

  void InitAsDefaultInstance();
  static PodCommsICDVersion* default_instance_;
};
// ===================================================================


// ===================================================================

// NetworkLayout

// optional int64 base_port = 1 [default = 8070];
inline bool NetworkLayout::has_base_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetworkLayout::set_has_base_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetworkLayout::clear_has_base_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetworkLayout::clear_base_port() {
  base_port_ = GOOGLE_LONGLONG(8070);
  clear_has_base_port();
}
inline ::google::protobuf::int64 NetworkLayout::base_port() const {
  return base_port_;
}
inline void NetworkLayout::set_base_port(::google::protobuf::int64 value) {
  set_has_base_port();
  base_port_ = value;
}

// optional int64 infrastructure_port_offset = 2 [default = 17];
inline bool NetworkLayout::has_infrastructure_port_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetworkLayout::set_has_infrastructure_port_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetworkLayout::clear_has_infrastructure_port_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetworkLayout::clear_infrastructure_port_offset() {
  infrastructure_port_offset_ = GOOGLE_LONGLONG(17);
  clear_has_infrastructure_port_offset();
}
inline ::google::protobuf::int64 NetworkLayout::infrastructure_port_offset() const {
  return infrastructure_port_offset_;
}
inline void NetworkLayout::set_infrastructure_port_offset(::google::protobuf::int64 value) {
  set_has_infrastructure_port_offset();
  infrastructure_port_offset_ = value;
}

// optional int64 service_port_offset = 3 [default = 19];
inline bool NetworkLayout::has_service_port_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NetworkLayout::set_has_service_port_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NetworkLayout::clear_has_service_port_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NetworkLayout::clear_service_port_offset() {
  service_port_offset_ = GOOGLE_LONGLONG(19);
  clear_has_service_port_offset();
}
inline ::google::protobuf::int64 NetworkLayout::service_port_offset() const {
  return service_port_offset_;
}
inline void NetworkLayout::set_service_port_offset(::google::protobuf::int64 value) {
  set_has_service_port_offset();
  service_port_offset_ = value;
}

// optional int64 air_port_offset = 4 [default = 21];
inline bool NetworkLayout::has_air_port_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NetworkLayout::set_has_air_port_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NetworkLayout::clear_has_air_port_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NetworkLayout::clear_air_port_offset() {
  air_port_offset_ = GOOGLE_LONGLONG(21);
  clear_has_air_port_offset();
}
inline ::google::protobuf::int64 NetworkLayout::air_port_offset() const {
  return air_port_offset_;
}
inline void NetworkLayout::set_air_port_offset(::google::protobuf::int64 value) {
  set_has_air_port_offset();
  air_port_offset_ = value;
}

// optional int64 ground_port_offset = 5 [default = 23];
inline bool NetworkLayout::has_ground_port_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NetworkLayout::set_has_ground_port_offset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NetworkLayout::clear_has_ground_port_offset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NetworkLayout::clear_ground_port_offset() {
  ground_port_offset_ = GOOGLE_LONGLONG(23);
  clear_has_ground_port_offset();
}
inline ::google::protobuf::int64 NetworkLayout::ground_port_offset() const {
  return ground_port_offset_;
}
inline void NetworkLayout::set_ground_port_offset(::google::protobuf::int64 value) {
  set_has_ground_port_offset();
  ground_port_offset_ = value;
}

// optional int64 sub_port = 6 [default = 8186];
inline bool NetworkLayout::has_sub_port() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NetworkLayout::set_has_sub_port() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NetworkLayout::clear_has_sub_port() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NetworkLayout::clear_sub_port() {
  sub_port_ = GOOGLE_LONGLONG(8186);
  clear_has_sub_port();
}
inline ::google::protobuf::int64 NetworkLayout::sub_port() const {
  return sub_port_;
}
inline void NetworkLayout::set_sub_port(::google::protobuf::int64 value) {
  set_has_sub_port();
  sub_port_ = value;
}

// optional int64 pub_port = 7 [default = 8185];
inline bool NetworkLayout::has_pub_port() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NetworkLayout::set_has_pub_port() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NetworkLayout::clear_has_pub_port() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NetworkLayout::clear_pub_port() {
  pub_port_ = GOOGLE_LONGLONG(8185);
  clear_has_pub_port();
}
inline ::google::protobuf::int64 NetworkLayout::pub_port() const {
  return pub_port_;
}
inline void NetworkLayout::set_pub_port(::google::protobuf::int64 value) {
  set_has_pub_port();
  pub_port_ = value;
}

// optional int64 air_port = 8 [default = 8184];
inline bool NetworkLayout::has_air_port() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NetworkLayout::set_has_air_port() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NetworkLayout::clear_has_air_port() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NetworkLayout::clear_air_port() {
  air_port_ = GOOGLE_LONGLONG(8184);
  clear_has_air_port();
}
inline ::google::protobuf::int64 NetworkLayout::air_port() const {
  return air_port_;
}
inline void NetworkLayout::set_air_port(::google::protobuf::int64 value) {
  set_has_air_port();
  air_port_ = value;
}

// optional int64 ground_port = 9 [default = 8183];
inline bool NetworkLayout::has_ground_port() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NetworkLayout::set_has_ground_port() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NetworkLayout::clear_has_ground_port() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NetworkLayout::clear_ground_port() {
  ground_port_ = GOOGLE_LONGLONG(8183);
  clear_has_ground_port();
}
inline ::google::protobuf::int64 NetworkLayout::ground_port() const {
  return ground_port_;
}
inline void NetworkLayout::set_ground_port(::google::protobuf::int64 value) {
  set_has_ground_port();
  ground_port_ = value;
}

// -------------------------------------------------------------------

// KeplerGroundToAirEnvelope

// optional .service_infrastructure.Header header = 1;
inline bool KeplerGroundToAirEnvelope::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeplerGroundToAirEnvelope::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeplerGroundToAirEnvelope::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeplerGroundToAirEnvelope::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& KeplerGroundToAirEnvelope::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* KeplerGroundToAirEnvelope::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* KeplerGroundToAirEnvelope::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void KeplerGroundToAirEnvelope::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .service_infrastructure.HandshakeTopic handshake = 4;
inline bool KeplerGroundToAirEnvelope::has_handshake() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeplerGroundToAirEnvelope::set_has_handshake() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeplerGroundToAirEnvelope::clear_has_handshake() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeplerGroundToAirEnvelope::clear_handshake() {
  if (handshake_ != NULL) handshake_->::service_infrastructure::HandshakeTopic::Clear();
  clear_has_handshake();
}
inline const ::service_infrastructure::HandshakeTopic& KeplerGroundToAirEnvelope::handshake() const {
  return handshake_ != NULL ? *handshake_ : *default_instance_->handshake_;
}
inline ::service_infrastructure::HandshakeTopic* KeplerGroundToAirEnvelope::mutable_handshake() {
  set_has_handshake();
  if (handshake_ == NULL) handshake_ = new ::service_infrastructure::HandshakeTopic;
  return handshake_;
}
inline ::service_infrastructure::HandshakeTopic* KeplerGroundToAirEnvelope::release_handshake() {
  clear_has_handshake();
  ::service_infrastructure::HandshakeTopic* temp = handshake_;
  handshake_ = NULL;
  return temp;
}
inline void KeplerGroundToAirEnvelope::set_allocated_handshake(::service_infrastructure::HandshakeTopic* handshake) {
  delete handshake_;
  handshake_ = handshake;
  if (handshake) {
    set_has_handshake();
  } else {
    clear_has_handshake();
  }
}

// optional .service_infrastructure.EWRequestTopic ew_request = 5;
inline bool KeplerGroundToAirEnvelope::has_ew_request() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KeplerGroundToAirEnvelope::set_has_ew_request() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KeplerGroundToAirEnvelope::clear_has_ew_request() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KeplerGroundToAirEnvelope::clear_ew_request() {
  if (ew_request_ != NULL) ew_request_->::service_infrastructure::EWRequestTopic::Clear();
  clear_has_ew_request();
}
inline const ::service_infrastructure::EWRequestTopic& KeplerGroundToAirEnvelope::ew_request() const {
  return ew_request_ != NULL ? *ew_request_ : *default_instance_->ew_request_;
}
inline ::service_infrastructure::EWRequestTopic* KeplerGroundToAirEnvelope::mutable_ew_request() {
  set_has_ew_request();
  if (ew_request_ == NULL) ew_request_ = new ::service_infrastructure::EWRequestTopic;
  return ew_request_;
}
inline ::service_infrastructure::EWRequestTopic* KeplerGroundToAirEnvelope::release_ew_request() {
  clear_has_ew_request();
  ::service_infrastructure::EWRequestTopic* temp = ew_request_;
  ew_request_ = NULL;
  return temp;
}
inline void KeplerGroundToAirEnvelope::set_allocated_ew_request(::service_infrastructure::EWRequestTopic* ew_request) {
  delete ew_request_;
  ew_request_ = ew_request;
  if (ew_request) {
    set_has_ew_request();
  } else {
    clear_has_ew_request();
  }
}

// optional .service_infrastructure.ProductRequestTopic product_request = 6;
inline bool KeplerGroundToAirEnvelope::has_product_request() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KeplerGroundToAirEnvelope::set_has_product_request() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KeplerGroundToAirEnvelope::clear_has_product_request() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KeplerGroundToAirEnvelope::clear_product_request() {
  if (product_request_ != NULL) product_request_->::service_infrastructure::ProductRequestTopic::Clear();
  clear_has_product_request();
}
inline const ::service_infrastructure::ProductRequestTopic& KeplerGroundToAirEnvelope::product_request() const {
  return product_request_ != NULL ? *product_request_ : *default_instance_->product_request_;
}
inline ::service_infrastructure::ProductRequestTopic* KeplerGroundToAirEnvelope::mutable_product_request() {
  set_has_product_request();
  if (product_request_ == NULL) product_request_ = new ::service_infrastructure::ProductRequestTopic;
  return product_request_;
}
inline ::service_infrastructure::ProductRequestTopic* KeplerGroundToAirEnvelope::release_product_request() {
  clear_has_product_request();
  ::service_infrastructure::ProductRequestTopic* temp = product_request_;
  product_request_ = NULL;
  return temp;
}
inline void KeplerGroundToAirEnvelope::set_allocated_product_request(::service_infrastructure::ProductRequestTopic* product_request) {
  delete product_request_;
  product_request_ = product_request;
  if (product_request) {
    set_has_product_request();
  } else {
    clear_has_product_request();
  }
}

// optional .bit_protos.BitRequestTopic bit_test_request = 8;
inline bool KeplerGroundToAirEnvelope::has_bit_test_request() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void KeplerGroundToAirEnvelope::set_has_bit_test_request() {
  _has_bits_[0] |= 0x00000010u;
}
inline void KeplerGroundToAirEnvelope::clear_has_bit_test_request() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void KeplerGroundToAirEnvelope::clear_bit_test_request() {
  if (bit_test_request_ != NULL) bit_test_request_->::bit_protos::BitRequestTopic::Clear();
  clear_has_bit_test_request();
}
inline const ::bit_protos::BitRequestTopic& KeplerGroundToAirEnvelope::bit_test_request() const {
  return bit_test_request_ != NULL ? *bit_test_request_ : *default_instance_->bit_test_request_;
}
inline ::bit_protos::BitRequestTopic* KeplerGroundToAirEnvelope::mutable_bit_test_request() {
  set_has_bit_test_request();
  if (bit_test_request_ == NULL) bit_test_request_ = new ::bit_protos::BitRequestTopic;
  return bit_test_request_;
}
inline ::bit_protos::BitRequestTopic* KeplerGroundToAirEnvelope::release_bit_test_request() {
  clear_has_bit_test_request();
  ::bit_protos::BitRequestTopic* temp = bit_test_request_;
  bit_test_request_ = NULL;
  return temp;
}
inline void KeplerGroundToAirEnvelope::set_allocated_bit_test_request(::bit_protos::BitRequestTopic* bit_test_request) {
  delete bit_test_request_;
  bit_test_request_ = bit_test_request;
  if (bit_test_request) {
    set_has_bit_test_request();
  } else {
    clear_has_bit_test_request();
  }
}

// -------------------------------------------------------------------

// KeplerAirToGroundEnvelope

// optional .service_infrastructure.Header header = 1;
inline bool KeplerAirToGroundEnvelope::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeplerAirToGroundEnvelope::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeplerAirToGroundEnvelope::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeplerAirToGroundEnvelope::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& KeplerAirToGroundEnvelope::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* KeplerAirToGroundEnvelope::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* KeplerAirToGroundEnvelope::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void KeplerAirToGroundEnvelope::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .service_infrastructure.HandshakeTopic handshake = 4;
inline bool KeplerAirToGroundEnvelope::has_handshake() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeplerAirToGroundEnvelope::set_has_handshake() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeplerAirToGroundEnvelope::clear_has_handshake() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeplerAirToGroundEnvelope::clear_handshake() {
  if (handshake_ != NULL) handshake_->::service_infrastructure::HandshakeTopic::Clear();
  clear_has_handshake();
}
inline const ::service_infrastructure::HandshakeTopic& KeplerAirToGroundEnvelope::handshake() const {
  return handshake_ != NULL ? *handshake_ : *default_instance_->handshake_;
}
inline ::service_infrastructure::HandshakeTopic* KeplerAirToGroundEnvelope::mutable_handshake() {
  set_has_handshake();
  if (handshake_ == NULL) handshake_ = new ::service_infrastructure::HandshakeTopic;
  return handshake_;
}
inline ::service_infrastructure::HandshakeTopic* KeplerAirToGroundEnvelope::release_handshake() {
  clear_has_handshake();
  ::service_infrastructure::HandshakeTopic* temp = handshake_;
  handshake_ = NULL;
  return temp;
}
inline void KeplerAirToGroundEnvelope::set_allocated_handshake(::service_infrastructure::HandshakeTopic* handshake) {
  delete handshake_;
  handshake_ = handshake;
  if (handshake) {
    set_has_handshake();
  } else {
    clear_has_handshake();
  }
}

// optional .service_infrastructure.EWResponseTopic ew_response = 6;
inline bool KeplerAirToGroundEnvelope::has_ew_response() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KeplerAirToGroundEnvelope::set_has_ew_response() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KeplerAirToGroundEnvelope::clear_has_ew_response() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KeplerAirToGroundEnvelope::clear_ew_response() {
  if (ew_response_ != NULL) ew_response_->::service_infrastructure::EWResponseTopic::Clear();
  clear_has_ew_response();
}
inline const ::service_infrastructure::EWResponseTopic& KeplerAirToGroundEnvelope::ew_response() const {
  return ew_response_ != NULL ? *ew_response_ : *default_instance_->ew_response_;
}
inline ::service_infrastructure::EWResponseTopic* KeplerAirToGroundEnvelope::mutable_ew_response() {
  set_has_ew_response();
  if (ew_response_ == NULL) ew_response_ = new ::service_infrastructure::EWResponseTopic;
  return ew_response_;
}
inline ::service_infrastructure::EWResponseTopic* KeplerAirToGroundEnvelope::release_ew_response() {
  clear_has_ew_response();
  ::service_infrastructure::EWResponseTopic* temp = ew_response_;
  ew_response_ = NULL;
  return temp;
}
inline void KeplerAirToGroundEnvelope::set_allocated_ew_response(::service_infrastructure::EWResponseTopic* ew_response) {
  delete ew_response_;
  ew_response_ = ew_response;
  if (ew_response) {
    set_has_ew_response();
  } else {
    clear_has_ew_response();
  }
}

// optional .service_infrastructure.ProductResponseTopic product_response = 7;
inline bool KeplerAirToGroundEnvelope::has_product_response() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KeplerAirToGroundEnvelope::set_has_product_response() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KeplerAirToGroundEnvelope::clear_has_product_response() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KeplerAirToGroundEnvelope::clear_product_response() {
  if (product_response_ != NULL) product_response_->::service_infrastructure::ProductResponseTopic::Clear();
  clear_has_product_response();
}
inline const ::service_infrastructure::ProductResponseTopic& KeplerAirToGroundEnvelope::product_response() const {
  return product_response_ != NULL ? *product_response_ : *default_instance_->product_response_;
}
inline ::service_infrastructure::ProductResponseTopic* KeplerAirToGroundEnvelope::mutable_product_response() {
  set_has_product_response();
  if (product_response_ == NULL) product_response_ = new ::service_infrastructure::ProductResponseTopic;
  return product_response_;
}
inline ::service_infrastructure::ProductResponseTopic* KeplerAirToGroundEnvelope::release_product_response() {
  clear_has_product_response();
  ::service_infrastructure::ProductResponseTopic* temp = product_response_;
  product_response_ = NULL;
  return temp;
}
inline void KeplerAirToGroundEnvelope::set_allocated_product_response(::service_infrastructure::ProductResponseTopic* product_response) {
  delete product_response_;
  product_response_ = product_response;
  if (product_response) {
    set_has_product_response();
  } else {
    clear_has_product_response();
  }
}

// optional .bit_protos.BitResponseTopic bit_test_response = 9;
inline bool KeplerAirToGroundEnvelope::has_bit_test_response() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void KeplerAirToGroundEnvelope::set_has_bit_test_response() {
  _has_bits_[0] |= 0x00000010u;
}
inline void KeplerAirToGroundEnvelope::clear_has_bit_test_response() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void KeplerAirToGroundEnvelope::clear_bit_test_response() {
  if (bit_test_response_ != NULL) bit_test_response_->::bit_protos::BitResponseTopic::Clear();
  clear_has_bit_test_response();
}
inline const ::bit_protos::BitResponseTopic& KeplerAirToGroundEnvelope::bit_test_response() const {
  return bit_test_response_ != NULL ? *bit_test_response_ : *default_instance_->bit_test_response_;
}
inline ::bit_protos::BitResponseTopic* KeplerAirToGroundEnvelope::mutable_bit_test_response() {
  set_has_bit_test_response();
  if (bit_test_response_ == NULL) bit_test_response_ = new ::bit_protos::BitResponseTopic;
  return bit_test_response_;
}
inline ::bit_protos::BitResponseTopic* KeplerAirToGroundEnvelope::release_bit_test_response() {
  clear_has_bit_test_response();
  ::bit_protos::BitResponseTopic* temp = bit_test_response_;
  bit_test_response_ = NULL;
  return temp;
}
inline void KeplerAirToGroundEnvelope::set_allocated_bit_test_response(::bit_protos::BitResponseTopic* bit_test_response) {
  delete bit_test_response_;
  bit_test_response_ = bit_test_response;
  if (bit_test_response) {
    set_has_bit_test_response();
  } else {
    clear_has_bit_test_response();
  }
}

// optional .service_infrastructure.DebugTopic debug_topic = 10;
inline bool KeplerAirToGroundEnvelope::has_debug_topic() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void KeplerAirToGroundEnvelope::set_has_debug_topic() {
  _has_bits_[0] |= 0x00000020u;
}
inline void KeplerAirToGroundEnvelope::clear_has_debug_topic() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void KeplerAirToGroundEnvelope::clear_debug_topic() {
  if (debug_topic_ != NULL) debug_topic_->::service_infrastructure::DebugTopic::Clear();
  clear_has_debug_topic();
}
inline const ::service_infrastructure::DebugTopic& KeplerAirToGroundEnvelope::debug_topic() const {
  return debug_topic_ != NULL ? *debug_topic_ : *default_instance_->debug_topic_;
}
inline ::service_infrastructure::DebugTopic* KeplerAirToGroundEnvelope::mutable_debug_topic() {
  set_has_debug_topic();
  if (debug_topic_ == NULL) debug_topic_ = new ::service_infrastructure::DebugTopic;
  return debug_topic_;
}
inline ::service_infrastructure::DebugTopic* KeplerAirToGroundEnvelope::release_debug_topic() {
  clear_has_debug_topic();
  ::service_infrastructure::DebugTopic* temp = debug_topic_;
  debug_topic_ = NULL;
  return temp;
}
inline void KeplerAirToGroundEnvelope::set_allocated_debug_topic(::service_infrastructure::DebugTopic* debug_topic) {
  delete debug_topic_;
  debug_topic_ = debug_topic;
  if (debug_topic) {
    set_has_debug_topic();
  } else {
    clear_has_debug_topic();
  }
}

// optional .service_infrastructure.SensorTopic sensor_topic = 11;
inline bool KeplerAirToGroundEnvelope::has_sensor_topic() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void KeplerAirToGroundEnvelope::set_has_sensor_topic() {
  _has_bits_[0] |= 0x00000040u;
}
inline void KeplerAirToGroundEnvelope::clear_has_sensor_topic() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void KeplerAirToGroundEnvelope::clear_sensor_topic() {
  if (sensor_topic_ != NULL) sensor_topic_->::service_infrastructure::SensorTopic::Clear();
  clear_has_sensor_topic();
}
inline const ::service_infrastructure::SensorTopic& KeplerAirToGroundEnvelope::sensor_topic() const {
  return sensor_topic_ != NULL ? *sensor_topic_ : *default_instance_->sensor_topic_;
}
inline ::service_infrastructure::SensorTopic* KeplerAirToGroundEnvelope::mutable_sensor_topic() {
  set_has_sensor_topic();
  if (sensor_topic_ == NULL) sensor_topic_ = new ::service_infrastructure::SensorTopic;
  return sensor_topic_;
}
inline ::service_infrastructure::SensorTopic* KeplerAirToGroundEnvelope::release_sensor_topic() {
  clear_has_sensor_topic();
  ::service_infrastructure::SensorTopic* temp = sensor_topic_;
  sensor_topic_ = NULL;
  return temp;
}
inline void KeplerAirToGroundEnvelope::set_allocated_sensor_topic(::service_infrastructure::SensorTopic* sensor_topic) {
  delete sensor_topic_;
  sensor_topic_ = sensor_topic;
  if (sensor_topic) {
    set_has_sensor_topic();
  } else {
    clear_has_sensor_topic();
  }
}

// -------------------------------------------------------------------

// KeplerBiDirectionalEnvelope

// optional .service_infrastructure.Header header = 1;
inline bool KeplerBiDirectionalEnvelope::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeplerBiDirectionalEnvelope::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeplerBiDirectionalEnvelope::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeplerBiDirectionalEnvelope::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& KeplerBiDirectionalEnvelope::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* KeplerBiDirectionalEnvelope::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* KeplerBiDirectionalEnvelope::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void KeplerBiDirectionalEnvelope::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .service_infrastructure.SignalEventTopic signal_event = 8;
inline bool KeplerBiDirectionalEnvelope::has_signal_event() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeplerBiDirectionalEnvelope::set_has_signal_event() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeplerBiDirectionalEnvelope::clear_has_signal_event() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeplerBiDirectionalEnvelope::clear_signal_event() {
  if (signal_event_ != NULL) signal_event_->::service_infrastructure::SignalEventTopic::Clear();
  clear_has_signal_event();
}
inline const ::service_infrastructure::SignalEventTopic& KeplerBiDirectionalEnvelope::signal_event() const {
  return signal_event_ != NULL ? *signal_event_ : *default_instance_->signal_event_;
}
inline ::service_infrastructure::SignalEventTopic* KeplerBiDirectionalEnvelope::mutable_signal_event() {
  set_has_signal_event();
  if (signal_event_ == NULL) signal_event_ = new ::service_infrastructure::SignalEventTopic;
  return signal_event_;
}
inline ::service_infrastructure::SignalEventTopic* KeplerBiDirectionalEnvelope::release_signal_event() {
  clear_has_signal_event();
  ::service_infrastructure::SignalEventTopic* temp = signal_event_;
  signal_event_ = NULL;
  return temp;
}
inline void KeplerBiDirectionalEnvelope::set_allocated_signal_event(::service_infrastructure::SignalEventTopic* signal_event) {
  delete signal_event_;
  signal_event_ = signal_event;
  if (signal_event) {
    set_has_signal_event();
  } else {
    clear_has_signal_event();
  }
}

// optional .service_infrastructure.SigFramesTopic sigframes_topic = 12;
inline bool KeplerBiDirectionalEnvelope::has_sigframes_topic() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KeplerBiDirectionalEnvelope::set_has_sigframes_topic() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KeplerBiDirectionalEnvelope::clear_has_sigframes_topic() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KeplerBiDirectionalEnvelope::clear_sigframes_topic() {
  if (sigframes_topic_ != NULL) sigframes_topic_->::service_infrastructure::SigFramesTopic::Clear();
  clear_has_sigframes_topic();
}
inline const ::service_infrastructure::SigFramesTopic& KeplerBiDirectionalEnvelope::sigframes_topic() const {
  return sigframes_topic_ != NULL ? *sigframes_topic_ : *default_instance_->sigframes_topic_;
}
inline ::service_infrastructure::SigFramesTopic* KeplerBiDirectionalEnvelope::mutable_sigframes_topic() {
  set_has_sigframes_topic();
  if (sigframes_topic_ == NULL) sigframes_topic_ = new ::service_infrastructure::SigFramesTopic;
  return sigframes_topic_;
}
inline ::service_infrastructure::SigFramesTopic* KeplerBiDirectionalEnvelope::release_sigframes_topic() {
  clear_has_sigframes_topic();
  ::service_infrastructure::SigFramesTopic* temp = sigframes_topic_;
  sigframes_topic_ = NULL;
  return temp;
}
inline void KeplerBiDirectionalEnvelope::set_allocated_sigframes_topic(::service_infrastructure::SigFramesTopic* sigframes_topic) {
  delete sigframes_topic_;
  sigframes_topic_ = sigframes_topic;
  if (sigframes_topic) {
    set_has_sigframes_topic();
  } else {
    clear_has_sigframes_topic();
  }
}

// -------------------------------------------------------------------

// PodCommsICDVersion

// optional int32 major = 1 [default = 0];
inline bool PodCommsICDVersion::has_major() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PodCommsICDVersion::set_has_major() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PodCommsICDVersion::clear_has_major() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PodCommsICDVersion::clear_major() {
  major_ = 0;
  clear_has_major();
}
inline ::google::protobuf::int32 PodCommsICDVersion::major() const {
  return major_;
}
inline void PodCommsICDVersion::set_major(::google::protobuf::int32 value) {
  set_has_major();
  major_ = value;
}

// optional int32 minor = 2 [default = 0];
inline bool PodCommsICDVersion::has_minor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PodCommsICDVersion::set_has_minor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PodCommsICDVersion::clear_has_minor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PodCommsICDVersion::clear_minor() {
  minor_ = 0;
  clear_has_minor();
}
inline ::google::protobuf::int32 PodCommsICDVersion::minor() const {
  return minor_;
}
inline void PodCommsICDVersion::set_minor(::google::protobuf::int32 value) {
  set_has_minor();
  minor_ = value;
}

// optional int32 patch = 3 [default = 2];
inline bool PodCommsICDVersion::has_patch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PodCommsICDVersion::set_has_patch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PodCommsICDVersion::clear_has_patch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PodCommsICDVersion::clear_patch() {
  patch_ = 2;
  clear_has_patch();
}
inline ::google::protobuf::int32 PodCommsICDVersion::patch() const {
  return patch_;
}
inline void PodCommsICDVersion::set_patch(::google::protobuf::int32 value) {
  set_has_patch();
  patch_ = value;
}

// optional string date = 4 [default = "2020-05-22"];
inline bool PodCommsICDVersion::has_date() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PodCommsICDVersion::set_has_date() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PodCommsICDVersion::clear_has_date() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PodCommsICDVersion::clear_date() {
  if (date_ != _default_date_) {
    date_->assign(*_default_date_);
  }
  clear_has_date();
}
inline const ::std::string& PodCommsICDVersion::date() const {
  return *date_;
}
inline void PodCommsICDVersion::set_date(const ::std::string& value) {
  set_has_date();
  if (date_ == _default_date_) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void PodCommsICDVersion::set_date(const char* value) {
  set_has_date();
  if (date_ == _default_date_) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void PodCommsICDVersion::set_date(const char* value, size_t size) {
  set_has_date();
  if (date_ == _default_date_) {
    date_ = new ::std::string;
  }
  date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PodCommsICDVersion::mutable_date() {
  set_has_date();
  if (date_ == _default_date_) {
    date_ = new ::std::string(*_default_date_);
  }
  return date_;
}
inline ::std::string* PodCommsICDVersion::release_date() {
  clear_has_date();
  if (date_ == _default_date_) {
    return NULL;
  } else {
    ::std::string* temp = date_;
    date_ = const_cast< ::std::string*>(_default_date_);
    return temp;
  }
}
inline void PodCommsICDVersion::set_allocated_date(::std::string* date) {
  if (date_ != _default_date_) {
    delete date_;
  }
  if (date) {
    set_has_date();
    date_ = date;
  } else {
    clear_has_date();
    date_ = const_cast< ::std::string*>(_default_date_);
  }
}

// optional string commit = 5;
inline bool PodCommsICDVersion::has_commit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PodCommsICDVersion::set_has_commit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PodCommsICDVersion::clear_has_commit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PodCommsICDVersion::clear_commit() {
  if (commit_ != &::google::protobuf::internal::kEmptyString) {
    commit_->clear();
  }
  clear_has_commit();
}
inline const ::std::string& PodCommsICDVersion::commit() const {
  return *commit_;
}
inline void PodCommsICDVersion::set_commit(const ::std::string& value) {
  set_has_commit();
  if (commit_ == &::google::protobuf::internal::kEmptyString) {
    commit_ = new ::std::string;
  }
  commit_->assign(value);
}
inline void PodCommsICDVersion::set_commit(const char* value) {
  set_has_commit();
  if (commit_ == &::google::protobuf::internal::kEmptyString) {
    commit_ = new ::std::string;
  }
  commit_->assign(value);
}
inline void PodCommsICDVersion::set_commit(const char* value, size_t size) {
  set_has_commit();
  if (commit_ == &::google::protobuf::internal::kEmptyString) {
    commit_ = new ::std::string;
  }
  commit_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PodCommsICDVersion::mutable_commit() {
  set_has_commit();
  if (commit_ == &::google::protobuf::internal::kEmptyString) {
    commit_ = new ::std::string;
  }
  return commit_;
}
inline ::std::string* PodCommsICDVersion::release_commit() {
  clear_has_commit();
  if (commit_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = commit_;
    commit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PodCommsICDVersion::set_allocated_commit(::std::string* commit) {
  if (commit_ != &::google::protobuf::internal::kEmptyString) {
    delete commit_;
  }
  if (commit) {
    set_has_commit();
    commit_ = commit;
  } else {
    clear_has_commit();
    commit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace PodCommsProtos
}  // namespace protos
}  // namespace podcomms
}  // namespace fv

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_PodCommsMessages_2eproto__INCLUDED
