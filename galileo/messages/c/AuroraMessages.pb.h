// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AuroraMessages.proto

#ifndef PROTOBUF_AuroraMessages_2eproto__INCLUDED
#define PROTOBUF_AuroraMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "ThunderbirdMessages.pb.h"
#include "ServiceInfrastructureCommon.pb.h"
#include "ServiceInfrastructureExclusive.pb.h"
#include "BitMessages.pb.h"
#include "BitStatusMessage.pb.h"
#include "BitManifestMessage.pb.h"
// @@protoc_insertion_point(includes)

namespace fv {
namespace aurora {
namespace protos {
namespace AuroraProtos {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_AuroraMessages_2eproto();
void protobuf_AssignDesc_AuroraMessages_2eproto();
void protobuf_ShutdownFile_AuroraMessages_2eproto();

class NetworkLayout;
class AuroraEnvelope;
class EWSDRCommandTopic;
class EWSDRRequestTopic;
class EWProcessorEnvelope;
class EWSDRStatusTopic;
class AuroraICDVersion;

// ===================================================================

class NetworkLayout : public ::google::protobuf::Message {
 public:
  NetworkLayout();
  virtual ~NetworkLayout();

  NetworkLayout(const NetworkLayout& from);

  inline NetworkLayout& operator=(const NetworkLayout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NetworkLayout& default_instance();

  void Swap(NetworkLayout* other);

  // implements Message ----------------------------------------------

  NetworkLayout* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NetworkLayout& from);
  void MergeFrom(const NetworkLayout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 base_port = 1 [default = 8080];
  inline bool has_base_port() const;
  inline void clear_base_port();
  static const int kBasePortFieldNumber = 1;
  inline ::google::protobuf::int64 base_port() const;
  inline void set_base_port(::google::protobuf::int64 value);

  // optional int64 infrastructure_port_offset = 2 [default = 17];
  inline bool has_infrastructure_port_offset() const;
  inline void clear_infrastructure_port_offset();
  static const int kInfrastructurePortOffsetFieldNumber = 2;
  inline ::google::protobuf::int64 infrastructure_port_offset() const;
  inline void set_infrastructure_port_offset(::google::protobuf::int64 value);

  // optional int64 service_port_offset = 3 [default = 19];
  inline bool has_service_port_offset() const;
  inline void clear_service_port_offset();
  static const int kServicePortOffsetFieldNumber = 3;
  inline ::google::protobuf::int64 service_port_offset() const;
  inline void set_service_port_offset(::google::protobuf::int64 value);

  // optional int64 rx_vita49_port = 4 [default = 40003];
  inline bool has_rx_vita49_port() const;
  inline void clear_rx_vita49_port();
  static const int kRxVita49PortFieldNumber = 4;
  inline ::google::protobuf::int64 rx_vita49_port() const;
  inline void set_rx_vita49_port(::google::protobuf::int64 value);

  // optional int64 tx_vita49_port = 5 [default = 40003];
  inline bool has_tx_vita49_port() const;
  inline void clear_tx_vita49_port();
  static const int kTxVita49PortFieldNumber = 5;
  inline ::google::protobuf::int64 tx_vita49_port() const;
  inline void set_tx_vita49_port(::google::protobuf::int64 value);

  // optional int64 sub_port = 6 [default = 6686];
  inline bool has_sub_port() const;
  inline void clear_sub_port();
  static const int kSubPortFieldNumber = 6;
  inline ::google::protobuf::int64 sub_port() const;
  inline void set_sub_port(::google::protobuf::int64 value);

  // optional int64 pub_port = 7 [default = 5585];
  inline bool has_pub_port() const;
  inline void clear_pub_port();
  static const int kPubPortFieldNumber = 7;
  inline ::google::protobuf::int64 pub_port() const;
  inline void set_pub_port(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:fv.aurora.protos.AuroraProtos.NetworkLayout)
 private:
  inline void set_has_base_port();
  inline void clear_has_base_port();
  inline void set_has_infrastructure_port_offset();
  inline void clear_has_infrastructure_port_offset();
  inline void set_has_service_port_offset();
  inline void clear_has_service_port_offset();
  inline void set_has_rx_vita49_port();
  inline void clear_has_rx_vita49_port();
  inline void set_has_tx_vita49_port();
  inline void clear_has_tx_vita49_port();
  inline void set_has_sub_port();
  inline void clear_has_sub_port();
  inline void set_has_pub_port();
  inline void clear_has_pub_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 base_port_;
  ::google::protobuf::int64 infrastructure_port_offset_;
  ::google::protobuf::int64 service_port_offset_;
  ::google::protobuf::int64 rx_vita49_port_;
  ::google::protobuf::int64 tx_vita49_port_;
  ::google::protobuf::int64 sub_port_;
  ::google::protobuf::int64 pub_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_AuroraMessages_2eproto();
  friend void protobuf_AssignDesc_AuroraMessages_2eproto();
  friend void protobuf_ShutdownFile_AuroraMessages_2eproto();

  void InitAsDefaultInstance();
  static NetworkLayout* default_instance_;
};
// -------------------------------------------------------------------

class AuroraEnvelope : public ::google::protobuf::Message {
 public:
  AuroraEnvelope();
  virtual ~AuroraEnvelope();

  AuroraEnvelope(const AuroraEnvelope& from);

  inline AuroraEnvelope& operator=(const AuroraEnvelope& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuroraEnvelope& default_instance();

  void Swap(AuroraEnvelope* other);

  // implements Message ----------------------------------------------

  AuroraEnvelope* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuroraEnvelope& from);
  void MergeFrom(const AuroraEnvelope& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional .service_infrastructure.Ack ack = 2;
  inline bool has_ack() const;
  inline void clear_ack();
  static const int kAckFieldNumber = 2;
  inline const ::service_infrastructure::Ack& ack() const;
  inline ::service_infrastructure::Ack* mutable_ack();
  inline ::service_infrastructure::Ack* release_ack();
  inline void set_allocated_ack(::service_infrastructure::Ack* ack);

  // optional .service_infrastructure.NAck nack = 3;
  inline bool has_nack() const;
  inline void clear_nack();
  static const int kNackFieldNumber = 3;
  inline const ::service_infrastructure::NAck& nack() const;
  inline ::service_infrastructure::NAck* mutable_nack();
  inline ::service_infrastructure::NAck* release_nack();
  inline void set_allocated_nack(::service_infrastructure::NAck* nack);

  // optional .service_infrastructure.HandshakeTopic handshake = 4;
  inline bool has_handshake() const;
  inline void clear_handshake();
  static const int kHandshakeFieldNumber = 4;
  inline const ::service_infrastructure::HandshakeTopic& handshake() const;
  inline ::service_infrastructure::HandshakeTopic* mutable_handshake();
  inline ::service_infrastructure::HandshakeTopic* release_handshake();
  inline void set_allocated_handshake(::service_infrastructure::HandshakeTopic* handshake);

  // optional .service_infrastructure.EWRequestTopic ew_request = 5;
  inline bool has_ew_request() const;
  inline void clear_ew_request();
  static const int kEwRequestFieldNumber = 5;
  inline const ::service_infrastructure::EWRequestTopic& ew_request() const;
  inline ::service_infrastructure::EWRequestTopic* mutable_ew_request();
  inline ::service_infrastructure::EWRequestTopic* release_ew_request();
  inline void set_allocated_ew_request(::service_infrastructure::EWRequestTopic* ew_request);

  // optional .service_infrastructure.ProductRequestTopic product_request = 6;
  inline bool has_product_request() const;
  inline void clear_product_request();
  static const int kProductRequestFieldNumber = 6;
  inline const ::service_infrastructure::ProductRequestTopic& product_request() const;
  inline ::service_infrastructure::ProductRequestTopic* mutable_product_request();
  inline ::service_infrastructure::ProductRequestTopic* release_product_request();
  inline void set_allocated_product_request(::service_infrastructure::ProductRequestTopic* product_request);

  // optional .fv.aurora.protos.AuroraProtos.EWSDRCommandTopic ew_sdr_command = 7;
  inline bool has_ew_sdr_command() const;
  inline void clear_ew_sdr_command();
  static const int kEwSdrCommandFieldNumber = 7;
  inline const ::fv::aurora::protos::AuroraProtos::EWSDRCommandTopic& ew_sdr_command() const;
  inline ::fv::aurora::protos::AuroraProtos::EWSDRCommandTopic* mutable_ew_sdr_command();
  inline ::fv::aurora::protos::AuroraProtos::EWSDRCommandTopic* release_ew_sdr_command();
  inline void set_allocated_ew_sdr_command(::fv::aurora::protos::AuroraProtos::EWSDRCommandTopic* ew_sdr_command);

  // optional .bit_protos.BitRequestTopic bit_test_request = 8;
  inline bool has_bit_test_request() const;
  inline void clear_bit_test_request();
  static const int kBitTestRequestFieldNumber = 8;
  inline const ::bit_protos::BitRequestTopic& bit_test_request() const;
  inline ::bit_protos::BitRequestTopic* mutable_bit_test_request();
  inline ::bit_protos::BitRequestTopic* release_bit_test_request();
  inline void set_allocated_bit_test_request(::bit_protos::BitRequestTopic* bit_test_request);

  // @@protoc_insertion_point(class_scope:fv.aurora.protos.AuroraProtos.AuroraEnvelope)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_ack();
  inline void clear_has_ack();
  inline void set_has_nack();
  inline void clear_has_nack();
  inline void set_has_handshake();
  inline void clear_has_handshake();
  inline void set_has_ew_request();
  inline void clear_has_ew_request();
  inline void set_has_product_request();
  inline void clear_has_product_request();
  inline void set_has_ew_sdr_command();
  inline void clear_has_ew_sdr_command();
  inline void set_has_bit_test_request();
  inline void clear_has_bit_test_request();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::service_infrastructure::Ack* ack_;
  ::service_infrastructure::NAck* nack_;
  ::service_infrastructure::HandshakeTopic* handshake_;
  ::service_infrastructure::EWRequestTopic* ew_request_;
  ::service_infrastructure::ProductRequestTopic* product_request_;
  ::fv::aurora::protos::AuroraProtos::EWSDRCommandTopic* ew_sdr_command_;
  ::bit_protos::BitRequestTopic* bit_test_request_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_AuroraMessages_2eproto();
  friend void protobuf_AssignDesc_AuroraMessages_2eproto();
  friend void protobuf_ShutdownFile_AuroraMessages_2eproto();

  void InitAsDefaultInstance();
  static AuroraEnvelope* default_instance_;
};
// -------------------------------------------------------------------

class EWSDRCommandTopic : public ::google::protobuf::Message {
 public:
  EWSDRCommandTopic();
  virtual ~EWSDRCommandTopic();

  EWSDRCommandTopic(const EWSDRCommandTopic& from);

  inline EWSDRCommandTopic& operator=(const EWSDRCommandTopic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EWSDRCommandTopic& default_instance();

  void Swap(EWSDRCommandTopic* other);

  // implements Message ----------------------------------------------

  EWSDRCommandTopic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EWSDRCommandTopic& from);
  void MergeFrom(const EWSDRCommandTopic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 100;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 100;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional .fv.tb.protos.TBProtos.EWSDRCommand ew_sdr_command = 1;
  inline bool has_ew_sdr_command() const;
  inline void clear_ew_sdr_command();
  static const int kEwSdrCommandFieldNumber = 1;
  inline const ::fv::tb::protos::TBProtos::EWSDRCommand& ew_sdr_command() const;
  inline ::fv::tb::protos::TBProtos::EWSDRCommand* mutable_ew_sdr_command();
  inline ::fv::tb::protos::TBProtos::EWSDRCommand* release_ew_sdr_command();
  inline void set_allocated_ew_sdr_command(::fv::tb::protos::TBProtos::EWSDRCommand* ew_sdr_command);

  // optional .fv.tb.protos.TBProtos.MissionMode mission_mode = 2;
  inline bool has_mission_mode() const;
  inline void clear_mission_mode();
  static const int kMissionModeFieldNumber = 2;
  inline const ::fv::tb::protos::TBProtos::MissionMode& mission_mode() const;
  inline ::fv::tb::protos::TBProtos::MissionMode* mutable_mission_mode();
  inline ::fv::tb::protos::TBProtos::MissionMode* release_mission_mode();
  inline void set_allocated_mission_mode(::fv::tb::protos::TBProtos::MissionMode* mission_mode);

  // optional .fv.tb.protos.TBProtos.SetAppParameters app_parameters = 3;
  inline bool has_app_parameters() const;
  inline void clear_app_parameters();
  static const int kAppParametersFieldNumber = 3;
  inline const ::fv::tb::protos::TBProtos::SetAppParameters& app_parameters() const;
  inline ::fv::tb::protos::TBProtos::SetAppParameters* mutable_app_parameters();
  inline ::fv::tb::protos::TBProtos::SetAppParameters* release_app_parameters();
  inline void set_allocated_app_parameters(::fv::tb::protos::TBProtos::SetAppParameters* app_parameters);

  // @@protoc_insertion_point(class_scope:fv.aurora.protos.AuroraProtos.EWSDRCommandTopic)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_ew_sdr_command();
  inline void clear_has_ew_sdr_command();
  inline void set_has_mission_mode();
  inline void clear_has_mission_mode();
  inline void set_has_app_parameters();
  inline void clear_has_app_parameters();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::fv::tb::protos::TBProtos::EWSDRCommand* ew_sdr_command_;
  ::fv::tb::protos::TBProtos::MissionMode* mission_mode_;
  ::fv::tb::protos::TBProtos::SetAppParameters* app_parameters_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_AuroraMessages_2eproto();
  friend void protobuf_AssignDesc_AuroraMessages_2eproto();
  friend void protobuf_ShutdownFile_AuroraMessages_2eproto();

  void InitAsDefaultInstance();
  static EWSDRCommandTopic* default_instance_;
};
// -------------------------------------------------------------------

class EWSDRRequestTopic : public ::google::protobuf::Message {
 public:
  EWSDRRequestTopic();
  virtual ~EWSDRRequestTopic();

  EWSDRRequestTopic(const EWSDRRequestTopic& from);

  inline EWSDRRequestTopic& operator=(const EWSDRRequestTopic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EWSDRRequestTopic& default_instance();

  void Swap(EWSDRRequestTopic* other);

  // implements Message ----------------------------------------------

  EWSDRRequestTopic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EWSDRRequestTopic& from);
  void MergeFrom(const EWSDRRequestTopic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 100;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 100;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional .fv.tb.protos.TBProtos.EWSDRRequest ew_sdr_request = 1;
  inline bool has_ew_sdr_request() const;
  inline void clear_ew_sdr_request();
  static const int kEwSdrRequestFieldNumber = 1;
  inline const ::fv::tb::protos::TBProtos::EWSDRRequest& ew_sdr_request() const;
  inline ::fv::tb::protos::TBProtos::EWSDRRequest* mutable_ew_sdr_request();
  inline ::fv::tb::protos::TBProtos::EWSDRRequest* release_ew_sdr_request();
  inline void set_allocated_ew_sdr_request(::fv::tb::protos::TBProtos::EWSDRRequest* ew_sdr_request);

  // optional .fv.tb.protos.TBProtos.MissionMode mission_mode = 2;
  inline bool has_mission_mode() const;
  inline void clear_mission_mode();
  static const int kMissionModeFieldNumber = 2;
  inline const ::fv::tb::protos::TBProtos::MissionMode& mission_mode() const;
  inline ::fv::tb::protos::TBProtos::MissionMode* mutable_mission_mode();
  inline ::fv::tb::protos::TBProtos::MissionMode* release_mission_mode();
  inline void set_allocated_mission_mode(::fv::tb::protos::TBProtos::MissionMode* mission_mode);

  // @@protoc_insertion_point(class_scope:fv.aurora.protos.AuroraProtos.EWSDRRequestTopic)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_ew_sdr_request();
  inline void clear_has_ew_sdr_request();
  inline void set_has_mission_mode();
  inline void clear_has_mission_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::fv::tb::protos::TBProtos::EWSDRRequest* ew_sdr_request_;
  ::fv::tb::protos::TBProtos::MissionMode* mission_mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_AuroraMessages_2eproto();
  friend void protobuf_AssignDesc_AuroraMessages_2eproto();
  friend void protobuf_ShutdownFile_AuroraMessages_2eproto();

  void InitAsDefaultInstance();
  static EWSDRRequestTopic* default_instance_;
};
// -------------------------------------------------------------------

class EWProcessorEnvelope : public ::google::protobuf::Message {
 public:
  EWProcessorEnvelope();
  virtual ~EWProcessorEnvelope();

  EWProcessorEnvelope(const EWProcessorEnvelope& from);

  inline EWProcessorEnvelope& operator=(const EWProcessorEnvelope& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EWProcessorEnvelope& default_instance();

  void Swap(EWProcessorEnvelope* other);

  // implements Message ----------------------------------------------

  EWProcessorEnvelope* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EWProcessorEnvelope& from);
  void MergeFrom(const EWProcessorEnvelope& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional .service_infrastructure.Ack ack = 2;
  inline bool has_ack() const;
  inline void clear_ack();
  static const int kAckFieldNumber = 2;
  inline const ::service_infrastructure::Ack& ack() const;
  inline ::service_infrastructure::Ack* mutable_ack();
  inline ::service_infrastructure::Ack* release_ack();
  inline void set_allocated_ack(::service_infrastructure::Ack* ack);

  // optional .service_infrastructure.NAck nack = 3;
  inline bool has_nack() const;
  inline void clear_nack();
  static const int kNackFieldNumber = 3;
  inline const ::service_infrastructure::NAck& nack() const;
  inline ::service_infrastructure::NAck* mutable_nack();
  inline ::service_infrastructure::NAck* release_nack();
  inline void set_allocated_nack(::service_infrastructure::NAck* nack);

  // optional .service_infrastructure.HandshakeTopic handshake = 4;
  inline bool has_handshake() const;
  inline void clear_handshake();
  static const int kHandshakeFieldNumber = 4;
  inline const ::service_infrastructure::HandshakeTopic& handshake() const;
  inline ::service_infrastructure::HandshakeTopic* mutable_handshake();
  inline ::service_infrastructure::HandshakeTopic* release_handshake();
  inline void set_allocated_handshake(::service_infrastructure::HandshakeTopic* handshake);

  // optional .service_infrastructure.SignalEventTopic signal_event = 5;
  inline bool has_signal_event() const;
  inline void clear_signal_event();
  static const int kSignalEventFieldNumber = 5;
  inline const ::service_infrastructure::SignalEventTopic& signal_event() const;
  inline ::service_infrastructure::SignalEventTopic* mutable_signal_event();
  inline ::service_infrastructure::SignalEventTopic* release_signal_event();
  inline void set_allocated_signal_event(::service_infrastructure::SignalEventTopic* signal_event);

  // optional .service_infrastructure.EWResponseTopic ew_response = 6;
  inline bool has_ew_response() const;
  inline void clear_ew_response();
  static const int kEwResponseFieldNumber = 6;
  inline const ::service_infrastructure::EWResponseTopic& ew_response() const;
  inline ::service_infrastructure::EWResponseTopic* mutable_ew_response();
  inline ::service_infrastructure::EWResponseTopic* release_ew_response();
  inline void set_allocated_ew_response(::service_infrastructure::EWResponseTopic* ew_response);

  // optional .service_infrastructure.ProductResponseTopic product_response = 7;
  inline bool has_product_response() const;
  inline void clear_product_response();
  static const int kProductResponseFieldNumber = 7;
  inline const ::service_infrastructure::ProductResponseTopic& product_response() const;
  inline ::service_infrastructure::ProductResponseTopic* mutable_product_response();
  inline ::service_infrastructure::ProductResponseTopic* release_product_response();
  inline void set_allocated_product_response(::service_infrastructure::ProductResponseTopic* product_response);

  // optional .fv.aurora.protos.AuroraProtos.EWSDRStatusTopic ew_sdr_status = 8;
  inline bool has_ew_sdr_status() const;
  inline void clear_ew_sdr_status();
  static const int kEwSdrStatusFieldNumber = 8;
  inline const ::fv::aurora::protos::AuroraProtos::EWSDRStatusTopic& ew_sdr_status() const;
  inline ::fv::aurora::protos::AuroraProtos::EWSDRStatusTopic* mutable_ew_sdr_status();
  inline ::fv::aurora::protos::AuroraProtos::EWSDRStatusTopic* release_ew_sdr_status();
  inline void set_allocated_ew_sdr_status(::fv::aurora::protos::AuroraProtos::EWSDRStatusTopic* ew_sdr_status);

  // optional .bit_protos.BitResponseTopic bit_test_response = 9;
  inline bool has_bit_test_response() const;
  inline void clear_bit_test_response();
  static const int kBitTestResponseFieldNumber = 9;
  inline const ::bit_protos::BitResponseTopic& bit_test_response() const;
  inline ::bit_protos::BitResponseTopic* mutable_bit_test_response();
  inline ::bit_protos::BitResponseTopic* release_bit_test_response();
  inline void set_allocated_bit_test_response(::bit_protos::BitResponseTopic* bit_test_response);

  // optional .com.srcinc.ngi.data.BitStatusTopic bit_status_response = 10;
  inline bool has_bit_status_response() const;
  inline void clear_bit_status_response();
  static const int kBitStatusResponseFieldNumber = 10;
  inline const ::com::srcinc::ngi::data::BitStatusTopic& bit_status_response() const;
  inline ::com::srcinc::ngi::data::BitStatusTopic* mutable_bit_status_response();
  inline ::com::srcinc::ngi::data::BitStatusTopic* release_bit_status_response();
  inline void set_allocated_bit_status_response(::com::srcinc::ngi::data::BitStatusTopic* bit_status_response);

  // optional .com.srcinc.ngi.data.BitManifestTopic bit_manifest_response = 11;
  inline bool has_bit_manifest_response() const;
  inline void clear_bit_manifest_response();
  static const int kBitManifestResponseFieldNumber = 11;
  inline const ::com::srcinc::ngi::data::BitManifestTopic& bit_manifest_response() const;
  inline ::com::srcinc::ngi::data::BitManifestTopic* mutable_bit_manifest_response();
  inline ::com::srcinc::ngi::data::BitManifestTopic* release_bit_manifest_response();
  inline void set_allocated_bit_manifest_response(::com::srcinc::ngi::data::BitManifestTopic* bit_manifest_response);

  // @@protoc_insertion_point(class_scope:fv.aurora.protos.AuroraProtos.EWProcessorEnvelope)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_ack();
  inline void clear_has_ack();
  inline void set_has_nack();
  inline void clear_has_nack();
  inline void set_has_handshake();
  inline void clear_has_handshake();
  inline void set_has_signal_event();
  inline void clear_has_signal_event();
  inline void set_has_ew_response();
  inline void clear_has_ew_response();
  inline void set_has_product_response();
  inline void clear_has_product_response();
  inline void set_has_ew_sdr_status();
  inline void clear_has_ew_sdr_status();
  inline void set_has_bit_test_response();
  inline void clear_has_bit_test_response();
  inline void set_has_bit_status_response();
  inline void clear_has_bit_status_response();
  inline void set_has_bit_manifest_response();
  inline void clear_has_bit_manifest_response();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::service_infrastructure::Ack* ack_;
  ::service_infrastructure::NAck* nack_;
  ::service_infrastructure::HandshakeTopic* handshake_;
  ::service_infrastructure::SignalEventTopic* signal_event_;
  ::service_infrastructure::EWResponseTopic* ew_response_;
  ::service_infrastructure::ProductResponseTopic* product_response_;
  ::fv::aurora::protos::AuroraProtos::EWSDRStatusTopic* ew_sdr_status_;
  ::bit_protos::BitResponseTopic* bit_test_response_;
  ::com::srcinc::ngi::data::BitStatusTopic* bit_status_response_;
  ::com::srcinc::ngi::data::BitManifestTopic* bit_manifest_response_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_AuroraMessages_2eproto();
  friend void protobuf_AssignDesc_AuroraMessages_2eproto();
  friend void protobuf_ShutdownFile_AuroraMessages_2eproto();

  void InitAsDefaultInstance();
  static EWProcessorEnvelope* default_instance_;
};
// -------------------------------------------------------------------

class EWSDRStatusTopic : public ::google::protobuf::Message {
 public:
  EWSDRStatusTopic();
  virtual ~EWSDRStatusTopic();

  EWSDRStatusTopic(const EWSDRStatusTopic& from);

  inline EWSDRStatusTopic& operator=(const EWSDRStatusTopic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EWSDRStatusTopic& default_instance();

  void Swap(EWSDRStatusTopic* other);

  // implements Message ----------------------------------------------

  EWSDRStatusTopic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EWSDRStatusTopic& from);
  void MergeFrom(const EWSDRStatusTopic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 100;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 100;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional .fv.tb.protos.TBProtos.EWSDRStatus ew_sdr_status = 1;
  inline bool has_ew_sdr_status() const;
  inline void clear_ew_sdr_status();
  static const int kEwSdrStatusFieldNumber = 1;
  inline const ::fv::tb::protos::TBProtos::EWSDRStatus& ew_sdr_status() const;
  inline ::fv::tb::protos::TBProtos::EWSDRStatus* mutable_ew_sdr_status();
  inline ::fv::tb::protos::TBProtos::EWSDRStatus* release_ew_sdr_status();
  inline void set_allocated_ew_sdr_status(::fv::tb::protos::TBProtos::EWSDRStatus* ew_sdr_status);

  // optional .fv.tb.protos.TBProtos.ThreatStatus threat_status = 2;
  inline bool has_threat_status() const;
  inline void clear_threat_status();
  static const int kThreatStatusFieldNumber = 2;
  inline const ::fv::tb::protos::TBProtos::ThreatStatus& threat_status() const;
  inline ::fv::tb::protos::TBProtos::ThreatStatus* mutable_threat_status();
  inline ::fv::tb::protos::TBProtos::ThreatStatus* release_threat_status();
  inline void set_allocated_threat_status(::fv::tb::protos::TBProtos::ThreatStatus* threat_status);

  // @@protoc_insertion_point(class_scope:fv.aurora.protos.AuroraProtos.EWSDRStatusTopic)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_ew_sdr_status();
  inline void clear_has_ew_sdr_status();
  inline void set_has_threat_status();
  inline void clear_has_threat_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::fv::tb::protos::TBProtos::EWSDRStatus* ew_sdr_status_;
  ::fv::tb::protos::TBProtos::ThreatStatus* threat_status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_AuroraMessages_2eproto();
  friend void protobuf_AssignDesc_AuroraMessages_2eproto();
  friend void protobuf_ShutdownFile_AuroraMessages_2eproto();

  void InitAsDefaultInstance();
  static EWSDRStatusTopic* default_instance_;
};
// -------------------------------------------------------------------

class AuroraICDVersion : public ::google::protobuf::Message {
 public:
  AuroraICDVersion();
  virtual ~AuroraICDVersion();

  AuroraICDVersion(const AuroraICDVersion& from);

  inline AuroraICDVersion& operator=(const AuroraICDVersion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuroraICDVersion& default_instance();

  void Swap(AuroraICDVersion* other);

  // implements Message ----------------------------------------------

  AuroraICDVersion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuroraICDVersion& from);
  void MergeFrom(const AuroraICDVersion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 major = 1 [default = 0];
  inline bool has_major() const;
  inline void clear_major();
  static const int kMajorFieldNumber = 1;
  inline ::google::protobuf::int32 major() const;
  inline void set_major(::google::protobuf::int32 value);

  // optional int32 minor = 2 [default = 0];
  inline bool has_minor() const;
  inline void clear_minor();
  static const int kMinorFieldNumber = 2;
  inline ::google::protobuf::int32 minor() const;
  inline void set_minor(::google::protobuf::int32 value);

  // optional int32 patch = 3 [default = 6];
  inline bool has_patch() const;
  inline void clear_patch();
  static const int kPatchFieldNumber = 3;
  inline ::google::protobuf::int32 patch() const;
  inline void set_patch(::google::protobuf::int32 value);

  // optional string date = 4 [default = "2020-08-14"];
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 4;
  inline const ::std::string& date() const;
  inline void set_date(const ::std::string& value);
  inline void set_date(const char* value);
  inline void set_date(const char* value, size_t size);
  inline ::std::string* mutable_date();
  inline ::std::string* release_date();
  inline void set_allocated_date(::std::string* date);

  // optional string commit = 5;
  inline bool has_commit() const;
  inline void clear_commit();
  static const int kCommitFieldNumber = 5;
  inline const ::std::string& commit() const;
  inline void set_commit(const ::std::string& value);
  inline void set_commit(const char* value);
  inline void set_commit(const char* value, size_t size);
  inline ::std::string* mutable_commit();
  inline ::std::string* release_commit();
  inline void set_allocated_commit(::std::string* commit);

  // @@protoc_insertion_point(class_scope:fv.aurora.protos.AuroraProtos.AuroraICDVersion)
 private:
  inline void set_has_major();
  inline void clear_has_major();
  inline void set_has_minor();
  inline void clear_has_minor();
  inline void set_has_patch();
  inline void clear_has_patch();
  inline void set_has_date();
  inline void clear_has_date();
  inline void set_has_commit();
  inline void clear_has_commit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 major_;
  ::google::protobuf::int32 minor_;
  ::std::string* date_;
  static ::std::string* _default_date_;
  ::std::string* commit_;
  ::google::protobuf::int32 patch_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_AuroraMessages_2eproto();
  friend void protobuf_AssignDesc_AuroraMessages_2eproto();
  friend void protobuf_ShutdownFile_AuroraMessages_2eproto();

  void InitAsDefaultInstance();
  static AuroraICDVersion* default_instance_;
};
// ===================================================================


// ===================================================================

// NetworkLayout

// optional int64 base_port = 1 [default = 8080];
inline bool NetworkLayout::has_base_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetworkLayout::set_has_base_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetworkLayout::clear_has_base_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetworkLayout::clear_base_port() {
  base_port_ = GOOGLE_LONGLONG(8080);
  clear_has_base_port();
}
inline ::google::protobuf::int64 NetworkLayout::base_port() const {
  return base_port_;
}
inline void NetworkLayout::set_base_port(::google::protobuf::int64 value) {
  set_has_base_port();
  base_port_ = value;
}

// optional int64 infrastructure_port_offset = 2 [default = 17];
inline bool NetworkLayout::has_infrastructure_port_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetworkLayout::set_has_infrastructure_port_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetworkLayout::clear_has_infrastructure_port_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetworkLayout::clear_infrastructure_port_offset() {
  infrastructure_port_offset_ = GOOGLE_LONGLONG(17);
  clear_has_infrastructure_port_offset();
}
inline ::google::protobuf::int64 NetworkLayout::infrastructure_port_offset() const {
  return infrastructure_port_offset_;
}
inline void NetworkLayout::set_infrastructure_port_offset(::google::protobuf::int64 value) {
  set_has_infrastructure_port_offset();
  infrastructure_port_offset_ = value;
}

// optional int64 service_port_offset = 3 [default = 19];
inline bool NetworkLayout::has_service_port_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NetworkLayout::set_has_service_port_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NetworkLayout::clear_has_service_port_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NetworkLayout::clear_service_port_offset() {
  service_port_offset_ = GOOGLE_LONGLONG(19);
  clear_has_service_port_offset();
}
inline ::google::protobuf::int64 NetworkLayout::service_port_offset() const {
  return service_port_offset_;
}
inline void NetworkLayout::set_service_port_offset(::google::protobuf::int64 value) {
  set_has_service_port_offset();
  service_port_offset_ = value;
}

// optional int64 rx_vita49_port = 4 [default = 40003];
inline bool NetworkLayout::has_rx_vita49_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NetworkLayout::set_has_rx_vita49_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NetworkLayout::clear_has_rx_vita49_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NetworkLayout::clear_rx_vita49_port() {
  rx_vita49_port_ = GOOGLE_LONGLONG(40003);
  clear_has_rx_vita49_port();
}
inline ::google::protobuf::int64 NetworkLayout::rx_vita49_port() const {
  return rx_vita49_port_;
}
inline void NetworkLayout::set_rx_vita49_port(::google::protobuf::int64 value) {
  set_has_rx_vita49_port();
  rx_vita49_port_ = value;
}

// optional int64 tx_vita49_port = 5 [default = 40003];
inline bool NetworkLayout::has_tx_vita49_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NetworkLayout::set_has_tx_vita49_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NetworkLayout::clear_has_tx_vita49_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NetworkLayout::clear_tx_vita49_port() {
  tx_vita49_port_ = GOOGLE_LONGLONG(40003);
  clear_has_tx_vita49_port();
}
inline ::google::protobuf::int64 NetworkLayout::tx_vita49_port() const {
  return tx_vita49_port_;
}
inline void NetworkLayout::set_tx_vita49_port(::google::protobuf::int64 value) {
  set_has_tx_vita49_port();
  tx_vita49_port_ = value;
}

// optional int64 sub_port = 6 [default = 6686];
inline bool NetworkLayout::has_sub_port() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NetworkLayout::set_has_sub_port() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NetworkLayout::clear_has_sub_port() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NetworkLayout::clear_sub_port() {
  sub_port_ = GOOGLE_LONGLONG(6686);
  clear_has_sub_port();
}
inline ::google::protobuf::int64 NetworkLayout::sub_port() const {
  return sub_port_;
}
inline void NetworkLayout::set_sub_port(::google::protobuf::int64 value) {
  set_has_sub_port();
  sub_port_ = value;
}

// optional int64 pub_port = 7 [default = 5585];
inline bool NetworkLayout::has_pub_port() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NetworkLayout::set_has_pub_port() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NetworkLayout::clear_has_pub_port() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NetworkLayout::clear_pub_port() {
  pub_port_ = GOOGLE_LONGLONG(5585);
  clear_has_pub_port();
}
inline ::google::protobuf::int64 NetworkLayout::pub_port() const {
  return pub_port_;
}
inline void NetworkLayout::set_pub_port(::google::protobuf::int64 value) {
  set_has_pub_port();
  pub_port_ = value;
}

// -------------------------------------------------------------------

// AuroraEnvelope

// optional .service_infrastructure.Header header = 1;
inline bool AuroraEnvelope::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuroraEnvelope::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuroraEnvelope::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuroraEnvelope::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& AuroraEnvelope::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* AuroraEnvelope::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* AuroraEnvelope::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void AuroraEnvelope::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .service_infrastructure.Ack ack = 2;
inline bool AuroraEnvelope::has_ack() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuroraEnvelope::set_has_ack() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuroraEnvelope::clear_has_ack() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuroraEnvelope::clear_ack() {
  if (ack_ != NULL) ack_->::service_infrastructure::Ack::Clear();
  clear_has_ack();
}
inline const ::service_infrastructure::Ack& AuroraEnvelope::ack() const {
  return ack_ != NULL ? *ack_ : *default_instance_->ack_;
}
inline ::service_infrastructure::Ack* AuroraEnvelope::mutable_ack() {
  set_has_ack();
  if (ack_ == NULL) ack_ = new ::service_infrastructure::Ack;
  return ack_;
}
inline ::service_infrastructure::Ack* AuroraEnvelope::release_ack() {
  clear_has_ack();
  ::service_infrastructure::Ack* temp = ack_;
  ack_ = NULL;
  return temp;
}
inline void AuroraEnvelope::set_allocated_ack(::service_infrastructure::Ack* ack) {
  delete ack_;
  ack_ = ack;
  if (ack) {
    set_has_ack();
  } else {
    clear_has_ack();
  }
}

// optional .service_infrastructure.NAck nack = 3;
inline bool AuroraEnvelope::has_nack() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AuroraEnvelope::set_has_nack() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AuroraEnvelope::clear_has_nack() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AuroraEnvelope::clear_nack() {
  if (nack_ != NULL) nack_->::service_infrastructure::NAck::Clear();
  clear_has_nack();
}
inline const ::service_infrastructure::NAck& AuroraEnvelope::nack() const {
  return nack_ != NULL ? *nack_ : *default_instance_->nack_;
}
inline ::service_infrastructure::NAck* AuroraEnvelope::mutable_nack() {
  set_has_nack();
  if (nack_ == NULL) nack_ = new ::service_infrastructure::NAck;
  return nack_;
}
inline ::service_infrastructure::NAck* AuroraEnvelope::release_nack() {
  clear_has_nack();
  ::service_infrastructure::NAck* temp = nack_;
  nack_ = NULL;
  return temp;
}
inline void AuroraEnvelope::set_allocated_nack(::service_infrastructure::NAck* nack) {
  delete nack_;
  nack_ = nack;
  if (nack) {
    set_has_nack();
  } else {
    clear_has_nack();
  }
}

// optional .service_infrastructure.HandshakeTopic handshake = 4;
inline bool AuroraEnvelope::has_handshake() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AuroraEnvelope::set_has_handshake() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AuroraEnvelope::clear_has_handshake() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AuroraEnvelope::clear_handshake() {
  if (handshake_ != NULL) handshake_->::service_infrastructure::HandshakeTopic::Clear();
  clear_has_handshake();
}
inline const ::service_infrastructure::HandshakeTopic& AuroraEnvelope::handshake() const {
  return handshake_ != NULL ? *handshake_ : *default_instance_->handshake_;
}
inline ::service_infrastructure::HandshakeTopic* AuroraEnvelope::mutable_handshake() {
  set_has_handshake();
  if (handshake_ == NULL) handshake_ = new ::service_infrastructure::HandshakeTopic;
  return handshake_;
}
inline ::service_infrastructure::HandshakeTopic* AuroraEnvelope::release_handshake() {
  clear_has_handshake();
  ::service_infrastructure::HandshakeTopic* temp = handshake_;
  handshake_ = NULL;
  return temp;
}
inline void AuroraEnvelope::set_allocated_handshake(::service_infrastructure::HandshakeTopic* handshake) {
  delete handshake_;
  handshake_ = handshake;
  if (handshake) {
    set_has_handshake();
  } else {
    clear_has_handshake();
  }
}

// optional .service_infrastructure.EWRequestTopic ew_request = 5;
inline bool AuroraEnvelope::has_ew_request() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AuroraEnvelope::set_has_ew_request() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AuroraEnvelope::clear_has_ew_request() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AuroraEnvelope::clear_ew_request() {
  if (ew_request_ != NULL) ew_request_->::service_infrastructure::EWRequestTopic::Clear();
  clear_has_ew_request();
}
inline const ::service_infrastructure::EWRequestTopic& AuroraEnvelope::ew_request() const {
  return ew_request_ != NULL ? *ew_request_ : *default_instance_->ew_request_;
}
inline ::service_infrastructure::EWRequestTopic* AuroraEnvelope::mutable_ew_request() {
  set_has_ew_request();
  if (ew_request_ == NULL) ew_request_ = new ::service_infrastructure::EWRequestTopic;
  return ew_request_;
}
inline ::service_infrastructure::EWRequestTopic* AuroraEnvelope::release_ew_request() {
  clear_has_ew_request();
  ::service_infrastructure::EWRequestTopic* temp = ew_request_;
  ew_request_ = NULL;
  return temp;
}
inline void AuroraEnvelope::set_allocated_ew_request(::service_infrastructure::EWRequestTopic* ew_request) {
  delete ew_request_;
  ew_request_ = ew_request;
  if (ew_request) {
    set_has_ew_request();
  } else {
    clear_has_ew_request();
  }
}

// optional .service_infrastructure.ProductRequestTopic product_request = 6;
inline bool AuroraEnvelope::has_product_request() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AuroraEnvelope::set_has_product_request() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AuroraEnvelope::clear_has_product_request() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AuroraEnvelope::clear_product_request() {
  if (product_request_ != NULL) product_request_->::service_infrastructure::ProductRequestTopic::Clear();
  clear_has_product_request();
}
inline const ::service_infrastructure::ProductRequestTopic& AuroraEnvelope::product_request() const {
  return product_request_ != NULL ? *product_request_ : *default_instance_->product_request_;
}
inline ::service_infrastructure::ProductRequestTopic* AuroraEnvelope::mutable_product_request() {
  set_has_product_request();
  if (product_request_ == NULL) product_request_ = new ::service_infrastructure::ProductRequestTopic;
  return product_request_;
}
inline ::service_infrastructure::ProductRequestTopic* AuroraEnvelope::release_product_request() {
  clear_has_product_request();
  ::service_infrastructure::ProductRequestTopic* temp = product_request_;
  product_request_ = NULL;
  return temp;
}
inline void AuroraEnvelope::set_allocated_product_request(::service_infrastructure::ProductRequestTopic* product_request) {
  delete product_request_;
  product_request_ = product_request;
  if (product_request) {
    set_has_product_request();
  } else {
    clear_has_product_request();
  }
}

// optional .fv.aurora.protos.AuroraProtos.EWSDRCommandTopic ew_sdr_command = 7;
inline bool AuroraEnvelope::has_ew_sdr_command() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AuroraEnvelope::set_has_ew_sdr_command() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AuroraEnvelope::clear_has_ew_sdr_command() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AuroraEnvelope::clear_ew_sdr_command() {
  if (ew_sdr_command_ != NULL) ew_sdr_command_->::fv::aurora::protos::AuroraProtos::EWSDRCommandTopic::Clear();
  clear_has_ew_sdr_command();
}
inline const ::fv::aurora::protos::AuroraProtos::EWSDRCommandTopic& AuroraEnvelope::ew_sdr_command() const {
  return ew_sdr_command_ != NULL ? *ew_sdr_command_ : *default_instance_->ew_sdr_command_;
}
inline ::fv::aurora::protos::AuroraProtos::EWSDRCommandTopic* AuroraEnvelope::mutable_ew_sdr_command() {
  set_has_ew_sdr_command();
  if (ew_sdr_command_ == NULL) ew_sdr_command_ = new ::fv::aurora::protos::AuroraProtos::EWSDRCommandTopic;
  return ew_sdr_command_;
}
inline ::fv::aurora::protos::AuroraProtos::EWSDRCommandTopic* AuroraEnvelope::release_ew_sdr_command() {
  clear_has_ew_sdr_command();
  ::fv::aurora::protos::AuroraProtos::EWSDRCommandTopic* temp = ew_sdr_command_;
  ew_sdr_command_ = NULL;
  return temp;
}
inline void AuroraEnvelope::set_allocated_ew_sdr_command(::fv::aurora::protos::AuroraProtos::EWSDRCommandTopic* ew_sdr_command) {
  delete ew_sdr_command_;
  ew_sdr_command_ = ew_sdr_command;
  if (ew_sdr_command) {
    set_has_ew_sdr_command();
  } else {
    clear_has_ew_sdr_command();
  }
}

// optional .bit_protos.BitRequestTopic bit_test_request = 8;
inline bool AuroraEnvelope::has_bit_test_request() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AuroraEnvelope::set_has_bit_test_request() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AuroraEnvelope::clear_has_bit_test_request() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AuroraEnvelope::clear_bit_test_request() {
  if (bit_test_request_ != NULL) bit_test_request_->::bit_protos::BitRequestTopic::Clear();
  clear_has_bit_test_request();
}
inline const ::bit_protos::BitRequestTopic& AuroraEnvelope::bit_test_request() const {
  return bit_test_request_ != NULL ? *bit_test_request_ : *default_instance_->bit_test_request_;
}
inline ::bit_protos::BitRequestTopic* AuroraEnvelope::mutable_bit_test_request() {
  set_has_bit_test_request();
  if (bit_test_request_ == NULL) bit_test_request_ = new ::bit_protos::BitRequestTopic;
  return bit_test_request_;
}
inline ::bit_protos::BitRequestTopic* AuroraEnvelope::release_bit_test_request() {
  clear_has_bit_test_request();
  ::bit_protos::BitRequestTopic* temp = bit_test_request_;
  bit_test_request_ = NULL;
  return temp;
}
inline void AuroraEnvelope::set_allocated_bit_test_request(::bit_protos::BitRequestTopic* bit_test_request) {
  delete bit_test_request_;
  bit_test_request_ = bit_test_request;
  if (bit_test_request) {
    set_has_bit_test_request();
  } else {
    clear_has_bit_test_request();
  }
}

// -------------------------------------------------------------------

// EWSDRCommandTopic

// optional .service_infrastructure.Header header = 100;
inline bool EWSDRCommandTopic::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EWSDRCommandTopic::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EWSDRCommandTopic::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EWSDRCommandTopic::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& EWSDRCommandTopic::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* EWSDRCommandTopic::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* EWSDRCommandTopic::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void EWSDRCommandTopic::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .fv.tb.protos.TBProtos.EWSDRCommand ew_sdr_command = 1;
inline bool EWSDRCommandTopic::has_ew_sdr_command() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EWSDRCommandTopic::set_has_ew_sdr_command() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EWSDRCommandTopic::clear_has_ew_sdr_command() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EWSDRCommandTopic::clear_ew_sdr_command() {
  if (ew_sdr_command_ != NULL) ew_sdr_command_->::fv::tb::protos::TBProtos::EWSDRCommand::Clear();
  clear_has_ew_sdr_command();
}
inline const ::fv::tb::protos::TBProtos::EWSDRCommand& EWSDRCommandTopic::ew_sdr_command() const {
  return ew_sdr_command_ != NULL ? *ew_sdr_command_ : *default_instance_->ew_sdr_command_;
}
inline ::fv::tb::protos::TBProtos::EWSDRCommand* EWSDRCommandTopic::mutable_ew_sdr_command() {
  set_has_ew_sdr_command();
  if (ew_sdr_command_ == NULL) ew_sdr_command_ = new ::fv::tb::protos::TBProtos::EWSDRCommand;
  return ew_sdr_command_;
}
inline ::fv::tb::protos::TBProtos::EWSDRCommand* EWSDRCommandTopic::release_ew_sdr_command() {
  clear_has_ew_sdr_command();
  ::fv::tb::protos::TBProtos::EWSDRCommand* temp = ew_sdr_command_;
  ew_sdr_command_ = NULL;
  return temp;
}
inline void EWSDRCommandTopic::set_allocated_ew_sdr_command(::fv::tb::protos::TBProtos::EWSDRCommand* ew_sdr_command) {
  delete ew_sdr_command_;
  ew_sdr_command_ = ew_sdr_command;
  if (ew_sdr_command) {
    set_has_ew_sdr_command();
  } else {
    clear_has_ew_sdr_command();
  }
}

// optional .fv.tb.protos.TBProtos.MissionMode mission_mode = 2;
inline bool EWSDRCommandTopic::has_mission_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EWSDRCommandTopic::set_has_mission_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EWSDRCommandTopic::clear_has_mission_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EWSDRCommandTopic::clear_mission_mode() {
  if (mission_mode_ != NULL) mission_mode_->::fv::tb::protos::TBProtos::MissionMode::Clear();
  clear_has_mission_mode();
}
inline const ::fv::tb::protos::TBProtos::MissionMode& EWSDRCommandTopic::mission_mode() const {
  return mission_mode_ != NULL ? *mission_mode_ : *default_instance_->mission_mode_;
}
inline ::fv::tb::protos::TBProtos::MissionMode* EWSDRCommandTopic::mutable_mission_mode() {
  set_has_mission_mode();
  if (mission_mode_ == NULL) mission_mode_ = new ::fv::tb::protos::TBProtos::MissionMode;
  return mission_mode_;
}
inline ::fv::tb::protos::TBProtos::MissionMode* EWSDRCommandTopic::release_mission_mode() {
  clear_has_mission_mode();
  ::fv::tb::protos::TBProtos::MissionMode* temp = mission_mode_;
  mission_mode_ = NULL;
  return temp;
}
inline void EWSDRCommandTopic::set_allocated_mission_mode(::fv::tb::protos::TBProtos::MissionMode* mission_mode) {
  delete mission_mode_;
  mission_mode_ = mission_mode;
  if (mission_mode) {
    set_has_mission_mode();
  } else {
    clear_has_mission_mode();
  }
}

// optional .fv.tb.protos.TBProtos.SetAppParameters app_parameters = 3;
inline bool EWSDRCommandTopic::has_app_parameters() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EWSDRCommandTopic::set_has_app_parameters() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EWSDRCommandTopic::clear_has_app_parameters() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EWSDRCommandTopic::clear_app_parameters() {
  if (app_parameters_ != NULL) app_parameters_->::fv::tb::protos::TBProtos::SetAppParameters::Clear();
  clear_has_app_parameters();
}
inline const ::fv::tb::protos::TBProtos::SetAppParameters& EWSDRCommandTopic::app_parameters() const {
  return app_parameters_ != NULL ? *app_parameters_ : *default_instance_->app_parameters_;
}
inline ::fv::tb::protos::TBProtos::SetAppParameters* EWSDRCommandTopic::mutable_app_parameters() {
  set_has_app_parameters();
  if (app_parameters_ == NULL) app_parameters_ = new ::fv::tb::protos::TBProtos::SetAppParameters;
  return app_parameters_;
}
inline ::fv::tb::protos::TBProtos::SetAppParameters* EWSDRCommandTopic::release_app_parameters() {
  clear_has_app_parameters();
  ::fv::tb::protos::TBProtos::SetAppParameters* temp = app_parameters_;
  app_parameters_ = NULL;
  return temp;
}
inline void EWSDRCommandTopic::set_allocated_app_parameters(::fv::tb::protos::TBProtos::SetAppParameters* app_parameters) {
  delete app_parameters_;
  app_parameters_ = app_parameters;
  if (app_parameters) {
    set_has_app_parameters();
  } else {
    clear_has_app_parameters();
  }
}

// -------------------------------------------------------------------

// EWSDRRequestTopic

// optional .service_infrastructure.Header header = 100;
inline bool EWSDRRequestTopic::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EWSDRRequestTopic::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EWSDRRequestTopic::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EWSDRRequestTopic::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& EWSDRRequestTopic::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* EWSDRRequestTopic::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* EWSDRRequestTopic::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void EWSDRRequestTopic::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .fv.tb.protos.TBProtos.EWSDRRequest ew_sdr_request = 1;
inline bool EWSDRRequestTopic::has_ew_sdr_request() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EWSDRRequestTopic::set_has_ew_sdr_request() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EWSDRRequestTopic::clear_has_ew_sdr_request() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EWSDRRequestTopic::clear_ew_sdr_request() {
  if (ew_sdr_request_ != NULL) ew_sdr_request_->::fv::tb::protos::TBProtos::EWSDRRequest::Clear();
  clear_has_ew_sdr_request();
}
inline const ::fv::tb::protos::TBProtos::EWSDRRequest& EWSDRRequestTopic::ew_sdr_request() const {
  return ew_sdr_request_ != NULL ? *ew_sdr_request_ : *default_instance_->ew_sdr_request_;
}
inline ::fv::tb::protos::TBProtos::EWSDRRequest* EWSDRRequestTopic::mutable_ew_sdr_request() {
  set_has_ew_sdr_request();
  if (ew_sdr_request_ == NULL) ew_sdr_request_ = new ::fv::tb::protos::TBProtos::EWSDRRequest;
  return ew_sdr_request_;
}
inline ::fv::tb::protos::TBProtos::EWSDRRequest* EWSDRRequestTopic::release_ew_sdr_request() {
  clear_has_ew_sdr_request();
  ::fv::tb::protos::TBProtos::EWSDRRequest* temp = ew_sdr_request_;
  ew_sdr_request_ = NULL;
  return temp;
}
inline void EWSDRRequestTopic::set_allocated_ew_sdr_request(::fv::tb::protos::TBProtos::EWSDRRequest* ew_sdr_request) {
  delete ew_sdr_request_;
  ew_sdr_request_ = ew_sdr_request;
  if (ew_sdr_request) {
    set_has_ew_sdr_request();
  } else {
    clear_has_ew_sdr_request();
  }
}

// optional .fv.tb.protos.TBProtos.MissionMode mission_mode = 2;
inline bool EWSDRRequestTopic::has_mission_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EWSDRRequestTopic::set_has_mission_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EWSDRRequestTopic::clear_has_mission_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EWSDRRequestTopic::clear_mission_mode() {
  if (mission_mode_ != NULL) mission_mode_->::fv::tb::protos::TBProtos::MissionMode::Clear();
  clear_has_mission_mode();
}
inline const ::fv::tb::protos::TBProtos::MissionMode& EWSDRRequestTopic::mission_mode() const {
  return mission_mode_ != NULL ? *mission_mode_ : *default_instance_->mission_mode_;
}
inline ::fv::tb::protos::TBProtos::MissionMode* EWSDRRequestTopic::mutable_mission_mode() {
  set_has_mission_mode();
  if (mission_mode_ == NULL) mission_mode_ = new ::fv::tb::protos::TBProtos::MissionMode;
  return mission_mode_;
}
inline ::fv::tb::protos::TBProtos::MissionMode* EWSDRRequestTopic::release_mission_mode() {
  clear_has_mission_mode();
  ::fv::tb::protos::TBProtos::MissionMode* temp = mission_mode_;
  mission_mode_ = NULL;
  return temp;
}
inline void EWSDRRequestTopic::set_allocated_mission_mode(::fv::tb::protos::TBProtos::MissionMode* mission_mode) {
  delete mission_mode_;
  mission_mode_ = mission_mode;
  if (mission_mode) {
    set_has_mission_mode();
  } else {
    clear_has_mission_mode();
  }
}

// -------------------------------------------------------------------

// EWProcessorEnvelope

// optional .service_infrastructure.Header header = 1;
inline bool EWProcessorEnvelope::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EWProcessorEnvelope::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EWProcessorEnvelope::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EWProcessorEnvelope::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& EWProcessorEnvelope::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* EWProcessorEnvelope::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* EWProcessorEnvelope::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void EWProcessorEnvelope::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .service_infrastructure.Ack ack = 2;
inline bool EWProcessorEnvelope::has_ack() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EWProcessorEnvelope::set_has_ack() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EWProcessorEnvelope::clear_has_ack() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EWProcessorEnvelope::clear_ack() {
  if (ack_ != NULL) ack_->::service_infrastructure::Ack::Clear();
  clear_has_ack();
}
inline const ::service_infrastructure::Ack& EWProcessorEnvelope::ack() const {
  return ack_ != NULL ? *ack_ : *default_instance_->ack_;
}
inline ::service_infrastructure::Ack* EWProcessorEnvelope::mutable_ack() {
  set_has_ack();
  if (ack_ == NULL) ack_ = new ::service_infrastructure::Ack;
  return ack_;
}
inline ::service_infrastructure::Ack* EWProcessorEnvelope::release_ack() {
  clear_has_ack();
  ::service_infrastructure::Ack* temp = ack_;
  ack_ = NULL;
  return temp;
}
inline void EWProcessorEnvelope::set_allocated_ack(::service_infrastructure::Ack* ack) {
  delete ack_;
  ack_ = ack;
  if (ack) {
    set_has_ack();
  } else {
    clear_has_ack();
  }
}

// optional .service_infrastructure.NAck nack = 3;
inline bool EWProcessorEnvelope::has_nack() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EWProcessorEnvelope::set_has_nack() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EWProcessorEnvelope::clear_has_nack() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EWProcessorEnvelope::clear_nack() {
  if (nack_ != NULL) nack_->::service_infrastructure::NAck::Clear();
  clear_has_nack();
}
inline const ::service_infrastructure::NAck& EWProcessorEnvelope::nack() const {
  return nack_ != NULL ? *nack_ : *default_instance_->nack_;
}
inline ::service_infrastructure::NAck* EWProcessorEnvelope::mutable_nack() {
  set_has_nack();
  if (nack_ == NULL) nack_ = new ::service_infrastructure::NAck;
  return nack_;
}
inline ::service_infrastructure::NAck* EWProcessorEnvelope::release_nack() {
  clear_has_nack();
  ::service_infrastructure::NAck* temp = nack_;
  nack_ = NULL;
  return temp;
}
inline void EWProcessorEnvelope::set_allocated_nack(::service_infrastructure::NAck* nack) {
  delete nack_;
  nack_ = nack;
  if (nack) {
    set_has_nack();
  } else {
    clear_has_nack();
  }
}

// optional .service_infrastructure.HandshakeTopic handshake = 4;
inline bool EWProcessorEnvelope::has_handshake() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EWProcessorEnvelope::set_has_handshake() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EWProcessorEnvelope::clear_has_handshake() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EWProcessorEnvelope::clear_handshake() {
  if (handshake_ != NULL) handshake_->::service_infrastructure::HandshakeTopic::Clear();
  clear_has_handshake();
}
inline const ::service_infrastructure::HandshakeTopic& EWProcessorEnvelope::handshake() const {
  return handshake_ != NULL ? *handshake_ : *default_instance_->handshake_;
}
inline ::service_infrastructure::HandshakeTopic* EWProcessorEnvelope::mutable_handshake() {
  set_has_handshake();
  if (handshake_ == NULL) handshake_ = new ::service_infrastructure::HandshakeTopic;
  return handshake_;
}
inline ::service_infrastructure::HandshakeTopic* EWProcessorEnvelope::release_handshake() {
  clear_has_handshake();
  ::service_infrastructure::HandshakeTopic* temp = handshake_;
  handshake_ = NULL;
  return temp;
}
inline void EWProcessorEnvelope::set_allocated_handshake(::service_infrastructure::HandshakeTopic* handshake) {
  delete handshake_;
  handshake_ = handshake;
  if (handshake) {
    set_has_handshake();
  } else {
    clear_has_handshake();
  }
}

// optional .service_infrastructure.SignalEventTopic signal_event = 5;
inline bool EWProcessorEnvelope::has_signal_event() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EWProcessorEnvelope::set_has_signal_event() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EWProcessorEnvelope::clear_has_signal_event() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EWProcessorEnvelope::clear_signal_event() {
  if (signal_event_ != NULL) signal_event_->::service_infrastructure::SignalEventTopic::Clear();
  clear_has_signal_event();
}
inline const ::service_infrastructure::SignalEventTopic& EWProcessorEnvelope::signal_event() const {
  return signal_event_ != NULL ? *signal_event_ : *default_instance_->signal_event_;
}
inline ::service_infrastructure::SignalEventTopic* EWProcessorEnvelope::mutable_signal_event() {
  set_has_signal_event();
  if (signal_event_ == NULL) signal_event_ = new ::service_infrastructure::SignalEventTopic;
  return signal_event_;
}
inline ::service_infrastructure::SignalEventTopic* EWProcessorEnvelope::release_signal_event() {
  clear_has_signal_event();
  ::service_infrastructure::SignalEventTopic* temp = signal_event_;
  signal_event_ = NULL;
  return temp;
}
inline void EWProcessorEnvelope::set_allocated_signal_event(::service_infrastructure::SignalEventTopic* signal_event) {
  delete signal_event_;
  signal_event_ = signal_event;
  if (signal_event) {
    set_has_signal_event();
  } else {
    clear_has_signal_event();
  }
}

// optional .service_infrastructure.EWResponseTopic ew_response = 6;
inline bool EWProcessorEnvelope::has_ew_response() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EWProcessorEnvelope::set_has_ew_response() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EWProcessorEnvelope::clear_has_ew_response() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EWProcessorEnvelope::clear_ew_response() {
  if (ew_response_ != NULL) ew_response_->::service_infrastructure::EWResponseTopic::Clear();
  clear_has_ew_response();
}
inline const ::service_infrastructure::EWResponseTopic& EWProcessorEnvelope::ew_response() const {
  return ew_response_ != NULL ? *ew_response_ : *default_instance_->ew_response_;
}
inline ::service_infrastructure::EWResponseTopic* EWProcessorEnvelope::mutable_ew_response() {
  set_has_ew_response();
  if (ew_response_ == NULL) ew_response_ = new ::service_infrastructure::EWResponseTopic;
  return ew_response_;
}
inline ::service_infrastructure::EWResponseTopic* EWProcessorEnvelope::release_ew_response() {
  clear_has_ew_response();
  ::service_infrastructure::EWResponseTopic* temp = ew_response_;
  ew_response_ = NULL;
  return temp;
}
inline void EWProcessorEnvelope::set_allocated_ew_response(::service_infrastructure::EWResponseTopic* ew_response) {
  delete ew_response_;
  ew_response_ = ew_response;
  if (ew_response) {
    set_has_ew_response();
  } else {
    clear_has_ew_response();
  }
}

// optional .service_infrastructure.ProductResponseTopic product_response = 7;
inline bool EWProcessorEnvelope::has_product_response() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EWProcessorEnvelope::set_has_product_response() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EWProcessorEnvelope::clear_has_product_response() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EWProcessorEnvelope::clear_product_response() {
  if (product_response_ != NULL) product_response_->::service_infrastructure::ProductResponseTopic::Clear();
  clear_has_product_response();
}
inline const ::service_infrastructure::ProductResponseTopic& EWProcessorEnvelope::product_response() const {
  return product_response_ != NULL ? *product_response_ : *default_instance_->product_response_;
}
inline ::service_infrastructure::ProductResponseTopic* EWProcessorEnvelope::mutable_product_response() {
  set_has_product_response();
  if (product_response_ == NULL) product_response_ = new ::service_infrastructure::ProductResponseTopic;
  return product_response_;
}
inline ::service_infrastructure::ProductResponseTopic* EWProcessorEnvelope::release_product_response() {
  clear_has_product_response();
  ::service_infrastructure::ProductResponseTopic* temp = product_response_;
  product_response_ = NULL;
  return temp;
}
inline void EWProcessorEnvelope::set_allocated_product_response(::service_infrastructure::ProductResponseTopic* product_response) {
  delete product_response_;
  product_response_ = product_response;
  if (product_response) {
    set_has_product_response();
  } else {
    clear_has_product_response();
  }
}

// optional .fv.aurora.protos.AuroraProtos.EWSDRStatusTopic ew_sdr_status = 8;
inline bool EWProcessorEnvelope::has_ew_sdr_status() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EWProcessorEnvelope::set_has_ew_sdr_status() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EWProcessorEnvelope::clear_has_ew_sdr_status() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EWProcessorEnvelope::clear_ew_sdr_status() {
  if (ew_sdr_status_ != NULL) ew_sdr_status_->::fv::aurora::protos::AuroraProtos::EWSDRStatusTopic::Clear();
  clear_has_ew_sdr_status();
}
inline const ::fv::aurora::protos::AuroraProtos::EWSDRStatusTopic& EWProcessorEnvelope::ew_sdr_status() const {
  return ew_sdr_status_ != NULL ? *ew_sdr_status_ : *default_instance_->ew_sdr_status_;
}
inline ::fv::aurora::protos::AuroraProtos::EWSDRStatusTopic* EWProcessorEnvelope::mutable_ew_sdr_status() {
  set_has_ew_sdr_status();
  if (ew_sdr_status_ == NULL) ew_sdr_status_ = new ::fv::aurora::protos::AuroraProtos::EWSDRStatusTopic;
  return ew_sdr_status_;
}
inline ::fv::aurora::protos::AuroraProtos::EWSDRStatusTopic* EWProcessorEnvelope::release_ew_sdr_status() {
  clear_has_ew_sdr_status();
  ::fv::aurora::protos::AuroraProtos::EWSDRStatusTopic* temp = ew_sdr_status_;
  ew_sdr_status_ = NULL;
  return temp;
}
inline void EWProcessorEnvelope::set_allocated_ew_sdr_status(::fv::aurora::protos::AuroraProtos::EWSDRStatusTopic* ew_sdr_status) {
  delete ew_sdr_status_;
  ew_sdr_status_ = ew_sdr_status;
  if (ew_sdr_status) {
    set_has_ew_sdr_status();
  } else {
    clear_has_ew_sdr_status();
  }
}

// optional .bit_protos.BitResponseTopic bit_test_response = 9;
inline bool EWProcessorEnvelope::has_bit_test_response() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EWProcessorEnvelope::set_has_bit_test_response() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EWProcessorEnvelope::clear_has_bit_test_response() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EWProcessorEnvelope::clear_bit_test_response() {
  if (bit_test_response_ != NULL) bit_test_response_->::bit_protos::BitResponseTopic::Clear();
  clear_has_bit_test_response();
}
inline const ::bit_protos::BitResponseTopic& EWProcessorEnvelope::bit_test_response() const {
  return bit_test_response_ != NULL ? *bit_test_response_ : *default_instance_->bit_test_response_;
}
inline ::bit_protos::BitResponseTopic* EWProcessorEnvelope::mutable_bit_test_response() {
  set_has_bit_test_response();
  if (bit_test_response_ == NULL) bit_test_response_ = new ::bit_protos::BitResponseTopic;
  return bit_test_response_;
}
inline ::bit_protos::BitResponseTopic* EWProcessorEnvelope::release_bit_test_response() {
  clear_has_bit_test_response();
  ::bit_protos::BitResponseTopic* temp = bit_test_response_;
  bit_test_response_ = NULL;
  return temp;
}
inline void EWProcessorEnvelope::set_allocated_bit_test_response(::bit_protos::BitResponseTopic* bit_test_response) {
  delete bit_test_response_;
  bit_test_response_ = bit_test_response;
  if (bit_test_response) {
    set_has_bit_test_response();
  } else {
    clear_has_bit_test_response();
  }
}

// optional .com.srcinc.ngi.data.BitStatusTopic bit_status_response = 10;
inline bool EWProcessorEnvelope::has_bit_status_response() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EWProcessorEnvelope::set_has_bit_status_response() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EWProcessorEnvelope::clear_has_bit_status_response() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EWProcessorEnvelope::clear_bit_status_response() {
  if (bit_status_response_ != NULL) bit_status_response_->::com::srcinc::ngi::data::BitStatusTopic::Clear();
  clear_has_bit_status_response();
}
inline const ::com::srcinc::ngi::data::BitStatusTopic& EWProcessorEnvelope::bit_status_response() const {
  return bit_status_response_ != NULL ? *bit_status_response_ : *default_instance_->bit_status_response_;
}
inline ::com::srcinc::ngi::data::BitStatusTopic* EWProcessorEnvelope::mutable_bit_status_response() {
  set_has_bit_status_response();
  if (bit_status_response_ == NULL) bit_status_response_ = new ::com::srcinc::ngi::data::BitStatusTopic;
  return bit_status_response_;
}
inline ::com::srcinc::ngi::data::BitStatusTopic* EWProcessorEnvelope::release_bit_status_response() {
  clear_has_bit_status_response();
  ::com::srcinc::ngi::data::BitStatusTopic* temp = bit_status_response_;
  bit_status_response_ = NULL;
  return temp;
}
inline void EWProcessorEnvelope::set_allocated_bit_status_response(::com::srcinc::ngi::data::BitStatusTopic* bit_status_response) {
  delete bit_status_response_;
  bit_status_response_ = bit_status_response;
  if (bit_status_response) {
    set_has_bit_status_response();
  } else {
    clear_has_bit_status_response();
  }
}

// optional .com.srcinc.ngi.data.BitManifestTopic bit_manifest_response = 11;
inline bool EWProcessorEnvelope::has_bit_manifest_response() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void EWProcessorEnvelope::set_has_bit_manifest_response() {
  _has_bits_[0] |= 0x00000400u;
}
inline void EWProcessorEnvelope::clear_has_bit_manifest_response() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void EWProcessorEnvelope::clear_bit_manifest_response() {
  if (bit_manifest_response_ != NULL) bit_manifest_response_->::com::srcinc::ngi::data::BitManifestTopic::Clear();
  clear_has_bit_manifest_response();
}
inline const ::com::srcinc::ngi::data::BitManifestTopic& EWProcessorEnvelope::bit_manifest_response() const {
  return bit_manifest_response_ != NULL ? *bit_manifest_response_ : *default_instance_->bit_manifest_response_;
}
inline ::com::srcinc::ngi::data::BitManifestTopic* EWProcessorEnvelope::mutable_bit_manifest_response() {
  set_has_bit_manifest_response();
  if (bit_manifest_response_ == NULL) bit_manifest_response_ = new ::com::srcinc::ngi::data::BitManifestTopic;
  return bit_manifest_response_;
}
inline ::com::srcinc::ngi::data::BitManifestTopic* EWProcessorEnvelope::release_bit_manifest_response() {
  clear_has_bit_manifest_response();
  ::com::srcinc::ngi::data::BitManifestTopic* temp = bit_manifest_response_;
  bit_manifest_response_ = NULL;
  return temp;
}
inline void EWProcessorEnvelope::set_allocated_bit_manifest_response(::com::srcinc::ngi::data::BitManifestTopic* bit_manifest_response) {
  delete bit_manifest_response_;
  bit_manifest_response_ = bit_manifest_response;
  if (bit_manifest_response) {
    set_has_bit_manifest_response();
  } else {
    clear_has_bit_manifest_response();
  }
}

// -------------------------------------------------------------------

// EWSDRStatusTopic

// optional .service_infrastructure.Header header = 100;
inline bool EWSDRStatusTopic::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EWSDRStatusTopic::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EWSDRStatusTopic::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EWSDRStatusTopic::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& EWSDRStatusTopic::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* EWSDRStatusTopic::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* EWSDRStatusTopic::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void EWSDRStatusTopic::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .fv.tb.protos.TBProtos.EWSDRStatus ew_sdr_status = 1;
inline bool EWSDRStatusTopic::has_ew_sdr_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EWSDRStatusTopic::set_has_ew_sdr_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EWSDRStatusTopic::clear_has_ew_sdr_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EWSDRStatusTopic::clear_ew_sdr_status() {
  if (ew_sdr_status_ != NULL) ew_sdr_status_->::fv::tb::protos::TBProtos::EWSDRStatus::Clear();
  clear_has_ew_sdr_status();
}
inline const ::fv::tb::protos::TBProtos::EWSDRStatus& EWSDRStatusTopic::ew_sdr_status() const {
  return ew_sdr_status_ != NULL ? *ew_sdr_status_ : *default_instance_->ew_sdr_status_;
}
inline ::fv::tb::protos::TBProtos::EWSDRStatus* EWSDRStatusTopic::mutable_ew_sdr_status() {
  set_has_ew_sdr_status();
  if (ew_sdr_status_ == NULL) ew_sdr_status_ = new ::fv::tb::protos::TBProtos::EWSDRStatus;
  return ew_sdr_status_;
}
inline ::fv::tb::protos::TBProtos::EWSDRStatus* EWSDRStatusTopic::release_ew_sdr_status() {
  clear_has_ew_sdr_status();
  ::fv::tb::protos::TBProtos::EWSDRStatus* temp = ew_sdr_status_;
  ew_sdr_status_ = NULL;
  return temp;
}
inline void EWSDRStatusTopic::set_allocated_ew_sdr_status(::fv::tb::protos::TBProtos::EWSDRStatus* ew_sdr_status) {
  delete ew_sdr_status_;
  ew_sdr_status_ = ew_sdr_status;
  if (ew_sdr_status) {
    set_has_ew_sdr_status();
  } else {
    clear_has_ew_sdr_status();
  }
}

// optional .fv.tb.protos.TBProtos.ThreatStatus threat_status = 2;
inline bool EWSDRStatusTopic::has_threat_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EWSDRStatusTopic::set_has_threat_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EWSDRStatusTopic::clear_has_threat_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EWSDRStatusTopic::clear_threat_status() {
  if (threat_status_ != NULL) threat_status_->::fv::tb::protos::TBProtos::ThreatStatus::Clear();
  clear_has_threat_status();
}
inline const ::fv::tb::protos::TBProtos::ThreatStatus& EWSDRStatusTopic::threat_status() const {
  return threat_status_ != NULL ? *threat_status_ : *default_instance_->threat_status_;
}
inline ::fv::tb::protos::TBProtos::ThreatStatus* EWSDRStatusTopic::mutable_threat_status() {
  set_has_threat_status();
  if (threat_status_ == NULL) threat_status_ = new ::fv::tb::protos::TBProtos::ThreatStatus;
  return threat_status_;
}
inline ::fv::tb::protos::TBProtos::ThreatStatus* EWSDRStatusTopic::release_threat_status() {
  clear_has_threat_status();
  ::fv::tb::protos::TBProtos::ThreatStatus* temp = threat_status_;
  threat_status_ = NULL;
  return temp;
}
inline void EWSDRStatusTopic::set_allocated_threat_status(::fv::tb::protos::TBProtos::ThreatStatus* threat_status) {
  delete threat_status_;
  threat_status_ = threat_status;
  if (threat_status) {
    set_has_threat_status();
  } else {
    clear_has_threat_status();
  }
}

// -------------------------------------------------------------------

// AuroraICDVersion

// optional int32 major = 1 [default = 0];
inline bool AuroraICDVersion::has_major() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuroraICDVersion::set_has_major() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuroraICDVersion::clear_has_major() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuroraICDVersion::clear_major() {
  major_ = 0;
  clear_has_major();
}
inline ::google::protobuf::int32 AuroraICDVersion::major() const {
  return major_;
}
inline void AuroraICDVersion::set_major(::google::protobuf::int32 value) {
  set_has_major();
  major_ = value;
}

// optional int32 minor = 2 [default = 0];
inline bool AuroraICDVersion::has_minor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuroraICDVersion::set_has_minor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuroraICDVersion::clear_has_minor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuroraICDVersion::clear_minor() {
  minor_ = 0;
  clear_has_minor();
}
inline ::google::protobuf::int32 AuroraICDVersion::minor() const {
  return minor_;
}
inline void AuroraICDVersion::set_minor(::google::protobuf::int32 value) {
  set_has_minor();
  minor_ = value;
}

// optional int32 patch = 3 [default = 6];
inline bool AuroraICDVersion::has_patch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AuroraICDVersion::set_has_patch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AuroraICDVersion::clear_has_patch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AuroraICDVersion::clear_patch() {
  patch_ = 6;
  clear_has_patch();
}
inline ::google::protobuf::int32 AuroraICDVersion::patch() const {
  return patch_;
}
inline void AuroraICDVersion::set_patch(::google::protobuf::int32 value) {
  set_has_patch();
  patch_ = value;
}

// optional string date = 4 [default = "2020-08-14"];
inline bool AuroraICDVersion::has_date() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AuroraICDVersion::set_has_date() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AuroraICDVersion::clear_has_date() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AuroraICDVersion::clear_date() {
  if (date_ != _default_date_) {
    date_->assign(*_default_date_);
  }
  clear_has_date();
}
inline const ::std::string& AuroraICDVersion::date() const {
  return *date_;
}
inline void AuroraICDVersion::set_date(const ::std::string& value) {
  set_has_date();
  if (date_ == _default_date_) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void AuroraICDVersion::set_date(const char* value) {
  set_has_date();
  if (date_ == _default_date_) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void AuroraICDVersion::set_date(const char* value, size_t size) {
  set_has_date();
  if (date_ == _default_date_) {
    date_ = new ::std::string;
  }
  date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuroraICDVersion::mutable_date() {
  set_has_date();
  if (date_ == _default_date_) {
    date_ = new ::std::string(*_default_date_);
  }
  return date_;
}
inline ::std::string* AuroraICDVersion::release_date() {
  clear_has_date();
  if (date_ == _default_date_) {
    return NULL;
  } else {
    ::std::string* temp = date_;
    date_ = const_cast< ::std::string*>(_default_date_);
    return temp;
  }
}
inline void AuroraICDVersion::set_allocated_date(::std::string* date) {
  if (date_ != _default_date_) {
    delete date_;
  }
  if (date) {
    set_has_date();
    date_ = date;
  } else {
    clear_has_date();
    date_ = const_cast< ::std::string*>(_default_date_);
  }
}

// optional string commit = 5;
inline bool AuroraICDVersion::has_commit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AuroraICDVersion::set_has_commit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AuroraICDVersion::clear_has_commit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AuroraICDVersion::clear_commit() {
  if (commit_ != &::google::protobuf::internal::kEmptyString) {
    commit_->clear();
  }
  clear_has_commit();
}
inline const ::std::string& AuroraICDVersion::commit() const {
  return *commit_;
}
inline void AuroraICDVersion::set_commit(const ::std::string& value) {
  set_has_commit();
  if (commit_ == &::google::protobuf::internal::kEmptyString) {
    commit_ = new ::std::string;
  }
  commit_->assign(value);
}
inline void AuroraICDVersion::set_commit(const char* value) {
  set_has_commit();
  if (commit_ == &::google::protobuf::internal::kEmptyString) {
    commit_ = new ::std::string;
  }
  commit_->assign(value);
}
inline void AuroraICDVersion::set_commit(const char* value, size_t size) {
  set_has_commit();
  if (commit_ == &::google::protobuf::internal::kEmptyString) {
    commit_ = new ::std::string;
  }
  commit_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuroraICDVersion::mutable_commit() {
  set_has_commit();
  if (commit_ == &::google::protobuf::internal::kEmptyString) {
    commit_ = new ::std::string;
  }
  return commit_;
}
inline ::std::string* AuroraICDVersion::release_commit() {
  clear_has_commit();
  if (commit_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = commit_;
    commit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AuroraICDVersion::set_allocated_commit(::std::string* commit) {
  if (commit_ != &::google::protobuf::internal::kEmptyString) {
    delete commit_;
  }
  if (commit) {
    set_has_commit();
    commit_ = commit;
  } else {
    clear_has_commit();
    commit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace AuroraProtos
}  // namespace protos
}  // namespace aurora
}  // namespace fv

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_AuroraMessages_2eproto__INCLUDED
