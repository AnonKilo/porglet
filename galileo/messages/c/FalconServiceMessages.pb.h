// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FalconServiceMessages.proto

#ifndef PROTOBUF_FalconServiceMessages_2eproto__INCLUDED
#define PROTOBUF_FalconServiceMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "FalconCommonMessages.pb.h"
// @@protoc_insertion_point(includes)

namespace falcon_svc_msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_FalconServiceMessages_2eproto();
void protobuf_AssignDesc_FalconServiceMessages_2eproto();
void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

class CharManConfig;
class MacroOptions;
class FalconVisionConfig;
class GSLManagerConfig;
class ExtraForkConfig;
class GPSMonitorConfig;
class FalconUtilitiesConfig;
class RTHopAnalysisConfig;
class GeoSnapConfig;
class TGConfig;
class EventHandlerConfig;
class GPSFakerConfig;
class SkyscraperConfig;
class NoiseTestConfig;
class ExtraScriptConfigMess;
class NoConfigMess;
class PentekConfigMess;
class PredTunerConfig;
class PredTransceiverConfig;
class SidekiqTransceiverConfig;
class MMSTunerConfig;
class DFServiceConfig;
class TechniqueConfig;
class RulesEngineConfig;
class DatabaseKeeperConfig;
class KeplerUIConnectionConfig;
class SensorStatusConfig;
class GeoTipperConfig;
class PreDClipperConfig;
class AmplifierConfig;
class SiggenConfig;
class CurrPosConfig;

enum MacroOptions_AutoControl {
  MacroOptions_AutoControl_HEADLESS = 0,
  MacroOptions_AutoControl_CONTROLLED = 1,
  MacroOptions_AutoControl_AUTO_MODE = 2
};
bool MacroOptions_AutoControl_IsValid(int value);
const MacroOptions_AutoControl MacroOptions_AutoControl_AutoControl_MIN = MacroOptions_AutoControl_HEADLESS;
const MacroOptions_AutoControl MacroOptions_AutoControl_AutoControl_MAX = MacroOptions_AutoControl_AUTO_MODE;
const int MacroOptions_AutoControl_AutoControl_ARRAYSIZE = MacroOptions_AutoControl_AutoControl_MAX + 1;

const ::google::protobuf::EnumDescriptor* MacroOptions_AutoControl_descriptor();
inline const ::std::string& MacroOptions_AutoControl_Name(MacroOptions_AutoControl value) {
  return ::google::protobuf::internal::NameOfEnum(
    MacroOptions_AutoControl_descriptor(), value);
}
inline bool MacroOptions_AutoControl_Parse(
    const ::std::string& name, MacroOptions_AutoControl* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MacroOptions_AutoControl>(
    MacroOptions_AutoControl_descriptor(), name, value);
}
enum MacroOptions_PPS {
  MacroOptions_PPS_PPS_OFF = 0,
  MacroOptions_PPS_PPS_ON = 1
};
bool MacroOptions_PPS_IsValid(int value);
const MacroOptions_PPS MacroOptions_PPS_PPS_MIN = MacroOptions_PPS_PPS_OFF;
const MacroOptions_PPS MacroOptions_PPS_PPS_MAX = MacroOptions_PPS_PPS_ON;
const int MacroOptions_PPS_PPS_ARRAYSIZE = MacroOptions_PPS_PPS_MAX + 1;

const ::google::protobuf::EnumDescriptor* MacroOptions_PPS_descriptor();
inline const ::std::string& MacroOptions_PPS_Name(MacroOptions_PPS value) {
  return ::google::protobuf::internal::NameOfEnum(
    MacroOptions_PPS_descriptor(), value);
}
inline bool MacroOptions_PPS_Parse(
    const ::std::string& name, MacroOptions_PPS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MacroOptions_PPS>(
    MacroOptions_PPS_descriptor(), name, value);
}
enum MacroOptions_Ref10m {
  MacroOptions_Ref10m_REF_OFF = 0,
  MacroOptions_Ref10m_REF_ON = 1
};
bool MacroOptions_Ref10m_IsValid(int value);
const MacroOptions_Ref10m MacroOptions_Ref10m_Ref10m_MIN = MacroOptions_Ref10m_REF_OFF;
const MacroOptions_Ref10m MacroOptions_Ref10m_Ref10m_MAX = MacroOptions_Ref10m_REF_ON;
const int MacroOptions_Ref10m_Ref10m_ARRAYSIZE = MacroOptions_Ref10m_Ref10m_MAX + 1;

const ::google::protobuf::EnumDescriptor* MacroOptions_Ref10m_descriptor();
inline const ::std::string& MacroOptions_Ref10m_Name(MacroOptions_Ref10m value) {
  return ::google::protobuf::internal::NameOfEnum(
    MacroOptions_Ref10m_descriptor(), value);
}
inline bool MacroOptions_Ref10m_Parse(
    const ::std::string& name, MacroOptions_Ref10m* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MacroOptions_Ref10m>(
    MacroOptions_Ref10m_descriptor(), name, value);
}
enum MacroOptions_ExportFlags {
  MacroOptions_ExportFlags_ENABLE_NONE = 0,
  MacroOptions_ExportFlags_ENABLE_VIDEO = 1,
  MacroOptions_ExportFlags_ENABLE_JPEGS = 2,
  MacroOptions_ExportFlags_ENABLE_PSD = 4,
  MacroOptions_ExportFlags_ENABLE_WORKSTATION = 8
};
bool MacroOptions_ExportFlags_IsValid(int value);
const MacroOptions_ExportFlags MacroOptions_ExportFlags_ExportFlags_MIN = MacroOptions_ExportFlags_ENABLE_NONE;
const MacroOptions_ExportFlags MacroOptions_ExportFlags_ExportFlags_MAX = MacroOptions_ExportFlags_ENABLE_WORKSTATION;
const int MacroOptions_ExportFlags_ExportFlags_ARRAYSIZE = MacroOptions_ExportFlags_ExportFlags_MAX + 1;

const ::google::protobuf::EnumDescriptor* MacroOptions_ExportFlags_descriptor();
inline const ::std::string& MacroOptions_ExportFlags_Name(MacroOptions_ExportFlags value) {
  return ::google::protobuf::internal::NameOfEnum(
    MacroOptions_ExportFlags_descriptor(), value);
}
inline bool MacroOptions_ExportFlags_Parse(
    const ::std::string& name, MacroOptions_ExportFlags* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MacroOptions_ExportFlags>(
    MacroOptions_ExportFlags_descriptor(), name, value);
}
// ===================================================================

class CharManConfig : public ::google::protobuf::Message {
 public:
  CharManConfig();
  virtual ~CharManConfig();

  CharManConfig(const CharManConfig& from);

  inline CharManConfig& operator=(const CharManConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CharManConfig& default_instance();

  void Swap(CharManConfig* other);

  // implements Message ----------------------------------------------

  CharManConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CharManConfig& from);
  void MergeFrom(const CharManConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "CHAR_MAN_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 xtalkPort = 2 [default = 32222];
  inline bool has_xtalkport() const;
  inline void clear_xtalkport();
  static const int kXtalkPortFieldNumber = 2;
  inline ::google::protobuf::int32 xtalkport() const;
  inline void set_xtalkport(::google::protobuf::int32 value);

  // optional int32 snapExtraCount = 3 [default = 1];
  inline bool has_snapextracount() const;
  inline void clear_snapextracount();
  static const int kSnapExtraCountFieldNumber = 3;
  inline ::google::protobuf::int32 snapextracount() const;
  inline void set_snapextracount(::google::protobuf::int32 value);

  // optional int32 snapExtraMin = 4;
  inline bool has_snapextramin() const;
  inline void clear_snapextramin();
  static const int kSnapExtraMinFieldNumber = 4;
  inline ::google::protobuf::int32 snapextramin() const;
  inline void set_snapextramin(::google::protobuf::int32 value);

  // optional string snapExtraConfig = 5 [default = "/user/config/snap_extra.cfg"];
  inline bool has_snapextraconfig() const;
  inline void clear_snapextraconfig();
  static const int kSnapExtraConfigFieldNumber = 5;
  inline const ::std::string& snapextraconfig() const;
  inline void set_snapextraconfig(const ::std::string& value);
  inline void set_snapextraconfig(const char* value);
  inline void set_snapextraconfig(const char* value, size_t size);
  inline ::std::string* mutable_snapextraconfig();
  inline ::std::string* release_snapextraconfig();
  inline void set_allocated_snapextraconfig(::std::string* snapextraconfig);

  // optional bool snapExtraDynamic = 6;
  inline bool has_snapextradynamic() const;
  inline void clear_snapextradynamic();
  static const int kSnapExtraDynamicFieldNumber = 6;
  inline bool snapextradynamic() const;
  inline void set_snapextradynamic(bool value);

  // optional bool sepriopt = 7;
  inline bool has_sepriopt() const;
  inline void clear_sepriopt();
  static const int kSeprioptFieldNumber = 7;
  inline bool sepriopt() const;
  inline void set_sepriopt(bool value);

  // optional int32 sr_to = 8;
  inline bool has_sr_to() const;
  inline void clear_sr_to();
  static const int kSrToFieldNumber = 8;
  inline ::google::protobuf::int32 sr_to() const;
  inline void set_sr_to(::google::protobuf::int32 value);

  // optional string outputPath = 9 [default = "19"];
  inline bool has_outputpath() const;
  inline void clear_outputpath();
  static const int kOutputPathFieldNumber = 9;
  inline const ::std::string& outputpath() const;
  inline void set_outputpath(const ::std::string& value);
  inline void set_outputpath(const char* value);
  inline void set_outputpath(const char* value, size_t size);
  inline ::std::string* mutable_outputpath();
  inline ::std::string* release_outputpath();
  inline void set_allocated_outputpath(::std::string* outputpath);

  // optional int32 esiCount = 10 [default = 6];
  inline bool has_esicount() const;
  inline void clear_esicount();
  static const int kEsiCountFieldNumber = 10;
  inline ::google::protobuf::int32 esicount() const;
  inline void set_esicount(::google::protobuf::int32 value);

  // optional string esiLogPath = 11;
  inline bool has_esilogpath() const;
  inline void clear_esilogpath();
  static const int kEsiLogPathFieldNumber = 11;
  inline const ::std::string& esilogpath() const;
  inline void set_esilogpath(const ::std::string& value);
  inline void set_esilogpath(const char* value);
  inline void set_esilogpath(const char* value, size_t size);
  inline ::std::string* mutable_esilogpath();
  inline ::std::string* release_esilogpath();
  inline void set_allocated_esilogpath(::std::string* esilogpath);

  // optional int32 videoRateFFTSize = 12 [default = 131072];
  inline bool has_videoratefftsize() const;
  inline void clear_videoratefftsize();
  static const int kVideoRateFFTSizeFieldNumber = 12;
  inline ::google::protobuf::int32 videoratefftsize() const;
  inline void set_videoratefftsize(::google::protobuf::int32 value);

  // optional float videoRateDCHz = 13 [default = 100];
  inline bool has_videoratedchz() const;
  inline void clear_videoratedchz();
  static const int kVideoRateDCHzFieldNumber = 13;
  inline float videoratedchz() const;
  inline void set_videoratedchz(float value);

  // optional int32 videoRateMaxFFT = 14 [default = 64];
  inline bool has_videoratemaxfft() const;
  inline void clear_videoratemaxfft();
  static const int kVideoRateMaxFFTFieldNumber = 14;
  inline ::google::protobuf::int32 videoratemaxfft() const;
  inline void set_videoratemaxfft(::google::protobuf::int32 value);

  // optional float videoRateThresh = 15 [default = 1.5];
  inline bool has_videoratethresh() const;
  inline void clear_videoratethresh();
  static const int kVideoRateThreshFieldNumber = 15;
  inline float videoratethresh() const;
  inline void set_videoratethresh(float value);

  // optional float videoSyncThresh = 16 [default = 2.5];
  inline bool has_videosyncthresh() const;
  inline void clear_videosyncthresh();
  static const int kVideoSyncThreshFieldNumber = 16;
  inline float videosyncthresh() const;
  inline void set_videosyncthresh(float value);

  // optional string rlVersion = 17 [default = "NORMAL"];
  inline bool has_rlversion() const;
  inline void clear_rlversion();
  static const int kRlVersionFieldNumber = 17;
  inline const ::std::string& rlversion() const;
  inline void set_rlversion(const ::std::string& value);
  inline void set_rlversion(const char* value);
  inline void set_rlversion(const char* value, size_t size);
  inline ::std::string* mutable_rlversion();
  inline ::std::string* release_rlversion();
  inline void set_allocated_rlversion(::std::string* rlversion);

  // optional bool rlDedup = 18 [default = true];
  inline bool has_rldedup() const;
  inline void clear_rldedup();
  static const int kRlDedupFieldNumber = 18;
  inline bool rldedup() const;
  inline void set_rldedup(bool value);

  // optional int32 energyNcoh = 19 [default = 20];
  inline bool has_energyncoh() const;
  inline void clear_energyncoh();
  static const int kEnergyNcohFieldNumber = 19;
  inline ::google::protobuf::int32 energyncoh() const;
  inline void set_energyncoh(::google::protobuf::int32 value);

  // optional int32 energyNnoncoh = 20 [default = 100];
  inline bool has_energynnoncoh() const;
  inline void clear_energynnoncoh();
  static const int kEnergyNnoncohFieldNumber = 20;
  inline ::google::protobuf::int32 energynnoncoh() const;
  inline void set_energynnoncoh(::google::protobuf::int32 value);

  // optional float energyThreshold = 21 [default = 0];
  inline bool has_energythreshold() const;
  inline void clear_energythreshold();
  static const int kEnergyThresholdFieldNumber = 21;
  inline float energythreshold() const;
  inline void set_energythreshold(float value);

  // optional int32 energyNon = 22 [default = 2];
  inline bool has_energynon() const;
  inline void clear_energynon();
  static const int kEnergyNonFieldNumber = 22;
  inline ::google::protobuf::int32 energynon() const;
  inline void set_energynon(::google::protobuf::int32 value);

  // optional int32 energyNoff = 23 [default = 2];
  inline bool has_energynoff() const;
  inline void clear_energynoff();
  static const int kEnergyNoffFieldNumber = 23;
  inline ::google::protobuf::int32 energynoff() const;
  inline void set_energynoff(::google::protobuf::int32 value);

  // optional float energyBW = 24 [default = 20000];
  inline bool has_energybw() const;
  inline void clear_energybw();
  static const int kEnergyBWFieldNumber = 24;
  inline float energybw() const;
  inline void set_energybw(float value);

  // optional float ofdmthresh = 25 [default = 5];
  inline bool has_ofdmthresh() const;
  inline void clear_ofdmthresh();
  static const int kOfdmthreshFieldNumber = 25;
  inline float ofdmthresh() const;
  inline void set_ofdmthresh(float value);

  // optional float priThreshold = 26 [default = 11];
  inline bool has_prithreshold() const;
  inline void clear_prithreshold();
  static const int kPriThresholdFieldNumber = 26;
  inline float prithreshold() const;
  inline void set_prithreshold(float value);

  // repeated string snapExtraTargets = 27;
  inline int snapextratargets_size() const;
  inline void clear_snapextratargets();
  static const int kSnapExtraTargetsFieldNumber = 27;
  inline const ::std::string& snapextratargets(int index) const;
  inline ::std::string* mutable_snapextratargets(int index);
  inline void set_snapextratargets(int index, const ::std::string& value);
  inline void set_snapextratargets(int index, const char* value);
  inline void set_snapextratargets(int index, const char* value, size_t size);
  inline ::std::string* add_snapextratargets();
  inline void add_snapextratargets(const ::std::string& value);
  inline void add_snapextratargets(const char* value);
  inline void add_snapextratargets(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& snapextratargets() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_snapextratargets();

  // optional string esiModulations = 28;
  inline bool has_esimodulations() const;
  inline void clear_esimodulations();
  static const int kEsiModulationsFieldNumber = 28;
  inline const ::std::string& esimodulations() const;
  inline void set_esimodulations(const ::std::string& value);
  inline void set_esimodulations(const char* value);
  inline void set_esimodulations(const char* value, size_t size);
  inline ::std::string* mutable_esimodulations();
  inline ::std::string* release_esimodulations();
  inline void set_allocated_esimodulations(::std::string* esimodulations);

  // optional string esiWritePath = 29 [default = ""];
  inline bool has_esiwritepath() const;
  inline void clear_esiwritepath();
  static const int kEsiWritePathFieldNumber = 29;
  inline const ::std::string& esiwritepath() const;
  inline void set_esiwritepath(const ::std::string& value);
  inline void set_esiwritepath(const char* value);
  inline void set_esiwritepath(const char* value, size_t size);
  inline ::std::string* mutable_esiwritepath();
  inline ::std::string* release_esiwritepath();
  inline void set_allocated_esiwritepath(::std::string* esiwritepath);

  // optional string edWritePath = 30 [default = ""];
  inline bool has_edwritepath() const;
  inline void clear_edwritepath();
  static const int kEdWritePathFieldNumber = 30;
  inline const ::std::string& edwritepath() const;
  inline void set_edwritepath(const ::std::string& value);
  inline void set_edwritepath(const char* value);
  inline void set_edwritepath(const char* value, size_t size);
  inline ::std::string* mutable_edwritepath();
  inline ::std::string* release_edwritepath();
  inline void set_allocated_edwritepath(::std::string* edwritepath);

  // optional string edLogPath = 31 [default = ""];
  inline bool has_edlogpath() const;
  inline void clear_edlogpath();
  static const int kEdLogPathFieldNumber = 31;
  inline const ::std::string& edlogpath() const;
  inline void set_edlogpath(const ::std::string& value);
  inline void set_edlogpath(const char* value);
  inline void set_edlogpath(const char* value, size_t size);
  inline ::std::string* mutable_edlogpath();
  inline ::std::string* release_edlogpath();
  inline void set_allocated_edlogpath(::std::string* edlogpath);

  // optional int32 edCount = 32 [default = 6];
  inline bool has_edcount() const;
  inline void clear_edcount();
  static const int kEdCountFieldNumber = 32;
  inline ::google::protobuf::int32 edcount() const;
  inline void set_edcount(::google::protobuf::int32 value);

  // optional int32 edThreshdB = 33;
  inline bool has_edthreshdb() const;
  inline void clear_edthreshdb();
  static const int kEdThreshdBFieldNumber = 33;
  inline ::google::protobuf::int32 edthreshdb() const;
  inline void set_edthreshdb(::google::protobuf::int32 value);

  // optional int32 edSpAvg = 34 [default = 50];
  inline bool has_edspavg() const;
  inline void clear_edspavg();
  static const int kEdSpAvgFieldNumber = 34;
  inline ::google::protobuf::int32 edspavg() const;
  inline void set_edspavg(::google::protobuf::int32 value);

  // optional int32 edFFTSize = 35 [default = 8192];
  inline bool has_edfftsize() const;
  inline void clear_edfftsize();
  static const int kEdFFTSizeFieldNumber = 35;
  inline ::google::protobuf::int32 edfftsize() const;
  inline void set_edfftsize(::google::protobuf::int32 value);

  // optional int32 edDetBW = 36;
  inline bool has_eddetbw() const;
  inline void clear_eddetbw();
  static const int kEdDetBWFieldNumber = 36;
  inline ::google::protobuf::int32 eddetbw() const;
  inline void set_eddetbw(::google::protobuf::int32 value);

  // optional int32 edMinDetBW = 37 [default = 8000];
  inline bool has_edmindetbw() const;
  inline void clear_edmindetbw();
  static const int kEdMinDetBWFieldNumber = 37;
  inline ::google::protobuf::int32 edmindetbw() const;
  inline void set_edmindetbw(::google::protobuf::int32 value);

  // optional int32 edGuardBW = 38 [default = 0];
  inline bool has_edguardbw() const;
  inline void clear_edguardbw();
  static const int kEdGuardBWFieldNumber = 38;
  inline ::google::protobuf::int32 edguardbw() const;
  inline void set_edguardbw(::google::protobuf::int32 value);

  // optional int32 edMinUpTime = 39;
  inline bool has_edminuptime() const;
  inline void clear_edminuptime();
  static const int kEdMinUpTimeFieldNumber = 39;
  inline ::google::protobuf::int32 edminuptime() const;
  inline void set_edminuptime(::google::protobuf::int32 value);

  // optional int32 edMinDownTime = 40;
  inline bool has_edmindowntime() const;
  inline void clear_edmindowntime();
  static const int kEdMinDownTimeFieldNumber = 40;
  inline ::google::protobuf::int32 edmindowntime() const;
  inline void set_edmindowntime(::google::protobuf::int32 value);

  // optional float edOverlapTh = 41 [default = 0.5];
  inline bool has_edoverlapth() const;
  inline void clear_edoverlapth();
  static const int kEdOverlapThFieldNumber = 41;
  inline float edoverlapth() const;
  inline void set_edoverlapth(float value);

  // optional bool streamFiles = 42 [default = false];
  inline bool has_streamfiles() const;
  inline void clear_streamfiles();
  static const int kStreamFilesFieldNumber = 42;
  inline bool streamfiles() const;
  inline void set_streamfiles(bool value);

  // optional string brainFile = 43;
  inline bool has_brainfile() const;
  inline void clear_brainfile();
  static const int kBrainFileFieldNumber = 43;
  inline const ::std::string& brainfile() const;
  inline void set_brainfile(const ::std::string& value);
  inline void set_brainfile(const char* value);
  inline void set_brainfile(const char* value, size_t size);
  inline ::std::string* mutable_brainfile();
  inline ::std::string* release_brainfile();
  inline void set_allocated_brainfile(::std::string* brainfile);

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.CharManConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_xtalkport();
  inline void clear_has_xtalkport();
  inline void set_has_snapextracount();
  inline void clear_has_snapextracount();
  inline void set_has_snapextramin();
  inline void clear_has_snapextramin();
  inline void set_has_snapextraconfig();
  inline void clear_has_snapextraconfig();
  inline void set_has_snapextradynamic();
  inline void clear_has_snapextradynamic();
  inline void set_has_sepriopt();
  inline void clear_has_sepriopt();
  inline void set_has_sr_to();
  inline void clear_has_sr_to();
  inline void set_has_outputpath();
  inline void clear_has_outputpath();
  inline void set_has_esicount();
  inline void clear_has_esicount();
  inline void set_has_esilogpath();
  inline void clear_has_esilogpath();
  inline void set_has_videoratefftsize();
  inline void clear_has_videoratefftsize();
  inline void set_has_videoratedchz();
  inline void clear_has_videoratedchz();
  inline void set_has_videoratemaxfft();
  inline void clear_has_videoratemaxfft();
  inline void set_has_videoratethresh();
  inline void clear_has_videoratethresh();
  inline void set_has_videosyncthresh();
  inline void clear_has_videosyncthresh();
  inline void set_has_rlversion();
  inline void clear_has_rlversion();
  inline void set_has_rldedup();
  inline void clear_has_rldedup();
  inline void set_has_energyncoh();
  inline void clear_has_energyncoh();
  inline void set_has_energynnoncoh();
  inline void clear_has_energynnoncoh();
  inline void set_has_energythreshold();
  inline void clear_has_energythreshold();
  inline void set_has_energynon();
  inline void clear_has_energynon();
  inline void set_has_energynoff();
  inline void clear_has_energynoff();
  inline void set_has_energybw();
  inline void clear_has_energybw();
  inline void set_has_ofdmthresh();
  inline void clear_has_ofdmthresh();
  inline void set_has_prithreshold();
  inline void clear_has_prithreshold();
  inline void set_has_esimodulations();
  inline void clear_has_esimodulations();
  inline void set_has_esiwritepath();
  inline void clear_has_esiwritepath();
  inline void set_has_edwritepath();
  inline void clear_has_edwritepath();
  inline void set_has_edlogpath();
  inline void clear_has_edlogpath();
  inline void set_has_edcount();
  inline void clear_has_edcount();
  inline void set_has_edthreshdb();
  inline void clear_has_edthreshdb();
  inline void set_has_edspavg();
  inline void clear_has_edspavg();
  inline void set_has_edfftsize();
  inline void clear_has_edfftsize();
  inline void set_has_eddetbw();
  inline void clear_has_eddetbw();
  inline void set_has_edmindetbw();
  inline void clear_has_edmindetbw();
  inline void set_has_edguardbw();
  inline void clear_has_edguardbw();
  inline void set_has_edminuptime();
  inline void clear_has_edminuptime();
  inline void set_has_edmindowntime();
  inline void clear_has_edmindowntime();
  inline void set_has_edoverlapth();
  inline void clear_has_edoverlapth();
  inline void set_has_streamfiles();
  inline void clear_has_streamfiles();
  inline void set_has_brainfile();
  inline void clear_has_brainfile();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 xtalkport_;
  ::google::protobuf::int32 snapextracount_;
  ::std::string* snapextraconfig_;
  static ::std::string* _default_snapextraconfig_;
  ::google::protobuf::int32 snapextramin_;
  ::google::protobuf::int32 sr_to_;
  ::std::string* outputpath_;
  static ::std::string* _default_outputpath_;
  ::google::protobuf::int32 esicount_;
  ::google::protobuf::int32 videoratefftsize_;
  ::std::string* esilogpath_;
  float videoratedchz_;
  ::google::protobuf::int32 videoratemaxfft_;
  float videoratethresh_;
  float videosyncthresh_;
  ::std::string* rlversion_;
  static ::std::string* _default_rlversion_;
  bool snapextradynamic_;
  bool sepriopt_;
  bool rldedup_;
  bool streamfiles_;
  ::google::protobuf::int32 energyncoh_;
  ::google::protobuf::int32 energynnoncoh_;
  float energythreshold_;
  ::google::protobuf::int32 energynon_;
  ::google::protobuf::int32 energynoff_;
  float energybw_;
  float ofdmthresh_;
  ::google::protobuf::RepeatedPtrField< ::std::string> snapextratargets_;
  ::std::string* esimodulations_;
  ::std::string* esiwritepath_;
  float prithreshold_;
  ::google::protobuf::int32 edcount_;
  ::std::string* edwritepath_;
  ::std::string* edlogpath_;
  ::google::protobuf::int32 edthreshdb_;
  ::google::protobuf::int32 edspavg_;
  ::google::protobuf::int32 edfftsize_;
  ::google::protobuf::int32 eddetbw_;
  ::google::protobuf::int32 edmindetbw_;
  ::google::protobuf::int32 edguardbw_;
  ::google::protobuf::int32 edminuptime_;
  ::google::protobuf::int32 edmindowntime_;
  ::std::string* brainfile_;
  float edoverlapth_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(43 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static CharManConfig* default_instance_;
};
// -------------------------------------------------------------------

class MacroOptions : public ::google::protobuf::Message {
 public:
  MacroOptions();
  virtual ~MacroOptions();

  MacroOptions(const MacroOptions& from);

  inline MacroOptions& operator=(const MacroOptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MacroOptions& default_instance();

  void Swap(MacroOptions* other);

  // implements Message ----------------------------------------------

  MacroOptions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MacroOptions& from);
  void MergeFrom(const MacroOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MacroOptions_AutoControl AutoControl;
  static const AutoControl HEADLESS = MacroOptions_AutoControl_HEADLESS;
  static const AutoControl CONTROLLED = MacroOptions_AutoControl_CONTROLLED;
  static const AutoControl AUTO_MODE = MacroOptions_AutoControl_AUTO_MODE;
  static inline bool AutoControl_IsValid(int value) {
    return MacroOptions_AutoControl_IsValid(value);
  }
  static const AutoControl AutoControl_MIN =
    MacroOptions_AutoControl_AutoControl_MIN;
  static const AutoControl AutoControl_MAX =
    MacroOptions_AutoControl_AutoControl_MAX;
  static const int AutoControl_ARRAYSIZE =
    MacroOptions_AutoControl_AutoControl_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AutoControl_descriptor() {
    return MacroOptions_AutoControl_descriptor();
  }
  static inline const ::std::string& AutoControl_Name(AutoControl value) {
    return MacroOptions_AutoControl_Name(value);
  }
  static inline bool AutoControl_Parse(const ::std::string& name,
      AutoControl* value) {
    return MacroOptions_AutoControl_Parse(name, value);
  }

  typedef MacroOptions_PPS PPS;
  static const PPS PPS_OFF = MacroOptions_PPS_PPS_OFF;
  static const PPS PPS_ON = MacroOptions_PPS_PPS_ON;
  static inline bool PPS_IsValid(int value) {
    return MacroOptions_PPS_IsValid(value);
  }
  static const PPS PPS_MIN =
    MacroOptions_PPS_PPS_MIN;
  static const PPS PPS_MAX =
    MacroOptions_PPS_PPS_MAX;
  static const int PPS_ARRAYSIZE =
    MacroOptions_PPS_PPS_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PPS_descriptor() {
    return MacroOptions_PPS_descriptor();
  }
  static inline const ::std::string& PPS_Name(PPS value) {
    return MacroOptions_PPS_Name(value);
  }
  static inline bool PPS_Parse(const ::std::string& name,
      PPS* value) {
    return MacroOptions_PPS_Parse(name, value);
  }

  typedef MacroOptions_Ref10m Ref10m;
  static const Ref10m REF_OFF = MacroOptions_Ref10m_REF_OFF;
  static const Ref10m REF_ON = MacroOptions_Ref10m_REF_ON;
  static inline bool Ref10m_IsValid(int value) {
    return MacroOptions_Ref10m_IsValid(value);
  }
  static const Ref10m Ref10m_MIN =
    MacroOptions_Ref10m_Ref10m_MIN;
  static const Ref10m Ref10m_MAX =
    MacroOptions_Ref10m_Ref10m_MAX;
  static const int Ref10m_ARRAYSIZE =
    MacroOptions_Ref10m_Ref10m_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Ref10m_descriptor() {
    return MacroOptions_Ref10m_descriptor();
  }
  static inline const ::std::string& Ref10m_Name(Ref10m value) {
    return MacroOptions_Ref10m_Name(value);
  }
  static inline bool Ref10m_Parse(const ::std::string& name,
      Ref10m* value) {
    return MacroOptions_Ref10m_Parse(name, value);
  }

  typedef MacroOptions_ExportFlags ExportFlags;
  static const ExportFlags ENABLE_NONE = MacroOptions_ExportFlags_ENABLE_NONE;
  static const ExportFlags ENABLE_VIDEO = MacroOptions_ExportFlags_ENABLE_VIDEO;
  static const ExportFlags ENABLE_JPEGS = MacroOptions_ExportFlags_ENABLE_JPEGS;
  static const ExportFlags ENABLE_PSD = MacroOptions_ExportFlags_ENABLE_PSD;
  static const ExportFlags ENABLE_WORKSTATION = MacroOptions_ExportFlags_ENABLE_WORKSTATION;
  static inline bool ExportFlags_IsValid(int value) {
    return MacroOptions_ExportFlags_IsValid(value);
  }
  static const ExportFlags ExportFlags_MIN =
    MacroOptions_ExportFlags_ExportFlags_MIN;
  static const ExportFlags ExportFlags_MAX =
    MacroOptions_ExportFlags_ExportFlags_MAX;
  static const int ExportFlags_ARRAYSIZE =
    MacroOptions_ExportFlags_ExportFlags_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ExportFlags_descriptor() {
    return MacroOptions_ExportFlags_descriptor();
  }
  static inline const ::std::string& ExportFlags_Name(ExportFlags value) {
    return MacroOptions_ExportFlags_Name(value);
  }
  static inline bool ExportFlags_Parse(const ::std::string& name,
      ExportFlags* value) {
    return MacroOptions_ExportFlags_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .falcon_svc_msg.MacroOptions.AutoControl autoControl = 1;
  inline bool has_autocontrol() const;
  inline void clear_autocontrol();
  static const int kAutoControlFieldNumber = 1;
  inline ::falcon_svc_msg::MacroOptions_AutoControl autocontrol() const;
  inline void set_autocontrol(::falcon_svc_msg::MacroOptions_AutoControl value);

  // optional .falcon_svc_msg.MacroOptions.PPS ppsEnable = 2 [default = PPS_OFF];
  inline bool has_ppsenable() const;
  inline void clear_ppsenable();
  static const int kPpsEnableFieldNumber = 2;
  inline ::falcon_svc_msg::MacroOptions_PPS ppsenable() const;
  inline void set_ppsenable(::falcon_svc_msg::MacroOptions_PPS value);

  // optional .falcon_svc_msg.MacroOptions.Ref10m refEnable = 3 [default = REF_OFF];
  inline bool has_refenable() const;
  inline void clear_refenable();
  static const int kRefEnableFieldNumber = 3;
  inline ::falcon_svc_msg::MacroOptions_Ref10m refenable() const;
  inline void set_refenable(::falcon_svc_msg::MacroOptions_Ref10m value);

  // optional double ifFrequency = 4 [default = 30000000];
  inline bool has_iffrequency() const;
  inline void clear_iffrequency();
  static const int kIfFrequencyFieldNumber = 4;
  inline double iffrequency() const;
  inline void set_iffrequency(double value);

  // optional int32 writeAux = 5 [default = 12];
  inline bool has_writeaux() const;
  inline void clear_writeaux();
  static const int kWriteAuxFieldNumber = 5;
  inline ::google::protobuf::int32 writeaux() const;
  inline void set_writeaux(::google::protobuf::int32 value);

  // optional int32 exportEnable = 6 [default = 0];
  inline bool has_exportenable() const;
  inline void clear_exportenable();
  static const int kExportEnableFieldNumber = 6;
  inline ::google::protobuf::int32 exportenable() const;
  inline void set_exportenable(::google::protobuf::int32 value);

  // optional int32 videoLength = 7 [default = 20];
  inline bool has_videolength() const;
  inline void clear_videolength();
  static const int kVideoLengthFieldNumber = 7;
  inline ::google::protobuf::int32 videolength() const;
  inline void set_videolength(::google::protobuf::int32 value);

  // optional string sensorName = 8 [default = "sensor"];
  inline bool has_sensorname() const;
  inline void clear_sensorname();
  static const int kSensorNameFieldNumber = 8;
  inline const ::std::string& sensorname() const;
  inline void set_sensorname(const ::std::string& value);
  inline void set_sensorname(const char* value);
  inline void set_sensorname(const char* value, size_t size);
  inline ::std::string* mutable_sensorname();
  inline ::std::string* release_sensorname();
  inline void set_allocated_sensorname(::std::string* sensorname);

  // optional string psdIPAddress = 9 [default = ""];
  inline bool has_psdipaddress() const;
  inline void clear_psdipaddress();
  static const int kPsdIPAddressFieldNumber = 9;
  inline const ::std::string& psdipaddress() const;
  inline void set_psdipaddress(const ::std::string& value);
  inline void set_psdipaddress(const char* value);
  inline void set_psdipaddress(const char* value, size_t size);
  inline ::std::string* mutable_psdipaddress();
  inline ::std::string* release_psdipaddress();
  inline void set_allocated_psdipaddress(::std::string* psdipaddress);

  // optional int32 psdPeriod = 10 [default = 200];
  inline bool has_psdperiod() const;
  inline void clear_psdperiod();
  static const int kPsdPeriodFieldNumber = 10;
  inline ::google::protobuf::int32 psdperiod() const;
  inline void set_psdperiod(::google::protobuf::int32 value);

  // optional int32 jpegPeriod = 11 [default = 50];
  inline bool has_jpegperiod() const;
  inline void clear_jpegperiod();
  static const int kJpegPeriodFieldNumber = 11;
  inline ::google::protobuf::int32 jpegperiod() const;
  inline void set_jpegperiod(::google::protobuf::int32 value);

  // optional int32 xmlPeriod = 12 [default = 5];
  inline bool has_xmlperiod() const;
  inline void clear_xmlperiod();
  static const int kXmlPeriodFieldNumber = 12;
  inline ::google::protobuf::int32 xmlperiod() const;
  inline void set_xmlperiod(::google::protobuf::int32 value);

  // optional int32 protectArch = 13 [default = 0];
  inline bool has_protectarch() const;
  inline void clear_protectarch();
  static const int kProtectArchFieldNumber = 13;
  inline ::google::protobuf::int32 protectarch() const;
  inline void set_protectarch(::google::protobuf::int32 value);

  // optional bool midasBundling = 14 [default = false];
  inline bool has_midasbundling() const;
  inline void clear_midasbundling();
  static const int kMidasBundlingFieldNumber = 14;
  inline bool midasbundling() const;
  inline void set_midasbundling(bool value);

  // optional int32 remoteThresh = 15 [default = 10];
  inline bool has_remotethresh() const;
  inline void clear_remotethresh();
  static const int kRemoteThreshFieldNumber = 15;
  inline ::google::protobuf::int32 remotethresh() const;
  inline void set_remotethresh(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.MacroOptions)
 private:
  inline void set_has_autocontrol();
  inline void clear_has_autocontrol();
  inline void set_has_ppsenable();
  inline void clear_has_ppsenable();
  inline void set_has_refenable();
  inline void clear_has_refenable();
  inline void set_has_iffrequency();
  inline void clear_has_iffrequency();
  inline void set_has_writeaux();
  inline void clear_has_writeaux();
  inline void set_has_exportenable();
  inline void clear_has_exportenable();
  inline void set_has_videolength();
  inline void clear_has_videolength();
  inline void set_has_sensorname();
  inline void clear_has_sensorname();
  inline void set_has_psdipaddress();
  inline void clear_has_psdipaddress();
  inline void set_has_psdperiod();
  inline void clear_has_psdperiod();
  inline void set_has_jpegperiod();
  inline void clear_has_jpegperiod();
  inline void set_has_xmlperiod();
  inline void clear_has_xmlperiod();
  inline void set_has_protectarch();
  inline void clear_has_protectarch();
  inline void set_has_midasbundling();
  inline void clear_has_midasbundling();
  inline void set_has_remotethresh();
  inline void clear_has_remotethresh();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int autocontrol_;
  int ppsenable_;
  double iffrequency_;
  int refenable_;
  ::google::protobuf::int32 writeaux_;
  ::google::protobuf::int32 exportenable_;
  ::google::protobuf::int32 videolength_;
  ::std::string* sensorname_;
  static ::std::string* _default_sensorname_;
  ::std::string* psdipaddress_;
  ::google::protobuf::int32 psdperiod_;
  ::google::protobuf::int32 jpegperiod_;
  ::google::protobuf::int32 xmlperiod_;
  ::google::protobuf::int32 protectarch_;
  bool midasbundling_;
  ::google::protobuf::int32 remotethresh_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static MacroOptions* default_instance_;
};
// -------------------------------------------------------------------

class FalconVisionConfig : public ::google::protobuf::Message {
 public:
  FalconVisionConfig();
  virtual ~FalconVisionConfig();

  FalconVisionConfig(const FalconVisionConfig& from);

  inline FalconVisionConfig& operator=(const FalconVisionConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FalconVisionConfig& default_instance();

  void Swap(FalconVisionConfig* other);

  // implements Message ----------------------------------------------

  FalconVisionConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FalconVisionConfig& from);
  void MergeFrom(const FalconVisionConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "FALCON_VISION_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 readPort = 2;
  inline bool has_readport() const;
  inline void clear_readport();
  static const int kReadPortFieldNumber = 2;
  inline ::google::protobuf::int32 readport() const;
  inline void set_readport(::google::protobuf::int32 value);

  // optional int32 writePort = 3;
  inline bool has_writeport() const;
  inline void clear_writeport();
  static const int kWritePortFieldNumber = 3;
  inline ::google::protobuf::int32 writeport() const;
  inline void set_writeport(::google::protobuf::int32 value);

  // optional int32 msgBufLen = 4;
  inline bool has_msgbuflen() const;
  inline void clear_msgbuflen();
  static const int kMsgBufLenFieldNumber = 4;
  inline ::google::protobuf::int32 msgbuflen() const;
  inline void set_msgbuflen(::google::protobuf::int32 value);

  // optional bool xmlEnable = 5;
  inline bool has_xmlenable() const;
  inline void clear_xmlenable();
  static const int kXmlEnableFieldNumber = 5;
  inline bool xmlenable() const;
  inline void set_xmlenable(bool value);

  // optional string xmlClass = 6;
  inline bool has_xmlclass() const;
  inline void clear_xmlclass();
  static const int kXmlClassFieldNumber = 6;
  inline const ::std::string& xmlclass() const;
  inline void set_xmlclass(const ::std::string& value);
  inline void set_xmlclass(const char* value);
  inline void set_xmlclass(const char* value, size_t size);
  inline ::std::string* mutable_xmlclass();
  inline ::std::string* release_xmlclass();
  inline void set_allocated_xmlclass(::std::string* xmlclass);

  // optional string xmlSource = 7;
  inline bool has_xmlsource() const;
  inline void clear_xmlsource();
  static const int kXmlSourceFieldNumber = 7;
  inline const ::std::string& xmlsource() const;
  inline void set_xmlsource(const ::std::string& value);
  inline void set_xmlsource(const char* value);
  inline void set_xmlsource(const char* value, size_t size);
  inline ::std::string* mutable_xmlsource();
  inline ::std::string* release_xmlsource();
  inline void set_allocated_xmlsource(::std::string* xmlsource);

  // optional string xmlPath = 8;
  inline bool has_xmlpath() const;
  inline void clear_xmlpath();
  static const int kXmlPathFieldNumber = 8;
  inline const ::std::string& xmlpath() const;
  inline void set_xmlpath(const ::std::string& value);
  inline void set_xmlpath(const char* value);
  inline void set_xmlpath(const char* value, size_t size);
  inline ::std::string* mutable_xmlpath();
  inline ::std::string* release_xmlpath();
  inline void set_allocated_xmlpath(::std::string* xmlpath);

  // optional string xmlWorkstation = 9;
  inline bool has_xmlworkstation() const;
  inline void clear_xmlworkstation();
  static const int kXmlWorkstationFieldNumber = 9;
  inline const ::std::string& xmlworkstation() const;
  inline void set_xmlworkstation(const ::std::string& value);
  inline void set_xmlworkstation(const char* value);
  inline void set_xmlworkstation(const char* value, size_t size);
  inline ::std::string* mutable_xmlworkstation();
  inline ::std::string* release_xmlworkstation();
  inline void set_allocated_xmlworkstation(::std::string* xmlworkstation);

  // optional int32 xmlPeriod = 10;
  inline bool has_xmlperiod() const;
  inline void clear_xmlperiod();
  static const int kXmlPeriodFieldNumber = 10;
  inline ::google::protobuf::int32 xmlperiod() const;
  inline void set_xmlperiod(::google::protobuf::int32 value);

  // optional string workstationWhitelist = 11;
  inline bool has_workstationwhitelist() const;
  inline void clear_workstationwhitelist();
  static const int kWorkstationWhitelistFieldNumber = 11;
  inline const ::std::string& workstationwhitelist() const;
  inline void set_workstationwhitelist(const ::std::string& value);
  inline void set_workstationwhitelist(const char* value);
  inline void set_workstationwhitelist(const char* value, size_t size);
  inline ::std::string* mutable_workstationwhitelist();
  inline ::std::string* release_workstationwhitelist();
  inline void set_allocated_workstationwhitelist(::std::string* workstationwhitelist);

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.FalconVisionConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_readport();
  inline void clear_has_readport();
  inline void set_has_writeport();
  inline void clear_has_writeport();
  inline void set_has_msgbuflen();
  inline void clear_has_msgbuflen();
  inline void set_has_xmlenable();
  inline void clear_has_xmlenable();
  inline void set_has_xmlclass();
  inline void clear_has_xmlclass();
  inline void set_has_xmlsource();
  inline void clear_has_xmlsource();
  inline void set_has_xmlpath();
  inline void clear_has_xmlpath();
  inline void set_has_xmlworkstation();
  inline void clear_has_xmlworkstation();
  inline void set_has_xmlperiod();
  inline void clear_has_xmlperiod();
  inline void set_has_workstationwhitelist();
  inline void clear_has_workstationwhitelist();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 readport_;
  ::google::protobuf::int32 writeport_;
  ::google::protobuf::int32 msgbuflen_;
  bool xmlenable_;
  ::std::string* xmlclass_;
  ::std::string* xmlsource_;
  ::std::string* xmlpath_;
  ::std::string* xmlworkstation_;
  ::std::string* workstationwhitelist_;
  ::google::protobuf::int32 xmlperiod_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static FalconVisionConfig* default_instance_;
};
// -------------------------------------------------------------------

class GSLManagerConfig : public ::google::protobuf::Message {
 public:
  GSLManagerConfig();
  virtual ~GSLManagerConfig();

  GSLManagerConfig(const GSLManagerConfig& from);

  inline GSLManagerConfig& operator=(const GSLManagerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GSLManagerConfig& default_instance();

  void Swap(GSLManagerConfig* other);

  // implements Message ----------------------------------------------

  GSLManagerConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GSLManagerConfig& from);
  void MergeFrom(const GSLManagerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "GSL_MANAGER_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string dbname = 2;
  inline bool has_dbname() const;
  inline void clear_dbname();
  static const int kDbnameFieldNumber = 2;
  inline const ::std::string& dbname() const;
  inline void set_dbname(const ::std::string& value);
  inline void set_dbname(const char* value);
  inline void set_dbname(const char* value, size_t size);
  inline ::std::string* mutable_dbname();
  inline ::std::string* release_dbname();
  inline void set_allocated_dbname(::std::string* dbname);

  // optional string dbuser = 3;
  inline bool has_dbuser() const;
  inline void clear_dbuser();
  static const int kDbuserFieldNumber = 3;
  inline const ::std::string& dbuser() const;
  inline void set_dbuser(const ::std::string& value);
  inline void set_dbuser(const char* value);
  inline void set_dbuser(const char* value, size_t size);
  inline ::std::string* mutable_dbuser();
  inline ::std::string* release_dbuser();
  inline void set_allocated_dbuser(::std::string* dbuser);

  // optional string dbhost = 4;
  inline bool has_dbhost() const;
  inline void clear_dbhost();
  static const int kDbhostFieldNumber = 4;
  inline const ::std::string& dbhost() const;
  inline void set_dbhost(const ::std::string& value);
  inline void set_dbhost(const char* value);
  inline void set_dbhost(const char* value, size_t size);
  inline ::std::string* mutable_dbhost();
  inline ::std::string* release_dbhost();
  inline void set_allocated_dbhost(::std::string* dbhost);

  // optional int32 globalSignalTimeout = 5;
  inline bool has_globalsignaltimeout() const;
  inline void clear_globalsignaltimeout();
  static const int kGlobalSignalTimeoutFieldNumber = 5;
  inline ::google::protobuf::int32 globalsignaltimeout() const;
  inline void set_globalsignaltimeout(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.GSLManagerConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_dbname();
  inline void clear_has_dbname();
  inline void set_has_dbuser();
  inline void clear_has_dbuser();
  inline void set_has_dbhost();
  inline void clear_has_dbhost();
  inline void set_has_globalsignaltimeout();
  inline void clear_has_globalsignaltimeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* dbname_;
  ::std::string* dbuser_;
  ::std::string* dbhost_;
  ::google::protobuf::int32 globalsignaltimeout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static GSLManagerConfig* default_instance_;
};
// -------------------------------------------------------------------

class ExtraForkConfig : public ::google::protobuf::Message {
 public:
  ExtraForkConfig();
  virtual ~ExtraForkConfig();

  ExtraForkConfig(const ExtraForkConfig& from);

  inline ExtraForkConfig& operator=(const ExtraForkConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExtraForkConfig& default_instance();

  void Swap(ExtraForkConfig* other);

  // implements Message ----------------------------------------------

  ExtraForkConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExtraForkConfig& from);
  void MergeFrom(const ExtraForkConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EXTRA_FORK_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // repeated .falcon_common_msg.ExtraForkChannel channels = 2;
  inline int channels_size() const;
  inline void clear_channels();
  static const int kChannelsFieldNumber = 2;
  inline const ::falcon_common_msg::ExtraForkChannel& channels(int index) const;
  inline ::falcon_common_msg::ExtraForkChannel* mutable_channels(int index);
  inline ::falcon_common_msg::ExtraForkChannel* add_channels();
  inline const ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::ExtraForkChannel >&
      channels() const;
  inline ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::ExtraForkChannel >*
      mutable_channels();

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.ExtraForkConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::ExtraForkChannel > channels_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static ExtraForkConfig* default_instance_;
};
// -------------------------------------------------------------------

class GPSMonitorConfig : public ::google::protobuf::Message {
 public:
  GPSMonitorConfig();
  virtual ~GPSMonitorConfig();

  GPSMonitorConfig(const GPSMonitorConfig& from);

  inline GPSMonitorConfig& operator=(const GPSMonitorConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GPSMonitorConfig& default_instance();

  void Swap(GPSMonitorConfig* other);

  // implements Message ----------------------------------------------

  GPSMonitorConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPSMonitorConfig& from);
  void MergeFrom(const GPSMonitorConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "GPS_MONITOR_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string gpsServer = 2 [default = "OFF"];
  inline bool has_gpsserver() const;
  inline void clear_gpsserver();
  static const int kGpsServerFieldNumber = 2;
  inline const ::std::string& gpsserver() const;
  inline void set_gpsserver(const ::std::string& value);
  inline void set_gpsserver(const char* value);
  inline void set_gpsserver(const char* value, size_t size);
  inline ::std::string* mutable_gpsserver();
  inline ::std::string* release_gpsserver();
  inline void set_allocated_gpsserver(::std::string* gpsserver);

  // optional string GPSIP = 3;
  inline bool has_gpsip() const;
  inline void clear_gpsip();
  static const int kGPSIPFieldNumber = 3;
  inline const ::std::string& gpsip() const;
  inline void set_gpsip(const ::std::string& value);
  inline void set_gpsip(const char* value);
  inline void set_gpsip(const char* value, size_t size);
  inline ::std::string* mutable_gpsip();
  inline ::std::string* release_gpsip();
  inline void set_allocated_gpsip(::std::string* gpsip);

  // optional int32 gpsPort = 4;
  inline bool has_gpsport() const;
  inline void clear_gpsport();
  static const int kGpsPortFieldNumber = 4;
  inline ::google::protobuf::int32 gpsport() const;
  inline void set_gpsport(::google::protobuf::int32 value);

  // optional int32 gpsPer = 5 [default = 5];
  inline bool has_gpsper() const;
  inline void clear_gpsper();
  static const int kGpsPerFieldNumber = 5;
  inline ::google::protobuf::int32 gpsper() const;
  inline void set_gpsper(::google::protobuf::int32 value);

  // optional int32 gpsWriteFile = 6 [default = 1];
  inline bool has_gpswritefile() const;
  inline void clear_gpswritefile();
  static const int kGpsWriteFileFieldNumber = 6;
  inline ::google::protobuf::int32 gpswritefile() const;
  inline void set_gpswritefile(::google::protobuf::int32 value);

  // optional int32 gpsFileInt = 7 [default = 10];
  inline bool has_gpsfileint() const;
  inline void clear_gpsfileint();
  static const int kGpsFileIntFieldNumber = 7;
  inline ::google::protobuf::int32 gpsfileint() const;
  inline void set_gpsfileint(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.GPSMonitorConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_gpsserver();
  inline void clear_has_gpsserver();
  inline void set_has_gpsip();
  inline void clear_has_gpsip();
  inline void set_has_gpsport();
  inline void clear_has_gpsport();
  inline void set_has_gpsper();
  inline void clear_has_gpsper();
  inline void set_has_gpswritefile();
  inline void clear_has_gpswritefile();
  inline void set_has_gpsfileint();
  inline void clear_has_gpsfileint();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* gpsserver_;
  static ::std::string* _default_gpsserver_;
  ::std::string* gpsip_;
  ::google::protobuf::int32 gpsport_;
  ::google::protobuf::int32 gpsper_;
  ::google::protobuf::int32 gpswritefile_;
  ::google::protobuf::int32 gpsfileint_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static GPSMonitorConfig* default_instance_;
};
// -------------------------------------------------------------------

class FalconUtilitiesConfig : public ::google::protobuf::Message {
 public:
  FalconUtilitiesConfig();
  virtual ~FalconUtilitiesConfig();

  FalconUtilitiesConfig(const FalconUtilitiesConfig& from);

  inline FalconUtilitiesConfig& operator=(const FalconUtilitiesConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FalconUtilitiesConfig& default_instance();

  void Swap(FalconUtilitiesConfig* other);

  // implements Message ----------------------------------------------

  FalconUtilitiesConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FalconUtilitiesConfig& from);
  void MergeFrom(const FalconUtilitiesConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "FALCON_UTILITIES_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string archive = 2 [default = "OFF"];
  inline bool has_archive() const;
  inline void clear_archive();
  static const int kArchiveFieldNumber = 2;
  inline const ::std::string& archive() const;
  inline void set_archive(const ::std::string& value);
  inline void set_archive(const char* value);
  inline void set_archive(const char* value, size_t size);
  inline ::std::string* mutable_archive();
  inline ::std::string* release_archive();
  inline void set_allocated_archive(::std::string* archive);

  // optional string delArchives = 3 [default = "OFF"];
  inline bool has_delarchives() const;
  inline void clear_delarchives();
  static const int kDelArchivesFieldNumber = 3;
  inline const ::std::string& delarchives() const;
  inline void set_delarchives(const ::std::string& value);
  inline void set_delarchives(const char* value);
  inline void set_delarchives(const char* value, size_t size);
  inline ::std::string* mutable_delarchives();
  inline ::std::string* release_delarchives();
  inline void set_allocated_delarchives(::std::string* delarchives);

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.FalconUtilitiesConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_archive();
  inline void clear_has_archive();
  inline void set_has_delarchives();
  inline void clear_has_delarchives();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* archive_;
  static ::std::string* _default_archive_;
  ::std::string* delarchives_;
  static ::std::string* _default_delarchives_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static FalconUtilitiesConfig* default_instance_;
};
// -------------------------------------------------------------------

class RTHopAnalysisConfig : public ::google::protobuf::Message {
 public:
  RTHopAnalysisConfig();
  virtual ~RTHopAnalysisConfig();

  RTHopAnalysisConfig(const RTHopAnalysisConfig& from);

  inline RTHopAnalysisConfig& operator=(const RTHopAnalysisConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RTHopAnalysisConfig& default_instance();

  void Swap(RTHopAnalysisConfig* other);

  // implements Message ----------------------------------------------

  RTHopAnalysisConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RTHopAnalysisConfig& from);
  void MergeFrom(const RTHopAnalysisConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "RTHOP_ANALYSIS_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string scrypt = 2 [default = "/user/scrypts/rthops.xml"];
  inline bool has_scrypt() const;
  inline void clear_scrypt();
  static const int kScryptFieldNumber = 2;
  inline const ::std::string& scrypt() const;
  inline void set_scrypt(const ::std::string& value);
  inline void set_scrypt(const char* value);
  inline void set_scrypt(const char* value, size_t size);
  inline ::std::string* mutable_scrypt();
  inline ::std::string* release_scrypt();
  inline void set_allocated_scrypt(::std::string* scrypt);

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.RTHopAnalysisConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_scrypt();
  inline void clear_has_scrypt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* scrypt_;
  static ::std::string* _default_scrypt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static RTHopAnalysisConfig* default_instance_;
};
// -------------------------------------------------------------------

class GeoSnapConfig : public ::google::protobuf::Message {
 public:
  GeoSnapConfig();
  virtual ~GeoSnapConfig();

  GeoSnapConfig(const GeoSnapConfig& from);

  inline GeoSnapConfig& operator=(const GeoSnapConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GeoSnapConfig& default_instance();

  void Swap(GeoSnapConfig* other);

  // implements Message ----------------------------------------------

  GeoSnapConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GeoSnapConfig& from);
  void MergeFrom(const GeoSnapConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "GEO_SNAP_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string geo_enabled = 2 [default = "OFF"];
  inline bool has_geo_enabled() const;
  inline void clear_geo_enabled();
  static const int kGeoEnabledFieldNumber = 2;
  inline const ::std::string& geo_enabled() const;
  inline void set_geo_enabled(const ::std::string& value);
  inline void set_geo_enabled(const char* value);
  inline void set_geo_enabled(const char* value, size_t size);
  inline ::std::string* mutable_geo_enabled();
  inline ::std::string* release_geo_enabled();
  inline void set_allocated_geo_enabled(::std::string* geo_enabled);

  // optional string auto_launch = 3 [default = "ON"];
  inline bool has_auto_launch() const;
  inline void clear_auto_launch();
  static const int kAutoLaunchFieldNumber = 3;
  inline const ::std::string& auto_launch() const;
  inline void set_auto_launch(const ::std::string& value);
  inline void set_auto_launch(const char* value);
  inline void set_auto_launch(const char* value, size_t size);
  inline ::std::string* mutable_auto_launch();
  inline ::std::string* release_auto_launch();
  inline void set_allocated_auto_launch(::std::string* auto_launch);

  // optional int32 temp_write_aux = 4;
  inline bool has_temp_write_aux() const;
  inline void clear_temp_write_aux();
  static const int kTempWriteAuxFieldNumber = 4;
  inline ::google::protobuf::int32 temp_write_aux() const;
  inline void set_temp_write_aux(::google::protobuf::int32 value);

  // optional string antenna = 5;
  inline bool has_antenna() const;
  inline void clear_antenna();
  static const int kAntennaFieldNumber = 5;
  inline const ::std::string& antenna() const;
  inline void set_antenna(const ::std::string& value);
  inline void set_antenna(const char* value);
  inline void set_antenna(const char* value, size_t size);
  inline ::std::string* mutable_antenna();
  inline ::std::string* release_antenna();
  inline void set_allocated_antenna(::std::string* antenna);

  // optional string mission = 6;
  inline bool has_mission() const;
  inline void clear_mission();
  static const int kMissionFieldNumber = 6;
  inline const ::std::string& mission() const;
  inline void set_mission(const ::std::string& value);
  inline void set_mission(const char* value);
  inline void set_mission(const char* value, size_t size);
  inline ::std::string* mutable_mission();
  inline ::std::string* release_mission();
  inline void set_allocated_mission(::std::string* mission);

  // optional string path = 7;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 7;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional int32 rx_path_delay = 8;
  inline bool has_rx_path_delay() const;
  inline void clear_rx_path_delay();
  static const int kRxPathDelayFieldNumber = 8;
  inline ::google::protobuf::int32 rx_path_delay() const;
  inline void set_rx_path_delay(::google::protobuf::int32 value);

  // optional int32 rx_site = 9;
  inline bool has_rx_site() const;
  inline void clear_rx_site();
  static const int kRxSiteFieldNumber = 9;
  inline ::google::protobuf::int32 rx_site() const;
  inline void set_rx_site(::google::protobuf::int32 value);

  // optional float feed_lat = 10;
  inline bool has_feed_lat() const;
  inline void clear_feed_lat();
  static const int kFeedLatFieldNumber = 10;
  inline float feed_lat() const;
  inline void set_feed_lat(float value);

  // optional float feed_lon = 11;
  inline bool has_feed_lon() const;
  inline void clear_feed_lon();
  static const int kFeedLonFieldNumber = 11;
  inline float feed_lon() const;
  inline void set_feed_lon(float value);

  // optional float feed_alt = 12;
  inline bool has_feed_alt() const;
  inline void clear_feed_alt();
  static const int kFeedAltFieldNumber = 12;
  inline float feed_alt() const;
  inline void set_feed_alt(float value);

  // optional float system_foa_sigma = 13;
  inline bool has_system_foa_sigma() const;
  inline void clear_system_foa_sigma();
  static const int kSystemFoaSigmaFieldNumber = 13;
  inline float system_foa_sigma() const;
  inline void set_system_foa_sigma(float value);

  // optional float system_toa_sigma = 14;
  inline bool has_system_toa_sigma() const;
  inline void clear_system_toa_sigma();
  static const int kSystemToaSigmaFieldNumber = 14;
  inline float system_toa_sigma() const;
  inline void set_system_toa_sigma(float value);

  // optional string desiredinterpolation = 15;
  inline bool has_desiredinterpolation() const;
  inline void clear_desiredinterpolation();
  static const int kDesiredinterpolationFieldNumber = 15;
  inline const ::std::string& desiredinterpolation() const;
  inline void set_desiredinterpolation(const ::std::string& value);
  inline void set_desiredinterpolation(const char* value);
  inline void set_desiredinterpolation(const char* value, size_t size);
  inline ::std::string* mutable_desiredinterpolation();
  inline ::std::string* release_desiredinterpolation();
  inline void set_allocated_desiredinterpolation(::std::string* desiredinterpolation);

  // optional int32 use_sv_keywords = 16;
  inline bool has_use_sv_keywords() const;
  inline void clear_use_sv_keywords();
  static const int kUseSvKeywordsFieldNumber = 16;
  inline ::google::protobuf::int32 use_sv_keywords() const;
  inline void set_use_sv_keywords(::google::protobuf::int32 value);

  // optional string skip_camel_transfer = 17 [default = "OFF"];
  inline bool has_skip_camel_transfer() const;
  inline void clear_skip_camel_transfer();
  static const int kSkipCamelTransferFieldNumber = 17;
  inline const ::std::string& skip_camel_transfer() const;
  inline void set_skip_camel_transfer(const ::std::string& value);
  inline void set_skip_camel_transfer(const char* value);
  inline void set_skip_camel_transfer(const char* value, size_t size);
  inline ::std::string* mutable_skip_camel_transfer();
  inline ::std::string* release_skip_camel_transfer();
  inline void set_allocated_skip_camel_transfer(::std::string* skip_camel_transfer);

  // optional float posx = 18;
  inline bool has_posx() const;
  inline void clear_posx();
  static const int kPosxFieldNumber = 18;
  inline float posx() const;
  inline void set_posx(float value);

  // optional float posy = 19;
  inline bool has_posy() const;
  inline void clear_posy();
  static const int kPosyFieldNumber = 19;
  inline float posy() const;
  inline void set_posy(float value);

  // optional float posz = 20;
  inline bool has_posz() const;
  inline void clear_posz();
  static const int kPoszFieldNumber = 20;
  inline float posz() const;
  inline void set_posz(float value);

  // optional string default_geo_app = 21;
  inline bool has_default_geo_app() const;
  inline void clear_default_geo_app();
  static const int kDefaultGeoAppFieldNumber = 21;
  inline const ::std::string& default_geo_app() const;
  inline void set_default_geo_app(const ::std::string& value);
  inline void set_default_geo_app(const char* value);
  inline void set_default_geo_app(const char* value, size_t size);
  inline ::std::string* mutable_default_geo_app();
  inline ::std::string* release_default_geo_app();
  inline void set_allocated_default_geo_app(::std::string* default_geo_app);

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.GeoSnapConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_geo_enabled();
  inline void clear_has_geo_enabled();
  inline void set_has_auto_launch();
  inline void clear_has_auto_launch();
  inline void set_has_temp_write_aux();
  inline void clear_has_temp_write_aux();
  inline void set_has_antenna();
  inline void clear_has_antenna();
  inline void set_has_mission();
  inline void clear_has_mission();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_rx_path_delay();
  inline void clear_has_rx_path_delay();
  inline void set_has_rx_site();
  inline void clear_has_rx_site();
  inline void set_has_feed_lat();
  inline void clear_has_feed_lat();
  inline void set_has_feed_lon();
  inline void clear_has_feed_lon();
  inline void set_has_feed_alt();
  inline void clear_has_feed_alt();
  inline void set_has_system_foa_sigma();
  inline void clear_has_system_foa_sigma();
  inline void set_has_system_toa_sigma();
  inline void clear_has_system_toa_sigma();
  inline void set_has_desiredinterpolation();
  inline void clear_has_desiredinterpolation();
  inline void set_has_use_sv_keywords();
  inline void clear_has_use_sv_keywords();
  inline void set_has_skip_camel_transfer();
  inline void clear_has_skip_camel_transfer();
  inline void set_has_posx();
  inline void clear_has_posx();
  inline void set_has_posy();
  inline void clear_has_posy();
  inline void set_has_posz();
  inline void clear_has_posz();
  inline void set_has_default_geo_app();
  inline void clear_has_default_geo_app();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* geo_enabled_;
  static ::std::string* _default_geo_enabled_;
  ::std::string* auto_launch_;
  static ::std::string* _default_auto_launch_;
  ::std::string* antenna_;
  ::std::string* mission_;
  ::google::protobuf::int32 temp_write_aux_;
  ::google::protobuf::int32 rx_path_delay_;
  ::std::string* path_;
  ::google::protobuf::int32 rx_site_;
  float feed_lat_;
  float feed_lon_;
  float feed_alt_;
  float system_foa_sigma_;
  float system_toa_sigma_;
  ::std::string* desiredinterpolation_;
  ::std::string* skip_camel_transfer_;
  static ::std::string* _default_skip_camel_transfer_;
  ::google::protobuf::int32 use_sv_keywords_;
  float posx_;
  float posy_;
  float posz_;
  ::std::string* default_geo_app_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static GeoSnapConfig* default_instance_;
};
// -------------------------------------------------------------------

class TGConfig : public ::google::protobuf::Message {
 public:
  TGConfig();
  virtual ~TGConfig();

  TGConfig(const TGConfig& from);

  inline TGConfig& operator=(const TGConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TGConfig& default_instance();

  void Swap(TGConfig* other);

  // implements Message ----------------------------------------------

  TGConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TGConfig& from);
  void MergeFrom(const TGConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "TG_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string geo_test = 2 [default = "OFF"];
  inline bool has_geo_test() const;
  inline void clear_geo_test();
  static const int kGeoTestFieldNumber = 2;
  inline const ::std::string& geo_test() const;
  inline void set_geo_test(const ::std::string& value);
  inline void set_geo_test(const char* value);
  inline void set_geo_test(const char* value, size_t size);
  inline ::std::string* mutable_geo_test();
  inline ::std::string* release_geo_test();
  inline void set_allocated_geo_test(::std::string* geo_test);

  // optional int32 telem_timeout = 3 [default = 400];
  inline bool has_telem_timeout() const;
  inline void clear_telem_timeout();
  static const int kTelemTimeoutFieldNumber = 3;
  inline ::google::protobuf::int32 telem_timeout() const;
  inline void set_telem_timeout(::google::protobuf::int32 value);

  // optional string geo_pri_file = 4;
  inline bool has_geo_pri_file() const;
  inline void clear_geo_pri_file();
  static const int kGeoPriFileFieldNumber = 4;
  inline const ::std::string& geo_pri_file() const;
  inline void set_geo_pri_file(const ::std::string& value);
  inline void set_geo_pri_file(const char* value);
  inline void set_geo_pri_file(const char* value, size_t size);
  inline ::std::string* mutable_geo_pri_file();
  inline ::std::string* release_geo_pri_file();
  inline void set_allocated_geo_pri_file(::std::string* geo_pri_file);

  // optional int32 state_timeout = 5 [default = 60];
  inline bool has_state_timeout() const;
  inline void clear_state_timeout();
  static const int kStateTimeoutFieldNumber = 5;
  inline ::google::protobuf::int32 state_timeout() const;
  inline void set_state_timeout(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.TGConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_geo_test();
  inline void clear_has_geo_test();
  inline void set_has_telem_timeout();
  inline void clear_has_telem_timeout();
  inline void set_has_geo_pri_file();
  inline void clear_has_geo_pri_file();
  inline void set_has_state_timeout();
  inline void clear_has_state_timeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* geo_test_;
  static ::std::string* _default_geo_test_;
  ::std::string* geo_pri_file_;
  ::google::protobuf::int32 telem_timeout_;
  ::google::protobuf::int32 state_timeout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static TGConfig* default_instance_;
};
// -------------------------------------------------------------------

class EventHandlerConfig : public ::google::protobuf::Message {
 public:
  EventHandlerConfig();
  virtual ~EventHandlerConfig();

  EventHandlerConfig(const EventHandlerConfig& from);

  inline EventHandlerConfig& operator=(const EventHandlerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EventHandlerConfig& default_instance();

  void Swap(EventHandlerConfig* other);

  // implements Message ----------------------------------------------

  EventHandlerConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EventHandlerConfig& from);
  void MergeFrom(const EventHandlerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EVENT_HANDLER_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional bool xmlEnable = 2;
  inline bool has_xmlenable() const;
  inline void clear_xmlenable();
  static const int kXmlEnableFieldNumber = 2;
  inline bool xmlenable() const;
  inline void set_xmlenable(bool value);

  // optional string xmlClass = 3;
  inline bool has_xmlclass() const;
  inline void clear_xmlclass();
  static const int kXmlClassFieldNumber = 3;
  inline const ::std::string& xmlclass() const;
  inline void set_xmlclass(const ::std::string& value);
  inline void set_xmlclass(const char* value);
  inline void set_xmlclass(const char* value, size_t size);
  inline ::std::string* mutable_xmlclass();
  inline ::std::string* release_xmlclass();
  inline void set_allocated_xmlclass(::std::string* xmlclass);

  // optional string xmlSource = 4;
  inline bool has_xmlsource() const;
  inline void clear_xmlsource();
  static const int kXmlSourceFieldNumber = 4;
  inline const ::std::string& xmlsource() const;
  inline void set_xmlsource(const ::std::string& value);
  inline void set_xmlsource(const char* value);
  inline void set_xmlsource(const char* value, size_t size);
  inline ::std::string* mutable_xmlsource();
  inline ::std::string* release_xmlsource();
  inline void set_allocated_xmlsource(::std::string* xmlsource);

  // optional string xmlPath = 5;
  inline bool has_xmlpath() const;
  inline void clear_xmlpath();
  static const int kXmlPathFieldNumber = 5;
  inline const ::std::string& xmlpath() const;
  inline void set_xmlpath(const ::std::string& value);
  inline void set_xmlpath(const char* value);
  inline void set_xmlpath(const char* value, size_t size);
  inline ::std::string* mutable_xmlpath();
  inline ::std::string* release_xmlpath();
  inline void set_allocated_xmlpath(::std::string* xmlpath);

  // optional string xmlWorkstation = 6;
  inline bool has_xmlworkstation() const;
  inline void clear_xmlworkstation();
  static const int kXmlWorkstationFieldNumber = 6;
  inline const ::std::string& xmlworkstation() const;
  inline void set_xmlworkstation(const ::std::string& value);
  inline void set_xmlworkstation(const char* value);
  inline void set_xmlworkstation(const char* value, size_t size);
  inline ::std::string* mutable_xmlworkstation();
  inline ::std::string* release_xmlworkstation();
  inline void set_allocated_xmlworkstation(::std::string* xmlworkstation);

  // optional int32 xmlPeriod = 7;
  inline bool has_xmlperiod() const;
  inline void clear_xmlperiod();
  static const int kXmlPeriodFieldNumber = 7;
  inline ::google::protobuf::int32 xmlperiod() const;
  inline void set_xmlperiod(::google::protobuf::int32 value);

  // optional int32 xmlGeoThreshold = 8;
  inline bool has_xmlgeothreshold() const;
  inline void clear_xmlgeothreshold();
  static const int kXmlGeoThresholdFieldNumber = 8;
  inline ::google::protobuf::int32 xmlgeothreshold() const;
  inline void set_xmlgeothreshold(::google::protobuf::int32 value);

  // optional string xmlGeoFilterFile = 9;
  inline bool has_xmlgeofilterfile() const;
  inline void clear_xmlgeofilterfile();
  static const int kXmlGeoFilterFileFieldNumber = 9;
  inline const ::std::string& xmlgeofilterfile() const;
  inline void set_xmlgeofilterfile(const ::std::string& value);
  inline void set_xmlgeofilterfile(const char* value);
  inline void set_xmlgeofilterfile(const char* value, size_t size);
  inline ::std::string* mutable_xmlgeofilterfile();
  inline ::std::string* release_xmlgeofilterfile();
  inline void set_allocated_xmlgeofilterfile(::std::string* xmlgeofilterfile);

  // optional string workstationWhitelist = 10;
  inline bool has_workstationwhitelist() const;
  inline void clear_workstationwhitelist();
  static const int kWorkstationWhitelistFieldNumber = 10;
  inline const ::std::string& workstationwhitelist() const;
  inline void set_workstationwhitelist(const ::std::string& value);
  inline void set_workstationwhitelist(const char* value);
  inline void set_workstationwhitelist(const char* value, size_t size);
  inline ::std::string* mutable_workstationwhitelist();
  inline ::std::string* release_workstationwhitelist();
  inline void set_allocated_workstationwhitelist(::std::string* workstationwhitelist);

  // optional int32 telemTimeout = 11 [default = 300];
  inline bool has_telemtimeout() const;
  inline void clear_telemtimeout();
  static const int kTelemTimeoutFieldNumber = 11;
  inline ::google::protobuf::int32 telemtimeout() const;
  inline void set_telemtimeout(::google::protobuf::int32 value);

  // optional int32 geoTimeout = 12 [default = 300];
  inline bool has_geotimeout() const;
  inline void clear_geotimeout();
  static const int kGeoTimeoutFieldNumber = 12;
  inline ::google::protobuf::int32 geotimeout() const;
  inline void set_geotimeout(::google::protobuf::int32 value);

  // optional string tagOverrideFile = 13;
  inline bool has_tagoverridefile() const;
  inline void clear_tagoverridefile();
  static const int kTagOverrideFileFieldNumber = 13;
  inline const ::std::string& tagoverridefile() const;
  inline void set_tagoverridefile(const ::std::string& value);
  inline void set_tagoverridefile(const char* value);
  inline void set_tagoverridefile(const char* value, size_t size);
  inline ::std::string* mutable_tagoverridefile();
  inline ::std::string* release_tagoverridefile();
  inline void set_allocated_tagoverridefile(::std::string* tagoverridefile);

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.EventHandlerConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_xmlenable();
  inline void clear_has_xmlenable();
  inline void set_has_xmlclass();
  inline void clear_has_xmlclass();
  inline void set_has_xmlsource();
  inline void clear_has_xmlsource();
  inline void set_has_xmlpath();
  inline void clear_has_xmlpath();
  inline void set_has_xmlworkstation();
  inline void clear_has_xmlworkstation();
  inline void set_has_xmlperiod();
  inline void clear_has_xmlperiod();
  inline void set_has_xmlgeothreshold();
  inline void clear_has_xmlgeothreshold();
  inline void set_has_xmlgeofilterfile();
  inline void clear_has_xmlgeofilterfile();
  inline void set_has_workstationwhitelist();
  inline void clear_has_workstationwhitelist();
  inline void set_has_telemtimeout();
  inline void clear_has_telemtimeout();
  inline void set_has_geotimeout();
  inline void clear_has_geotimeout();
  inline void set_has_tagoverridefile();
  inline void clear_has_tagoverridefile();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* xmlclass_;
  ::std::string* xmlsource_;
  bool xmlenable_;
  ::google::protobuf::int32 xmlperiod_;
  ::std::string* xmlpath_;
  ::std::string* xmlworkstation_;
  ::std::string* xmlgeofilterfile_;
  ::google::protobuf::int32 xmlgeothreshold_;
  ::google::protobuf::int32 telemtimeout_;
  ::std::string* workstationwhitelist_;
  ::std::string* tagoverridefile_;
  ::google::protobuf::int32 geotimeout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static EventHandlerConfig* default_instance_;
};
// -------------------------------------------------------------------

class GPSFakerConfig : public ::google::protobuf::Message {
 public:
  GPSFakerConfig();
  virtual ~GPSFakerConfig();

  GPSFakerConfig(const GPSFakerConfig& from);

  inline GPSFakerConfig& operator=(const GPSFakerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GPSFakerConfig& default_instance();

  void Swap(GPSFakerConfig* other);

  // implements Message ----------------------------------------------

  GPSFakerConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPSFakerConfig& from);
  void MergeFrom(const GPSFakerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "GPS_FAKER_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string gpsFile = 2;
  inline bool has_gpsfile() const;
  inline void clear_gpsfile();
  static const int kGpsFileFieldNumber = 2;
  inline const ::std::string& gpsfile() const;
  inline void set_gpsfile(const ::std::string& value);
  inline void set_gpsfile(const char* value);
  inline void set_gpsfile(const char* value, size_t size);
  inline ::std::string* mutable_gpsfile();
  inline ::std::string* release_gpsfile();
  inline void set_allocated_gpsfile(::std::string* gpsfile);

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.GPSFakerConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_gpsfile();
  inline void clear_has_gpsfile();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* gpsfile_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static GPSFakerConfig* default_instance_;
};
// -------------------------------------------------------------------

class SkyscraperConfig : public ::google::protobuf::Message {
 public:
  SkyscraperConfig();
  virtual ~SkyscraperConfig();

  SkyscraperConfig(const SkyscraperConfig& from);

  inline SkyscraperConfig& operator=(const SkyscraperConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SkyscraperConfig& default_instance();

  void Swap(SkyscraperConfig* other);

  // implements Message ----------------------------------------------

  SkyscraperConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SkyscraperConfig& from);
  void MergeFrom(const SkyscraperConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SKYSCRAPER_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string directory = 2;
  inline bool has_directory() const;
  inline void clear_directory();
  static const int kDirectoryFieldNumber = 2;
  inline const ::std::string& directory() const;
  inline void set_directory(const ::std::string& value);
  inline void set_directory(const char* value);
  inline void set_directory(const char* value, size_t size);
  inline ::std::string* mutable_directory();
  inline ::std::string* release_directory();
  inline void set_allocated_directory(::std::string* directory);

  // optional string filename = 3;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 3;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.SkyscraperConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_directory();
  inline void clear_has_directory();
  inline void set_has_filename();
  inline void clear_has_filename();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* directory_;
  ::std::string* filename_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static SkyscraperConfig* default_instance_;
};
// -------------------------------------------------------------------

class NoiseTestConfig : public ::google::protobuf::Message {
 public:
  NoiseTestConfig();
  virtual ~NoiseTestConfig();

  NoiseTestConfig(const NoiseTestConfig& from);

  inline NoiseTestConfig& operator=(const NoiseTestConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NoiseTestConfig& default_instance();

  void Swap(NoiseTestConfig* other);

  // implements Message ----------------------------------------------

  NoiseTestConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NoiseTestConfig& from);
  void MergeFrom(const NoiseTestConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "NOISE_TEST_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional .falcon_svc_msg.MacroOptions options = 2;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 2;
  inline const ::falcon_svc_msg::MacroOptions& options() const;
  inline ::falcon_svc_msg::MacroOptions* mutable_options();
  inline ::falcon_svc_msg::MacroOptions* release_options();
  inline void set_allocated_options(::falcon_svc_msg::MacroOptions* options);

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.NoiseTestConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_options();
  inline void clear_has_options();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::falcon_svc_msg::MacroOptions* options_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static NoiseTestConfig* default_instance_;
};
// -------------------------------------------------------------------

class ExtraScriptConfigMess : public ::google::protobuf::Message {
 public:
  ExtraScriptConfigMess();
  virtual ~ExtraScriptConfigMess();

  ExtraScriptConfigMess(const ExtraScriptConfigMess& from);

  inline ExtraScriptConfigMess& operator=(const ExtraScriptConfigMess& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExtraScriptConfigMess& default_instance();

  void Swap(ExtraScriptConfigMess* other);

  // implements Message ----------------------------------------------

  ExtraScriptConfigMess* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExtraScriptConfigMess& from);
  void MergeFrom(const ExtraScriptConfigMess& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EXTRASCRIPTCONFIGMESS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string script = 2;
  inline bool has_script() const;
  inline void clear_script();
  static const int kScriptFieldNumber = 2;
  inline const ::std::string& script() const;
  inline void set_script(const ::std::string& value);
  inline void set_script(const char* value);
  inline void set_script(const char* value, size_t size);
  inline ::std::string* mutable_script();
  inline ::std::string* release_script();
  inline void set_allocated_script(::std::string* script);

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.ExtraScriptConfigMess)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_script();
  inline void clear_has_script();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* script_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static ExtraScriptConfigMess* default_instance_;
};
// -------------------------------------------------------------------

class NoConfigMess : public ::google::protobuf::Message {
 public:
  NoConfigMess();
  virtual ~NoConfigMess();

  NoConfigMess(const NoConfigMess& from);

  inline NoConfigMess& operator=(const NoConfigMess& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NoConfigMess& default_instance();

  void Swap(NoConfigMess* other);

  // implements Message ----------------------------------------------

  NoConfigMess* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NoConfigMess& from);
  void MergeFrom(const NoConfigMess& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "NOCONFIGMESS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.NoConfigMess)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static NoConfigMess* default_instance_;
};
// -------------------------------------------------------------------

class PentekConfigMess : public ::google::protobuf::Message {
 public:
  PentekConfigMess();
  virtual ~PentekConfigMess();

  PentekConfigMess(const PentekConfigMess& from);

  inline PentekConfigMess& operator=(const PentekConfigMess& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PentekConfigMess& default_instance();

  void Swap(PentekConfigMess* other);

  // implements Message ----------------------------------------------

  PentekConfigMess* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PentekConfigMess& from);
  void MergeFrom(const PentekConfigMess& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EXTRASCRIPTCONFIGMESS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional float txSampleRate = 2;
  inline bool has_txsamplerate() const;
  inline void clear_txsamplerate();
  static const int kTxSampleRateFieldNumber = 2;
  inline float txsamplerate() const;
  inline void set_txsamplerate(float value);

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.PentekConfigMess)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_txsamplerate();
  inline void clear_has_txsamplerate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  float txsamplerate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static PentekConfigMess* default_instance_;
};
// -------------------------------------------------------------------

class PredTunerConfig : public ::google::protobuf::Message {
 public:
  PredTunerConfig();
  virtual ~PredTunerConfig();

  PredTunerConfig(const PredTunerConfig& from);

  inline PredTunerConfig& operator=(const PredTunerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PredTunerConfig& default_instance();

  void Swap(PredTunerConfig* other);

  // implements Message ----------------------------------------------

  PredTunerConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PredTunerConfig& from);
  void MergeFrom(const PredTunerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "PREDTUNER_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 numTuners = 2;
  inline bool has_numtuners() const;
  inline void clear_numtuners();
  static const int kNumTunersFieldNumber = 2;
  inline ::google::protobuf::int32 numtuners() const;
  inline void set_numtuners(::google::protobuf::int32 value);

  // optional int32 arcfilenum = 3;
  inline bool has_arcfilenum() const;
  inline void clear_arcfilenum();
  static const int kArcfilenumFieldNumber = 3;
  inline ::google::protobuf::int32 arcfilenum() const;
  inline void set_arcfilenum(::google::protobuf::int32 value);

  // optional int32 arcfilesize = 4;
  inline bool has_arcfilesize() const;
  inline void clear_arcfilesize();
  static const int kArcfilesizeFieldNumber = 4;
  inline ::google::protobuf::int32 arcfilesize() const;
  inline void set_arcfilesize(::google::protobuf::int32 value);

  // optional string config = 5;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 5;
  inline const ::std::string& config() const;
  inline void set_config(const ::std::string& value);
  inline void set_config(const char* value);
  inline void set_config(const char* value, size_t size);
  inline ::std::string* mutable_config();
  inline ::std::string* release_config();
  inline void set_allocated_config(::std::string* config);

  // optional int32 startTunerNum = 6;
  inline bool has_starttunernum() const;
  inline void clear_starttunernum();
  static const int kStartTunerNumFieldNumber = 6;
  inline ::google::protobuf::int32 starttunernum() const;
  inline void set_starttunernum(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.PredTunerConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_numtuners();
  inline void clear_has_numtuners();
  inline void set_has_arcfilenum();
  inline void clear_has_arcfilenum();
  inline void set_has_arcfilesize();
  inline void clear_has_arcfilesize();
  inline void set_has_config();
  inline void clear_has_config();
  inline void set_has_starttunernum();
  inline void clear_has_starttunernum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 numtuners_;
  ::google::protobuf::int32 arcfilenum_;
  ::std::string* config_;
  ::google::protobuf::int32 arcfilesize_;
  ::google::protobuf::int32 starttunernum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static PredTunerConfig* default_instance_;
};
// -------------------------------------------------------------------

class PredTransceiverConfig : public ::google::protobuf::Message {
 public:
  PredTransceiverConfig();
  virtual ~PredTransceiverConfig();

  PredTransceiverConfig(const PredTransceiverConfig& from);

  inline PredTransceiverConfig& operator=(const PredTransceiverConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PredTransceiverConfig& default_instance();

  void Swap(PredTransceiverConfig* other);

  // implements Message ----------------------------------------------

  PredTransceiverConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PredTransceiverConfig& from);
  void MergeFrom(const PredTransceiverConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "TRANSCEIVER_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 snapshotRingCapacity = 2 [default = 50];
  inline bool has_snapshotringcapacity() const;
  inline void clear_snapshotringcapacity();
  static const int kSnapshotRingCapacityFieldNumber = 2;
  inline ::google::protobuf::int32 snapshotringcapacity() const;
  inline void set_snapshotringcapacity(::google::protobuf::int32 value);

  // optional int32 numTuners = 3;
  inline bool has_numtuners() const;
  inline void clear_numtuners();
  static const int kNumTunersFieldNumber = 3;
  inline ::google::protobuf::int32 numtuners() const;
  inline void set_numtuners(::google::protobuf::int32 value);

  // optional int32 numTransmitters = 4;
  inline bool has_numtransmitters() const;
  inline void clear_numtransmitters();
  static const int kNumTransmittersFieldNumber = 4;
  inline ::google::protobuf::int32 numtransmitters() const;
  inline void set_numtransmitters(::google::protobuf::int32 value);

  // optional int32 startTunerNum = 5;
  inline bool has_starttunernum() const;
  inline void clear_starttunernum();
  static const int kStartTunerNumFieldNumber = 5;
  inline ::google::protobuf::int32 starttunernum() const;
  inline void set_starttunernum(::google::protobuf::int32 value);

  // optional string ipaddr = 6;
  inline bool has_ipaddr() const;
  inline void clear_ipaddr();
  static const int kIpaddrFieldNumber = 6;
  inline const ::std::string& ipaddr() const;
  inline void set_ipaddr(const ::std::string& value);
  inline void set_ipaddr(const char* value);
  inline void set_ipaddr(const char* value, size_t size);
  inline ::std::string* mutable_ipaddr();
  inline ::std::string* release_ipaddr();
  inline void set_allocated_ipaddr(::std::string* ipaddr);

  // optional string hwType = 7 [default = "USRP"];
  inline bool has_hwtype() const;
  inline void clear_hwtype();
  static const int kHwTypeFieldNumber = 7;
  inline const ::std::string& hwtype() const;
  inline void set_hwtype(const ::std::string& value);
  inline void set_hwtype(const char* value);
  inline void set_hwtype(const char* value, size_t size);
  inline ::std::string* mutable_hwtype();
  inline ::std::string* release_hwtype();
  inline void set_allocated_hwtype(::std::string* hwtype);

  // optional float rxSampleRate = 8 [default = 2.5e+07];
  inline bool has_rxsamplerate() const;
  inline void clear_rxsamplerate();
  static const int kRxSampleRateFieldNumber = 8;
  inline float rxsamplerate() const;
  inline void set_rxsamplerate(float value);

  // optional float txSampleRate = 9 [default = 1e+08];
  inline bool has_txsamplerate() const;
  inline void clear_txsamplerate();
  static const int kTxSampleRateFieldNumber = 9;
  inline float txsamplerate() const;
  inline void set_txsamplerate(float value);

  // optional string usrpClockSource = 10 [default = "internal"];
  inline bool has_usrpclocksource() const;
  inline void clear_usrpclocksource();
  static const int kUsrpClockSourceFieldNumber = 10;
  inline const ::std::string& usrpclocksource() const;
  inline void set_usrpclocksource(const ::std::string& value);
  inline void set_usrpclocksource(const char* value);
  inline void set_usrpclocksource(const char* value, size_t size);
  inline ::std::string* mutable_usrpclocksource();
  inline ::std::string* release_usrpclocksource();
  inline void set_allocated_usrpclocksource(::std::string* usrpclocksource);

  // optional string usrpTimeSource = 11 [default = "internal"];
  inline bool has_usrptimesource() const;
  inline void clear_usrptimesource();
  static const int kUsrpTimeSourceFieldNumber = 11;
  inline const ::std::string& usrptimesource() const;
  inline void set_usrptimesource(const ::std::string& value);
  inline void set_usrptimesource(const char* value);
  inline void set_usrptimesource(const char* value, size_t size);
  inline ::std::string* mutable_usrptimesource();
  inline ::std::string* release_usrptimesource();
  inline void set_allocated_usrptimesource(::std::string* usrptimesource);

  // optional string fft = 12 [default = "false"];
  inline bool has_fft() const;
  inline void clear_fft();
  static const int kFftFieldNumber = 12;
  inline const ::std::string& fft() const;
  inline void set_fft(const ::std::string& value);
  inline void set_fft(const char* value);
  inline void set_fft(const char* value, size_t size);
  inline ::std::string* mutable_fft();
  inline ::std::string* release_fft();
  inline void set_allocated_fft(::std::string* fft);

  // optional float arcFileSecs = 13 [default = -1];
  inline bool has_arcfilesecs() const;
  inline void clear_arcfilesecs();
  static const int kArcFileSecsFieldNumber = 13;
  inline float arcfilesecs() const;
  inline void set_arcfilesecs(float value);

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.PredTransceiverConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_snapshotringcapacity();
  inline void clear_has_snapshotringcapacity();
  inline void set_has_numtuners();
  inline void clear_has_numtuners();
  inline void set_has_numtransmitters();
  inline void clear_has_numtransmitters();
  inline void set_has_starttunernum();
  inline void clear_has_starttunernum();
  inline void set_has_ipaddr();
  inline void clear_has_ipaddr();
  inline void set_has_hwtype();
  inline void clear_has_hwtype();
  inline void set_has_rxsamplerate();
  inline void clear_has_rxsamplerate();
  inline void set_has_txsamplerate();
  inline void clear_has_txsamplerate();
  inline void set_has_usrpclocksource();
  inline void clear_has_usrpclocksource();
  inline void set_has_usrptimesource();
  inline void clear_has_usrptimesource();
  inline void set_has_fft();
  inline void clear_has_fft();
  inline void set_has_arcfilesecs();
  inline void clear_has_arcfilesecs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 snapshotringcapacity_;
  ::google::protobuf::int32 numtuners_;
  ::google::protobuf::int32 numtransmitters_;
  ::google::protobuf::int32 starttunernum_;
  ::std::string* ipaddr_;
  ::std::string* hwtype_;
  static ::std::string* _default_hwtype_;
  float rxsamplerate_;
  float txsamplerate_;
  ::std::string* usrpclocksource_;
  static ::std::string* _default_usrpclocksource_;
  ::std::string* usrptimesource_;
  static ::std::string* _default_usrptimesource_;
  ::std::string* fft_;
  static ::std::string* _default_fft_;
  float arcfilesecs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static PredTransceiverConfig* default_instance_;
};
// -------------------------------------------------------------------

class SidekiqTransceiverConfig : public ::google::protobuf::Message {
 public:
  SidekiqTransceiverConfig();
  virtual ~SidekiqTransceiverConfig();

  SidekiqTransceiverConfig(const SidekiqTransceiverConfig& from);

  inline SidekiqTransceiverConfig& operator=(const SidekiqTransceiverConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SidekiqTransceiverConfig& default_instance();

  void Swap(SidekiqTransceiverConfig* other);

  // implements Message ----------------------------------------------

  SidekiqTransceiverConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SidekiqTransceiverConfig& from);
  void MergeFrom(const SidekiqTransceiverConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SIDEKIQTRANSCEIVER_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 snapshotRingCapacity = 2 [default = 50];
  inline bool has_snapshotringcapacity() const;
  inline void clear_snapshotringcapacity();
  static const int kSnapshotRingCapacityFieldNumber = 2;
  inline ::google::protobuf::int32 snapshotringcapacity() const;
  inline void set_snapshotringcapacity(::google::protobuf::int32 value);

  // optional int32 rxA1 = 3 [default = -1];
  inline bool has_rxa1() const;
  inline void clear_rxa1();
  static const int kRxA1FieldNumber = 3;
  inline ::google::protobuf::int32 rxa1() const;
  inline void set_rxa1(::google::protobuf::int32 value);

  // optional int32 rxA2 = 4 [default = -1];
  inline bool has_rxa2() const;
  inline void clear_rxa2();
  static const int kRxA2FieldNumber = 4;
  inline ::google::protobuf::int32 rxa2() const;
  inline void set_rxa2(::google::protobuf::int32 value);

  // optional int32 rxB1 = 5 [default = -1];
  inline bool has_rxb1() const;
  inline void clear_rxb1();
  static const int kRxB1FieldNumber = 5;
  inline ::google::protobuf::int32 rxb1() const;
  inline void set_rxb1(::google::protobuf::int32 value);

  // optional int32 rxB2 = 6 [default = -1];
  inline bool has_rxb2() const;
  inline void clear_rxb2();
  static const int kRxB2FieldNumber = 6;
  inline ::google::protobuf::int32 rxb2() const;
  inline void set_rxb2(::google::protobuf::int32 value);

  // optional int32 txA1 = 7 [default = -1];
  inline bool has_txa1() const;
  inline void clear_txa1();
  static const int kTxA1FieldNumber = 7;
  inline ::google::protobuf::int32 txa1() const;
  inline void set_txa1(::google::protobuf::int32 value);

  // optional int32 txA2 = 8 [default = -1];
  inline bool has_txa2() const;
  inline void clear_txa2();
  static const int kTxA2FieldNumber = 8;
  inline ::google::protobuf::int32 txa2() const;
  inline void set_txa2(::google::protobuf::int32 value);

  // optional int32 txB1 = 9 [default = -1];
  inline bool has_txb1() const;
  inline void clear_txb1();
  static const int kTxB1FieldNumber = 9;
  inline ::google::protobuf::int32 txb1() const;
  inline void set_txb1(::google::protobuf::int32 value);

  // optional int32 txB2 = 10 [default = -1];
  inline bool has_txb2() const;
  inline void clear_txb2();
  static const int kTxB2FieldNumber = 10;
  inline ::google::protobuf::int32 txb2() const;
  inline void set_txb2(::google::protobuf::int32 value);

  // optional bool ppcA1 = 11 [default = false];
  inline bool has_ppca1() const;
  inline void clear_ppca1();
  static const int kPpcA1FieldNumber = 11;
  inline bool ppca1() const;
  inline void set_ppca1(bool value);

  // optional bool ppcA2 = 12 [default = false];
  inline bool has_ppca2() const;
  inline void clear_ppca2();
  static const int kPpcA2FieldNumber = 12;
  inline bool ppca2() const;
  inline void set_ppca2(bool value);

  // optional bool ppcB1 = 13 [default = false];
  inline bool has_ppcb1() const;
  inline void clear_ppcb1();
  static const int kPpcB1FieldNumber = 13;
  inline bool ppcb1() const;
  inline void set_ppcb1(bool value);

  // optional bool ppcB2 = 14 [default = false];
  inline bool has_ppcb2() const;
  inline void clear_ppcb2();
  static const int kPpcB2FieldNumber = 14;
  inline bool ppcb2() const;
  inline void set_ppcb2(bool value);

  // optional string cardID = 15 [default = "0"];
  inline bool has_cardid() const;
  inline void clear_cardid();
  static const int kCardIDFieldNumber = 15;
  inline const ::std::string& cardid() const;
  inline void set_cardid(const ::std::string& value);
  inline void set_cardid(const char* value);
  inline void set_cardid(const char* value, size_t size);
  inline ::std::string* mutable_cardid();
  inline ::std::string* release_cardid();
  inline void set_allocated_cardid(::std::string* cardid);

  // optional float sampleRateA = 16 [default = 5e+07];
  inline bool has_sampleratea() const;
  inline void clear_sampleratea();
  static const int kSampleRateAFieldNumber = 16;
  inline float sampleratea() const;
  inline void set_sampleratea(float value);

  // optional float sampleRateB = 17 [default = 5e+07];
  inline bool has_samplerateb() const;
  inline void clear_samplerateb();
  static const int kSampleRateBFieldNumber = 17;
  inline float samplerateb() const;
  inline void set_samplerateb(float value);

  // optional float energyThreshA = 18 [default = -70];
  inline bool has_energythresha() const;
  inline void clear_energythresha();
  static const int kEnergyThreshAFieldNumber = 18;
  inline float energythresha() const;
  inline void set_energythresha(float value);

  // optional float energyThreshB = 19 [default = -70];
  inline bool has_energythreshb() const;
  inline void clear_energythreshb();
  static const int kEnergyThreshBFieldNumber = 19;
  inline float energythreshb() const;
  inline void set_energythreshb(float value);

  // optional int32 energyThreshNumA = 20 [default = 200];
  inline bool has_energythreshnuma() const;
  inline void clear_energythreshnuma();
  static const int kEnergyThreshNumAFieldNumber = 20;
  inline ::google::protobuf::int32 energythreshnuma() const;
  inline void set_energythreshnuma(::google::protobuf::int32 value);

  // optional int32 energyThreshNumB = 21 [default = 200];
  inline bool has_energythreshnumb() const;
  inline void clear_energythreshnumb();
  static const int kEnergyThreshNumBFieldNumber = 21;
  inline ::google::protobuf::int32 energythreshnumb() const;
  inline void set_energythreshnumb(::google::protobuf::int32 value);

  // optional int32 rxBufferSize = 22 [default = 512];
  inline bool has_rxbuffersize() const;
  inline void clear_rxbuffersize();
  static const int kRxBufferSizeFieldNumber = 22;
  inline ::google::protobuf::int32 rxbuffersize() const;
  inline void set_rxbuffersize(::google::protobuf::int32 value);

  // optional int32 debuglvl = 23 [default = 0];
  inline bool has_debuglvl() const;
  inline void clear_debuglvl();
  static const int kDebuglvlFieldNumber = 23;
  inline ::google::protobuf::int32 debuglvl() const;
  inline void set_debuglvl(::google::protobuf::int32 value);

  // optional bool externalReference = 24 [default = true];
  inline bool has_externalreference() const;
  inline void clear_externalreference();
  static const int kExternalReferenceFieldNumber = 24;
  inline bool externalreference() const;
  inline void set_externalreference(bool value);

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.SidekiqTransceiverConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_snapshotringcapacity();
  inline void clear_has_snapshotringcapacity();
  inline void set_has_rxa1();
  inline void clear_has_rxa1();
  inline void set_has_rxa2();
  inline void clear_has_rxa2();
  inline void set_has_rxb1();
  inline void clear_has_rxb1();
  inline void set_has_rxb2();
  inline void clear_has_rxb2();
  inline void set_has_txa1();
  inline void clear_has_txa1();
  inline void set_has_txa2();
  inline void clear_has_txa2();
  inline void set_has_txb1();
  inline void clear_has_txb1();
  inline void set_has_txb2();
  inline void clear_has_txb2();
  inline void set_has_ppca1();
  inline void clear_has_ppca1();
  inline void set_has_ppca2();
  inline void clear_has_ppca2();
  inline void set_has_ppcb1();
  inline void clear_has_ppcb1();
  inline void set_has_ppcb2();
  inline void clear_has_ppcb2();
  inline void set_has_cardid();
  inline void clear_has_cardid();
  inline void set_has_sampleratea();
  inline void clear_has_sampleratea();
  inline void set_has_samplerateb();
  inline void clear_has_samplerateb();
  inline void set_has_energythresha();
  inline void clear_has_energythresha();
  inline void set_has_energythreshb();
  inline void clear_has_energythreshb();
  inline void set_has_energythreshnuma();
  inline void clear_has_energythreshnuma();
  inline void set_has_energythreshnumb();
  inline void clear_has_energythreshnumb();
  inline void set_has_rxbuffersize();
  inline void clear_has_rxbuffersize();
  inline void set_has_debuglvl();
  inline void clear_has_debuglvl();
  inline void set_has_externalreference();
  inline void clear_has_externalreference();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 snapshotringcapacity_;
  ::google::protobuf::int32 rxa1_;
  ::google::protobuf::int32 rxa2_;
  ::google::protobuf::int32 rxb1_;
  ::google::protobuf::int32 rxb2_;
  ::google::protobuf::int32 txa1_;
  ::google::protobuf::int32 txa2_;
  ::google::protobuf::int32 txb1_;
  ::google::protobuf::int32 txb2_;
  bool ppca1_;
  bool ppca2_;
  bool ppcb1_;
  bool ppcb2_;
  ::std::string* cardid_;
  static ::std::string* _default_cardid_;
  float sampleratea_;
  float samplerateb_;
  float energythresha_;
  float energythreshb_;
  ::google::protobuf::int32 energythreshnuma_;
  ::google::protobuf::int32 energythreshnumb_;
  ::google::protobuf::int32 rxbuffersize_;
  ::google::protobuf::int32 debuglvl_;
  bool externalreference_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(24 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static SidekiqTransceiverConfig* default_instance_;
};
// -------------------------------------------------------------------

class MMSTunerConfig : public ::google::protobuf::Message {
 public:
  MMSTunerConfig();
  virtual ~MMSTunerConfig();

  MMSTunerConfig(const MMSTunerConfig& from);

  inline MMSTunerConfig& operator=(const MMSTunerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MMSTunerConfig& default_instance();

  void Swap(MMSTunerConfig* other);

  // implements Message ----------------------------------------------

  MMSTunerConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MMSTunerConfig& from);
  void MergeFrom(const MMSTunerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "MMSTUNERCONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 snapshotRingCapacity = 2 [default = 50];
  inline bool has_snapshotringcapacity() const;
  inline void clear_snapshotringcapacity();
  static const int kSnapshotRingCapacityFieldNumber = 2;
  inline ::google::protobuf::int32 snapshotringcapacity() const;
  inline void set_snapshotringcapacity(::google::protobuf::int32 value);

  // optional int32 channel = 3;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 3;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional string ip = 4;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 4;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional string interface = 5;
  inline bool has_interface() const;
  inline void clear_interface();
  static const int kInterfaceFieldNumber = 5;
  inline const ::std::string& interface() const;
  inline void set_interface(const ::std::string& value);
  inline void set_interface(const char* value);
  inline void set_interface(const char* value, size_t size);
  inline ::std::string* mutable_interface();
  inline ::std::string* release_interface();
  inline void set_allocated_interface(::std::string* interface);

  // optional float bandwidth = 6;
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandwidthFieldNumber = 6;
  inline float bandwidth() const;
  inline void set_bandwidth(float value);

  // optional float sampleRate = 7;
  inline bool has_samplerate() const;
  inline void clear_samplerate();
  static const int kSampleRateFieldNumber = 7;
  inline float samplerate() const;
  inline void set_samplerate(float value);

  // optional int32 mmsRcvrNum = 8;
  inline bool has_mmsrcvrnum() const;
  inline void clear_mmsrcvrnum();
  static const int kMmsRcvrNumFieldNumber = 8;
  inline ::google::protobuf::int32 mmsrcvrnum() const;
  inline void set_mmsrcvrnum(::google::protobuf::int32 value);

  // optional bool usehwffts = 9 [default = false];
  inline bool has_usehwffts() const;
  inline void clear_usehwffts();
  static const int kUsehwfftsFieldNumber = 9;
  inline bool usehwffts() const;
  inline void set_usehwffts(bool value);

  // optional bool mmsWatchdogEnabled = 10 [default = true];
  inline bool has_mmswatchdogenabled() const;
  inline void clear_mmswatchdogenabled();
  static const int kMmsWatchdogEnabledFieldNumber = 10;
  inline bool mmswatchdogenabled() const;
  inline void set_mmswatchdogenabled(bool value);

  // optional float mmsWatchdogPetDeltaWarningThreshold = 11 [default = 20];
  inline bool has_mmswatchdogpetdeltawarningthreshold() const;
  inline void clear_mmswatchdogpetdeltawarningthreshold();
  static const int kMmsWatchdogPetDeltaWarningThresholdFieldNumber = 11;
  inline float mmswatchdogpetdeltawarningthreshold() const;
  inline void set_mmswatchdogpetdeltawarningthreshold(float value);

  // optional float mmsWatchdogPetInterval = 12 [default = 5];
  inline bool has_mmswatchdogpetinterval() const;
  inline void clear_mmswatchdogpetinterval();
  static const int kMmsWatchdogPetIntervalFieldNumber = 12;
  inline float mmswatchdogpetinterval() const;
  inline void set_mmswatchdogpetinterval(float value);

  // optional int32 mmsWatchdogTimeout = 13 [default = 30];
  inline bool has_mmswatchdogtimeout() const;
  inline void clear_mmswatchdogtimeout();
  static const int kMmsWatchdogTimeoutFieldNumber = 13;
  inline ::google::protobuf::int32 mmswatchdogtimeout() const;
  inline void set_mmswatchdogtimeout(::google::protobuf::int32 value);

  // optional bool xpipemonitorEnabled = 14 [default = false];
  inline bool has_xpipemonitorenabled() const;
  inline void clear_xpipemonitorenabled();
  static const int kXpipemonitorEnabledFieldNumber = 14;
  inline bool xpipemonitorenabled() const;
  inline void set_xpipemonitorenabled(bool value);

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.MMSTunerConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_snapshotringcapacity();
  inline void clear_has_snapshotringcapacity();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_interface();
  inline void clear_has_interface();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();
  inline void set_has_samplerate();
  inline void clear_has_samplerate();
  inline void set_has_mmsrcvrnum();
  inline void clear_has_mmsrcvrnum();
  inline void set_has_usehwffts();
  inline void clear_has_usehwffts();
  inline void set_has_mmswatchdogenabled();
  inline void clear_has_mmswatchdogenabled();
  inline void set_has_mmswatchdogpetdeltawarningthreshold();
  inline void clear_has_mmswatchdogpetdeltawarningthreshold();
  inline void set_has_mmswatchdogpetinterval();
  inline void clear_has_mmswatchdogpetinterval();
  inline void set_has_mmswatchdogtimeout();
  inline void clear_has_mmswatchdogtimeout();
  inline void set_has_xpipemonitorenabled();
  inline void clear_has_xpipemonitorenabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 snapshotringcapacity_;
  ::google::protobuf::int32 channel_;
  ::std::string* ip_;
  ::std::string* interface_;
  float bandwidth_;
  float samplerate_;
  ::google::protobuf::int32 mmsrcvrnum_;
  float mmswatchdogpetdeltawarningthreshold_;
  bool usehwffts_;
  bool mmswatchdogenabled_;
  bool xpipemonitorenabled_;
  float mmswatchdogpetinterval_;
  ::google::protobuf::int32 mmswatchdogtimeout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static MMSTunerConfig* default_instance_;
};
// -------------------------------------------------------------------

class DFServiceConfig : public ::google::protobuf::Message {
 public:
  DFServiceConfig();
  virtual ~DFServiceConfig();

  DFServiceConfig(const DFServiceConfig& from);

  inline DFServiceConfig& operator=(const DFServiceConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DFServiceConfig& default_instance();

  void Swap(DFServiceConfig* other);

  // implements Message ----------------------------------------------

  DFServiceConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DFServiceConfig& from);
  void MergeFrom(const DFServiceConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "DFSERVICECONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 interceptTimeout = 2 [default = 300];
  inline bool has_intercepttimeout() const;
  inline void clear_intercepttimeout();
  static const int kInterceptTimeoutFieldNumber = 2;
  inline ::google::protobuf::int32 intercepttimeout() const;
  inline void set_intercepttimeout(::google::protobuf::int32 value);

  // optional int32 sigupTimeout = 3 [default = 7200];
  inline bool has_siguptimeout() const;
  inline void clear_siguptimeout();
  static const int kSigupTimeoutFieldNumber = 3;
  inline ::google::protobuf::int32 siguptimeout() const;
  inline void set_siguptimeout(::google::protobuf::int32 value);

  // optional int32 sigdownTimeout = 4 [default = 120];
  inline bool has_sigdowntimeout() const;
  inline void clear_sigdowntimeout();
  static const int kSigdownTimeoutFieldNumber = 4;
  inline ::google::protobuf::int32 sigdowntimeout() const;
  inline void set_sigdowntimeout(::google::protobuf::int32 value);

  // optional string additionalBox1 = 5;
  inline bool has_additionalbox1() const;
  inline void clear_additionalbox1();
  static const int kAdditionalBox1FieldNumber = 5;
  inline const ::std::string& additionalbox1() const;
  inline void set_additionalbox1(const ::std::string& value);
  inline void set_additionalbox1(const char* value);
  inline void set_additionalbox1(const char* value, size_t size);
  inline ::std::string* mutable_additionalbox1();
  inline ::std::string* release_additionalbox1();
  inline void set_allocated_additionalbox1(::std::string* additionalbox1);

  // optional string additionalBox2 = 6;
  inline bool has_additionalbox2() const;
  inline void clear_additionalbox2();
  static const int kAdditionalBox2FieldNumber = 6;
  inline const ::std::string& additionalbox2() const;
  inline void set_additionalbox2(const ::std::string& value);
  inline void set_additionalbox2(const char* value);
  inline void set_additionalbox2(const char* value, size_t size);
  inline ::std::string* mutable_additionalbox2();
  inline ::std::string* release_additionalbox2();
  inline void set_allocated_additionalbox2(::std::string* additionalbox2);

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.DFServiceConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_intercepttimeout();
  inline void clear_has_intercepttimeout();
  inline void set_has_siguptimeout();
  inline void clear_has_siguptimeout();
  inline void set_has_sigdowntimeout();
  inline void clear_has_sigdowntimeout();
  inline void set_has_additionalbox1();
  inline void clear_has_additionalbox1();
  inline void set_has_additionalbox2();
  inline void clear_has_additionalbox2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 intercepttimeout_;
  ::google::protobuf::int32 siguptimeout_;
  ::std::string* additionalbox1_;
  ::std::string* additionalbox2_;
  ::google::protobuf::int32 sigdowntimeout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static DFServiceConfig* default_instance_;
};
// -------------------------------------------------------------------

class TechniqueConfig : public ::google::protobuf::Message {
 public:
  TechniqueConfig();
  virtual ~TechniqueConfig();

  TechniqueConfig(const TechniqueConfig& from);

  inline TechniqueConfig& operator=(const TechniqueConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TechniqueConfig& default_instance();

  void Swap(TechniqueConfig* other);

  // implements Message ----------------------------------------------

  TechniqueConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TechniqueConfig& from);
  void MergeFrom(const TechniqueConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "TECHNIQUECONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string platform = 2;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 2;
  inline const ::std::string& platform() const;
  inline void set_platform(const ::std::string& value);
  inline void set_platform(const char* value);
  inline void set_platform(const char* value, size_t size);
  inline ::std::string* mutable_platform();
  inline ::std::string* release_platform();
  inline void set_allocated_platform(::std::string* platform);

  // optional string method = 3;
  inline bool has_method() const;
  inline void clear_method();
  static const int kMethodFieldNumber = 3;
  inline const ::std::string& method() const;
  inline void set_method(const ::std::string& value);
  inline void set_method(const char* value);
  inline void set_method(const char* value, size_t size);
  inline ::std::string* mutable_method();
  inline ::std::string* release_method();
  inline void set_allocated_method(::std::string* method);

  // optional string script = 4;
  inline bool has_script() const;
  inline void clear_script();
  static const int kScriptFieldNumber = 4;
  inline const ::std::string& script() const;
  inline void set_script(const ::std::string& value);
  inline void set_script(const char* value);
  inline void set_script(const char* value, size_t size);
  inline ::std::string* mutable_script();
  inline ::std::string* release_script();
  inline void set_allocated_script(::std::string* script);

  // optional float samplerate = 5;
  inline bool has_samplerate() const;
  inline void clear_samplerate();
  static const int kSamplerateFieldNumber = 5;
  inline float samplerate() const;
  inline void set_samplerate(float value);

  // optional float inputsamplerate = 6;
  inline bool has_inputsamplerate() const;
  inline void clear_inputsamplerate();
  static const int kInputsamplerateFieldNumber = 6;
  inline float inputsamplerate() const;
  inline void set_inputsamplerate(float value);

  // optional string host = 7;
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 7;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  inline void set_allocated_host(::std::string* host);

  // optional int32 port = 8;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 8;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // optional float if_freq = 9 [default = 0];
  inline bool has_if_freq() const;
  inline void clear_if_freq();
  static const int kIfFreqFieldNumber = 9;
  inline float if_freq() const;
  inline void set_if_freq(float value);

  // optional float estimatedRFMHz = 10 [default = 433];
  inline bool has_estimatedrfmhz() const;
  inline void clear_estimatedrfmhz();
  static const int kEstimatedRFMHzFieldNumber = 10;
  inline float estimatedrfmhz() const;
  inline void set_estimatedrfmhz(float value);

  // optional int32 overrideChannel = 11 [default = -1];
  inline bool has_overridechannel() const;
  inline void clear_overridechannel();
  static const int kOverrideChannelFieldNumber = 11;
  inline ::google::protobuf::int32 overridechannel() const;
  inline void set_overridechannel(::google::protobuf::int32 value);

  // optional string capabilityId = 12 [default = "<DERIVE>"];
  inline bool has_capabilityid() const;
  inline void clear_capabilityid();
  static const int kCapabilityIdFieldNumber = 12;
  inline const ::std::string& capabilityid() const;
  inline void set_capabilityid(const ::std::string& value);
  inline void set_capabilityid(const char* value);
  inline void set_capabilityid(const char* value, size_t size);
  inline ::std::string* mutable_capabilityid();
  inline ::std::string* release_capabilityid();
  inline void set_allocated_capabilityid(::std::string* capabilityid);

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.TechniqueConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_method();
  inline void clear_has_method();
  inline void set_has_script();
  inline void clear_has_script();
  inline void set_has_samplerate();
  inline void clear_has_samplerate();
  inline void set_has_inputsamplerate();
  inline void clear_has_inputsamplerate();
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_if_freq();
  inline void clear_has_if_freq();
  inline void set_has_estimatedrfmhz();
  inline void clear_has_estimatedrfmhz();
  inline void set_has_overridechannel();
  inline void clear_has_overridechannel();
  inline void set_has_capabilityid();
  inline void clear_has_capabilityid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* platform_;
  ::std::string* method_;
  ::std::string* script_;
  float samplerate_;
  float inputsamplerate_;
  ::std::string* host_;
  ::google::protobuf::int32 port_;
  float if_freq_;
  float estimatedrfmhz_;
  ::google::protobuf::int32 overridechannel_;
  ::std::string* capabilityid_;
  static ::std::string* _default_capabilityid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static TechniqueConfig* default_instance_;
};
// -------------------------------------------------------------------

class RulesEngineConfig : public ::google::protobuf::Message {
 public:
  RulesEngineConfig();
  virtual ~RulesEngineConfig();

  RulesEngineConfig(const RulesEngineConfig& from);

  inline RulesEngineConfig& operator=(const RulesEngineConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RulesEngineConfig& default_instance();

  void Swap(RulesEngineConfig* other);

  // implements Message ----------------------------------------------

  RulesEngineConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RulesEngineConfig& from);
  void MergeFrom(const RulesEngineConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "RULESENGINECONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // repeated string xmlRules = 2;
  inline int xmlrules_size() const;
  inline void clear_xmlrules();
  static const int kXmlRulesFieldNumber = 2;
  inline const ::std::string& xmlrules(int index) const;
  inline ::std::string* mutable_xmlrules(int index);
  inline void set_xmlrules(int index, const ::std::string& value);
  inline void set_xmlrules(int index, const char* value);
  inline void set_xmlrules(int index, const char* value, size_t size);
  inline ::std::string* add_xmlrules();
  inline void add_xmlrules(const ::std::string& value);
  inline void add_xmlrules(const char* value);
  inline void add_xmlrules(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& xmlrules() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_xmlrules();

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.RulesEngineConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::RepeatedPtrField< ::std::string> xmlrules_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static RulesEngineConfig* default_instance_;
};
// -------------------------------------------------------------------

class DatabaseKeeperConfig : public ::google::protobuf::Message {
 public:
  DatabaseKeeperConfig();
  virtual ~DatabaseKeeperConfig();

  DatabaseKeeperConfig(const DatabaseKeeperConfig& from);

  inline DatabaseKeeperConfig& operator=(const DatabaseKeeperConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DatabaseKeeperConfig& default_instance();

  void Swap(DatabaseKeeperConfig* other);

  // implements Message ----------------------------------------------

  DatabaseKeeperConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DatabaseKeeperConfig& from);
  void MergeFrom(const DatabaseKeeperConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "DATABASEKEEPERCONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 writeInterval = 2 [default = 1];
  inline bool has_writeinterval() const;
  inline void clear_writeinterval();
  static const int kWriteIntervalFieldNumber = 2;
  inline ::google::protobuf::int32 writeinterval() const;
  inline void set_writeinterval(::google::protobuf::int32 value);

  // optional bool disableWrite = 3 [default = false];
  inline bool has_disablewrite() const;
  inline void clear_disablewrite();
  static const int kDisableWriteFieldNumber = 3;
  inline bool disablewrite() const;
  inline void set_disablewrite(bool value);

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.DatabaseKeeperConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_writeinterval();
  inline void clear_has_writeinterval();
  inline void set_has_disablewrite();
  inline void clear_has_disablewrite();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 writeinterval_;
  bool disablewrite_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static DatabaseKeeperConfig* default_instance_;
};
// -------------------------------------------------------------------

class KeplerUIConnectionConfig : public ::google::protobuf::Message {
 public:
  KeplerUIConnectionConfig();
  virtual ~KeplerUIConnectionConfig();

  KeplerUIConnectionConfig(const KeplerUIConnectionConfig& from);

  inline KeplerUIConnectionConfig& operator=(const KeplerUIConnectionConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeplerUIConnectionConfig& default_instance();

  void Swap(KeplerUIConnectionConfig* other);

  // implements Message ----------------------------------------------

  KeplerUIConnectionConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeplerUIConnectionConfig& from);
  void MergeFrom(const KeplerUIConnectionConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "KEPLERUICONNECTIONCONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.KeplerUIConnectionConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static KeplerUIConnectionConfig* default_instance_;
};
// -------------------------------------------------------------------

class SensorStatusConfig : public ::google::protobuf::Message {
 public:
  SensorStatusConfig();
  virtual ~SensorStatusConfig();

  SensorStatusConfig(const SensorStatusConfig& from);

  inline SensorStatusConfig& operator=(const SensorStatusConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorStatusConfig& default_instance();

  void Swap(SensorStatusConfig* other);

  // implements Message ----------------------------------------------

  SensorStatusConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SensorStatusConfig& from);
  void MergeFrom(const SensorStatusConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SENSORSTATUSCONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional float lat = 2;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 2;
  inline float lat() const;
  inline void set_lat(float value);

  // optional float lon = 3;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 3;
  inline float lon() const;
  inline void set_lon(float value);

  // optional float alt = 4;
  inline bool has_alt() const;
  inline void clear_alt();
  static const int kAltFieldNumber = 4;
  inline float alt() const;
  inline void set_alt(float value);

  // optional string siteId = 5;
  inline bool has_siteid() const;
  inline void clear_siteid();
  static const int kSiteIdFieldNumber = 5;
  inline const ::std::string& siteid() const;
  inline void set_siteid(const ::std::string& value);
  inline void set_siteid(const char* value);
  inline void set_siteid(const char* value, size_t size);
  inline ::std::string* mutable_siteid();
  inline ::std::string* release_siteid();
  inline void set_allocated_siteid(::std::string* siteid);

  // optional string sigAd = 6;
  inline bool has_sigad() const;
  inline void clear_sigad();
  static const int kSigAdFieldNumber = 6;
  inline const ::std::string& sigad() const;
  inline void set_sigad(const ::std::string& value);
  inline void set_sigad(const char* value);
  inline void set_sigad(const char* value, size_t size);
  inline ::std::string* mutable_sigad();
  inline ::std::string* release_sigad();
  inline void set_allocated_sigad(::std::string* sigad);

  // optional float elevation = 7;
  inline bool has_elevation() const;
  inline void clear_elevation();
  static const int kElevationFieldNumber = 7;
  inline float elevation() const;
  inline void set_elevation(float value);

  // optional float azimuth = 8;
  inline bool has_azimuth() const;
  inline void clear_azimuth();
  static const int kAzimuthFieldNumber = 8;
  inline float azimuth() const;
  inline void set_azimuth(float value);

  // optional float beamWidth = 9;
  inline bool has_beamwidth() const;
  inline void clear_beamwidth();
  static const int kBeamWidthFieldNumber = 9;
  inline float beamwidth() const;
  inline void set_beamwidth(float value);

  // optional float boreSite = 10;
  inline bool has_boresite() const;
  inline void clear_boresite();
  static const int kBoreSiteFieldNumber = 10;
  inline float boresite() const;
  inline void set_boresite(float value);

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.SensorStatusConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_alt();
  inline void clear_has_alt();
  inline void set_has_siteid();
  inline void clear_has_siteid();
  inline void set_has_sigad();
  inline void clear_has_sigad();
  inline void set_has_elevation();
  inline void clear_has_elevation();
  inline void set_has_azimuth();
  inline void clear_has_azimuth();
  inline void set_has_beamwidth();
  inline void clear_has_beamwidth();
  inline void set_has_boresite();
  inline void clear_has_boresite();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  float lat_;
  float lon_;
  ::std::string* siteid_;
  float alt_;
  float elevation_;
  ::std::string* sigad_;
  float azimuth_;
  float beamwidth_;
  float boresite_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static SensorStatusConfig* default_instance_;
};
// -------------------------------------------------------------------

class GeoTipperConfig : public ::google::protobuf::Message {
 public:
  GeoTipperConfig();
  virtual ~GeoTipperConfig();

  GeoTipperConfig(const GeoTipperConfig& from);

  inline GeoTipperConfig& operator=(const GeoTipperConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GeoTipperConfig& default_instance();

  void Swap(GeoTipperConfig* other);

  // implements Message ----------------------------------------------

  GeoTipperConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GeoTipperConfig& from);
  void MergeFrom(const GeoTipperConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "GEOTIPPERCONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // repeated string sensorName = 2;
  inline int sensorname_size() const;
  inline void clear_sensorname();
  static const int kSensorNameFieldNumber = 2;
  inline const ::std::string& sensorname(int index) const;
  inline ::std::string* mutable_sensorname(int index);
  inline void set_sensorname(int index, const ::std::string& value);
  inline void set_sensorname(int index, const char* value);
  inline void set_sensorname(int index, const char* value, size_t size);
  inline ::std::string* add_sensorname();
  inline void add_sensorname(const ::std::string& value);
  inline void add_sensorname(const char* value);
  inline void add_sensorname(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& sensorname() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_sensorname();

  // optional int64 lookBack = 3 [default = 2];
  inline bool has_lookback() const;
  inline void clear_lookback();
  static const int kLookBackFieldNumber = 3;
  inline ::google::protobuf::int64 lookback() const;
  inline void set_lookback(::google::protobuf::int64 value);

  // optional bool autoAdjust = 4 [default = false];
  inline bool has_autoadjust() const;
  inline void clear_autoadjust();
  static const int kAutoAdjustFieldNumber = 4;
  inline bool autoadjust() const;
  inline void set_autoadjust(bool value);

  // optional int64 queryInterval = 5 [default = 1];
  inline bool has_queryinterval() const;
  inline void clear_queryinterval();
  static const int kQueryIntervalFieldNumber = 5;
  inline ::google::protobuf::int64 queryinterval() const;
  inline void set_queryinterval(::google::protobuf::int64 value);

  // optional int64 tipTimeout = 6 [default = 2];
  inline bool has_tiptimeout() const;
  inline void clear_tiptimeout();
  static const int kTipTimeoutFieldNumber = 6;
  inline ::google::protobuf::int64 tiptimeout() const;
  inline void set_tiptimeout(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.GeoTipperConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_lookback();
  inline void clear_has_lookback();
  inline void set_has_autoadjust();
  inline void clear_has_autoadjust();
  inline void set_has_queryinterval();
  inline void clear_has_queryinterval();
  inline void set_has_tiptimeout();
  inline void clear_has_tiptimeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::RepeatedPtrField< ::std::string> sensorname_;
  ::google::protobuf::int64 lookback_;
  ::google::protobuf::int64 queryinterval_;
  ::google::protobuf::int64 tiptimeout_;
  bool autoadjust_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static GeoTipperConfig* default_instance_;
};
// -------------------------------------------------------------------

class PreDClipperConfig : public ::google::protobuf::Message {
 public:
  PreDClipperConfig();
  virtual ~PreDClipperConfig();

  PreDClipperConfig(const PreDClipperConfig& from);

  inline PreDClipperConfig& operator=(const PreDClipperConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PreDClipperConfig& default_instance();

  void Swap(PreDClipperConfig* other);

  // implements Message ----------------------------------------------

  PreDClipperConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PreDClipperConfig& from);
  void MergeFrom(const PreDClipperConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "PREDCLIPPERCONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string fileHost = 2;
  inline bool has_filehost() const;
  inline void clear_filehost();
  static const int kFileHostFieldNumber = 2;
  inline const ::std::string& filehost() const;
  inline void set_filehost(const ::std::string& value);
  inline void set_filehost(const char* value);
  inline void set_filehost(const char* value, size_t size);
  inline ::std::string* mutable_filehost();
  inline ::std::string* release_filehost();
  inline void set_allocated_filehost(::std::string* filehost);

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.PreDClipperConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_filehost();
  inline void clear_has_filehost();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* filehost_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static PreDClipperConfig* default_instance_;
};
// -------------------------------------------------------------------

class AmplifierConfig : public ::google::protobuf::Message {
 public:
  AmplifierConfig();
  virtual ~AmplifierConfig();

  AmplifierConfig(const AmplifierConfig& from);

  inline AmplifierConfig& operator=(const AmplifierConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AmplifierConfig& default_instance();

  void Swap(AmplifierConfig* other);

  // implements Message ----------------------------------------------

  AmplifierConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AmplifierConfig& from);
  void MergeFrom(const AmplifierConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "AMPLIFIERCONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string ip = 3;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 3;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional int32 port = 4;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 4;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.AmplifierConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* name_;
  ::std::string* ip_;
  ::google::protobuf::int32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static AmplifierConfig* default_instance_;
};
// -------------------------------------------------------------------

class SiggenConfig : public ::google::protobuf::Message {
 public:
  SiggenConfig();
  virtual ~SiggenConfig();

  SiggenConfig(const SiggenConfig& from);

  inline SiggenConfig& operator=(const SiggenConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SiggenConfig& default_instance();

  void Swap(SiggenConfig* other);

  // implements Message ----------------------------------------------

  SiggenConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SiggenConfig& from);
  void MergeFrom(const SiggenConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SIGGENCONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional int32 chan = 3;
  inline bool has_chan() const;
  inline void clear_chan();
  static const int kChanFieldNumber = 3;
  inline ::google::protobuf::int32 chan() const;
  inline void set_chan(::google::protobuf::int32 value);

  // optional string ip = 4;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 4;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional float freqMHz = 5;
  inline bool has_freqmhz() const;
  inline void clear_freqmhz();
  static const int kFreqMHzFieldNumber = 5;
  inline float freqmhz() const;
  inline void set_freqmhz(float value);

  // optional float powerdBm = 6;
  inline bool has_powerdbm() const;
  inline void clear_powerdbm();
  static const int kPowerdBmFieldNumber = 6;
  inline float powerdbm() const;
  inline void set_powerdbm(float value);

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.SiggenConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_chan();
  inline void clear_has_chan();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_freqmhz();
  inline void clear_has_freqmhz();
  inline void set_has_powerdbm();
  inline void clear_has_powerdbm();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* type_;
  ::std::string* ip_;
  ::google::protobuf::int32 chan_;
  float freqmhz_;
  float powerdbm_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static SiggenConfig* default_instance_;
};
// -------------------------------------------------------------------

class CurrPosConfig : public ::google::protobuf::Message {
 public:
  CurrPosConfig();
  virtual ~CurrPosConfig();

  CurrPosConfig(const CurrPosConfig& from);

  inline CurrPosConfig& operator=(const CurrPosConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CurrPosConfig& default_instance();

  void Swap(CurrPosConfig* other);

  // implements Message ----------------------------------------------

  CurrPosConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CurrPosConfig& from);
  void MergeFrom(const CurrPosConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "CURRPOSCONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string hostname = 2;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 2;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional int32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // optional string method = 4;
  inline bool has_method() const;
  inline void clear_method();
  static const int kMethodFieldNumber = 4;
  inline const ::std::string& method() const;
  inline void set_method(const ::std::string& value);
  inline void set_method(const char* value);
  inline void set_method(const char* value, size_t size);
  inline ::std::string* mutable_method();
  inline ::std::string* release_method();
  inline void set_allocated_method(::std::string* method);

  // optional string ins_hostname = 5;
  inline bool has_ins_hostname() const;
  inline void clear_ins_hostname();
  static const int kInsHostnameFieldNumber = 5;
  inline const ::std::string& ins_hostname() const;
  inline void set_ins_hostname(const ::std::string& value);
  inline void set_ins_hostname(const char* value);
  inline void set_ins_hostname(const char* value, size_t size);
  inline ::std::string* mutable_ins_hostname();
  inline ::std::string* release_ins_hostname();
  inline void set_allocated_ins_hostname(::std::string* ins_hostname);

  // optional int32 ins_port = 6;
  inline bool has_ins_port() const;
  inline void clear_ins_port();
  static const int kInsPortFieldNumber = 6;
  inline ::google::protobuf::int32 ins_port() const;
  inline void set_ins_port(::google::protobuf::int32 value);

  // optional bool orientation_enable = 7 [default = false];
  inline bool has_orientation_enable() const;
  inline void clear_orientation_enable();
  static const int kOrientationEnableFieldNumber = 7;
  inline bool orientation_enable() const;
  inline void set_orientation_enable(bool value);

  // optional bool vector_enable = 8 [default = false];
  inline bool has_vector_enable() const;
  inline void clear_vector_enable();
  static const int kVectorEnableFieldNumber = 8;
  inline bool vector_enable() const;
  inline void set_vector_enable(bool value);

  // optional float sim_lat = 9;
  inline bool has_sim_lat() const;
  inline void clear_sim_lat();
  static const int kSimLatFieldNumber = 9;
  inline float sim_lat() const;
  inline void set_sim_lat(float value);

  // optional float sim_lon = 10;
  inline bool has_sim_lon() const;
  inline void clear_sim_lon();
  static const int kSimLonFieldNumber = 10;
  inline float sim_lon() const;
  inline void set_sim_lon(float value);

  // optional float sim_alt = 11;
  inline bool has_sim_alt() const;
  inline void clear_sim_alt();
  static const int kSimAltFieldNumber = 11;
  inline float sim_alt() const;
  inline void set_sim_alt(float value);

  // @@protoc_insertion_point(class_scope:falcon_svc_msg.CurrPosConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_method();
  inline void clear_has_method();
  inline void set_has_ins_hostname();
  inline void clear_has_ins_hostname();
  inline void set_has_ins_port();
  inline void clear_has_ins_port();
  inline void set_has_orientation_enable();
  inline void clear_has_orientation_enable();
  inline void set_has_vector_enable();
  inline void clear_has_vector_enable();
  inline void set_has_sim_lat();
  inline void clear_has_sim_lat();
  inline void set_has_sim_lon();
  inline void clear_has_sim_lon();
  inline void set_has_sim_alt();
  inline void clear_has_sim_alt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* hostname_;
  ::std::string* method_;
  ::google::protobuf::int32 port_;
  ::google::protobuf::int32 ins_port_;
  ::std::string* ins_hostname_;
  bool orientation_enable_;
  bool vector_enable_;
  float sim_lat_;
  float sim_lon_;
  float sim_alt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_FalconServiceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconServiceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconServiceMessages_2eproto();

  void InitAsDefaultInstance();
  static CurrPosConfig* default_instance_;
};
// ===================================================================


// ===================================================================

// CharManConfig

// optional string msgName = 1 [default = "CHAR_MAN_CONFIG"];
inline bool CharManConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CharManConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CharManConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CharManConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& CharManConfig::msgname() const {
  return *msgname_;
}
inline void CharManConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void CharManConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void CharManConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CharManConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* CharManConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void CharManConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 xtalkPort = 2 [default = 32222];
inline bool CharManConfig::has_xtalkport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CharManConfig::set_has_xtalkport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CharManConfig::clear_has_xtalkport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CharManConfig::clear_xtalkport() {
  xtalkport_ = 32222;
  clear_has_xtalkport();
}
inline ::google::protobuf::int32 CharManConfig::xtalkport() const {
  return xtalkport_;
}
inline void CharManConfig::set_xtalkport(::google::protobuf::int32 value) {
  set_has_xtalkport();
  xtalkport_ = value;
}

// optional int32 snapExtraCount = 3 [default = 1];
inline bool CharManConfig::has_snapextracount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CharManConfig::set_has_snapextracount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CharManConfig::clear_has_snapextracount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CharManConfig::clear_snapextracount() {
  snapextracount_ = 1;
  clear_has_snapextracount();
}
inline ::google::protobuf::int32 CharManConfig::snapextracount() const {
  return snapextracount_;
}
inline void CharManConfig::set_snapextracount(::google::protobuf::int32 value) {
  set_has_snapextracount();
  snapextracount_ = value;
}

// optional int32 snapExtraMin = 4;
inline bool CharManConfig::has_snapextramin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CharManConfig::set_has_snapextramin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CharManConfig::clear_has_snapextramin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CharManConfig::clear_snapextramin() {
  snapextramin_ = 0;
  clear_has_snapextramin();
}
inline ::google::protobuf::int32 CharManConfig::snapextramin() const {
  return snapextramin_;
}
inline void CharManConfig::set_snapextramin(::google::protobuf::int32 value) {
  set_has_snapextramin();
  snapextramin_ = value;
}

// optional string snapExtraConfig = 5 [default = "/user/config/snap_extra.cfg"];
inline bool CharManConfig::has_snapextraconfig() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CharManConfig::set_has_snapextraconfig() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CharManConfig::clear_has_snapextraconfig() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CharManConfig::clear_snapextraconfig() {
  if (snapextraconfig_ != _default_snapextraconfig_) {
    snapextraconfig_->assign(*_default_snapextraconfig_);
  }
  clear_has_snapextraconfig();
}
inline const ::std::string& CharManConfig::snapextraconfig() const {
  return *snapextraconfig_;
}
inline void CharManConfig::set_snapextraconfig(const ::std::string& value) {
  set_has_snapextraconfig();
  if (snapextraconfig_ == _default_snapextraconfig_) {
    snapextraconfig_ = new ::std::string;
  }
  snapextraconfig_->assign(value);
}
inline void CharManConfig::set_snapextraconfig(const char* value) {
  set_has_snapextraconfig();
  if (snapextraconfig_ == _default_snapextraconfig_) {
    snapextraconfig_ = new ::std::string;
  }
  snapextraconfig_->assign(value);
}
inline void CharManConfig::set_snapextraconfig(const char* value, size_t size) {
  set_has_snapextraconfig();
  if (snapextraconfig_ == _default_snapextraconfig_) {
    snapextraconfig_ = new ::std::string;
  }
  snapextraconfig_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CharManConfig::mutable_snapextraconfig() {
  set_has_snapextraconfig();
  if (snapextraconfig_ == _default_snapextraconfig_) {
    snapextraconfig_ = new ::std::string(*_default_snapextraconfig_);
  }
  return snapextraconfig_;
}
inline ::std::string* CharManConfig::release_snapextraconfig() {
  clear_has_snapextraconfig();
  if (snapextraconfig_ == _default_snapextraconfig_) {
    return NULL;
  } else {
    ::std::string* temp = snapextraconfig_;
    snapextraconfig_ = const_cast< ::std::string*>(_default_snapextraconfig_);
    return temp;
  }
}
inline void CharManConfig::set_allocated_snapextraconfig(::std::string* snapextraconfig) {
  if (snapextraconfig_ != _default_snapextraconfig_) {
    delete snapextraconfig_;
  }
  if (snapextraconfig) {
    set_has_snapextraconfig();
    snapextraconfig_ = snapextraconfig;
  } else {
    clear_has_snapextraconfig();
    snapextraconfig_ = const_cast< ::std::string*>(_default_snapextraconfig_);
  }
}

// optional bool snapExtraDynamic = 6;
inline bool CharManConfig::has_snapextradynamic() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CharManConfig::set_has_snapextradynamic() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CharManConfig::clear_has_snapextradynamic() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CharManConfig::clear_snapextradynamic() {
  snapextradynamic_ = false;
  clear_has_snapextradynamic();
}
inline bool CharManConfig::snapextradynamic() const {
  return snapextradynamic_;
}
inline void CharManConfig::set_snapextradynamic(bool value) {
  set_has_snapextradynamic();
  snapextradynamic_ = value;
}

// optional bool sepriopt = 7;
inline bool CharManConfig::has_sepriopt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CharManConfig::set_has_sepriopt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CharManConfig::clear_has_sepriopt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CharManConfig::clear_sepriopt() {
  sepriopt_ = false;
  clear_has_sepriopt();
}
inline bool CharManConfig::sepriopt() const {
  return sepriopt_;
}
inline void CharManConfig::set_sepriopt(bool value) {
  set_has_sepriopt();
  sepriopt_ = value;
}

// optional int32 sr_to = 8;
inline bool CharManConfig::has_sr_to() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CharManConfig::set_has_sr_to() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CharManConfig::clear_has_sr_to() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CharManConfig::clear_sr_to() {
  sr_to_ = 0;
  clear_has_sr_to();
}
inline ::google::protobuf::int32 CharManConfig::sr_to() const {
  return sr_to_;
}
inline void CharManConfig::set_sr_to(::google::protobuf::int32 value) {
  set_has_sr_to();
  sr_to_ = value;
}

// optional string outputPath = 9 [default = "19"];
inline bool CharManConfig::has_outputpath() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CharManConfig::set_has_outputpath() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CharManConfig::clear_has_outputpath() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CharManConfig::clear_outputpath() {
  if (outputpath_ != _default_outputpath_) {
    outputpath_->assign(*_default_outputpath_);
  }
  clear_has_outputpath();
}
inline const ::std::string& CharManConfig::outputpath() const {
  return *outputpath_;
}
inline void CharManConfig::set_outputpath(const ::std::string& value) {
  set_has_outputpath();
  if (outputpath_ == _default_outputpath_) {
    outputpath_ = new ::std::string;
  }
  outputpath_->assign(value);
}
inline void CharManConfig::set_outputpath(const char* value) {
  set_has_outputpath();
  if (outputpath_ == _default_outputpath_) {
    outputpath_ = new ::std::string;
  }
  outputpath_->assign(value);
}
inline void CharManConfig::set_outputpath(const char* value, size_t size) {
  set_has_outputpath();
  if (outputpath_ == _default_outputpath_) {
    outputpath_ = new ::std::string;
  }
  outputpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CharManConfig::mutable_outputpath() {
  set_has_outputpath();
  if (outputpath_ == _default_outputpath_) {
    outputpath_ = new ::std::string(*_default_outputpath_);
  }
  return outputpath_;
}
inline ::std::string* CharManConfig::release_outputpath() {
  clear_has_outputpath();
  if (outputpath_ == _default_outputpath_) {
    return NULL;
  } else {
    ::std::string* temp = outputpath_;
    outputpath_ = const_cast< ::std::string*>(_default_outputpath_);
    return temp;
  }
}
inline void CharManConfig::set_allocated_outputpath(::std::string* outputpath) {
  if (outputpath_ != _default_outputpath_) {
    delete outputpath_;
  }
  if (outputpath) {
    set_has_outputpath();
    outputpath_ = outputpath;
  } else {
    clear_has_outputpath();
    outputpath_ = const_cast< ::std::string*>(_default_outputpath_);
  }
}

// optional int32 esiCount = 10 [default = 6];
inline bool CharManConfig::has_esicount() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CharManConfig::set_has_esicount() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CharManConfig::clear_has_esicount() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CharManConfig::clear_esicount() {
  esicount_ = 6;
  clear_has_esicount();
}
inline ::google::protobuf::int32 CharManConfig::esicount() const {
  return esicount_;
}
inline void CharManConfig::set_esicount(::google::protobuf::int32 value) {
  set_has_esicount();
  esicount_ = value;
}

// optional string esiLogPath = 11;
inline bool CharManConfig::has_esilogpath() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CharManConfig::set_has_esilogpath() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CharManConfig::clear_has_esilogpath() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CharManConfig::clear_esilogpath() {
  if (esilogpath_ != &::google::protobuf::internal::kEmptyString) {
    esilogpath_->clear();
  }
  clear_has_esilogpath();
}
inline const ::std::string& CharManConfig::esilogpath() const {
  return *esilogpath_;
}
inline void CharManConfig::set_esilogpath(const ::std::string& value) {
  set_has_esilogpath();
  if (esilogpath_ == &::google::protobuf::internal::kEmptyString) {
    esilogpath_ = new ::std::string;
  }
  esilogpath_->assign(value);
}
inline void CharManConfig::set_esilogpath(const char* value) {
  set_has_esilogpath();
  if (esilogpath_ == &::google::protobuf::internal::kEmptyString) {
    esilogpath_ = new ::std::string;
  }
  esilogpath_->assign(value);
}
inline void CharManConfig::set_esilogpath(const char* value, size_t size) {
  set_has_esilogpath();
  if (esilogpath_ == &::google::protobuf::internal::kEmptyString) {
    esilogpath_ = new ::std::string;
  }
  esilogpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CharManConfig::mutable_esilogpath() {
  set_has_esilogpath();
  if (esilogpath_ == &::google::protobuf::internal::kEmptyString) {
    esilogpath_ = new ::std::string;
  }
  return esilogpath_;
}
inline ::std::string* CharManConfig::release_esilogpath() {
  clear_has_esilogpath();
  if (esilogpath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = esilogpath_;
    esilogpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CharManConfig::set_allocated_esilogpath(::std::string* esilogpath) {
  if (esilogpath_ != &::google::protobuf::internal::kEmptyString) {
    delete esilogpath_;
  }
  if (esilogpath) {
    set_has_esilogpath();
    esilogpath_ = esilogpath;
  } else {
    clear_has_esilogpath();
    esilogpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 videoRateFFTSize = 12 [default = 131072];
inline bool CharManConfig::has_videoratefftsize() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CharManConfig::set_has_videoratefftsize() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CharManConfig::clear_has_videoratefftsize() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CharManConfig::clear_videoratefftsize() {
  videoratefftsize_ = 131072;
  clear_has_videoratefftsize();
}
inline ::google::protobuf::int32 CharManConfig::videoratefftsize() const {
  return videoratefftsize_;
}
inline void CharManConfig::set_videoratefftsize(::google::protobuf::int32 value) {
  set_has_videoratefftsize();
  videoratefftsize_ = value;
}

// optional float videoRateDCHz = 13 [default = 100];
inline bool CharManConfig::has_videoratedchz() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CharManConfig::set_has_videoratedchz() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CharManConfig::clear_has_videoratedchz() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CharManConfig::clear_videoratedchz() {
  videoratedchz_ = 100;
  clear_has_videoratedchz();
}
inline float CharManConfig::videoratedchz() const {
  return videoratedchz_;
}
inline void CharManConfig::set_videoratedchz(float value) {
  set_has_videoratedchz();
  videoratedchz_ = value;
}

// optional int32 videoRateMaxFFT = 14 [default = 64];
inline bool CharManConfig::has_videoratemaxfft() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CharManConfig::set_has_videoratemaxfft() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CharManConfig::clear_has_videoratemaxfft() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CharManConfig::clear_videoratemaxfft() {
  videoratemaxfft_ = 64;
  clear_has_videoratemaxfft();
}
inline ::google::protobuf::int32 CharManConfig::videoratemaxfft() const {
  return videoratemaxfft_;
}
inline void CharManConfig::set_videoratemaxfft(::google::protobuf::int32 value) {
  set_has_videoratemaxfft();
  videoratemaxfft_ = value;
}

// optional float videoRateThresh = 15 [default = 1.5];
inline bool CharManConfig::has_videoratethresh() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CharManConfig::set_has_videoratethresh() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CharManConfig::clear_has_videoratethresh() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CharManConfig::clear_videoratethresh() {
  videoratethresh_ = 1.5f;
  clear_has_videoratethresh();
}
inline float CharManConfig::videoratethresh() const {
  return videoratethresh_;
}
inline void CharManConfig::set_videoratethresh(float value) {
  set_has_videoratethresh();
  videoratethresh_ = value;
}

// optional float videoSyncThresh = 16 [default = 2.5];
inline bool CharManConfig::has_videosyncthresh() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CharManConfig::set_has_videosyncthresh() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CharManConfig::clear_has_videosyncthresh() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CharManConfig::clear_videosyncthresh() {
  videosyncthresh_ = 2.5f;
  clear_has_videosyncthresh();
}
inline float CharManConfig::videosyncthresh() const {
  return videosyncthresh_;
}
inline void CharManConfig::set_videosyncthresh(float value) {
  set_has_videosyncthresh();
  videosyncthresh_ = value;
}

// optional string rlVersion = 17 [default = "NORMAL"];
inline bool CharManConfig::has_rlversion() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CharManConfig::set_has_rlversion() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CharManConfig::clear_has_rlversion() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CharManConfig::clear_rlversion() {
  if (rlversion_ != _default_rlversion_) {
    rlversion_->assign(*_default_rlversion_);
  }
  clear_has_rlversion();
}
inline const ::std::string& CharManConfig::rlversion() const {
  return *rlversion_;
}
inline void CharManConfig::set_rlversion(const ::std::string& value) {
  set_has_rlversion();
  if (rlversion_ == _default_rlversion_) {
    rlversion_ = new ::std::string;
  }
  rlversion_->assign(value);
}
inline void CharManConfig::set_rlversion(const char* value) {
  set_has_rlversion();
  if (rlversion_ == _default_rlversion_) {
    rlversion_ = new ::std::string;
  }
  rlversion_->assign(value);
}
inline void CharManConfig::set_rlversion(const char* value, size_t size) {
  set_has_rlversion();
  if (rlversion_ == _default_rlversion_) {
    rlversion_ = new ::std::string;
  }
  rlversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CharManConfig::mutable_rlversion() {
  set_has_rlversion();
  if (rlversion_ == _default_rlversion_) {
    rlversion_ = new ::std::string(*_default_rlversion_);
  }
  return rlversion_;
}
inline ::std::string* CharManConfig::release_rlversion() {
  clear_has_rlversion();
  if (rlversion_ == _default_rlversion_) {
    return NULL;
  } else {
    ::std::string* temp = rlversion_;
    rlversion_ = const_cast< ::std::string*>(_default_rlversion_);
    return temp;
  }
}
inline void CharManConfig::set_allocated_rlversion(::std::string* rlversion) {
  if (rlversion_ != _default_rlversion_) {
    delete rlversion_;
  }
  if (rlversion) {
    set_has_rlversion();
    rlversion_ = rlversion;
  } else {
    clear_has_rlversion();
    rlversion_ = const_cast< ::std::string*>(_default_rlversion_);
  }
}

// optional bool rlDedup = 18 [default = true];
inline bool CharManConfig::has_rldedup() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CharManConfig::set_has_rldedup() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CharManConfig::clear_has_rldedup() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CharManConfig::clear_rldedup() {
  rldedup_ = true;
  clear_has_rldedup();
}
inline bool CharManConfig::rldedup() const {
  return rldedup_;
}
inline void CharManConfig::set_rldedup(bool value) {
  set_has_rldedup();
  rldedup_ = value;
}

// optional int32 energyNcoh = 19 [default = 20];
inline bool CharManConfig::has_energyncoh() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CharManConfig::set_has_energyncoh() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CharManConfig::clear_has_energyncoh() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CharManConfig::clear_energyncoh() {
  energyncoh_ = 20;
  clear_has_energyncoh();
}
inline ::google::protobuf::int32 CharManConfig::energyncoh() const {
  return energyncoh_;
}
inline void CharManConfig::set_energyncoh(::google::protobuf::int32 value) {
  set_has_energyncoh();
  energyncoh_ = value;
}

// optional int32 energyNnoncoh = 20 [default = 100];
inline bool CharManConfig::has_energynnoncoh() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CharManConfig::set_has_energynnoncoh() {
  _has_bits_[0] |= 0x00080000u;
}
inline void CharManConfig::clear_has_energynnoncoh() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void CharManConfig::clear_energynnoncoh() {
  energynnoncoh_ = 100;
  clear_has_energynnoncoh();
}
inline ::google::protobuf::int32 CharManConfig::energynnoncoh() const {
  return energynnoncoh_;
}
inline void CharManConfig::set_energynnoncoh(::google::protobuf::int32 value) {
  set_has_energynnoncoh();
  energynnoncoh_ = value;
}

// optional float energyThreshold = 21 [default = 0];
inline bool CharManConfig::has_energythreshold() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void CharManConfig::set_has_energythreshold() {
  _has_bits_[0] |= 0x00100000u;
}
inline void CharManConfig::clear_has_energythreshold() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void CharManConfig::clear_energythreshold() {
  energythreshold_ = 0;
  clear_has_energythreshold();
}
inline float CharManConfig::energythreshold() const {
  return energythreshold_;
}
inline void CharManConfig::set_energythreshold(float value) {
  set_has_energythreshold();
  energythreshold_ = value;
}

// optional int32 energyNon = 22 [default = 2];
inline bool CharManConfig::has_energynon() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void CharManConfig::set_has_energynon() {
  _has_bits_[0] |= 0x00200000u;
}
inline void CharManConfig::clear_has_energynon() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void CharManConfig::clear_energynon() {
  energynon_ = 2;
  clear_has_energynon();
}
inline ::google::protobuf::int32 CharManConfig::energynon() const {
  return energynon_;
}
inline void CharManConfig::set_energynon(::google::protobuf::int32 value) {
  set_has_energynon();
  energynon_ = value;
}

// optional int32 energyNoff = 23 [default = 2];
inline bool CharManConfig::has_energynoff() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void CharManConfig::set_has_energynoff() {
  _has_bits_[0] |= 0x00400000u;
}
inline void CharManConfig::clear_has_energynoff() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void CharManConfig::clear_energynoff() {
  energynoff_ = 2;
  clear_has_energynoff();
}
inline ::google::protobuf::int32 CharManConfig::energynoff() const {
  return energynoff_;
}
inline void CharManConfig::set_energynoff(::google::protobuf::int32 value) {
  set_has_energynoff();
  energynoff_ = value;
}

// optional float energyBW = 24 [default = 20000];
inline bool CharManConfig::has_energybw() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void CharManConfig::set_has_energybw() {
  _has_bits_[0] |= 0x00800000u;
}
inline void CharManConfig::clear_has_energybw() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void CharManConfig::clear_energybw() {
  energybw_ = 20000;
  clear_has_energybw();
}
inline float CharManConfig::energybw() const {
  return energybw_;
}
inline void CharManConfig::set_energybw(float value) {
  set_has_energybw();
  energybw_ = value;
}

// optional float ofdmthresh = 25 [default = 5];
inline bool CharManConfig::has_ofdmthresh() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void CharManConfig::set_has_ofdmthresh() {
  _has_bits_[0] |= 0x01000000u;
}
inline void CharManConfig::clear_has_ofdmthresh() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void CharManConfig::clear_ofdmthresh() {
  ofdmthresh_ = 5;
  clear_has_ofdmthresh();
}
inline float CharManConfig::ofdmthresh() const {
  return ofdmthresh_;
}
inline void CharManConfig::set_ofdmthresh(float value) {
  set_has_ofdmthresh();
  ofdmthresh_ = value;
}

// optional float priThreshold = 26 [default = 11];
inline bool CharManConfig::has_prithreshold() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void CharManConfig::set_has_prithreshold() {
  _has_bits_[0] |= 0x02000000u;
}
inline void CharManConfig::clear_has_prithreshold() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void CharManConfig::clear_prithreshold() {
  prithreshold_ = 11;
  clear_has_prithreshold();
}
inline float CharManConfig::prithreshold() const {
  return prithreshold_;
}
inline void CharManConfig::set_prithreshold(float value) {
  set_has_prithreshold();
  prithreshold_ = value;
}

// repeated string snapExtraTargets = 27;
inline int CharManConfig::snapextratargets_size() const {
  return snapextratargets_.size();
}
inline void CharManConfig::clear_snapextratargets() {
  snapextratargets_.Clear();
}
inline const ::std::string& CharManConfig::snapextratargets(int index) const {
  return snapextratargets_.Get(index);
}
inline ::std::string* CharManConfig::mutable_snapextratargets(int index) {
  return snapextratargets_.Mutable(index);
}
inline void CharManConfig::set_snapextratargets(int index, const ::std::string& value) {
  snapextratargets_.Mutable(index)->assign(value);
}
inline void CharManConfig::set_snapextratargets(int index, const char* value) {
  snapextratargets_.Mutable(index)->assign(value);
}
inline void CharManConfig::set_snapextratargets(int index, const char* value, size_t size) {
  snapextratargets_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CharManConfig::add_snapextratargets() {
  return snapextratargets_.Add();
}
inline void CharManConfig::add_snapextratargets(const ::std::string& value) {
  snapextratargets_.Add()->assign(value);
}
inline void CharManConfig::add_snapextratargets(const char* value) {
  snapextratargets_.Add()->assign(value);
}
inline void CharManConfig::add_snapextratargets(const char* value, size_t size) {
  snapextratargets_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CharManConfig::snapextratargets() const {
  return snapextratargets_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CharManConfig::mutable_snapextratargets() {
  return &snapextratargets_;
}

// optional string esiModulations = 28;
inline bool CharManConfig::has_esimodulations() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void CharManConfig::set_has_esimodulations() {
  _has_bits_[0] |= 0x08000000u;
}
inline void CharManConfig::clear_has_esimodulations() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void CharManConfig::clear_esimodulations() {
  if (esimodulations_ != &::google::protobuf::internal::kEmptyString) {
    esimodulations_->clear();
  }
  clear_has_esimodulations();
}
inline const ::std::string& CharManConfig::esimodulations() const {
  return *esimodulations_;
}
inline void CharManConfig::set_esimodulations(const ::std::string& value) {
  set_has_esimodulations();
  if (esimodulations_ == &::google::protobuf::internal::kEmptyString) {
    esimodulations_ = new ::std::string;
  }
  esimodulations_->assign(value);
}
inline void CharManConfig::set_esimodulations(const char* value) {
  set_has_esimodulations();
  if (esimodulations_ == &::google::protobuf::internal::kEmptyString) {
    esimodulations_ = new ::std::string;
  }
  esimodulations_->assign(value);
}
inline void CharManConfig::set_esimodulations(const char* value, size_t size) {
  set_has_esimodulations();
  if (esimodulations_ == &::google::protobuf::internal::kEmptyString) {
    esimodulations_ = new ::std::string;
  }
  esimodulations_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CharManConfig::mutable_esimodulations() {
  set_has_esimodulations();
  if (esimodulations_ == &::google::protobuf::internal::kEmptyString) {
    esimodulations_ = new ::std::string;
  }
  return esimodulations_;
}
inline ::std::string* CharManConfig::release_esimodulations() {
  clear_has_esimodulations();
  if (esimodulations_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = esimodulations_;
    esimodulations_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CharManConfig::set_allocated_esimodulations(::std::string* esimodulations) {
  if (esimodulations_ != &::google::protobuf::internal::kEmptyString) {
    delete esimodulations_;
  }
  if (esimodulations) {
    set_has_esimodulations();
    esimodulations_ = esimodulations;
  } else {
    clear_has_esimodulations();
    esimodulations_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string esiWritePath = 29 [default = ""];
inline bool CharManConfig::has_esiwritepath() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void CharManConfig::set_has_esiwritepath() {
  _has_bits_[0] |= 0x10000000u;
}
inline void CharManConfig::clear_has_esiwritepath() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void CharManConfig::clear_esiwritepath() {
  if (esiwritepath_ != &::google::protobuf::internal::kEmptyString) {
    esiwritepath_->clear();
  }
  clear_has_esiwritepath();
}
inline const ::std::string& CharManConfig::esiwritepath() const {
  return *esiwritepath_;
}
inline void CharManConfig::set_esiwritepath(const ::std::string& value) {
  set_has_esiwritepath();
  if (esiwritepath_ == &::google::protobuf::internal::kEmptyString) {
    esiwritepath_ = new ::std::string;
  }
  esiwritepath_->assign(value);
}
inline void CharManConfig::set_esiwritepath(const char* value) {
  set_has_esiwritepath();
  if (esiwritepath_ == &::google::protobuf::internal::kEmptyString) {
    esiwritepath_ = new ::std::string;
  }
  esiwritepath_->assign(value);
}
inline void CharManConfig::set_esiwritepath(const char* value, size_t size) {
  set_has_esiwritepath();
  if (esiwritepath_ == &::google::protobuf::internal::kEmptyString) {
    esiwritepath_ = new ::std::string;
  }
  esiwritepath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CharManConfig::mutable_esiwritepath() {
  set_has_esiwritepath();
  if (esiwritepath_ == &::google::protobuf::internal::kEmptyString) {
    esiwritepath_ = new ::std::string;
  }
  return esiwritepath_;
}
inline ::std::string* CharManConfig::release_esiwritepath() {
  clear_has_esiwritepath();
  if (esiwritepath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = esiwritepath_;
    esiwritepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CharManConfig::set_allocated_esiwritepath(::std::string* esiwritepath) {
  if (esiwritepath_ != &::google::protobuf::internal::kEmptyString) {
    delete esiwritepath_;
  }
  if (esiwritepath) {
    set_has_esiwritepath();
    esiwritepath_ = esiwritepath;
  } else {
    clear_has_esiwritepath();
    esiwritepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string edWritePath = 30 [default = ""];
inline bool CharManConfig::has_edwritepath() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void CharManConfig::set_has_edwritepath() {
  _has_bits_[0] |= 0x20000000u;
}
inline void CharManConfig::clear_has_edwritepath() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void CharManConfig::clear_edwritepath() {
  if (edwritepath_ != &::google::protobuf::internal::kEmptyString) {
    edwritepath_->clear();
  }
  clear_has_edwritepath();
}
inline const ::std::string& CharManConfig::edwritepath() const {
  return *edwritepath_;
}
inline void CharManConfig::set_edwritepath(const ::std::string& value) {
  set_has_edwritepath();
  if (edwritepath_ == &::google::protobuf::internal::kEmptyString) {
    edwritepath_ = new ::std::string;
  }
  edwritepath_->assign(value);
}
inline void CharManConfig::set_edwritepath(const char* value) {
  set_has_edwritepath();
  if (edwritepath_ == &::google::protobuf::internal::kEmptyString) {
    edwritepath_ = new ::std::string;
  }
  edwritepath_->assign(value);
}
inline void CharManConfig::set_edwritepath(const char* value, size_t size) {
  set_has_edwritepath();
  if (edwritepath_ == &::google::protobuf::internal::kEmptyString) {
    edwritepath_ = new ::std::string;
  }
  edwritepath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CharManConfig::mutable_edwritepath() {
  set_has_edwritepath();
  if (edwritepath_ == &::google::protobuf::internal::kEmptyString) {
    edwritepath_ = new ::std::string;
  }
  return edwritepath_;
}
inline ::std::string* CharManConfig::release_edwritepath() {
  clear_has_edwritepath();
  if (edwritepath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = edwritepath_;
    edwritepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CharManConfig::set_allocated_edwritepath(::std::string* edwritepath) {
  if (edwritepath_ != &::google::protobuf::internal::kEmptyString) {
    delete edwritepath_;
  }
  if (edwritepath) {
    set_has_edwritepath();
    edwritepath_ = edwritepath;
  } else {
    clear_has_edwritepath();
    edwritepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string edLogPath = 31 [default = ""];
inline bool CharManConfig::has_edlogpath() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void CharManConfig::set_has_edlogpath() {
  _has_bits_[0] |= 0x40000000u;
}
inline void CharManConfig::clear_has_edlogpath() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void CharManConfig::clear_edlogpath() {
  if (edlogpath_ != &::google::protobuf::internal::kEmptyString) {
    edlogpath_->clear();
  }
  clear_has_edlogpath();
}
inline const ::std::string& CharManConfig::edlogpath() const {
  return *edlogpath_;
}
inline void CharManConfig::set_edlogpath(const ::std::string& value) {
  set_has_edlogpath();
  if (edlogpath_ == &::google::protobuf::internal::kEmptyString) {
    edlogpath_ = new ::std::string;
  }
  edlogpath_->assign(value);
}
inline void CharManConfig::set_edlogpath(const char* value) {
  set_has_edlogpath();
  if (edlogpath_ == &::google::protobuf::internal::kEmptyString) {
    edlogpath_ = new ::std::string;
  }
  edlogpath_->assign(value);
}
inline void CharManConfig::set_edlogpath(const char* value, size_t size) {
  set_has_edlogpath();
  if (edlogpath_ == &::google::protobuf::internal::kEmptyString) {
    edlogpath_ = new ::std::string;
  }
  edlogpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CharManConfig::mutable_edlogpath() {
  set_has_edlogpath();
  if (edlogpath_ == &::google::protobuf::internal::kEmptyString) {
    edlogpath_ = new ::std::string;
  }
  return edlogpath_;
}
inline ::std::string* CharManConfig::release_edlogpath() {
  clear_has_edlogpath();
  if (edlogpath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = edlogpath_;
    edlogpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CharManConfig::set_allocated_edlogpath(::std::string* edlogpath) {
  if (edlogpath_ != &::google::protobuf::internal::kEmptyString) {
    delete edlogpath_;
  }
  if (edlogpath) {
    set_has_edlogpath();
    edlogpath_ = edlogpath;
  } else {
    clear_has_edlogpath();
    edlogpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 edCount = 32 [default = 6];
inline bool CharManConfig::has_edcount() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void CharManConfig::set_has_edcount() {
  _has_bits_[0] |= 0x80000000u;
}
inline void CharManConfig::clear_has_edcount() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void CharManConfig::clear_edcount() {
  edcount_ = 6;
  clear_has_edcount();
}
inline ::google::protobuf::int32 CharManConfig::edcount() const {
  return edcount_;
}
inline void CharManConfig::set_edcount(::google::protobuf::int32 value) {
  set_has_edcount();
  edcount_ = value;
}

// optional int32 edThreshdB = 33;
inline bool CharManConfig::has_edthreshdb() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void CharManConfig::set_has_edthreshdb() {
  _has_bits_[1] |= 0x00000001u;
}
inline void CharManConfig::clear_has_edthreshdb() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void CharManConfig::clear_edthreshdb() {
  edthreshdb_ = 0;
  clear_has_edthreshdb();
}
inline ::google::protobuf::int32 CharManConfig::edthreshdb() const {
  return edthreshdb_;
}
inline void CharManConfig::set_edthreshdb(::google::protobuf::int32 value) {
  set_has_edthreshdb();
  edthreshdb_ = value;
}

// optional int32 edSpAvg = 34 [default = 50];
inline bool CharManConfig::has_edspavg() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void CharManConfig::set_has_edspavg() {
  _has_bits_[1] |= 0x00000002u;
}
inline void CharManConfig::clear_has_edspavg() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void CharManConfig::clear_edspavg() {
  edspavg_ = 50;
  clear_has_edspavg();
}
inline ::google::protobuf::int32 CharManConfig::edspavg() const {
  return edspavg_;
}
inline void CharManConfig::set_edspavg(::google::protobuf::int32 value) {
  set_has_edspavg();
  edspavg_ = value;
}

// optional int32 edFFTSize = 35 [default = 8192];
inline bool CharManConfig::has_edfftsize() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void CharManConfig::set_has_edfftsize() {
  _has_bits_[1] |= 0x00000004u;
}
inline void CharManConfig::clear_has_edfftsize() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void CharManConfig::clear_edfftsize() {
  edfftsize_ = 8192;
  clear_has_edfftsize();
}
inline ::google::protobuf::int32 CharManConfig::edfftsize() const {
  return edfftsize_;
}
inline void CharManConfig::set_edfftsize(::google::protobuf::int32 value) {
  set_has_edfftsize();
  edfftsize_ = value;
}

// optional int32 edDetBW = 36;
inline bool CharManConfig::has_eddetbw() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void CharManConfig::set_has_eddetbw() {
  _has_bits_[1] |= 0x00000008u;
}
inline void CharManConfig::clear_has_eddetbw() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void CharManConfig::clear_eddetbw() {
  eddetbw_ = 0;
  clear_has_eddetbw();
}
inline ::google::protobuf::int32 CharManConfig::eddetbw() const {
  return eddetbw_;
}
inline void CharManConfig::set_eddetbw(::google::protobuf::int32 value) {
  set_has_eddetbw();
  eddetbw_ = value;
}

// optional int32 edMinDetBW = 37 [default = 8000];
inline bool CharManConfig::has_edmindetbw() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void CharManConfig::set_has_edmindetbw() {
  _has_bits_[1] |= 0x00000010u;
}
inline void CharManConfig::clear_has_edmindetbw() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void CharManConfig::clear_edmindetbw() {
  edmindetbw_ = 8000;
  clear_has_edmindetbw();
}
inline ::google::protobuf::int32 CharManConfig::edmindetbw() const {
  return edmindetbw_;
}
inline void CharManConfig::set_edmindetbw(::google::protobuf::int32 value) {
  set_has_edmindetbw();
  edmindetbw_ = value;
}

// optional int32 edGuardBW = 38 [default = 0];
inline bool CharManConfig::has_edguardbw() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void CharManConfig::set_has_edguardbw() {
  _has_bits_[1] |= 0x00000020u;
}
inline void CharManConfig::clear_has_edguardbw() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void CharManConfig::clear_edguardbw() {
  edguardbw_ = 0;
  clear_has_edguardbw();
}
inline ::google::protobuf::int32 CharManConfig::edguardbw() const {
  return edguardbw_;
}
inline void CharManConfig::set_edguardbw(::google::protobuf::int32 value) {
  set_has_edguardbw();
  edguardbw_ = value;
}

// optional int32 edMinUpTime = 39;
inline bool CharManConfig::has_edminuptime() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void CharManConfig::set_has_edminuptime() {
  _has_bits_[1] |= 0x00000040u;
}
inline void CharManConfig::clear_has_edminuptime() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void CharManConfig::clear_edminuptime() {
  edminuptime_ = 0;
  clear_has_edminuptime();
}
inline ::google::protobuf::int32 CharManConfig::edminuptime() const {
  return edminuptime_;
}
inline void CharManConfig::set_edminuptime(::google::protobuf::int32 value) {
  set_has_edminuptime();
  edminuptime_ = value;
}

// optional int32 edMinDownTime = 40;
inline bool CharManConfig::has_edmindowntime() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void CharManConfig::set_has_edmindowntime() {
  _has_bits_[1] |= 0x00000080u;
}
inline void CharManConfig::clear_has_edmindowntime() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void CharManConfig::clear_edmindowntime() {
  edmindowntime_ = 0;
  clear_has_edmindowntime();
}
inline ::google::protobuf::int32 CharManConfig::edmindowntime() const {
  return edmindowntime_;
}
inline void CharManConfig::set_edmindowntime(::google::protobuf::int32 value) {
  set_has_edmindowntime();
  edmindowntime_ = value;
}

// optional float edOverlapTh = 41 [default = 0.5];
inline bool CharManConfig::has_edoverlapth() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void CharManConfig::set_has_edoverlapth() {
  _has_bits_[1] |= 0x00000100u;
}
inline void CharManConfig::clear_has_edoverlapth() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void CharManConfig::clear_edoverlapth() {
  edoverlapth_ = 0.5f;
  clear_has_edoverlapth();
}
inline float CharManConfig::edoverlapth() const {
  return edoverlapth_;
}
inline void CharManConfig::set_edoverlapth(float value) {
  set_has_edoverlapth();
  edoverlapth_ = value;
}

// optional bool streamFiles = 42 [default = false];
inline bool CharManConfig::has_streamfiles() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void CharManConfig::set_has_streamfiles() {
  _has_bits_[1] |= 0x00000200u;
}
inline void CharManConfig::clear_has_streamfiles() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void CharManConfig::clear_streamfiles() {
  streamfiles_ = false;
  clear_has_streamfiles();
}
inline bool CharManConfig::streamfiles() const {
  return streamfiles_;
}
inline void CharManConfig::set_streamfiles(bool value) {
  set_has_streamfiles();
  streamfiles_ = value;
}

// optional string brainFile = 43;
inline bool CharManConfig::has_brainfile() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void CharManConfig::set_has_brainfile() {
  _has_bits_[1] |= 0x00000400u;
}
inline void CharManConfig::clear_has_brainfile() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void CharManConfig::clear_brainfile() {
  if (brainfile_ != &::google::protobuf::internal::kEmptyString) {
    brainfile_->clear();
  }
  clear_has_brainfile();
}
inline const ::std::string& CharManConfig::brainfile() const {
  return *brainfile_;
}
inline void CharManConfig::set_brainfile(const ::std::string& value) {
  set_has_brainfile();
  if (brainfile_ == &::google::protobuf::internal::kEmptyString) {
    brainfile_ = new ::std::string;
  }
  brainfile_->assign(value);
}
inline void CharManConfig::set_brainfile(const char* value) {
  set_has_brainfile();
  if (brainfile_ == &::google::protobuf::internal::kEmptyString) {
    brainfile_ = new ::std::string;
  }
  brainfile_->assign(value);
}
inline void CharManConfig::set_brainfile(const char* value, size_t size) {
  set_has_brainfile();
  if (brainfile_ == &::google::protobuf::internal::kEmptyString) {
    brainfile_ = new ::std::string;
  }
  brainfile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CharManConfig::mutable_brainfile() {
  set_has_brainfile();
  if (brainfile_ == &::google::protobuf::internal::kEmptyString) {
    brainfile_ = new ::std::string;
  }
  return brainfile_;
}
inline ::std::string* CharManConfig::release_brainfile() {
  clear_has_brainfile();
  if (brainfile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brainfile_;
    brainfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CharManConfig::set_allocated_brainfile(::std::string* brainfile) {
  if (brainfile_ != &::google::protobuf::internal::kEmptyString) {
    delete brainfile_;
  }
  if (brainfile) {
    set_has_brainfile();
    brainfile_ = brainfile;
  } else {
    clear_has_brainfile();
    brainfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MacroOptions

// optional .falcon_svc_msg.MacroOptions.AutoControl autoControl = 1;
inline bool MacroOptions::has_autocontrol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MacroOptions::set_has_autocontrol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MacroOptions::clear_has_autocontrol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MacroOptions::clear_autocontrol() {
  autocontrol_ = 0;
  clear_has_autocontrol();
}
inline ::falcon_svc_msg::MacroOptions_AutoControl MacroOptions::autocontrol() const {
  return static_cast< ::falcon_svc_msg::MacroOptions_AutoControl >(autocontrol_);
}
inline void MacroOptions::set_autocontrol(::falcon_svc_msg::MacroOptions_AutoControl value) {
  assert(::falcon_svc_msg::MacroOptions_AutoControl_IsValid(value));
  set_has_autocontrol();
  autocontrol_ = value;
}

// optional .falcon_svc_msg.MacroOptions.PPS ppsEnable = 2 [default = PPS_OFF];
inline bool MacroOptions::has_ppsenable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MacroOptions::set_has_ppsenable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MacroOptions::clear_has_ppsenable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MacroOptions::clear_ppsenable() {
  ppsenable_ = 0;
  clear_has_ppsenable();
}
inline ::falcon_svc_msg::MacroOptions_PPS MacroOptions::ppsenable() const {
  return static_cast< ::falcon_svc_msg::MacroOptions_PPS >(ppsenable_);
}
inline void MacroOptions::set_ppsenable(::falcon_svc_msg::MacroOptions_PPS value) {
  assert(::falcon_svc_msg::MacroOptions_PPS_IsValid(value));
  set_has_ppsenable();
  ppsenable_ = value;
}

// optional .falcon_svc_msg.MacroOptions.Ref10m refEnable = 3 [default = REF_OFF];
inline bool MacroOptions::has_refenable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MacroOptions::set_has_refenable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MacroOptions::clear_has_refenable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MacroOptions::clear_refenable() {
  refenable_ = 0;
  clear_has_refenable();
}
inline ::falcon_svc_msg::MacroOptions_Ref10m MacroOptions::refenable() const {
  return static_cast< ::falcon_svc_msg::MacroOptions_Ref10m >(refenable_);
}
inline void MacroOptions::set_refenable(::falcon_svc_msg::MacroOptions_Ref10m value) {
  assert(::falcon_svc_msg::MacroOptions_Ref10m_IsValid(value));
  set_has_refenable();
  refenable_ = value;
}

// optional double ifFrequency = 4 [default = 30000000];
inline bool MacroOptions::has_iffrequency() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MacroOptions::set_has_iffrequency() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MacroOptions::clear_has_iffrequency() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MacroOptions::clear_iffrequency() {
  iffrequency_ = 30000000;
  clear_has_iffrequency();
}
inline double MacroOptions::iffrequency() const {
  return iffrequency_;
}
inline void MacroOptions::set_iffrequency(double value) {
  set_has_iffrequency();
  iffrequency_ = value;
}

// optional int32 writeAux = 5 [default = 12];
inline bool MacroOptions::has_writeaux() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MacroOptions::set_has_writeaux() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MacroOptions::clear_has_writeaux() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MacroOptions::clear_writeaux() {
  writeaux_ = 12;
  clear_has_writeaux();
}
inline ::google::protobuf::int32 MacroOptions::writeaux() const {
  return writeaux_;
}
inline void MacroOptions::set_writeaux(::google::protobuf::int32 value) {
  set_has_writeaux();
  writeaux_ = value;
}

// optional int32 exportEnable = 6 [default = 0];
inline bool MacroOptions::has_exportenable() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MacroOptions::set_has_exportenable() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MacroOptions::clear_has_exportenable() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MacroOptions::clear_exportenable() {
  exportenable_ = 0;
  clear_has_exportenable();
}
inline ::google::protobuf::int32 MacroOptions::exportenable() const {
  return exportenable_;
}
inline void MacroOptions::set_exportenable(::google::protobuf::int32 value) {
  set_has_exportenable();
  exportenable_ = value;
}

// optional int32 videoLength = 7 [default = 20];
inline bool MacroOptions::has_videolength() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MacroOptions::set_has_videolength() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MacroOptions::clear_has_videolength() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MacroOptions::clear_videolength() {
  videolength_ = 20;
  clear_has_videolength();
}
inline ::google::protobuf::int32 MacroOptions::videolength() const {
  return videolength_;
}
inline void MacroOptions::set_videolength(::google::protobuf::int32 value) {
  set_has_videolength();
  videolength_ = value;
}

// optional string sensorName = 8 [default = "sensor"];
inline bool MacroOptions::has_sensorname() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MacroOptions::set_has_sensorname() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MacroOptions::clear_has_sensorname() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MacroOptions::clear_sensorname() {
  if (sensorname_ != _default_sensorname_) {
    sensorname_->assign(*_default_sensorname_);
  }
  clear_has_sensorname();
}
inline const ::std::string& MacroOptions::sensorname() const {
  return *sensorname_;
}
inline void MacroOptions::set_sensorname(const ::std::string& value) {
  set_has_sensorname();
  if (sensorname_ == _default_sensorname_) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void MacroOptions::set_sensorname(const char* value) {
  set_has_sensorname();
  if (sensorname_ == _default_sensorname_) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void MacroOptions::set_sensorname(const char* value, size_t size) {
  set_has_sensorname();
  if (sensorname_ == _default_sensorname_) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MacroOptions::mutable_sensorname() {
  set_has_sensorname();
  if (sensorname_ == _default_sensorname_) {
    sensorname_ = new ::std::string(*_default_sensorname_);
  }
  return sensorname_;
}
inline ::std::string* MacroOptions::release_sensorname() {
  clear_has_sensorname();
  if (sensorname_ == _default_sensorname_) {
    return NULL;
  } else {
    ::std::string* temp = sensorname_;
    sensorname_ = const_cast< ::std::string*>(_default_sensorname_);
    return temp;
  }
}
inline void MacroOptions::set_allocated_sensorname(::std::string* sensorname) {
  if (sensorname_ != _default_sensorname_) {
    delete sensorname_;
  }
  if (sensorname) {
    set_has_sensorname();
    sensorname_ = sensorname;
  } else {
    clear_has_sensorname();
    sensorname_ = const_cast< ::std::string*>(_default_sensorname_);
  }
}

// optional string psdIPAddress = 9 [default = ""];
inline bool MacroOptions::has_psdipaddress() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MacroOptions::set_has_psdipaddress() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MacroOptions::clear_has_psdipaddress() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MacroOptions::clear_psdipaddress() {
  if (psdipaddress_ != &::google::protobuf::internal::kEmptyString) {
    psdipaddress_->clear();
  }
  clear_has_psdipaddress();
}
inline const ::std::string& MacroOptions::psdipaddress() const {
  return *psdipaddress_;
}
inline void MacroOptions::set_psdipaddress(const ::std::string& value) {
  set_has_psdipaddress();
  if (psdipaddress_ == &::google::protobuf::internal::kEmptyString) {
    psdipaddress_ = new ::std::string;
  }
  psdipaddress_->assign(value);
}
inline void MacroOptions::set_psdipaddress(const char* value) {
  set_has_psdipaddress();
  if (psdipaddress_ == &::google::protobuf::internal::kEmptyString) {
    psdipaddress_ = new ::std::string;
  }
  psdipaddress_->assign(value);
}
inline void MacroOptions::set_psdipaddress(const char* value, size_t size) {
  set_has_psdipaddress();
  if (psdipaddress_ == &::google::protobuf::internal::kEmptyString) {
    psdipaddress_ = new ::std::string;
  }
  psdipaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MacroOptions::mutable_psdipaddress() {
  set_has_psdipaddress();
  if (psdipaddress_ == &::google::protobuf::internal::kEmptyString) {
    psdipaddress_ = new ::std::string;
  }
  return psdipaddress_;
}
inline ::std::string* MacroOptions::release_psdipaddress() {
  clear_has_psdipaddress();
  if (psdipaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = psdipaddress_;
    psdipaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MacroOptions::set_allocated_psdipaddress(::std::string* psdipaddress) {
  if (psdipaddress_ != &::google::protobuf::internal::kEmptyString) {
    delete psdipaddress_;
  }
  if (psdipaddress) {
    set_has_psdipaddress();
    psdipaddress_ = psdipaddress;
  } else {
    clear_has_psdipaddress();
    psdipaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 psdPeriod = 10 [default = 200];
inline bool MacroOptions::has_psdperiod() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MacroOptions::set_has_psdperiod() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MacroOptions::clear_has_psdperiod() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MacroOptions::clear_psdperiod() {
  psdperiod_ = 200;
  clear_has_psdperiod();
}
inline ::google::protobuf::int32 MacroOptions::psdperiod() const {
  return psdperiod_;
}
inline void MacroOptions::set_psdperiod(::google::protobuf::int32 value) {
  set_has_psdperiod();
  psdperiod_ = value;
}

// optional int32 jpegPeriod = 11 [default = 50];
inline bool MacroOptions::has_jpegperiod() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MacroOptions::set_has_jpegperiod() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MacroOptions::clear_has_jpegperiod() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MacroOptions::clear_jpegperiod() {
  jpegperiod_ = 50;
  clear_has_jpegperiod();
}
inline ::google::protobuf::int32 MacroOptions::jpegperiod() const {
  return jpegperiod_;
}
inline void MacroOptions::set_jpegperiod(::google::protobuf::int32 value) {
  set_has_jpegperiod();
  jpegperiod_ = value;
}

// optional int32 xmlPeriod = 12 [default = 5];
inline bool MacroOptions::has_xmlperiod() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MacroOptions::set_has_xmlperiod() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MacroOptions::clear_has_xmlperiod() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MacroOptions::clear_xmlperiod() {
  xmlperiod_ = 5;
  clear_has_xmlperiod();
}
inline ::google::protobuf::int32 MacroOptions::xmlperiod() const {
  return xmlperiod_;
}
inline void MacroOptions::set_xmlperiod(::google::protobuf::int32 value) {
  set_has_xmlperiod();
  xmlperiod_ = value;
}

// optional int32 protectArch = 13 [default = 0];
inline bool MacroOptions::has_protectarch() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MacroOptions::set_has_protectarch() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MacroOptions::clear_has_protectarch() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MacroOptions::clear_protectarch() {
  protectarch_ = 0;
  clear_has_protectarch();
}
inline ::google::protobuf::int32 MacroOptions::protectarch() const {
  return protectarch_;
}
inline void MacroOptions::set_protectarch(::google::protobuf::int32 value) {
  set_has_protectarch();
  protectarch_ = value;
}

// optional bool midasBundling = 14 [default = false];
inline bool MacroOptions::has_midasbundling() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MacroOptions::set_has_midasbundling() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MacroOptions::clear_has_midasbundling() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MacroOptions::clear_midasbundling() {
  midasbundling_ = false;
  clear_has_midasbundling();
}
inline bool MacroOptions::midasbundling() const {
  return midasbundling_;
}
inline void MacroOptions::set_midasbundling(bool value) {
  set_has_midasbundling();
  midasbundling_ = value;
}

// optional int32 remoteThresh = 15 [default = 10];
inline bool MacroOptions::has_remotethresh() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MacroOptions::set_has_remotethresh() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MacroOptions::clear_has_remotethresh() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MacroOptions::clear_remotethresh() {
  remotethresh_ = 10;
  clear_has_remotethresh();
}
inline ::google::protobuf::int32 MacroOptions::remotethresh() const {
  return remotethresh_;
}
inline void MacroOptions::set_remotethresh(::google::protobuf::int32 value) {
  set_has_remotethresh();
  remotethresh_ = value;
}

// -------------------------------------------------------------------

// FalconVisionConfig

// optional string msgName = 1 [default = "FALCON_VISION_CONFIG"];
inline bool FalconVisionConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FalconVisionConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FalconVisionConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FalconVisionConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& FalconVisionConfig::msgname() const {
  return *msgname_;
}
inline void FalconVisionConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void FalconVisionConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void FalconVisionConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FalconVisionConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* FalconVisionConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void FalconVisionConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 readPort = 2;
inline bool FalconVisionConfig::has_readport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FalconVisionConfig::set_has_readport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FalconVisionConfig::clear_has_readport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FalconVisionConfig::clear_readport() {
  readport_ = 0;
  clear_has_readport();
}
inline ::google::protobuf::int32 FalconVisionConfig::readport() const {
  return readport_;
}
inline void FalconVisionConfig::set_readport(::google::protobuf::int32 value) {
  set_has_readport();
  readport_ = value;
}

// optional int32 writePort = 3;
inline bool FalconVisionConfig::has_writeport() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FalconVisionConfig::set_has_writeport() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FalconVisionConfig::clear_has_writeport() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FalconVisionConfig::clear_writeport() {
  writeport_ = 0;
  clear_has_writeport();
}
inline ::google::protobuf::int32 FalconVisionConfig::writeport() const {
  return writeport_;
}
inline void FalconVisionConfig::set_writeport(::google::protobuf::int32 value) {
  set_has_writeport();
  writeport_ = value;
}

// optional int32 msgBufLen = 4;
inline bool FalconVisionConfig::has_msgbuflen() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FalconVisionConfig::set_has_msgbuflen() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FalconVisionConfig::clear_has_msgbuflen() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FalconVisionConfig::clear_msgbuflen() {
  msgbuflen_ = 0;
  clear_has_msgbuflen();
}
inline ::google::protobuf::int32 FalconVisionConfig::msgbuflen() const {
  return msgbuflen_;
}
inline void FalconVisionConfig::set_msgbuflen(::google::protobuf::int32 value) {
  set_has_msgbuflen();
  msgbuflen_ = value;
}

// optional bool xmlEnable = 5;
inline bool FalconVisionConfig::has_xmlenable() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FalconVisionConfig::set_has_xmlenable() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FalconVisionConfig::clear_has_xmlenable() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FalconVisionConfig::clear_xmlenable() {
  xmlenable_ = false;
  clear_has_xmlenable();
}
inline bool FalconVisionConfig::xmlenable() const {
  return xmlenable_;
}
inline void FalconVisionConfig::set_xmlenable(bool value) {
  set_has_xmlenable();
  xmlenable_ = value;
}

// optional string xmlClass = 6;
inline bool FalconVisionConfig::has_xmlclass() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FalconVisionConfig::set_has_xmlclass() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FalconVisionConfig::clear_has_xmlclass() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FalconVisionConfig::clear_xmlclass() {
  if (xmlclass_ != &::google::protobuf::internal::kEmptyString) {
    xmlclass_->clear();
  }
  clear_has_xmlclass();
}
inline const ::std::string& FalconVisionConfig::xmlclass() const {
  return *xmlclass_;
}
inline void FalconVisionConfig::set_xmlclass(const ::std::string& value) {
  set_has_xmlclass();
  if (xmlclass_ == &::google::protobuf::internal::kEmptyString) {
    xmlclass_ = new ::std::string;
  }
  xmlclass_->assign(value);
}
inline void FalconVisionConfig::set_xmlclass(const char* value) {
  set_has_xmlclass();
  if (xmlclass_ == &::google::protobuf::internal::kEmptyString) {
    xmlclass_ = new ::std::string;
  }
  xmlclass_->assign(value);
}
inline void FalconVisionConfig::set_xmlclass(const char* value, size_t size) {
  set_has_xmlclass();
  if (xmlclass_ == &::google::protobuf::internal::kEmptyString) {
    xmlclass_ = new ::std::string;
  }
  xmlclass_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FalconVisionConfig::mutable_xmlclass() {
  set_has_xmlclass();
  if (xmlclass_ == &::google::protobuf::internal::kEmptyString) {
    xmlclass_ = new ::std::string;
  }
  return xmlclass_;
}
inline ::std::string* FalconVisionConfig::release_xmlclass() {
  clear_has_xmlclass();
  if (xmlclass_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = xmlclass_;
    xmlclass_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FalconVisionConfig::set_allocated_xmlclass(::std::string* xmlclass) {
  if (xmlclass_ != &::google::protobuf::internal::kEmptyString) {
    delete xmlclass_;
  }
  if (xmlclass) {
    set_has_xmlclass();
    xmlclass_ = xmlclass;
  } else {
    clear_has_xmlclass();
    xmlclass_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string xmlSource = 7;
inline bool FalconVisionConfig::has_xmlsource() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FalconVisionConfig::set_has_xmlsource() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FalconVisionConfig::clear_has_xmlsource() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FalconVisionConfig::clear_xmlsource() {
  if (xmlsource_ != &::google::protobuf::internal::kEmptyString) {
    xmlsource_->clear();
  }
  clear_has_xmlsource();
}
inline const ::std::string& FalconVisionConfig::xmlsource() const {
  return *xmlsource_;
}
inline void FalconVisionConfig::set_xmlsource(const ::std::string& value) {
  set_has_xmlsource();
  if (xmlsource_ == &::google::protobuf::internal::kEmptyString) {
    xmlsource_ = new ::std::string;
  }
  xmlsource_->assign(value);
}
inline void FalconVisionConfig::set_xmlsource(const char* value) {
  set_has_xmlsource();
  if (xmlsource_ == &::google::protobuf::internal::kEmptyString) {
    xmlsource_ = new ::std::string;
  }
  xmlsource_->assign(value);
}
inline void FalconVisionConfig::set_xmlsource(const char* value, size_t size) {
  set_has_xmlsource();
  if (xmlsource_ == &::google::protobuf::internal::kEmptyString) {
    xmlsource_ = new ::std::string;
  }
  xmlsource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FalconVisionConfig::mutable_xmlsource() {
  set_has_xmlsource();
  if (xmlsource_ == &::google::protobuf::internal::kEmptyString) {
    xmlsource_ = new ::std::string;
  }
  return xmlsource_;
}
inline ::std::string* FalconVisionConfig::release_xmlsource() {
  clear_has_xmlsource();
  if (xmlsource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = xmlsource_;
    xmlsource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FalconVisionConfig::set_allocated_xmlsource(::std::string* xmlsource) {
  if (xmlsource_ != &::google::protobuf::internal::kEmptyString) {
    delete xmlsource_;
  }
  if (xmlsource) {
    set_has_xmlsource();
    xmlsource_ = xmlsource;
  } else {
    clear_has_xmlsource();
    xmlsource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string xmlPath = 8;
inline bool FalconVisionConfig::has_xmlpath() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FalconVisionConfig::set_has_xmlpath() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FalconVisionConfig::clear_has_xmlpath() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FalconVisionConfig::clear_xmlpath() {
  if (xmlpath_ != &::google::protobuf::internal::kEmptyString) {
    xmlpath_->clear();
  }
  clear_has_xmlpath();
}
inline const ::std::string& FalconVisionConfig::xmlpath() const {
  return *xmlpath_;
}
inline void FalconVisionConfig::set_xmlpath(const ::std::string& value) {
  set_has_xmlpath();
  if (xmlpath_ == &::google::protobuf::internal::kEmptyString) {
    xmlpath_ = new ::std::string;
  }
  xmlpath_->assign(value);
}
inline void FalconVisionConfig::set_xmlpath(const char* value) {
  set_has_xmlpath();
  if (xmlpath_ == &::google::protobuf::internal::kEmptyString) {
    xmlpath_ = new ::std::string;
  }
  xmlpath_->assign(value);
}
inline void FalconVisionConfig::set_xmlpath(const char* value, size_t size) {
  set_has_xmlpath();
  if (xmlpath_ == &::google::protobuf::internal::kEmptyString) {
    xmlpath_ = new ::std::string;
  }
  xmlpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FalconVisionConfig::mutable_xmlpath() {
  set_has_xmlpath();
  if (xmlpath_ == &::google::protobuf::internal::kEmptyString) {
    xmlpath_ = new ::std::string;
  }
  return xmlpath_;
}
inline ::std::string* FalconVisionConfig::release_xmlpath() {
  clear_has_xmlpath();
  if (xmlpath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = xmlpath_;
    xmlpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FalconVisionConfig::set_allocated_xmlpath(::std::string* xmlpath) {
  if (xmlpath_ != &::google::protobuf::internal::kEmptyString) {
    delete xmlpath_;
  }
  if (xmlpath) {
    set_has_xmlpath();
    xmlpath_ = xmlpath;
  } else {
    clear_has_xmlpath();
    xmlpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string xmlWorkstation = 9;
inline bool FalconVisionConfig::has_xmlworkstation() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FalconVisionConfig::set_has_xmlworkstation() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FalconVisionConfig::clear_has_xmlworkstation() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FalconVisionConfig::clear_xmlworkstation() {
  if (xmlworkstation_ != &::google::protobuf::internal::kEmptyString) {
    xmlworkstation_->clear();
  }
  clear_has_xmlworkstation();
}
inline const ::std::string& FalconVisionConfig::xmlworkstation() const {
  return *xmlworkstation_;
}
inline void FalconVisionConfig::set_xmlworkstation(const ::std::string& value) {
  set_has_xmlworkstation();
  if (xmlworkstation_ == &::google::protobuf::internal::kEmptyString) {
    xmlworkstation_ = new ::std::string;
  }
  xmlworkstation_->assign(value);
}
inline void FalconVisionConfig::set_xmlworkstation(const char* value) {
  set_has_xmlworkstation();
  if (xmlworkstation_ == &::google::protobuf::internal::kEmptyString) {
    xmlworkstation_ = new ::std::string;
  }
  xmlworkstation_->assign(value);
}
inline void FalconVisionConfig::set_xmlworkstation(const char* value, size_t size) {
  set_has_xmlworkstation();
  if (xmlworkstation_ == &::google::protobuf::internal::kEmptyString) {
    xmlworkstation_ = new ::std::string;
  }
  xmlworkstation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FalconVisionConfig::mutable_xmlworkstation() {
  set_has_xmlworkstation();
  if (xmlworkstation_ == &::google::protobuf::internal::kEmptyString) {
    xmlworkstation_ = new ::std::string;
  }
  return xmlworkstation_;
}
inline ::std::string* FalconVisionConfig::release_xmlworkstation() {
  clear_has_xmlworkstation();
  if (xmlworkstation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = xmlworkstation_;
    xmlworkstation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FalconVisionConfig::set_allocated_xmlworkstation(::std::string* xmlworkstation) {
  if (xmlworkstation_ != &::google::protobuf::internal::kEmptyString) {
    delete xmlworkstation_;
  }
  if (xmlworkstation) {
    set_has_xmlworkstation();
    xmlworkstation_ = xmlworkstation;
  } else {
    clear_has_xmlworkstation();
    xmlworkstation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 xmlPeriod = 10;
inline bool FalconVisionConfig::has_xmlperiod() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FalconVisionConfig::set_has_xmlperiod() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FalconVisionConfig::clear_has_xmlperiod() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FalconVisionConfig::clear_xmlperiod() {
  xmlperiod_ = 0;
  clear_has_xmlperiod();
}
inline ::google::protobuf::int32 FalconVisionConfig::xmlperiod() const {
  return xmlperiod_;
}
inline void FalconVisionConfig::set_xmlperiod(::google::protobuf::int32 value) {
  set_has_xmlperiod();
  xmlperiod_ = value;
}

// optional string workstationWhitelist = 11;
inline bool FalconVisionConfig::has_workstationwhitelist() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void FalconVisionConfig::set_has_workstationwhitelist() {
  _has_bits_[0] |= 0x00000400u;
}
inline void FalconVisionConfig::clear_has_workstationwhitelist() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void FalconVisionConfig::clear_workstationwhitelist() {
  if (workstationwhitelist_ != &::google::protobuf::internal::kEmptyString) {
    workstationwhitelist_->clear();
  }
  clear_has_workstationwhitelist();
}
inline const ::std::string& FalconVisionConfig::workstationwhitelist() const {
  return *workstationwhitelist_;
}
inline void FalconVisionConfig::set_workstationwhitelist(const ::std::string& value) {
  set_has_workstationwhitelist();
  if (workstationwhitelist_ == &::google::protobuf::internal::kEmptyString) {
    workstationwhitelist_ = new ::std::string;
  }
  workstationwhitelist_->assign(value);
}
inline void FalconVisionConfig::set_workstationwhitelist(const char* value) {
  set_has_workstationwhitelist();
  if (workstationwhitelist_ == &::google::protobuf::internal::kEmptyString) {
    workstationwhitelist_ = new ::std::string;
  }
  workstationwhitelist_->assign(value);
}
inline void FalconVisionConfig::set_workstationwhitelist(const char* value, size_t size) {
  set_has_workstationwhitelist();
  if (workstationwhitelist_ == &::google::protobuf::internal::kEmptyString) {
    workstationwhitelist_ = new ::std::string;
  }
  workstationwhitelist_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FalconVisionConfig::mutable_workstationwhitelist() {
  set_has_workstationwhitelist();
  if (workstationwhitelist_ == &::google::protobuf::internal::kEmptyString) {
    workstationwhitelist_ = new ::std::string;
  }
  return workstationwhitelist_;
}
inline ::std::string* FalconVisionConfig::release_workstationwhitelist() {
  clear_has_workstationwhitelist();
  if (workstationwhitelist_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = workstationwhitelist_;
    workstationwhitelist_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FalconVisionConfig::set_allocated_workstationwhitelist(::std::string* workstationwhitelist) {
  if (workstationwhitelist_ != &::google::protobuf::internal::kEmptyString) {
    delete workstationwhitelist_;
  }
  if (workstationwhitelist) {
    set_has_workstationwhitelist();
    workstationwhitelist_ = workstationwhitelist;
  } else {
    clear_has_workstationwhitelist();
    workstationwhitelist_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GSLManagerConfig

// optional string msgName = 1 [default = "GSL_MANAGER_CONFIG"];
inline bool GSLManagerConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GSLManagerConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GSLManagerConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GSLManagerConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& GSLManagerConfig::msgname() const {
  return *msgname_;
}
inline void GSLManagerConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GSLManagerConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GSLManagerConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GSLManagerConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* GSLManagerConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void GSLManagerConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string dbname = 2;
inline bool GSLManagerConfig::has_dbname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GSLManagerConfig::set_has_dbname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GSLManagerConfig::clear_has_dbname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GSLManagerConfig::clear_dbname() {
  if (dbname_ != &::google::protobuf::internal::kEmptyString) {
    dbname_->clear();
  }
  clear_has_dbname();
}
inline const ::std::string& GSLManagerConfig::dbname() const {
  return *dbname_;
}
inline void GSLManagerConfig::set_dbname(const ::std::string& value) {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    dbname_ = new ::std::string;
  }
  dbname_->assign(value);
}
inline void GSLManagerConfig::set_dbname(const char* value) {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    dbname_ = new ::std::string;
  }
  dbname_->assign(value);
}
inline void GSLManagerConfig::set_dbname(const char* value, size_t size) {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    dbname_ = new ::std::string;
  }
  dbname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GSLManagerConfig::mutable_dbname() {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    dbname_ = new ::std::string;
  }
  return dbname_;
}
inline ::std::string* GSLManagerConfig::release_dbname() {
  clear_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dbname_;
    dbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GSLManagerConfig::set_allocated_dbname(::std::string* dbname) {
  if (dbname_ != &::google::protobuf::internal::kEmptyString) {
    delete dbname_;
  }
  if (dbname) {
    set_has_dbname();
    dbname_ = dbname;
  } else {
    clear_has_dbname();
    dbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dbuser = 3;
inline bool GSLManagerConfig::has_dbuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GSLManagerConfig::set_has_dbuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GSLManagerConfig::clear_has_dbuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GSLManagerConfig::clear_dbuser() {
  if (dbuser_ != &::google::protobuf::internal::kEmptyString) {
    dbuser_->clear();
  }
  clear_has_dbuser();
}
inline const ::std::string& GSLManagerConfig::dbuser() const {
  return *dbuser_;
}
inline void GSLManagerConfig::set_dbuser(const ::std::string& value) {
  set_has_dbuser();
  if (dbuser_ == &::google::protobuf::internal::kEmptyString) {
    dbuser_ = new ::std::string;
  }
  dbuser_->assign(value);
}
inline void GSLManagerConfig::set_dbuser(const char* value) {
  set_has_dbuser();
  if (dbuser_ == &::google::protobuf::internal::kEmptyString) {
    dbuser_ = new ::std::string;
  }
  dbuser_->assign(value);
}
inline void GSLManagerConfig::set_dbuser(const char* value, size_t size) {
  set_has_dbuser();
  if (dbuser_ == &::google::protobuf::internal::kEmptyString) {
    dbuser_ = new ::std::string;
  }
  dbuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GSLManagerConfig::mutable_dbuser() {
  set_has_dbuser();
  if (dbuser_ == &::google::protobuf::internal::kEmptyString) {
    dbuser_ = new ::std::string;
  }
  return dbuser_;
}
inline ::std::string* GSLManagerConfig::release_dbuser() {
  clear_has_dbuser();
  if (dbuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dbuser_;
    dbuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GSLManagerConfig::set_allocated_dbuser(::std::string* dbuser) {
  if (dbuser_ != &::google::protobuf::internal::kEmptyString) {
    delete dbuser_;
  }
  if (dbuser) {
    set_has_dbuser();
    dbuser_ = dbuser;
  } else {
    clear_has_dbuser();
    dbuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dbhost = 4;
inline bool GSLManagerConfig::has_dbhost() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GSLManagerConfig::set_has_dbhost() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GSLManagerConfig::clear_has_dbhost() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GSLManagerConfig::clear_dbhost() {
  if (dbhost_ != &::google::protobuf::internal::kEmptyString) {
    dbhost_->clear();
  }
  clear_has_dbhost();
}
inline const ::std::string& GSLManagerConfig::dbhost() const {
  return *dbhost_;
}
inline void GSLManagerConfig::set_dbhost(const ::std::string& value) {
  set_has_dbhost();
  if (dbhost_ == &::google::protobuf::internal::kEmptyString) {
    dbhost_ = new ::std::string;
  }
  dbhost_->assign(value);
}
inline void GSLManagerConfig::set_dbhost(const char* value) {
  set_has_dbhost();
  if (dbhost_ == &::google::protobuf::internal::kEmptyString) {
    dbhost_ = new ::std::string;
  }
  dbhost_->assign(value);
}
inline void GSLManagerConfig::set_dbhost(const char* value, size_t size) {
  set_has_dbhost();
  if (dbhost_ == &::google::protobuf::internal::kEmptyString) {
    dbhost_ = new ::std::string;
  }
  dbhost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GSLManagerConfig::mutable_dbhost() {
  set_has_dbhost();
  if (dbhost_ == &::google::protobuf::internal::kEmptyString) {
    dbhost_ = new ::std::string;
  }
  return dbhost_;
}
inline ::std::string* GSLManagerConfig::release_dbhost() {
  clear_has_dbhost();
  if (dbhost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dbhost_;
    dbhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GSLManagerConfig::set_allocated_dbhost(::std::string* dbhost) {
  if (dbhost_ != &::google::protobuf::internal::kEmptyString) {
    delete dbhost_;
  }
  if (dbhost) {
    set_has_dbhost();
    dbhost_ = dbhost;
  } else {
    clear_has_dbhost();
    dbhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 globalSignalTimeout = 5;
inline bool GSLManagerConfig::has_globalsignaltimeout() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GSLManagerConfig::set_has_globalsignaltimeout() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GSLManagerConfig::clear_has_globalsignaltimeout() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GSLManagerConfig::clear_globalsignaltimeout() {
  globalsignaltimeout_ = 0;
  clear_has_globalsignaltimeout();
}
inline ::google::protobuf::int32 GSLManagerConfig::globalsignaltimeout() const {
  return globalsignaltimeout_;
}
inline void GSLManagerConfig::set_globalsignaltimeout(::google::protobuf::int32 value) {
  set_has_globalsignaltimeout();
  globalsignaltimeout_ = value;
}

// -------------------------------------------------------------------

// ExtraForkConfig

// optional string msgName = 1 [default = "EXTRA_FORK_CONFIG"];
inline bool ExtraForkConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExtraForkConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExtraForkConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExtraForkConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ExtraForkConfig::msgname() const {
  return *msgname_;
}
inline void ExtraForkConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ExtraForkConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ExtraForkConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExtraForkConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ExtraForkConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ExtraForkConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// repeated .falcon_common_msg.ExtraForkChannel channels = 2;
inline int ExtraForkConfig::channels_size() const {
  return channels_.size();
}
inline void ExtraForkConfig::clear_channels() {
  channels_.Clear();
}
inline const ::falcon_common_msg::ExtraForkChannel& ExtraForkConfig::channels(int index) const {
  return channels_.Get(index);
}
inline ::falcon_common_msg::ExtraForkChannel* ExtraForkConfig::mutable_channels(int index) {
  return channels_.Mutable(index);
}
inline ::falcon_common_msg::ExtraForkChannel* ExtraForkConfig::add_channels() {
  return channels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::ExtraForkChannel >&
ExtraForkConfig::channels() const {
  return channels_;
}
inline ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::ExtraForkChannel >*
ExtraForkConfig::mutable_channels() {
  return &channels_;
}

// -------------------------------------------------------------------

// GPSMonitorConfig

// optional string msgName = 1 [default = "GPS_MONITOR_CONFIG"];
inline bool GPSMonitorConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPSMonitorConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPSMonitorConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPSMonitorConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& GPSMonitorConfig::msgname() const {
  return *msgname_;
}
inline void GPSMonitorConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GPSMonitorConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GPSMonitorConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSMonitorConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* GPSMonitorConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void GPSMonitorConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string gpsServer = 2 [default = "OFF"];
inline bool GPSMonitorConfig::has_gpsserver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GPSMonitorConfig::set_has_gpsserver() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GPSMonitorConfig::clear_has_gpsserver() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GPSMonitorConfig::clear_gpsserver() {
  if (gpsserver_ != _default_gpsserver_) {
    gpsserver_->assign(*_default_gpsserver_);
  }
  clear_has_gpsserver();
}
inline const ::std::string& GPSMonitorConfig::gpsserver() const {
  return *gpsserver_;
}
inline void GPSMonitorConfig::set_gpsserver(const ::std::string& value) {
  set_has_gpsserver();
  if (gpsserver_ == _default_gpsserver_) {
    gpsserver_ = new ::std::string;
  }
  gpsserver_->assign(value);
}
inline void GPSMonitorConfig::set_gpsserver(const char* value) {
  set_has_gpsserver();
  if (gpsserver_ == _default_gpsserver_) {
    gpsserver_ = new ::std::string;
  }
  gpsserver_->assign(value);
}
inline void GPSMonitorConfig::set_gpsserver(const char* value, size_t size) {
  set_has_gpsserver();
  if (gpsserver_ == _default_gpsserver_) {
    gpsserver_ = new ::std::string;
  }
  gpsserver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSMonitorConfig::mutable_gpsserver() {
  set_has_gpsserver();
  if (gpsserver_ == _default_gpsserver_) {
    gpsserver_ = new ::std::string(*_default_gpsserver_);
  }
  return gpsserver_;
}
inline ::std::string* GPSMonitorConfig::release_gpsserver() {
  clear_has_gpsserver();
  if (gpsserver_ == _default_gpsserver_) {
    return NULL;
  } else {
    ::std::string* temp = gpsserver_;
    gpsserver_ = const_cast< ::std::string*>(_default_gpsserver_);
    return temp;
  }
}
inline void GPSMonitorConfig::set_allocated_gpsserver(::std::string* gpsserver) {
  if (gpsserver_ != _default_gpsserver_) {
    delete gpsserver_;
  }
  if (gpsserver) {
    set_has_gpsserver();
    gpsserver_ = gpsserver;
  } else {
    clear_has_gpsserver();
    gpsserver_ = const_cast< ::std::string*>(_default_gpsserver_);
  }
}

// optional string GPSIP = 3;
inline bool GPSMonitorConfig::has_gpsip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GPSMonitorConfig::set_has_gpsip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GPSMonitorConfig::clear_has_gpsip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GPSMonitorConfig::clear_gpsip() {
  if (gpsip_ != &::google::protobuf::internal::kEmptyString) {
    gpsip_->clear();
  }
  clear_has_gpsip();
}
inline const ::std::string& GPSMonitorConfig::gpsip() const {
  return *gpsip_;
}
inline void GPSMonitorConfig::set_gpsip(const ::std::string& value) {
  set_has_gpsip();
  if (gpsip_ == &::google::protobuf::internal::kEmptyString) {
    gpsip_ = new ::std::string;
  }
  gpsip_->assign(value);
}
inline void GPSMonitorConfig::set_gpsip(const char* value) {
  set_has_gpsip();
  if (gpsip_ == &::google::protobuf::internal::kEmptyString) {
    gpsip_ = new ::std::string;
  }
  gpsip_->assign(value);
}
inline void GPSMonitorConfig::set_gpsip(const char* value, size_t size) {
  set_has_gpsip();
  if (gpsip_ == &::google::protobuf::internal::kEmptyString) {
    gpsip_ = new ::std::string;
  }
  gpsip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSMonitorConfig::mutable_gpsip() {
  set_has_gpsip();
  if (gpsip_ == &::google::protobuf::internal::kEmptyString) {
    gpsip_ = new ::std::string;
  }
  return gpsip_;
}
inline ::std::string* GPSMonitorConfig::release_gpsip() {
  clear_has_gpsip();
  if (gpsip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gpsip_;
    gpsip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSMonitorConfig::set_allocated_gpsip(::std::string* gpsip) {
  if (gpsip_ != &::google::protobuf::internal::kEmptyString) {
    delete gpsip_;
  }
  if (gpsip) {
    set_has_gpsip();
    gpsip_ = gpsip;
  } else {
    clear_has_gpsip();
    gpsip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 gpsPort = 4;
inline bool GPSMonitorConfig::has_gpsport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GPSMonitorConfig::set_has_gpsport() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GPSMonitorConfig::clear_has_gpsport() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GPSMonitorConfig::clear_gpsport() {
  gpsport_ = 0;
  clear_has_gpsport();
}
inline ::google::protobuf::int32 GPSMonitorConfig::gpsport() const {
  return gpsport_;
}
inline void GPSMonitorConfig::set_gpsport(::google::protobuf::int32 value) {
  set_has_gpsport();
  gpsport_ = value;
}

// optional int32 gpsPer = 5 [default = 5];
inline bool GPSMonitorConfig::has_gpsper() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GPSMonitorConfig::set_has_gpsper() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GPSMonitorConfig::clear_has_gpsper() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GPSMonitorConfig::clear_gpsper() {
  gpsper_ = 5;
  clear_has_gpsper();
}
inline ::google::protobuf::int32 GPSMonitorConfig::gpsper() const {
  return gpsper_;
}
inline void GPSMonitorConfig::set_gpsper(::google::protobuf::int32 value) {
  set_has_gpsper();
  gpsper_ = value;
}

// optional int32 gpsWriteFile = 6 [default = 1];
inline bool GPSMonitorConfig::has_gpswritefile() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GPSMonitorConfig::set_has_gpswritefile() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GPSMonitorConfig::clear_has_gpswritefile() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GPSMonitorConfig::clear_gpswritefile() {
  gpswritefile_ = 1;
  clear_has_gpswritefile();
}
inline ::google::protobuf::int32 GPSMonitorConfig::gpswritefile() const {
  return gpswritefile_;
}
inline void GPSMonitorConfig::set_gpswritefile(::google::protobuf::int32 value) {
  set_has_gpswritefile();
  gpswritefile_ = value;
}

// optional int32 gpsFileInt = 7 [default = 10];
inline bool GPSMonitorConfig::has_gpsfileint() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GPSMonitorConfig::set_has_gpsfileint() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GPSMonitorConfig::clear_has_gpsfileint() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GPSMonitorConfig::clear_gpsfileint() {
  gpsfileint_ = 10;
  clear_has_gpsfileint();
}
inline ::google::protobuf::int32 GPSMonitorConfig::gpsfileint() const {
  return gpsfileint_;
}
inline void GPSMonitorConfig::set_gpsfileint(::google::protobuf::int32 value) {
  set_has_gpsfileint();
  gpsfileint_ = value;
}

// -------------------------------------------------------------------

// FalconUtilitiesConfig

// optional string msgName = 1 [default = "FALCON_UTILITIES_CONFIG"];
inline bool FalconUtilitiesConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FalconUtilitiesConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FalconUtilitiesConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FalconUtilitiesConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& FalconUtilitiesConfig::msgname() const {
  return *msgname_;
}
inline void FalconUtilitiesConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void FalconUtilitiesConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void FalconUtilitiesConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FalconUtilitiesConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* FalconUtilitiesConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void FalconUtilitiesConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string archive = 2 [default = "OFF"];
inline bool FalconUtilitiesConfig::has_archive() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FalconUtilitiesConfig::set_has_archive() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FalconUtilitiesConfig::clear_has_archive() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FalconUtilitiesConfig::clear_archive() {
  if (archive_ != _default_archive_) {
    archive_->assign(*_default_archive_);
  }
  clear_has_archive();
}
inline const ::std::string& FalconUtilitiesConfig::archive() const {
  return *archive_;
}
inline void FalconUtilitiesConfig::set_archive(const ::std::string& value) {
  set_has_archive();
  if (archive_ == _default_archive_) {
    archive_ = new ::std::string;
  }
  archive_->assign(value);
}
inline void FalconUtilitiesConfig::set_archive(const char* value) {
  set_has_archive();
  if (archive_ == _default_archive_) {
    archive_ = new ::std::string;
  }
  archive_->assign(value);
}
inline void FalconUtilitiesConfig::set_archive(const char* value, size_t size) {
  set_has_archive();
  if (archive_ == _default_archive_) {
    archive_ = new ::std::string;
  }
  archive_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FalconUtilitiesConfig::mutable_archive() {
  set_has_archive();
  if (archive_ == _default_archive_) {
    archive_ = new ::std::string(*_default_archive_);
  }
  return archive_;
}
inline ::std::string* FalconUtilitiesConfig::release_archive() {
  clear_has_archive();
  if (archive_ == _default_archive_) {
    return NULL;
  } else {
    ::std::string* temp = archive_;
    archive_ = const_cast< ::std::string*>(_default_archive_);
    return temp;
  }
}
inline void FalconUtilitiesConfig::set_allocated_archive(::std::string* archive) {
  if (archive_ != _default_archive_) {
    delete archive_;
  }
  if (archive) {
    set_has_archive();
    archive_ = archive;
  } else {
    clear_has_archive();
    archive_ = const_cast< ::std::string*>(_default_archive_);
  }
}

// optional string delArchives = 3 [default = "OFF"];
inline bool FalconUtilitiesConfig::has_delarchives() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FalconUtilitiesConfig::set_has_delarchives() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FalconUtilitiesConfig::clear_has_delarchives() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FalconUtilitiesConfig::clear_delarchives() {
  if (delarchives_ != _default_delarchives_) {
    delarchives_->assign(*_default_delarchives_);
  }
  clear_has_delarchives();
}
inline const ::std::string& FalconUtilitiesConfig::delarchives() const {
  return *delarchives_;
}
inline void FalconUtilitiesConfig::set_delarchives(const ::std::string& value) {
  set_has_delarchives();
  if (delarchives_ == _default_delarchives_) {
    delarchives_ = new ::std::string;
  }
  delarchives_->assign(value);
}
inline void FalconUtilitiesConfig::set_delarchives(const char* value) {
  set_has_delarchives();
  if (delarchives_ == _default_delarchives_) {
    delarchives_ = new ::std::string;
  }
  delarchives_->assign(value);
}
inline void FalconUtilitiesConfig::set_delarchives(const char* value, size_t size) {
  set_has_delarchives();
  if (delarchives_ == _default_delarchives_) {
    delarchives_ = new ::std::string;
  }
  delarchives_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FalconUtilitiesConfig::mutable_delarchives() {
  set_has_delarchives();
  if (delarchives_ == _default_delarchives_) {
    delarchives_ = new ::std::string(*_default_delarchives_);
  }
  return delarchives_;
}
inline ::std::string* FalconUtilitiesConfig::release_delarchives() {
  clear_has_delarchives();
  if (delarchives_ == _default_delarchives_) {
    return NULL;
  } else {
    ::std::string* temp = delarchives_;
    delarchives_ = const_cast< ::std::string*>(_default_delarchives_);
    return temp;
  }
}
inline void FalconUtilitiesConfig::set_allocated_delarchives(::std::string* delarchives) {
  if (delarchives_ != _default_delarchives_) {
    delete delarchives_;
  }
  if (delarchives) {
    set_has_delarchives();
    delarchives_ = delarchives;
  } else {
    clear_has_delarchives();
    delarchives_ = const_cast< ::std::string*>(_default_delarchives_);
  }
}

// -------------------------------------------------------------------

// RTHopAnalysisConfig

// optional string msgName = 1 [default = "RTHOP_ANALYSIS_CONFIG"];
inline bool RTHopAnalysisConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RTHopAnalysisConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RTHopAnalysisConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RTHopAnalysisConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& RTHopAnalysisConfig::msgname() const {
  return *msgname_;
}
inline void RTHopAnalysisConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RTHopAnalysisConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RTHopAnalysisConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RTHopAnalysisConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* RTHopAnalysisConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void RTHopAnalysisConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string scrypt = 2 [default = "/user/scrypts/rthops.xml"];
inline bool RTHopAnalysisConfig::has_scrypt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RTHopAnalysisConfig::set_has_scrypt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RTHopAnalysisConfig::clear_has_scrypt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RTHopAnalysisConfig::clear_scrypt() {
  if (scrypt_ != _default_scrypt_) {
    scrypt_->assign(*_default_scrypt_);
  }
  clear_has_scrypt();
}
inline const ::std::string& RTHopAnalysisConfig::scrypt() const {
  return *scrypt_;
}
inline void RTHopAnalysisConfig::set_scrypt(const ::std::string& value) {
  set_has_scrypt();
  if (scrypt_ == _default_scrypt_) {
    scrypt_ = new ::std::string;
  }
  scrypt_->assign(value);
}
inline void RTHopAnalysisConfig::set_scrypt(const char* value) {
  set_has_scrypt();
  if (scrypt_ == _default_scrypt_) {
    scrypt_ = new ::std::string;
  }
  scrypt_->assign(value);
}
inline void RTHopAnalysisConfig::set_scrypt(const char* value, size_t size) {
  set_has_scrypt();
  if (scrypt_ == _default_scrypt_) {
    scrypt_ = new ::std::string;
  }
  scrypt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RTHopAnalysisConfig::mutable_scrypt() {
  set_has_scrypt();
  if (scrypt_ == _default_scrypt_) {
    scrypt_ = new ::std::string(*_default_scrypt_);
  }
  return scrypt_;
}
inline ::std::string* RTHopAnalysisConfig::release_scrypt() {
  clear_has_scrypt();
  if (scrypt_ == _default_scrypt_) {
    return NULL;
  } else {
    ::std::string* temp = scrypt_;
    scrypt_ = const_cast< ::std::string*>(_default_scrypt_);
    return temp;
  }
}
inline void RTHopAnalysisConfig::set_allocated_scrypt(::std::string* scrypt) {
  if (scrypt_ != _default_scrypt_) {
    delete scrypt_;
  }
  if (scrypt) {
    set_has_scrypt();
    scrypt_ = scrypt;
  } else {
    clear_has_scrypt();
    scrypt_ = const_cast< ::std::string*>(_default_scrypt_);
  }
}

// -------------------------------------------------------------------

// GeoSnapConfig

// optional string msgName = 1 [default = "GEO_SNAP_CONFIG"];
inline bool GeoSnapConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GeoSnapConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GeoSnapConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GeoSnapConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& GeoSnapConfig::msgname() const {
  return *msgname_;
}
inline void GeoSnapConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GeoSnapConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GeoSnapConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoSnapConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* GeoSnapConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void GeoSnapConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string geo_enabled = 2 [default = "OFF"];
inline bool GeoSnapConfig::has_geo_enabled() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GeoSnapConfig::set_has_geo_enabled() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GeoSnapConfig::clear_has_geo_enabled() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GeoSnapConfig::clear_geo_enabled() {
  if (geo_enabled_ != _default_geo_enabled_) {
    geo_enabled_->assign(*_default_geo_enabled_);
  }
  clear_has_geo_enabled();
}
inline const ::std::string& GeoSnapConfig::geo_enabled() const {
  return *geo_enabled_;
}
inline void GeoSnapConfig::set_geo_enabled(const ::std::string& value) {
  set_has_geo_enabled();
  if (geo_enabled_ == _default_geo_enabled_) {
    geo_enabled_ = new ::std::string;
  }
  geo_enabled_->assign(value);
}
inline void GeoSnapConfig::set_geo_enabled(const char* value) {
  set_has_geo_enabled();
  if (geo_enabled_ == _default_geo_enabled_) {
    geo_enabled_ = new ::std::string;
  }
  geo_enabled_->assign(value);
}
inline void GeoSnapConfig::set_geo_enabled(const char* value, size_t size) {
  set_has_geo_enabled();
  if (geo_enabled_ == _default_geo_enabled_) {
    geo_enabled_ = new ::std::string;
  }
  geo_enabled_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoSnapConfig::mutable_geo_enabled() {
  set_has_geo_enabled();
  if (geo_enabled_ == _default_geo_enabled_) {
    geo_enabled_ = new ::std::string(*_default_geo_enabled_);
  }
  return geo_enabled_;
}
inline ::std::string* GeoSnapConfig::release_geo_enabled() {
  clear_has_geo_enabled();
  if (geo_enabled_ == _default_geo_enabled_) {
    return NULL;
  } else {
    ::std::string* temp = geo_enabled_;
    geo_enabled_ = const_cast< ::std::string*>(_default_geo_enabled_);
    return temp;
  }
}
inline void GeoSnapConfig::set_allocated_geo_enabled(::std::string* geo_enabled) {
  if (geo_enabled_ != _default_geo_enabled_) {
    delete geo_enabled_;
  }
  if (geo_enabled) {
    set_has_geo_enabled();
    geo_enabled_ = geo_enabled;
  } else {
    clear_has_geo_enabled();
    geo_enabled_ = const_cast< ::std::string*>(_default_geo_enabled_);
  }
}

// optional string auto_launch = 3 [default = "ON"];
inline bool GeoSnapConfig::has_auto_launch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GeoSnapConfig::set_has_auto_launch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GeoSnapConfig::clear_has_auto_launch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GeoSnapConfig::clear_auto_launch() {
  if (auto_launch_ != _default_auto_launch_) {
    auto_launch_->assign(*_default_auto_launch_);
  }
  clear_has_auto_launch();
}
inline const ::std::string& GeoSnapConfig::auto_launch() const {
  return *auto_launch_;
}
inline void GeoSnapConfig::set_auto_launch(const ::std::string& value) {
  set_has_auto_launch();
  if (auto_launch_ == _default_auto_launch_) {
    auto_launch_ = new ::std::string;
  }
  auto_launch_->assign(value);
}
inline void GeoSnapConfig::set_auto_launch(const char* value) {
  set_has_auto_launch();
  if (auto_launch_ == _default_auto_launch_) {
    auto_launch_ = new ::std::string;
  }
  auto_launch_->assign(value);
}
inline void GeoSnapConfig::set_auto_launch(const char* value, size_t size) {
  set_has_auto_launch();
  if (auto_launch_ == _default_auto_launch_) {
    auto_launch_ = new ::std::string;
  }
  auto_launch_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoSnapConfig::mutable_auto_launch() {
  set_has_auto_launch();
  if (auto_launch_ == _default_auto_launch_) {
    auto_launch_ = new ::std::string(*_default_auto_launch_);
  }
  return auto_launch_;
}
inline ::std::string* GeoSnapConfig::release_auto_launch() {
  clear_has_auto_launch();
  if (auto_launch_ == _default_auto_launch_) {
    return NULL;
  } else {
    ::std::string* temp = auto_launch_;
    auto_launch_ = const_cast< ::std::string*>(_default_auto_launch_);
    return temp;
  }
}
inline void GeoSnapConfig::set_allocated_auto_launch(::std::string* auto_launch) {
  if (auto_launch_ != _default_auto_launch_) {
    delete auto_launch_;
  }
  if (auto_launch) {
    set_has_auto_launch();
    auto_launch_ = auto_launch;
  } else {
    clear_has_auto_launch();
    auto_launch_ = const_cast< ::std::string*>(_default_auto_launch_);
  }
}

// optional int32 temp_write_aux = 4;
inline bool GeoSnapConfig::has_temp_write_aux() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GeoSnapConfig::set_has_temp_write_aux() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GeoSnapConfig::clear_has_temp_write_aux() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GeoSnapConfig::clear_temp_write_aux() {
  temp_write_aux_ = 0;
  clear_has_temp_write_aux();
}
inline ::google::protobuf::int32 GeoSnapConfig::temp_write_aux() const {
  return temp_write_aux_;
}
inline void GeoSnapConfig::set_temp_write_aux(::google::protobuf::int32 value) {
  set_has_temp_write_aux();
  temp_write_aux_ = value;
}

// optional string antenna = 5;
inline bool GeoSnapConfig::has_antenna() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GeoSnapConfig::set_has_antenna() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GeoSnapConfig::clear_has_antenna() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GeoSnapConfig::clear_antenna() {
  if (antenna_ != &::google::protobuf::internal::kEmptyString) {
    antenna_->clear();
  }
  clear_has_antenna();
}
inline const ::std::string& GeoSnapConfig::antenna() const {
  return *antenna_;
}
inline void GeoSnapConfig::set_antenna(const ::std::string& value) {
  set_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    antenna_ = new ::std::string;
  }
  antenna_->assign(value);
}
inline void GeoSnapConfig::set_antenna(const char* value) {
  set_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    antenna_ = new ::std::string;
  }
  antenna_->assign(value);
}
inline void GeoSnapConfig::set_antenna(const char* value, size_t size) {
  set_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    antenna_ = new ::std::string;
  }
  antenna_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoSnapConfig::mutable_antenna() {
  set_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    antenna_ = new ::std::string;
  }
  return antenna_;
}
inline ::std::string* GeoSnapConfig::release_antenna() {
  clear_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = antenna_;
    antenna_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeoSnapConfig::set_allocated_antenna(::std::string* antenna) {
  if (antenna_ != &::google::protobuf::internal::kEmptyString) {
    delete antenna_;
  }
  if (antenna) {
    set_has_antenna();
    antenna_ = antenna;
  } else {
    clear_has_antenna();
    antenna_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mission = 6;
inline bool GeoSnapConfig::has_mission() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GeoSnapConfig::set_has_mission() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GeoSnapConfig::clear_has_mission() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GeoSnapConfig::clear_mission() {
  if (mission_ != &::google::protobuf::internal::kEmptyString) {
    mission_->clear();
  }
  clear_has_mission();
}
inline const ::std::string& GeoSnapConfig::mission() const {
  return *mission_;
}
inline void GeoSnapConfig::set_mission(const ::std::string& value) {
  set_has_mission();
  if (mission_ == &::google::protobuf::internal::kEmptyString) {
    mission_ = new ::std::string;
  }
  mission_->assign(value);
}
inline void GeoSnapConfig::set_mission(const char* value) {
  set_has_mission();
  if (mission_ == &::google::protobuf::internal::kEmptyString) {
    mission_ = new ::std::string;
  }
  mission_->assign(value);
}
inline void GeoSnapConfig::set_mission(const char* value, size_t size) {
  set_has_mission();
  if (mission_ == &::google::protobuf::internal::kEmptyString) {
    mission_ = new ::std::string;
  }
  mission_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoSnapConfig::mutable_mission() {
  set_has_mission();
  if (mission_ == &::google::protobuf::internal::kEmptyString) {
    mission_ = new ::std::string;
  }
  return mission_;
}
inline ::std::string* GeoSnapConfig::release_mission() {
  clear_has_mission();
  if (mission_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mission_;
    mission_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeoSnapConfig::set_allocated_mission(::std::string* mission) {
  if (mission_ != &::google::protobuf::internal::kEmptyString) {
    delete mission_;
  }
  if (mission) {
    set_has_mission();
    mission_ = mission;
  } else {
    clear_has_mission();
    mission_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string path = 7;
inline bool GeoSnapConfig::has_path() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GeoSnapConfig::set_has_path() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GeoSnapConfig::clear_has_path() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GeoSnapConfig::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& GeoSnapConfig::path() const {
  return *path_;
}
inline void GeoSnapConfig::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void GeoSnapConfig::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void GeoSnapConfig::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoSnapConfig::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* GeoSnapConfig::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeoSnapConfig::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 rx_path_delay = 8;
inline bool GeoSnapConfig::has_rx_path_delay() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GeoSnapConfig::set_has_rx_path_delay() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GeoSnapConfig::clear_has_rx_path_delay() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GeoSnapConfig::clear_rx_path_delay() {
  rx_path_delay_ = 0;
  clear_has_rx_path_delay();
}
inline ::google::protobuf::int32 GeoSnapConfig::rx_path_delay() const {
  return rx_path_delay_;
}
inline void GeoSnapConfig::set_rx_path_delay(::google::protobuf::int32 value) {
  set_has_rx_path_delay();
  rx_path_delay_ = value;
}

// optional int32 rx_site = 9;
inline bool GeoSnapConfig::has_rx_site() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GeoSnapConfig::set_has_rx_site() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GeoSnapConfig::clear_has_rx_site() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GeoSnapConfig::clear_rx_site() {
  rx_site_ = 0;
  clear_has_rx_site();
}
inline ::google::protobuf::int32 GeoSnapConfig::rx_site() const {
  return rx_site_;
}
inline void GeoSnapConfig::set_rx_site(::google::protobuf::int32 value) {
  set_has_rx_site();
  rx_site_ = value;
}

// optional float feed_lat = 10;
inline bool GeoSnapConfig::has_feed_lat() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GeoSnapConfig::set_has_feed_lat() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GeoSnapConfig::clear_has_feed_lat() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GeoSnapConfig::clear_feed_lat() {
  feed_lat_ = 0;
  clear_has_feed_lat();
}
inline float GeoSnapConfig::feed_lat() const {
  return feed_lat_;
}
inline void GeoSnapConfig::set_feed_lat(float value) {
  set_has_feed_lat();
  feed_lat_ = value;
}

// optional float feed_lon = 11;
inline bool GeoSnapConfig::has_feed_lon() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GeoSnapConfig::set_has_feed_lon() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GeoSnapConfig::clear_has_feed_lon() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GeoSnapConfig::clear_feed_lon() {
  feed_lon_ = 0;
  clear_has_feed_lon();
}
inline float GeoSnapConfig::feed_lon() const {
  return feed_lon_;
}
inline void GeoSnapConfig::set_feed_lon(float value) {
  set_has_feed_lon();
  feed_lon_ = value;
}

// optional float feed_alt = 12;
inline bool GeoSnapConfig::has_feed_alt() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GeoSnapConfig::set_has_feed_alt() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GeoSnapConfig::clear_has_feed_alt() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GeoSnapConfig::clear_feed_alt() {
  feed_alt_ = 0;
  clear_has_feed_alt();
}
inline float GeoSnapConfig::feed_alt() const {
  return feed_alt_;
}
inline void GeoSnapConfig::set_feed_alt(float value) {
  set_has_feed_alt();
  feed_alt_ = value;
}

// optional float system_foa_sigma = 13;
inline bool GeoSnapConfig::has_system_foa_sigma() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GeoSnapConfig::set_has_system_foa_sigma() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GeoSnapConfig::clear_has_system_foa_sigma() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GeoSnapConfig::clear_system_foa_sigma() {
  system_foa_sigma_ = 0;
  clear_has_system_foa_sigma();
}
inline float GeoSnapConfig::system_foa_sigma() const {
  return system_foa_sigma_;
}
inline void GeoSnapConfig::set_system_foa_sigma(float value) {
  set_has_system_foa_sigma();
  system_foa_sigma_ = value;
}

// optional float system_toa_sigma = 14;
inline bool GeoSnapConfig::has_system_toa_sigma() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GeoSnapConfig::set_has_system_toa_sigma() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GeoSnapConfig::clear_has_system_toa_sigma() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GeoSnapConfig::clear_system_toa_sigma() {
  system_toa_sigma_ = 0;
  clear_has_system_toa_sigma();
}
inline float GeoSnapConfig::system_toa_sigma() const {
  return system_toa_sigma_;
}
inline void GeoSnapConfig::set_system_toa_sigma(float value) {
  set_has_system_toa_sigma();
  system_toa_sigma_ = value;
}

// optional string desiredinterpolation = 15;
inline bool GeoSnapConfig::has_desiredinterpolation() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GeoSnapConfig::set_has_desiredinterpolation() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GeoSnapConfig::clear_has_desiredinterpolation() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GeoSnapConfig::clear_desiredinterpolation() {
  if (desiredinterpolation_ != &::google::protobuf::internal::kEmptyString) {
    desiredinterpolation_->clear();
  }
  clear_has_desiredinterpolation();
}
inline const ::std::string& GeoSnapConfig::desiredinterpolation() const {
  return *desiredinterpolation_;
}
inline void GeoSnapConfig::set_desiredinterpolation(const ::std::string& value) {
  set_has_desiredinterpolation();
  if (desiredinterpolation_ == &::google::protobuf::internal::kEmptyString) {
    desiredinterpolation_ = new ::std::string;
  }
  desiredinterpolation_->assign(value);
}
inline void GeoSnapConfig::set_desiredinterpolation(const char* value) {
  set_has_desiredinterpolation();
  if (desiredinterpolation_ == &::google::protobuf::internal::kEmptyString) {
    desiredinterpolation_ = new ::std::string;
  }
  desiredinterpolation_->assign(value);
}
inline void GeoSnapConfig::set_desiredinterpolation(const char* value, size_t size) {
  set_has_desiredinterpolation();
  if (desiredinterpolation_ == &::google::protobuf::internal::kEmptyString) {
    desiredinterpolation_ = new ::std::string;
  }
  desiredinterpolation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoSnapConfig::mutable_desiredinterpolation() {
  set_has_desiredinterpolation();
  if (desiredinterpolation_ == &::google::protobuf::internal::kEmptyString) {
    desiredinterpolation_ = new ::std::string;
  }
  return desiredinterpolation_;
}
inline ::std::string* GeoSnapConfig::release_desiredinterpolation() {
  clear_has_desiredinterpolation();
  if (desiredinterpolation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desiredinterpolation_;
    desiredinterpolation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeoSnapConfig::set_allocated_desiredinterpolation(::std::string* desiredinterpolation) {
  if (desiredinterpolation_ != &::google::protobuf::internal::kEmptyString) {
    delete desiredinterpolation_;
  }
  if (desiredinterpolation) {
    set_has_desiredinterpolation();
    desiredinterpolation_ = desiredinterpolation;
  } else {
    clear_has_desiredinterpolation();
    desiredinterpolation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 use_sv_keywords = 16;
inline bool GeoSnapConfig::has_use_sv_keywords() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GeoSnapConfig::set_has_use_sv_keywords() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GeoSnapConfig::clear_has_use_sv_keywords() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GeoSnapConfig::clear_use_sv_keywords() {
  use_sv_keywords_ = 0;
  clear_has_use_sv_keywords();
}
inline ::google::protobuf::int32 GeoSnapConfig::use_sv_keywords() const {
  return use_sv_keywords_;
}
inline void GeoSnapConfig::set_use_sv_keywords(::google::protobuf::int32 value) {
  set_has_use_sv_keywords();
  use_sv_keywords_ = value;
}

// optional string skip_camel_transfer = 17 [default = "OFF"];
inline bool GeoSnapConfig::has_skip_camel_transfer() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void GeoSnapConfig::set_has_skip_camel_transfer() {
  _has_bits_[0] |= 0x00010000u;
}
inline void GeoSnapConfig::clear_has_skip_camel_transfer() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void GeoSnapConfig::clear_skip_camel_transfer() {
  if (skip_camel_transfer_ != _default_skip_camel_transfer_) {
    skip_camel_transfer_->assign(*_default_skip_camel_transfer_);
  }
  clear_has_skip_camel_transfer();
}
inline const ::std::string& GeoSnapConfig::skip_camel_transfer() const {
  return *skip_camel_transfer_;
}
inline void GeoSnapConfig::set_skip_camel_transfer(const ::std::string& value) {
  set_has_skip_camel_transfer();
  if (skip_camel_transfer_ == _default_skip_camel_transfer_) {
    skip_camel_transfer_ = new ::std::string;
  }
  skip_camel_transfer_->assign(value);
}
inline void GeoSnapConfig::set_skip_camel_transfer(const char* value) {
  set_has_skip_camel_transfer();
  if (skip_camel_transfer_ == _default_skip_camel_transfer_) {
    skip_camel_transfer_ = new ::std::string;
  }
  skip_camel_transfer_->assign(value);
}
inline void GeoSnapConfig::set_skip_camel_transfer(const char* value, size_t size) {
  set_has_skip_camel_transfer();
  if (skip_camel_transfer_ == _default_skip_camel_transfer_) {
    skip_camel_transfer_ = new ::std::string;
  }
  skip_camel_transfer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoSnapConfig::mutable_skip_camel_transfer() {
  set_has_skip_camel_transfer();
  if (skip_camel_transfer_ == _default_skip_camel_transfer_) {
    skip_camel_transfer_ = new ::std::string(*_default_skip_camel_transfer_);
  }
  return skip_camel_transfer_;
}
inline ::std::string* GeoSnapConfig::release_skip_camel_transfer() {
  clear_has_skip_camel_transfer();
  if (skip_camel_transfer_ == _default_skip_camel_transfer_) {
    return NULL;
  } else {
    ::std::string* temp = skip_camel_transfer_;
    skip_camel_transfer_ = const_cast< ::std::string*>(_default_skip_camel_transfer_);
    return temp;
  }
}
inline void GeoSnapConfig::set_allocated_skip_camel_transfer(::std::string* skip_camel_transfer) {
  if (skip_camel_transfer_ != _default_skip_camel_transfer_) {
    delete skip_camel_transfer_;
  }
  if (skip_camel_transfer) {
    set_has_skip_camel_transfer();
    skip_camel_transfer_ = skip_camel_transfer;
  } else {
    clear_has_skip_camel_transfer();
    skip_camel_transfer_ = const_cast< ::std::string*>(_default_skip_camel_transfer_);
  }
}

// optional float posx = 18;
inline bool GeoSnapConfig::has_posx() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void GeoSnapConfig::set_has_posx() {
  _has_bits_[0] |= 0x00020000u;
}
inline void GeoSnapConfig::clear_has_posx() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void GeoSnapConfig::clear_posx() {
  posx_ = 0;
  clear_has_posx();
}
inline float GeoSnapConfig::posx() const {
  return posx_;
}
inline void GeoSnapConfig::set_posx(float value) {
  set_has_posx();
  posx_ = value;
}

// optional float posy = 19;
inline bool GeoSnapConfig::has_posy() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void GeoSnapConfig::set_has_posy() {
  _has_bits_[0] |= 0x00040000u;
}
inline void GeoSnapConfig::clear_has_posy() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void GeoSnapConfig::clear_posy() {
  posy_ = 0;
  clear_has_posy();
}
inline float GeoSnapConfig::posy() const {
  return posy_;
}
inline void GeoSnapConfig::set_posy(float value) {
  set_has_posy();
  posy_ = value;
}

// optional float posz = 20;
inline bool GeoSnapConfig::has_posz() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void GeoSnapConfig::set_has_posz() {
  _has_bits_[0] |= 0x00080000u;
}
inline void GeoSnapConfig::clear_has_posz() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void GeoSnapConfig::clear_posz() {
  posz_ = 0;
  clear_has_posz();
}
inline float GeoSnapConfig::posz() const {
  return posz_;
}
inline void GeoSnapConfig::set_posz(float value) {
  set_has_posz();
  posz_ = value;
}

// optional string default_geo_app = 21;
inline bool GeoSnapConfig::has_default_geo_app() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void GeoSnapConfig::set_has_default_geo_app() {
  _has_bits_[0] |= 0x00100000u;
}
inline void GeoSnapConfig::clear_has_default_geo_app() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void GeoSnapConfig::clear_default_geo_app() {
  if (default_geo_app_ != &::google::protobuf::internal::kEmptyString) {
    default_geo_app_->clear();
  }
  clear_has_default_geo_app();
}
inline const ::std::string& GeoSnapConfig::default_geo_app() const {
  return *default_geo_app_;
}
inline void GeoSnapConfig::set_default_geo_app(const ::std::string& value) {
  set_has_default_geo_app();
  if (default_geo_app_ == &::google::protobuf::internal::kEmptyString) {
    default_geo_app_ = new ::std::string;
  }
  default_geo_app_->assign(value);
}
inline void GeoSnapConfig::set_default_geo_app(const char* value) {
  set_has_default_geo_app();
  if (default_geo_app_ == &::google::protobuf::internal::kEmptyString) {
    default_geo_app_ = new ::std::string;
  }
  default_geo_app_->assign(value);
}
inline void GeoSnapConfig::set_default_geo_app(const char* value, size_t size) {
  set_has_default_geo_app();
  if (default_geo_app_ == &::google::protobuf::internal::kEmptyString) {
    default_geo_app_ = new ::std::string;
  }
  default_geo_app_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoSnapConfig::mutable_default_geo_app() {
  set_has_default_geo_app();
  if (default_geo_app_ == &::google::protobuf::internal::kEmptyString) {
    default_geo_app_ = new ::std::string;
  }
  return default_geo_app_;
}
inline ::std::string* GeoSnapConfig::release_default_geo_app() {
  clear_has_default_geo_app();
  if (default_geo_app_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = default_geo_app_;
    default_geo_app_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeoSnapConfig::set_allocated_default_geo_app(::std::string* default_geo_app) {
  if (default_geo_app_ != &::google::protobuf::internal::kEmptyString) {
    delete default_geo_app_;
  }
  if (default_geo_app) {
    set_has_default_geo_app();
    default_geo_app_ = default_geo_app;
  } else {
    clear_has_default_geo_app();
    default_geo_app_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TGConfig

// optional string msgName = 1 [default = "TG_CONFIG"];
inline bool TGConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TGConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TGConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TGConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& TGConfig::msgname() const {
  return *msgname_;
}
inline void TGConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void TGConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void TGConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TGConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* TGConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void TGConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string geo_test = 2 [default = "OFF"];
inline bool TGConfig::has_geo_test() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TGConfig::set_has_geo_test() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TGConfig::clear_has_geo_test() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TGConfig::clear_geo_test() {
  if (geo_test_ != _default_geo_test_) {
    geo_test_->assign(*_default_geo_test_);
  }
  clear_has_geo_test();
}
inline const ::std::string& TGConfig::geo_test() const {
  return *geo_test_;
}
inline void TGConfig::set_geo_test(const ::std::string& value) {
  set_has_geo_test();
  if (geo_test_ == _default_geo_test_) {
    geo_test_ = new ::std::string;
  }
  geo_test_->assign(value);
}
inline void TGConfig::set_geo_test(const char* value) {
  set_has_geo_test();
  if (geo_test_ == _default_geo_test_) {
    geo_test_ = new ::std::string;
  }
  geo_test_->assign(value);
}
inline void TGConfig::set_geo_test(const char* value, size_t size) {
  set_has_geo_test();
  if (geo_test_ == _default_geo_test_) {
    geo_test_ = new ::std::string;
  }
  geo_test_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TGConfig::mutable_geo_test() {
  set_has_geo_test();
  if (geo_test_ == _default_geo_test_) {
    geo_test_ = new ::std::string(*_default_geo_test_);
  }
  return geo_test_;
}
inline ::std::string* TGConfig::release_geo_test() {
  clear_has_geo_test();
  if (geo_test_ == _default_geo_test_) {
    return NULL;
  } else {
    ::std::string* temp = geo_test_;
    geo_test_ = const_cast< ::std::string*>(_default_geo_test_);
    return temp;
  }
}
inline void TGConfig::set_allocated_geo_test(::std::string* geo_test) {
  if (geo_test_ != _default_geo_test_) {
    delete geo_test_;
  }
  if (geo_test) {
    set_has_geo_test();
    geo_test_ = geo_test;
  } else {
    clear_has_geo_test();
    geo_test_ = const_cast< ::std::string*>(_default_geo_test_);
  }
}

// optional int32 telem_timeout = 3 [default = 400];
inline bool TGConfig::has_telem_timeout() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TGConfig::set_has_telem_timeout() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TGConfig::clear_has_telem_timeout() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TGConfig::clear_telem_timeout() {
  telem_timeout_ = 400;
  clear_has_telem_timeout();
}
inline ::google::protobuf::int32 TGConfig::telem_timeout() const {
  return telem_timeout_;
}
inline void TGConfig::set_telem_timeout(::google::protobuf::int32 value) {
  set_has_telem_timeout();
  telem_timeout_ = value;
}

// optional string geo_pri_file = 4;
inline bool TGConfig::has_geo_pri_file() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TGConfig::set_has_geo_pri_file() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TGConfig::clear_has_geo_pri_file() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TGConfig::clear_geo_pri_file() {
  if (geo_pri_file_ != &::google::protobuf::internal::kEmptyString) {
    geo_pri_file_->clear();
  }
  clear_has_geo_pri_file();
}
inline const ::std::string& TGConfig::geo_pri_file() const {
  return *geo_pri_file_;
}
inline void TGConfig::set_geo_pri_file(const ::std::string& value) {
  set_has_geo_pri_file();
  if (geo_pri_file_ == &::google::protobuf::internal::kEmptyString) {
    geo_pri_file_ = new ::std::string;
  }
  geo_pri_file_->assign(value);
}
inline void TGConfig::set_geo_pri_file(const char* value) {
  set_has_geo_pri_file();
  if (geo_pri_file_ == &::google::protobuf::internal::kEmptyString) {
    geo_pri_file_ = new ::std::string;
  }
  geo_pri_file_->assign(value);
}
inline void TGConfig::set_geo_pri_file(const char* value, size_t size) {
  set_has_geo_pri_file();
  if (geo_pri_file_ == &::google::protobuf::internal::kEmptyString) {
    geo_pri_file_ = new ::std::string;
  }
  geo_pri_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TGConfig::mutable_geo_pri_file() {
  set_has_geo_pri_file();
  if (geo_pri_file_ == &::google::protobuf::internal::kEmptyString) {
    geo_pri_file_ = new ::std::string;
  }
  return geo_pri_file_;
}
inline ::std::string* TGConfig::release_geo_pri_file() {
  clear_has_geo_pri_file();
  if (geo_pri_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = geo_pri_file_;
    geo_pri_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TGConfig::set_allocated_geo_pri_file(::std::string* geo_pri_file) {
  if (geo_pri_file_ != &::google::protobuf::internal::kEmptyString) {
    delete geo_pri_file_;
  }
  if (geo_pri_file) {
    set_has_geo_pri_file();
    geo_pri_file_ = geo_pri_file;
  } else {
    clear_has_geo_pri_file();
    geo_pri_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 state_timeout = 5 [default = 60];
inline bool TGConfig::has_state_timeout() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TGConfig::set_has_state_timeout() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TGConfig::clear_has_state_timeout() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TGConfig::clear_state_timeout() {
  state_timeout_ = 60;
  clear_has_state_timeout();
}
inline ::google::protobuf::int32 TGConfig::state_timeout() const {
  return state_timeout_;
}
inline void TGConfig::set_state_timeout(::google::protobuf::int32 value) {
  set_has_state_timeout();
  state_timeout_ = value;
}

// -------------------------------------------------------------------

// EventHandlerConfig

// optional string msgName = 1 [default = "EVENT_HANDLER_CONFIG"];
inline bool EventHandlerConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EventHandlerConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EventHandlerConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EventHandlerConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& EventHandlerConfig::msgname() const {
  return *msgname_;
}
inline void EventHandlerConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EventHandlerConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EventHandlerConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EventHandlerConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* EventHandlerConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void EventHandlerConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional bool xmlEnable = 2;
inline bool EventHandlerConfig::has_xmlenable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EventHandlerConfig::set_has_xmlenable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EventHandlerConfig::clear_has_xmlenable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EventHandlerConfig::clear_xmlenable() {
  xmlenable_ = false;
  clear_has_xmlenable();
}
inline bool EventHandlerConfig::xmlenable() const {
  return xmlenable_;
}
inline void EventHandlerConfig::set_xmlenable(bool value) {
  set_has_xmlenable();
  xmlenable_ = value;
}

// optional string xmlClass = 3;
inline bool EventHandlerConfig::has_xmlclass() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EventHandlerConfig::set_has_xmlclass() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EventHandlerConfig::clear_has_xmlclass() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EventHandlerConfig::clear_xmlclass() {
  if (xmlclass_ != &::google::protobuf::internal::kEmptyString) {
    xmlclass_->clear();
  }
  clear_has_xmlclass();
}
inline const ::std::string& EventHandlerConfig::xmlclass() const {
  return *xmlclass_;
}
inline void EventHandlerConfig::set_xmlclass(const ::std::string& value) {
  set_has_xmlclass();
  if (xmlclass_ == &::google::protobuf::internal::kEmptyString) {
    xmlclass_ = new ::std::string;
  }
  xmlclass_->assign(value);
}
inline void EventHandlerConfig::set_xmlclass(const char* value) {
  set_has_xmlclass();
  if (xmlclass_ == &::google::protobuf::internal::kEmptyString) {
    xmlclass_ = new ::std::string;
  }
  xmlclass_->assign(value);
}
inline void EventHandlerConfig::set_xmlclass(const char* value, size_t size) {
  set_has_xmlclass();
  if (xmlclass_ == &::google::protobuf::internal::kEmptyString) {
    xmlclass_ = new ::std::string;
  }
  xmlclass_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EventHandlerConfig::mutable_xmlclass() {
  set_has_xmlclass();
  if (xmlclass_ == &::google::protobuf::internal::kEmptyString) {
    xmlclass_ = new ::std::string;
  }
  return xmlclass_;
}
inline ::std::string* EventHandlerConfig::release_xmlclass() {
  clear_has_xmlclass();
  if (xmlclass_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = xmlclass_;
    xmlclass_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EventHandlerConfig::set_allocated_xmlclass(::std::string* xmlclass) {
  if (xmlclass_ != &::google::protobuf::internal::kEmptyString) {
    delete xmlclass_;
  }
  if (xmlclass) {
    set_has_xmlclass();
    xmlclass_ = xmlclass;
  } else {
    clear_has_xmlclass();
    xmlclass_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string xmlSource = 4;
inline bool EventHandlerConfig::has_xmlsource() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EventHandlerConfig::set_has_xmlsource() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EventHandlerConfig::clear_has_xmlsource() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EventHandlerConfig::clear_xmlsource() {
  if (xmlsource_ != &::google::protobuf::internal::kEmptyString) {
    xmlsource_->clear();
  }
  clear_has_xmlsource();
}
inline const ::std::string& EventHandlerConfig::xmlsource() const {
  return *xmlsource_;
}
inline void EventHandlerConfig::set_xmlsource(const ::std::string& value) {
  set_has_xmlsource();
  if (xmlsource_ == &::google::protobuf::internal::kEmptyString) {
    xmlsource_ = new ::std::string;
  }
  xmlsource_->assign(value);
}
inline void EventHandlerConfig::set_xmlsource(const char* value) {
  set_has_xmlsource();
  if (xmlsource_ == &::google::protobuf::internal::kEmptyString) {
    xmlsource_ = new ::std::string;
  }
  xmlsource_->assign(value);
}
inline void EventHandlerConfig::set_xmlsource(const char* value, size_t size) {
  set_has_xmlsource();
  if (xmlsource_ == &::google::protobuf::internal::kEmptyString) {
    xmlsource_ = new ::std::string;
  }
  xmlsource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EventHandlerConfig::mutable_xmlsource() {
  set_has_xmlsource();
  if (xmlsource_ == &::google::protobuf::internal::kEmptyString) {
    xmlsource_ = new ::std::string;
  }
  return xmlsource_;
}
inline ::std::string* EventHandlerConfig::release_xmlsource() {
  clear_has_xmlsource();
  if (xmlsource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = xmlsource_;
    xmlsource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EventHandlerConfig::set_allocated_xmlsource(::std::string* xmlsource) {
  if (xmlsource_ != &::google::protobuf::internal::kEmptyString) {
    delete xmlsource_;
  }
  if (xmlsource) {
    set_has_xmlsource();
    xmlsource_ = xmlsource;
  } else {
    clear_has_xmlsource();
    xmlsource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string xmlPath = 5;
inline bool EventHandlerConfig::has_xmlpath() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EventHandlerConfig::set_has_xmlpath() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EventHandlerConfig::clear_has_xmlpath() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EventHandlerConfig::clear_xmlpath() {
  if (xmlpath_ != &::google::protobuf::internal::kEmptyString) {
    xmlpath_->clear();
  }
  clear_has_xmlpath();
}
inline const ::std::string& EventHandlerConfig::xmlpath() const {
  return *xmlpath_;
}
inline void EventHandlerConfig::set_xmlpath(const ::std::string& value) {
  set_has_xmlpath();
  if (xmlpath_ == &::google::protobuf::internal::kEmptyString) {
    xmlpath_ = new ::std::string;
  }
  xmlpath_->assign(value);
}
inline void EventHandlerConfig::set_xmlpath(const char* value) {
  set_has_xmlpath();
  if (xmlpath_ == &::google::protobuf::internal::kEmptyString) {
    xmlpath_ = new ::std::string;
  }
  xmlpath_->assign(value);
}
inline void EventHandlerConfig::set_xmlpath(const char* value, size_t size) {
  set_has_xmlpath();
  if (xmlpath_ == &::google::protobuf::internal::kEmptyString) {
    xmlpath_ = new ::std::string;
  }
  xmlpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EventHandlerConfig::mutable_xmlpath() {
  set_has_xmlpath();
  if (xmlpath_ == &::google::protobuf::internal::kEmptyString) {
    xmlpath_ = new ::std::string;
  }
  return xmlpath_;
}
inline ::std::string* EventHandlerConfig::release_xmlpath() {
  clear_has_xmlpath();
  if (xmlpath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = xmlpath_;
    xmlpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EventHandlerConfig::set_allocated_xmlpath(::std::string* xmlpath) {
  if (xmlpath_ != &::google::protobuf::internal::kEmptyString) {
    delete xmlpath_;
  }
  if (xmlpath) {
    set_has_xmlpath();
    xmlpath_ = xmlpath;
  } else {
    clear_has_xmlpath();
    xmlpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string xmlWorkstation = 6;
inline bool EventHandlerConfig::has_xmlworkstation() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EventHandlerConfig::set_has_xmlworkstation() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EventHandlerConfig::clear_has_xmlworkstation() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EventHandlerConfig::clear_xmlworkstation() {
  if (xmlworkstation_ != &::google::protobuf::internal::kEmptyString) {
    xmlworkstation_->clear();
  }
  clear_has_xmlworkstation();
}
inline const ::std::string& EventHandlerConfig::xmlworkstation() const {
  return *xmlworkstation_;
}
inline void EventHandlerConfig::set_xmlworkstation(const ::std::string& value) {
  set_has_xmlworkstation();
  if (xmlworkstation_ == &::google::protobuf::internal::kEmptyString) {
    xmlworkstation_ = new ::std::string;
  }
  xmlworkstation_->assign(value);
}
inline void EventHandlerConfig::set_xmlworkstation(const char* value) {
  set_has_xmlworkstation();
  if (xmlworkstation_ == &::google::protobuf::internal::kEmptyString) {
    xmlworkstation_ = new ::std::string;
  }
  xmlworkstation_->assign(value);
}
inline void EventHandlerConfig::set_xmlworkstation(const char* value, size_t size) {
  set_has_xmlworkstation();
  if (xmlworkstation_ == &::google::protobuf::internal::kEmptyString) {
    xmlworkstation_ = new ::std::string;
  }
  xmlworkstation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EventHandlerConfig::mutable_xmlworkstation() {
  set_has_xmlworkstation();
  if (xmlworkstation_ == &::google::protobuf::internal::kEmptyString) {
    xmlworkstation_ = new ::std::string;
  }
  return xmlworkstation_;
}
inline ::std::string* EventHandlerConfig::release_xmlworkstation() {
  clear_has_xmlworkstation();
  if (xmlworkstation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = xmlworkstation_;
    xmlworkstation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EventHandlerConfig::set_allocated_xmlworkstation(::std::string* xmlworkstation) {
  if (xmlworkstation_ != &::google::protobuf::internal::kEmptyString) {
    delete xmlworkstation_;
  }
  if (xmlworkstation) {
    set_has_xmlworkstation();
    xmlworkstation_ = xmlworkstation;
  } else {
    clear_has_xmlworkstation();
    xmlworkstation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 xmlPeriod = 7;
inline bool EventHandlerConfig::has_xmlperiod() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EventHandlerConfig::set_has_xmlperiod() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EventHandlerConfig::clear_has_xmlperiod() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EventHandlerConfig::clear_xmlperiod() {
  xmlperiod_ = 0;
  clear_has_xmlperiod();
}
inline ::google::protobuf::int32 EventHandlerConfig::xmlperiod() const {
  return xmlperiod_;
}
inline void EventHandlerConfig::set_xmlperiod(::google::protobuf::int32 value) {
  set_has_xmlperiod();
  xmlperiod_ = value;
}

// optional int32 xmlGeoThreshold = 8;
inline bool EventHandlerConfig::has_xmlgeothreshold() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EventHandlerConfig::set_has_xmlgeothreshold() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EventHandlerConfig::clear_has_xmlgeothreshold() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EventHandlerConfig::clear_xmlgeothreshold() {
  xmlgeothreshold_ = 0;
  clear_has_xmlgeothreshold();
}
inline ::google::protobuf::int32 EventHandlerConfig::xmlgeothreshold() const {
  return xmlgeothreshold_;
}
inline void EventHandlerConfig::set_xmlgeothreshold(::google::protobuf::int32 value) {
  set_has_xmlgeothreshold();
  xmlgeothreshold_ = value;
}

// optional string xmlGeoFilterFile = 9;
inline bool EventHandlerConfig::has_xmlgeofilterfile() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EventHandlerConfig::set_has_xmlgeofilterfile() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EventHandlerConfig::clear_has_xmlgeofilterfile() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EventHandlerConfig::clear_xmlgeofilterfile() {
  if (xmlgeofilterfile_ != &::google::protobuf::internal::kEmptyString) {
    xmlgeofilterfile_->clear();
  }
  clear_has_xmlgeofilterfile();
}
inline const ::std::string& EventHandlerConfig::xmlgeofilterfile() const {
  return *xmlgeofilterfile_;
}
inline void EventHandlerConfig::set_xmlgeofilterfile(const ::std::string& value) {
  set_has_xmlgeofilterfile();
  if (xmlgeofilterfile_ == &::google::protobuf::internal::kEmptyString) {
    xmlgeofilterfile_ = new ::std::string;
  }
  xmlgeofilterfile_->assign(value);
}
inline void EventHandlerConfig::set_xmlgeofilterfile(const char* value) {
  set_has_xmlgeofilterfile();
  if (xmlgeofilterfile_ == &::google::protobuf::internal::kEmptyString) {
    xmlgeofilterfile_ = new ::std::string;
  }
  xmlgeofilterfile_->assign(value);
}
inline void EventHandlerConfig::set_xmlgeofilterfile(const char* value, size_t size) {
  set_has_xmlgeofilterfile();
  if (xmlgeofilterfile_ == &::google::protobuf::internal::kEmptyString) {
    xmlgeofilterfile_ = new ::std::string;
  }
  xmlgeofilterfile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EventHandlerConfig::mutable_xmlgeofilterfile() {
  set_has_xmlgeofilterfile();
  if (xmlgeofilterfile_ == &::google::protobuf::internal::kEmptyString) {
    xmlgeofilterfile_ = new ::std::string;
  }
  return xmlgeofilterfile_;
}
inline ::std::string* EventHandlerConfig::release_xmlgeofilterfile() {
  clear_has_xmlgeofilterfile();
  if (xmlgeofilterfile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = xmlgeofilterfile_;
    xmlgeofilterfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EventHandlerConfig::set_allocated_xmlgeofilterfile(::std::string* xmlgeofilterfile) {
  if (xmlgeofilterfile_ != &::google::protobuf::internal::kEmptyString) {
    delete xmlgeofilterfile_;
  }
  if (xmlgeofilterfile) {
    set_has_xmlgeofilterfile();
    xmlgeofilterfile_ = xmlgeofilterfile;
  } else {
    clear_has_xmlgeofilterfile();
    xmlgeofilterfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string workstationWhitelist = 10;
inline bool EventHandlerConfig::has_workstationwhitelist() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EventHandlerConfig::set_has_workstationwhitelist() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EventHandlerConfig::clear_has_workstationwhitelist() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EventHandlerConfig::clear_workstationwhitelist() {
  if (workstationwhitelist_ != &::google::protobuf::internal::kEmptyString) {
    workstationwhitelist_->clear();
  }
  clear_has_workstationwhitelist();
}
inline const ::std::string& EventHandlerConfig::workstationwhitelist() const {
  return *workstationwhitelist_;
}
inline void EventHandlerConfig::set_workstationwhitelist(const ::std::string& value) {
  set_has_workstationwhitelist();
  if (workstationwhitelist_ == &::google::protobuf::internal::kEmptyString) {
    workstationwhitelist_ = new ::std::string;
  }
  workstationwhitelist_->assign(value);
}
inline void EventHandlerConfig::set_workstationwhitelist(const char* value) {
  set_has_workstationwhitelist();
  if (workstationwhitelist_ == &::google::protobuf::internal::kEmptyString) {
    workstationwhitelist_ = new ::std::string;
  }
  workstationwhitelist_->assign(value);
}
inline void EventHandlerConfig::set_workstationwhitelist(const char* value, size_t size) {
  set_has_workstationwhitelist();
  if (workstationwhitelist_ == &::google::protobuf::internal::kEmptyString) {
    workstationwhitelist_ = new ::std::string;
  }
  workstationwhitelist_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EventHandlerConfig::mutable_workstationwhitelist() {
  set_has_workstationwhitelist();
  if (workstationwhitelist_ == &::google::protobuf::internal::kEmptyString) {
    workstationwhitelist_ = new ::std::string;
  }
  return workstationwhitelist_;
}
inline ::std::string* EventHandlerConfig::release_workstationwhitelist() {
  clear_has_workstationwhitelist();
  if (workstationwhitelist_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = workstationwhitelist_;
    workstationwhitelist_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EventHandlerConfig::set_allocated_workstationwhitelist(::std::string* workstationwhitelist) {
  if (workstationwhitelist_ != &::google::protobuf::internal::kEmptyString) {
    delete workstationwhitelist_;
  }
  if (workstationwhitelist) {
    set_has_workstationwhitelist();
    workstationwhitelist_ = workstationwhitelist;
  } else {
    clear_has_workstationwhitelist();
    workstationwhitelist_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 telemTimeout = 11 [default = 300];
inline bool EventHandlerConfig::has_telemtimeout() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void EventHandlerConfig::set_has_telemtimeout() {
  _has_bits_[0] |= 0x00000400u;
}
inline void EventHandlerConfig::clear_has_telemtimeout() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void EventHandlerConfig::clear_telemtimeout() {
  telemtimeout_ = 300;
  clear_has_telemtimeout();
}
inline ::google::protobuf::int32 EventHandlerConfig::telemtimeout() const {
  return telemtimeout_;
}
inline void EventHandlerConfig::set_telemtimeout(::google::protobuf::int32 value) {
  set_has_telemtimeout();
  telemtimeout_ = value;
}

// optional int32 geoTimeout = 12 [default = 300];
inline bool EventHandlerConfig::has_geotimeout() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void EventHandlerConfig::set_has_geotimeout() {
  _has_bits_[0] |= 0x00000800u;
}
inline void EventHandlerConfig::clear_has_geotimeout() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void EventHandlerConfig::clear_geotimeout() {
  geotimeout_ = 300;
  clear_has_geotimeout();
}
inline ::google::protobuf::int32 EventHandlerConfig::geotimeout() const {
  return geotimeout_;
}
inline void EventHandlerConfig::set_geotimeout(::google::protobuf::int32 value) {
  set_has_geotimeout();
  geotimeout_ = value;
}

// optional string tagOverrideFile = 13;
inline bool EventHandlerConfig::has_tagoverridefile() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void EventHandlerConfig::set_has_tagoverridefile() {
  _has_bits_[0] |= 0x00001000u;
}
inline void EventHandlerConfig::clear_has_tagoverridefile() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void EventHandlerConfig::clear_tagoverridefile() {
  if (tagoverridefile_ != &::google::protobuf::internal::kEmptyString) {
    tagoverridefile_->clear();
  }
  clear_has_tagoverridefile();
}
inline const ::std::string& EventHandlerConfig::tagoverridefile() const {
  return *tagoverridefile_;
}
inline void EventHandlerConfig::set_tagoverridefile(const ::std::string& value) {
  set_has_tagoverridefile();
  if (tagoverridefile_ == &::google::protobuf::internal::kEmptyString) {
    tagoverridefile_ = new ::std::string;
  }
  tagoverridefile_->assign(value);
}
inline void EventHandlerConfig::set_tagoverridefile(const char* value) {
  set_has_tagoverridefile();
  if (tagoverridefile_ == &::google::protobuf::internal::kEmptyString) {
    tagoverridefile_ = new ::std::string;
  }
  tagoverridefile_->assign(value);
}
inline void EventHandlerConfig::set_tagoverridefile(const char* value, size_t size) {
  set_has_tagoverridefile();
  if (tagoverridefile_ == &::google::protobuf::internal::kEmptyString) {
    tagoverridefile_ = new ::std::string;
  }
  tagoverridefile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EventHandlerConfig::mutable_tagoverridefile() {
  set_has_tagoverridefile();
  if (tagoverridefile_ == &::google::protobuf::internal::kEmptyString) {
    tagoverridefile_ = new ::std::string;
  }
  return tagoverridefile_;
}
inline ::std::string* EventHandlerConfig::release_tagoverridefile() {
  clear_has_tagoverridefile();
  if (tagoverridefile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tagoverridefile_;
    tagoverridefile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EventHandlerConfig::set_allocated_tagoverridefile(::std::string* tagoverridefile) {
  if (tagoverridefile_ != &::google::protobuf::internal::kEmptyString) {
    delete tagoverridefile_;
  }
  if (tagoverridefile) {
    set_has_tagoverridefile();
    tagoverridefile_ = tagoverridefile;
  } else {
    clear_has_tagoverridefile();
    tagoverridefile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GPSFakerConfig

// optional string msgName = 1 [default = "GPS_FAKER_CONFIG"];
inline bool GPSFakerConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPSFakerConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPSFakerConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPSFakerConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& GPSFakerConfig::msgname() const {
  return *msgname_;
}
inline void GPSFakerConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GPSFakerConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GPSFakerConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSFakerConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* GPSFakerConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void GPSFakerConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string gpsFile = 2;
inline bool GPSFakerConfig::has_gpsfile() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GPSFakerConfig::set_has_gpsfile() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GPSFakerConfig::clear_has_gpsfile() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GPSFakerConfig::clear_gpsfile() {
  if (gpsfile_ != &::google::protobuf::internal::kEmptyString) {
    gpsfile_->clear();
  }
  clear_has_gpsfile();
}
inline const ::std::string& GPSFakerConfig::gpsfile() const {
  return *gpsfile_;
}
inline void GPSFakerConfig::set_gpsfile(const ::std::string& value) {
  set_has_gpsfile();
  if (gpsfile_ == &::google::protobuf::internal::kEmptyString) {
    gpsfile_ = new ::std::string;
  }
  gpsfile_->assign(value);
}
inline void GPSFakerConfig::set_gpsfile(const char* value) {
  set_has_gpsfile();
  if (gpsfile_ == &::google::protobuf::internal::kEmptyString) {
    gpsfile_ = new ::std::string;
  }
  gpsfile_->assign(value);
}
inline void GPSFakerConfig::set_gpsfile(const char* value, size_t size) {
  set_has_gpsfile();
  if (gpsfile_ == &::google::protobuf::internal::kEmptyString) {
    gpsfile_ = new ::std::string;
  }
  gpsfile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSFakerConfig::mutable_gpsfile() {
  set_has_gpsfile();
  if (gpsfile_ == &::google::protobuf::internal::kEmptyString) {
    gpsfile_ = new ::std::string;
  }
  return gpsfile_;
}
inline ::std::string* GPSFakerConfig::release_gpsfile() {
  clear_has_gpsfile();
  if (gpsfile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gpsfile_;
    gpsfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSFakerConfig::set_allocated_gpsfile(::std::string* gpsfile) {
  if (gpsfile_ != &::google::protobuf::internal::kEmptyString) {
    delete gpsfile_;
  }
  if (gpsfile) {
    set_has_gpsfile();
    gpsfile_ = gpsfile;
  } else {
    clear_has_gpsfile();
    gpsfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SkyscraperConfig

// optional string msgName = 1 [default = "SKYSCRAPER_CONFIG"];
inline bool SkyscraperConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SkyscraperConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SkyscraperConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SkyscraperConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SkyscraperConfig::msgname() const {
  return *msgname_;
}
inline void SkyscraperConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SkyscraperConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SkyscraperConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SkyscraperConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SkyscraperConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SkyscraperConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string directory = 2;
inline bool SkyscraperConfig::has_directory() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SkyscraperConfig::set_has_directory() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SkyscraperConfig::clear_has_directory() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SkyscraperConfig::clear_directory() {
  if (directory_ != &::google::protobuf::internal::kEmptyString) {
    directory_->clear();
  }
  clear_has_directory();
}
inline const ::std::string& SkyscraperConfig::directory() const {
  return *directory_;
}
inline void SkyscraperConfig::set_directory(const ::std::string& value) {
  set_has_directory();
  if (directory_ == &::google::protobuf::internal::kEmptyString) {
    directory_ = new ::std::string;
  }
  directory_->assign(value);
}
inline void SkyscraperConfig::set_directory(const char* value) {
  set_has_directory();
  if (directory_ == &::google::protobuf::internal::kEmptyString) {
    directory_ = new ::std::string;
  }
  directory_->assign(value);
}
inline void SkyscraperConfig::set_directory(const char* value, size_t size) {
  set_has_directory();
  if (directory_ == &::google::protobuf::internal::kEmptyString) {
    directory_ = new ::std::string;
  }
  directory_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SkyscraperConfig::mutable_directory() {
  set_has_directory();
  if (directory_ == &::google::protobuf::internal::kEmptyString) {
    directory_ = new ::std::string;
  }
  return directory_;
}
inline ::std::string* SkyscraperConfig::release_directory() {
  clear_has_directory();
  if (directory_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = directory_;
    directory_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SkyscraperConfig::set_allocated_directory(::std::string* directory) {
  if (directory_ != &::google::protobuf::internal::kEmptyString) {
    delete directory_;
  }
  if (directory) {
    set_has_directory();
    directory_ = directory;
  } else {
    clear_has_directory();
    directory_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string filename = 3;
inline bool SkyscraperConfig::has_filename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SkyscraperConfig::set_has_filename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SkyscraperConfig::clear_has_filename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SkyscraperConfig::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& SkyscraperConfig::filename() const {
  return *filename_;
}
inline void SkyscraperConfig::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void SkyscraperConfig::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void SkyscraperConfig::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SkyscraperConfig::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* SkyscraperConfig::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SkyscraperConfig::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NoiseTestConfig

// optional string msgName = 1 [default = "NOISE_TEST_CONFIG"];
inline bool NoiseTestConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NoiseTestConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NoiseTestConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NoiseTestConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& NoiseTestConfig::msgname() const {
  return *msgname_;
}
inline void NoiseTestConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void NoiseTestConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void NoiseTestConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NoiseTestConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* NoiseTestConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void NoiseTestConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional .falcon_svc_msg.MacroOptions options = 2;
inline bool NoiseTestConfig::has_options() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NoiseTestConfig::set_has_options() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NoiseTestConfig::clear_has_options() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NoiseTestConfig::clear_options() {
  if (options_ != NULL) options_->::falcon_svc_msg::MacroOptions::Clear();
  clear_has_options();
}
inline const ::falcon_svc_msg::MacroOptions& NoiseTestConfig::options() const {
  return options_ != NULL ? *options_ : *default_instance_->options_;
}
inline ::falcon_svc_msg::MacroOptions* NoiseTestConfig::mutable_options() {
  set_has_options();
  if (options_ == NULL) options_ = new ::falcon_svc_msg::MacroOptions;
  return options_;
}
inline ::falcon_svc_msg::MacroOptions* NoiseTestConfig::release_options() {
  clear_has_options();
  ::falcon_svc_msg::MacroOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline void NoiseTestConfig::set_allocated_options(::falcon_svc_msg::MacroOptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
}

// -------------------------------------------------------------------

// ExtraScriptConfigMess

// optional string msgName = 1 [default = "EXTRASCRIPTCONFIGMESS"];
inline bool ExtraScriptConfigMess::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExtraScriptConfigMess::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExtraScriptConfigMess::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExtraScriptConfigMess::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ExtraScriptConfigMess::msgname() const {
  return *msgname_;
}
inline void ExtraScriptConfigMess::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ExtraScriptConfigMess::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ExtraScriptConfigMess::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExtraScriptConfigMess::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ExtraScriptConfigMess::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ExtraScriptConfigMess::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string script = 2;
inline bool ExtraScriptConfigMess::has_script() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExtraScriptConfigMess::set_has_script() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExtraScriptConfigMess::clear_has_script() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExtraScriptConfigMess::clear_script() {
  if (script_ != &::google::protobuf::internal::kEmptyString) {
    script_->clear();
  }
  clear_has_script();
}
inline const ::std::string& ExtraScriptConfigMess::script() const {
  return *script_;
}
inline void ExtraScriptConfigMess::set_script(const ::std::string& value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(value);
}
inline void ExtraScriptConfigMess::set_script(const char* value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(value);
}
inline void ExtraScriptConfigMess::set_script(const char* value, size_t size) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExtraScriptConfigMess::mutable_script() {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  return script_;
}
inline ::std::string* ExtraScriptConfigMess::release_script() {
  clear_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = script_;
    script_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExtraScriptConfigMess::set_allocated_script(::std::string* script) {
  if (script_ != &::google::protobuf::internal::kEmptyString) {
    delete script_;
  }
  if (script) {
    set_has_script();
    script_ = script;
  } else {
    clear_has_script();
    script_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NoConfigMess

// optional string msgName = 1 [default = "NOCONFIGMESS"];
inline bool NoConfigMess::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NoConfigMess::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NoConfigMess::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NoConfigMess::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& NoConfigMess::msgname() const {
  return *msgname_;
}
inline void NoConfigMess::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void NoConfigMess::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void NoConfigMess::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NoConfigMess::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* NoConfigMess::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void NoConfigMess::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// -------------------------------------------------------------------

// PentekConfigMess

// optional string msgName = 1 [default = "EXTRASCRIPTCONFIGMESS"];
inline bool PentekConfigMess::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PentekConfigMess::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PentekConfigMess::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PentekConfigMess::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& PentekConfigMess::msgname() const {
  return *msgname_;
}
inline void PentekConfigMess::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void PentekConfigMess::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void PentekConfigMess::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PentekConfigMess::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* PentekConfigMess::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void PentekConfigMess::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional float txSampleRate = 2;
inline bool PentekConfigMess::has_txsamplerate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PentekConfigMess::set_has_txsamplerate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PentekConfigMess::clear_has_txsamplerate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PentekConfigMess::clear_txsamplerate() {
  txsamplerate_ = 0;
  clear_has_txsamplerate();
}
inline float PentekConfigMess::txsamplerate() const {
  return txsamplerate_;
}
inline void PentekConfigMess::set_txsamplerate(float value) {
  set_has_txsamplerate();
  txsamplerate_ = value;
}

// -------------------------------------------------------------------

// PredTunerConfig

// optional string msgName = 1 [default = "PREDTUNER_CONFIG"];
inline bool PredTunerConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PredTunerConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PredTunerConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PredTunerConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& PredTunerConfig::msgname() const {
  return *msgname_;
}
inline void PredTunerConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void PredTunerConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void PredTunerConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PredTunerConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* PredTunerConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void PredTunerConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 numTuners = 2;
inline bool PredTunerConfig::has_numtuners() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PredTunerConfig::set_has_numtuners() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PredTunerConfig::clear_has_numtuners() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PredTunerConfig::clear_numtuners() {
  numtuners_ = 0;
  clear_has_numtuners();
}
inline ::google::protobuf::int32 PredTunerConfig::numtuners() const {
  return numtuners_;
}
inline void PredTunerConfig::set_numtuners(::google::protobuf::int32 value) {
  set_has_numtuners();
  numtuners_ = value;
}

// optional int32 arcfilenum = 3;
inline bool PredTunerConfig::has_arcfilenum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PredTunerConfig::set_has_arcfilenum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PredTunerConfig::clear_has_arcfilenum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PredTunerConfig::clear_arcfilenum() {
  arcfilenum_ = 0;
  clear_has_arcfilenum();
}
inline ::google::protobuf::int32 PredTunerConfig::arcfilenum() const {
  return arcfilenum_;
}
inline void PredTunerConfig::set_arcfilenum(::google::protobuf::int32 value) {
  set_has_arcfilenum();
  arcfilenum_ = value;
}

// optional int32 arcfilesize = 4;
inline bool PredTunerConfig::has_arcfilesize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PredTunerConfig::set_has_arcfilesize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PredTunerConfig::clear_has_arcfilesize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PredTunerConfig::clear_arcfilesize() {
  arcfilesize_ = 0;
  clear_has_arcfilesize();
}
inline ::google::protobuf::int32 PredTunerConfig::arcfilesize() const {
  return arcfilesize_;
}
inline void PredTunerConfig::set_arcfilesize(::google::protobuf::int32 value) {
  set_has_arcfilesize();
  arcfilesize_ = value;
}

// optional string config = 5;
inline bool PredTunerConfig::has_config() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PredTunerConfig::set_has_config() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PredTunerConfig::clear_has_config() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PredTunerConfig::clear_config() {
  if (config_ != &::google::protobuf::internal::kEmptyString) {
    config_->clear();
  }
  clear_has_config();
}
inline const ::std::string& PredTunerConfig::config() const {
  return *config_;
}
inline void PredTunerConfig::set_config(const ::std::string& value) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void PredTunerConfig::set_config(const char* value) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void PredTunerConfig::set_config(const char* value, size_t size) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PredTunerConfig::mutable_config() {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  return config_;
}
inline ::std::string* PredTunerConfig::release_config() {
  clear_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = config_;
    config_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PredTunerConfig::set_allocated_config(::std::string* config) {
  if (config_ != &::google::protobuf::internal::kEmptyString) {
    delete config_;
  }
  if (config) {
    set_has_config();
    config_ = config;
  } else {
    clear_has_config();
    config_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 startTunerNum = 6;
inline bool PredTunerConfig::has_starttunernum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PredTunerConfig::set_has_starttunernum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PredTunerConfig::clear_has_starttunernum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PredTunerConfig::clear_starttunernum() {
  starttunernum_ = 0;
  clear_has_starttunernum();
}
inline ::google::protobuf::int32 PredTunerConfig::starttunernum() const {
  return starttunernum_;
}
inline void PredTunerConfig::set_starttunernum(::google::protobuf::int32 value) {
  set_has_starttunernum();
  starttunernum_ = value;
}

// -------------------------------------------------------------------

// PredTransceiverConfig

// optional string msgName = 1 [default = "TRANSCEIVER_CONFIG"];
inline bool PredTransceiverConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PredTransceiverConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PredTransceiverConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PredTransceiverConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& PredTransceiverConfig::msgname() const {
  return *msgname_;
}
inline void PredTransceiverConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void PredTransceiverConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void PredTransceiverConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PredTransceiverConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* PredTransceiverConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void PredTransceiverConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 snapshotRingCapacity = 2 [default = 50];
inline bool PredTransceiverConfig::has_snapshotringcapacity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PredTransceiverConfig::set_has_snapshotringcapacity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PredTransceiverConfig::clear_has_snapshotringcapacity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PredTransceiverConfig::clear_snapshotringcapacity() {
  snapshotringcapacity_ = 50;
  clear_has_snapshotringcapacity();
}
inline ::google::protobuf::int32 PredTransceiverConfig::snapshotringcapacity() const {
  return snapshotringcapacity_;
}
inline void PredTransceiverConfig::set_snapshotringcapacity(::google::protobuf::int32 value) {
  set_has_snapshotringcapacity();
  snapshotringcapacity_ = value;
}

// optional int32 numTuners = 3;
inline bool PredTransceiverConfig::has_numtuners() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PredTransceiverConfig::set_has_numtuners() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PredTransceiverConfig::clear_has_numtuners() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PredTransceiverConfig::clear_numtuners() {
  numtuners_ = 0;
  clear_has_numtuners();
}
inline ::google::protobuf::int32 PredTransceiverConfig::numtuners() const {
  return numtuners_;
}
inline void PredTransceiverConfig::set_numtuners(::google::protobuf::int32 value) {
  set_has_numtuners();
  numtuners_ = value;
}

// optional int32 numTransmitters = 4;
inline bool PredTransceiverConfig::has_numtransmitters() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PredTransceiverConfig::set_has_numtransmitters() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PredTransceiverConfig::clear_has_numtransmitters() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PredTransceiverConfig::clear_numtransmitters() {
  numtransmitters_ = 0;
  clear_has_numtransmitters();
}
inline ::google::protobuf::int32 PredTransceiverConfig::numtransmitters() const {
  return numtransmitters_;
}
inline void PredTransceiverConfig::set_numtransmitters(::google::protobuf::int32 value) {
  set_has_numtransmitters();
  numtransmitters_ = value;
}

// optional int32 startTunerNum = 5;
inline bool PredTransceiverConfig::has_starttunernum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PredTransceiverConfig::set_has_starttunernum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PredTransceiverConfig::clear_has_starttunernum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PredTransceiverConfig::clear_starttunernum() {
  starttunernum_ = 0;
  clear_has_starttunernum();
}
inline ::google::protobuf::int32 PredTransceiverConfig::starttunernum() const {
  return starttunernum_;
}
inline void PredTransceiverConfig::set_starttunernum(::google::protobuf::int32 value) {
  set_has_starttunernum();
  starttunernum_ = value;
}

// optional string ipaddr = 6;
inline bool PredTransceiverConfig::has_ipaddr() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PredTransceiverConfig::set_has_ipaddr() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PredTransceiverConfig::clear_has_ipaddr() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PredTransceiverConfig::clear_ipaddr() {
  if (ipaddr_ != &::google::protobuf::internal::kEmptyString) {
    ipaddr_->clear();
  }
  clear_has_ipaddr();
}
inline const ::std::string& PredTransceiverConfig::ipaddr() const {
  return *ipaddr_;
}
inline void PredTransceiverConfig::set_ipaddr(const ::std::string& value) {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    ipaddr_ = new ::std::string;
  }
  ipaddr_->assign(value);
}
inline void PredTransceiverConfig::set_ipaddr(const char* value) {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    ipaddr_ = new ::std::string;
  }
  ipaddr_->assign(value);
}
inline void PredTransceiverConfig::set_ipaddr(const char* value, size_t size) {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    ipaddr_ = new ::std::string;
  }
  ipaddr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PredTransceiverConfig::mutable_ipaddr() {
  set_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    ipaddr_ = new ::std::string;
  }
  return ipaddr_;
}
inline ::std::string* PredTransceiverConfig::release_ipaddr() {
  clear_has_ipaddr();
  if (ipaddr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ipaddr_;
    ipaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PredTransceiverConfig::set_allocated_ipaddr(::std::string* ipaddr) {
  if (ipaddr_ != &::google::protobuf::internal::kEmptyString) {
    delete ipaddr_;
  }
  if (ipaddr) {
    set_has_ipaddr();
    ipaddr_ = ipaddr;
  } else {
    clear_has_ipaddr();
    ipaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string hwType = 7 [default = "USRP"];
inline bool PredTransceiverConfig::has_hwtype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PredTransceiverConfig::set_has_hwtype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PredTransceiverConfig::clear_has_hwtype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PredTransceiverConfig::clear_hwtype() {
  if (hwtype_ != _default_hwtype_) {
    hwtype_->assign(*_default_hwtype_);
  }
  clear_has_hwtype();
}
inline const ::std::string& PredTransceiverConfig::hwtype() const {
  return *hwtype_;
}
inline void PredTransceiverConfig::set_hwtype(const ::std::string& value) {
  set_has_hwtype();
  if (hwtype_ == _default_hwtype_) {
    hwtype_ = new ::std::string;
  }
  hwtype_->assign(value);
}
inline void PredTransceiverConfig::set_hwtype(const char* value) {
  set_has_hwtype();
  if (hwtype_ == _default_hwtype_) {
    hwtype_ = new ::std::string;
  }
  hwtype_->assign(value);
}
inline void PredTransceiverConfig::set_hwtype(const char* value, size_t size) {
  set_has_hwtype();
  if (hwtype_ == _default_hwtype_) {
    hwtype_ = new ::std::string;
  }
  hwtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PredTransceiverConfig::mutable_hwtype() {
  set_has_hwtype();
  if (hwtype_ == _default_hwtype_) {
    hwtype_ = new ::std::string(*_default_hwtype_);
  }
  return hwtype_;
}
inline ::std::string* PredTransceiverConfig::release_hwtype() {
  clear_has_hwtype();
  if (hwtype_ == _default_hwtype_) {
    return NULL;
  } else {
    ::std::string* temp = hwtype_;
    hwtype_ = const_cast< ::std::string*>(_default_hwtype_);
    return temp;
  }
}
inline void PredTransceiverConfig::set_allocated_hwtype(::std::string* hwtype) {
  if (hwtype_ != _default_hwtype_) {
    delete hwtype_;
  }
  if (hwtype) {
    set_has_hwtype();
    hwtype_ = hwtype;
  } else {
    clear_has_hwtype();
    hwtype_ = const_cast< ::std::string*>(_default_hwtype_);
  }
}

// optional float rxSampleRate = 8 [default = 2.5e+07];
inline bool PredTransceiverConfig::has_rxsamplerate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PredTransceiverConfig::set_has_rxsamplerate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PredTransceiverConfig::clear_has_rxsamplerate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PredTransceiverConfig::clear_rxsamplerate() {
  rxsamplerate_ = 2.5e+07f;
  clear_has_rxsamplerate();
}
inline float PredTransceiverConfig::rxsamplerate() const {
  return rxsamplerate_;
}
inline void PredTransceiverConfig::set_rxsamplerate(float value) {
  set_has_rxsamplerate();
  rxsamplerate_ = value;
}

// optional float txSampleRate = 9 [default = 1e+08];
inline bool PredTransceiverConfig::has_txsamplerate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PredTransceiverConfig::set_has_txsamplerate() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PredTransceiverConfig::clear_has_txsamplerate() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PredTransceiverConfig::clear_txsamplerate() {
  txsamplerate_ = 1e+08f;
  clear_has_txsamplerate();
}
inline float PredTransceiverConfig::txsamplerate() const {
  return txsamplerate_;
}
inline void PredTransceiverConfig::set_txsamplerate(float value) {
  set_has_txsamplerate();
  txsamplerate_ = value;
}

// optional string usrpClockSource = 10 [default = "internal"];
inline bool PredTransceiverConfig::has_usrpclocksource() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PredTransceiverConfig::set_has_usrpclocksource() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PredTransceiverConfig::clear_has_usrpclocksource() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PredTransceiverConfig::clear_usrpclocksource() {
  if (usrpclocksource_ != _default_usrpclocksource_) {
    usrpclocksource_->assign(*_default_usrpclocksource_);
  }
  clear_has_usrpclocksource();
}
inline const ::std::string& PredTransceiverConfig::usrpclocksource() const {
  return *usrpclocksource_;
}
inline void PredTransceiverConfig::set_usrpclocksource(const ::std::string& value) {
  set_has_usrpclocksource();
  if (usrpclocksource_ == _default_usrpclocksource_) {
    usrpclocksource_ = new ::std::string;
  }
  usrpclocksource_->assign(value);
}
inline void PredTransceiverConfig::set_usrpclocksource(const char* value) {
  set_has_usrpclocksource();
  if (usrpclocksource_ == _default_usrpclocksource_) {
    usrpclocksource_ = new ::std::string;
  }
  usrpclocksource_->assign(value);
}
inline void PredTransceiverConfig::set_usrpclocksource(const char* value, size_t size) {
  set_has_usrpclocksource();
  if (usrpclocksource_ == _default_usrpclocksource_) {
    usrpclocksource_ = new ::std::string;
  }
  usrpclocksource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PredTransceiverConfig::mutable_usrpclocksource() {
  set_has_usrpclocksource();
  if (usrpclocksource_ == _default_usrpclocksource_) {
    usrpclocksource_ = new ::std::string(*_default_usrpclocksource_);
  }
  return usrpclocksource_;
}
inline ::std::string* PredTransceiverConfig::release_usrpclocksource() {
  clear_has_usrpclocksource();
  if (usrpclocksource_ == _default_usrpclocksource_) {
    return NULL;
  } else {
    ::std::string* temp = usrpclocksource_;
    usrpclocksource_ = const_cast< ::std::string*>(_default_usrpclocksource_);
    return temp;
  }
}
inline void PredTransceiverConfig::set_allocated_usrpclocksource(::std::string* usrpclocksource) {
  if (usrpclocksource_ != _default_usrpclocksource_) {
    delete usrpclocksource_;
  }
  if (usrpclocksource) {
    set_has_usrpclocksource();
    usrpclocksource_ = usrpclocksource;
  } else {
    clear_has_usrpclocksource();
    usrpclocksource_ = const_cast< ::std::string*>(_default_usrpclocksource_);
  }
}

// optional string usrpTimeSource = 11 [default = "internal"];
inline bool PredTransceiverConfig::has_usrptimesource() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PredTransceiverConfig::set_has_usrptimesource() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PredTransceiverConfig::clear_has_usrptimesource() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PredTransceiverConfig::clear_usrptimesource() {
  if (usrptimesource_ != _default_usrptimesource_) {
    usrptimesource_->assign(*_default_usrptimesource_);
  }
  clear_has_usrptimesource();
}
inline const ::std::string& PredTransceiverConfig::usrptimesource() const {
  return *usrptimesource_;
}
inline void PredTransceiverConfig::set_usrptimesource(const ::std::string& value) {
  set_has_usrptimesource();
  if (usrptimesource_ == _default_usrptimesource_) {
    usrptimesource_ = new ::std::string;
  }
  usrptimesource_->assign(value);
}
inline void PredTransceiverConfig::set_usrptimesource(const char* value) {
  set_has_usrptimesource();
  if (usrptimesource_ == _default_usrptimesource_) {
    usrptimesource_ = new ::std::string;
  }
  usrptimesource_->assign(value);
}
inline void PredTransceiverConfig::set_usrptimesource(const char* value, size_t size) {
  set_has_usrptimesource();
  if (usrptimesource_ == _default_usrptimesource_) {
    usrptimesource_ = new ::std::string;
  }
  usrptimesource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PredTransceiverConfig::mutable_usrptimesource() {
  set_has_usrptimesource();
  if (usrptimesource_ == _default_usrptimesource_) {
    usrptimesource_ = new ::std::string(*_default_usrptimesource_);
  }
  return usrptimesource_;
}
inline ::std::string* PredTransceiverConfig::release_usrptimesource() {
  clear_has_usrptimesource();
  if (usrptimesource_ == _default_usrptimesource_) {
    return NULL;
  } else {
    ::std::string* temp = usrptimesource_;
    usrptimesource_ = const_cast< ::std::string*>(_default_usrptimesource_);
    return temp;
  }
}
inline void PredTransceiverConfig::set_allocated_usrptimesource(::std::string* usrptimesource) {
  if (usrptimesource_ != _default_usrptimesource_) {
    delete usrptimesource_;
  }
  if (usrptimesource) {
    set_has_usrptimesource();
    usrptimesource_ = usrptimesource;
  } else {
    clear_has_usrptimesource();
    usrptimesource_ = const_cast< ::std::string*>(_default_usrptimesource_);
  }
}

// optional string fft = 12 [default = "false"];
inline bool PredTransceiverConfig::has_fft() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PredTransceiverConfig::set_has_fft() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PredTransceiverConfig::clear_has_fft() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PredTransceiverConfig::clear_fft() {
  if (fft_ != _default_fft_) {
    fft_->assign(*_default_fft_);
  }
  clear_has_fft();
}
inline const ::std::string& PredTransceiverConfig::fft() const {
  return *fft_;
}
inline void PredTransceiverConfig::set_fft(const ::std::string& value) {
  set_has_fft();
  if (fft_ == _default_fft_) {
    fft_ = new ::std::string;
  }
  fft_->assign(value);
}
inline void PredTransceiverConfig::set_fft(const char* value) {
  set_has_fft();
  if (fft_ == _default_fft_) {
    fft_ = new ::std::string;
  }
  fft_->assign(value);
}
inline void PredTransceiverConfig::set_fft(const char* value, size_t size) {
  set_has_fft();
  if (fft_ == _default_fft_) {
    fft_ = new ::std::string;
  }
  fft_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PredTransceiverConfig::mutable_fft() {
  set_has_fft();
  if (fft_ == _default_fft_) {
    fft_ = new ::std::string(*_default_fft_);
  }
  return fft_;
}
inline ::std::string* PredTransceiverConfig::release_fft() {
  clear_has_fft();
  if (fft_ == _default_fft_) {
    return NULL;
  } else {
    ::std::string* temp = fft_;
    fft_ = const_cast< ::std::string*>(_default_fft_);
    return temp;
  }
}
inline void PredTransceiverConfig::set_allocated_fft(::std::string* fft) {
  if (fft_ != _default_fft_) {
    delete fft_;
  }
  if (fft) {
    set_has_fft();
    fft_ = fft;
  } else {
    clear_has_fft();
    fft_ = const_cast< ::std::string*>(_default_fft_);
  }
}

// optional float arcFileSecs = 13 [default = -1];
inline bool PredTransceiverConfig::has_arcfilesecs() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PredTransceiverConfig::set_has_arcfilesecs() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PredTransceiverConfig::clear_has_arcfilesecs() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PredTransceiverConfig::clear_arcfilesecs() {
  arcfilesecs_ = -1;
  clear_has_arcfilesecs();
}
inline float PredTransceiverConfig::arcfilesecs() const {
  return arcfilesecs_;
}
inline void PredTransceiverConfig::set_arcfilesecs(float value) {
  set_has_arcfilesecs();
  arcfilesecs_ = value;
}

// -------------------------------------------------------------------

// SidekiqTransceiverConfig

// optional string msgName = 1 [default = "SIDEKIQTRANSCEIVER_CONFIG"];
inline bool SidekiqTransceiverConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SidekiqTransceiverConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SidekiqTransceiverConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SidekiqTransceiverConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SidekiqTransceiverConfig::msgname() const {
  return *msgname_;
}
inline void SidekiqTransceiverConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SidekiqTransceiverConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SidekiqTransceiverConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SidekiqTransceiverConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SidekiqTransceiverConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SidekiqTransceiverConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 snapshotRingCapacity = 2 [default = 50];
inline bool SidekiqTransceiverConfig::has_snapshotringcapacity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SidekiqTransceiverConfig::set_has_snapshotringcapacity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SidekiqTransceiverConfig::clear_has_snapshotringcapacity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SidekiqTransceiverConfig::clear_snapshotringcapacity() {
  snapshotringcapacity_ = 50;
  clear_has_snapshotringcapacity();
}
inline ::google::protobuf::int32 SidekiqTransceiverConfig::snapshotringcapacity() const {
  return snapshotringcapacity_;
}
inline void SidekiqTransceiverConfig::set_snapshotringcapacity(::google::protobuf::int32 value) {
  set_has_snapshotringcapacity();
  snapshotringcapacity_ = value;
}

// optional int32 rxA1 = 3 [default = -1];
inline bool SidekiqTransceiverConfig::has_rxa1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SidekiqTransceiverConfig::set_has_rxa1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SidekiqTransceiverConfig::clear_has_rxa1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SidekiqTransceiverConfig::clear_rxa1() {
  rxa1_ = -1;
  clear_has_rxa1();
}
inline ::google::protobuf::int32 SidekiqTransceiverConfig::rxa1() const {
  return rxa1_;
}
inline void SidekiqTransceiverConfig::set_rxa1(::google::protobuf::int32 value) {
  set_has_rxa1();
  rxa1_ = value;
}

// optional int32 rxA2 = 4 [default = -1];
inline bool SidekiqTransceiverConfig::has_rxa2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SidekiqTransceiverConfig::set_has_rxa2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SidekiqTransceiverConfig::clear_has_rxa2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SidekiqTransceiverConfig::clear_rxa2() {
  rxa2_ = -1;
  clear_has_rxa2();
}
inline ::google::protobuf::int32 SidekiqTransceiverConfig::rxa2() const {
  return rxa2_;
}
inline void SidekiqTransceiverConfig::set_rxa2(::google::protobuf::int32 value) {
  set_has_rxa2();
  rxa2_ = value;
}

// optional int32 rxB1 = 5 [default = -1];
inline bool SidekiqTransceiverConfig::has_rxb1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SidekiqTransceiverConfig::set_has_rxb1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SidekiqTransceiverConfig::clear_has_rxb1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SidekiqTransceiverConfig::clear_rxb1() {
  rxb1_ = -1;
  clear_has_rxb1();
}
inline ::google::protobuf::int32 SidekiqTransceiverConfig::rxb1() const {
  return rxb1_;
}
inline void SidekiqTransceiverConfig::set_rxb1(::google::protobuf::int32 value) {
  set_has_rxb1();
  rxb1_ = value;
}

// optional int32 rxB2 = 6 [default = -1];
inline bool SidekiqTransceiverConfig::has_rxb2() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SidekiqTransceiverConfig::set_has_rxb2() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SidekiqTransceiverConfig::clear_has_rxb2() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SidekiqTransceiverConfig::clear_rxb2() {
  rxb2_ = -1;
  clear_has_rxb2();
}
inline ::google::protobuf::int32 SidekiqTransceiverConfig::rxb2() const {
  return rxb2_;
}
inline void SidekiqTransceiverConfig::set_rxb2(::google::protobuf::int32 value) {
  set_has_rxb2();
  rxb2_ = value;
}

// optional int32 txA1 = 7 [default = -1];
inline bool SidekiqTransceiverConfig::has_txa1() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SidekiqTransceiverConfig::set_has_txa1() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SidekiqTransceiverConfig::clear_has_txa1() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SidekiqTransceiverConfig::clear_txa1() {
  txa1_ = -1;
  clear_has_txa1();
}
inline ::google::protobuf::int32 SidekiqTransceiverConfig::txa1() const {
  return txa1_;
}
inline void SidekiqTransceiverConfig::set_txa1(::google::protobuf::int32 value) {
  set_has_txa1();
  txa1_ = value;
}

// optional int32 txA2 = 8 [default = -1];
inline bool SidekiqTransceiverConfig::has_txa2() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SidekiqTransceiverConfig::set_has_txa2() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SidekiqTransceiverConfig::clear_has_txa2() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SidekiqTransceiverConfig::clear_txa2() {
  txa2_ = -1;
  clear_has_txa2();
}
inline ::google::protobuf::int32 SidekiqTransceiverConfig::txa2() const {
  return txa2_;
}
inline void SidekiqTransceiverConfig::set_txa2(::google::protobuf::int32 value) {
  set_has_txa2();
  txa2_ = value;
}

// optional int32 txB1 = 9 [default = -1];
inline bool SidekiqTransceiverConfig::has_txb1() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SidekiqTransceiverConfig::set_has_txb1() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SidekiqTransceiverConfig::clear_has_txb1() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SidekiqTransceiverConfig::clear_txb1() {
  txb1_ = -1;
  clear_has_txb1();
}
inline ::google::protobuf::int32 SidekiqTransceiverConfig::txb1() const {
  return txb1_;
}
inline void SidekiqTransceiverConfig::set_txb1(::google::protobuf::int32 value) {
  set_has_txb1();
  txb1_ = value;
}

// optional int32 txB2 = 10 [default = -1];
inline bool SidekiqTransceiverConfig::has_txb2() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SidekiqTransceiverConfig::set_has_txb2() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SidekiqTransceiverConfig::clear_has_txb2() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SidekiqTransceiverConfig::clear_txb2() {
  txb2_ = -1;
  clear_has_txb2();
}
inline ::google::protobuf::int32 SidekiqTransceiverConfig::txb2() const {
  return txb2_;
}
inline void SidekiqTransceiverConfig::set_txb2(::google::protobuf::int32 value) {
  set_has_txb2();
  txb2_ = value;
}

// optional bool ppcA1 = 11 [default = false];
inline bool SidekiqTransceiverConfig::has_ppca1() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SidekiqTransceiverConfig::set_has_ppca1() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SidekiqTransceiverConfig::clear_has_ppca1() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SidekiqTransceiverConfig::clear_ppca1() {
  ppca1_ = false;
  clear_has_ppca1();
}
inline bool SidekiqTransceiverConfig::ppca1() const {
  return ppca1_;
}
inline void SidekiqTransceiverConfig::set_ppca1(bool value) {
  set_has_ppca1();
  ppca1_ = value;
}

// optional bool ppcA2 = 12 [default = false];
inline bool SidekiqTransceiverConfig::has_ppca2() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SidekiqTransceiverConfig::set_has_ppca2() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SidekiqTransceiverConfig::clear_has_ppca2() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SidekiqTransceiverConfig::clear_ppca2() {
  ppca2_ = false;
  clear_has_ppca2();
}
inline bool SidekiqTransceiverConfig::ppca2() const {
  return ppca2_;
}
inline void SidekiqTransceiverConfig::set_ppca2(bool value) {
  set_has_ppca2();
  ppca2_ = value;
}

// optional bool ppcB1 = 13 [default = false];
inline bool SidekiqTransceiverConfig::has_ppcb1() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SidekiqTransceiverConfig::set_has_ppcb1() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SidekiqTransceiverConfig::clear_has_ppcb1() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SidekiqTransceiverConfig::clear_ppcb1() {
  ppcb1_ = false;
  clear_has_ppcb1();
}
inline bool SidekiqTransceiverConfig::ppcb1() const {
  return ppcb1_;
}
inline void SidekiqTransceiverConfig::set_ppcb1(bool value) {
  set_has_ppcb1();
  ppcb1_ = value;
}

// optional bool ppcB2 = 14 [default = false];
inline bool SidekiqTransceiverConfig::has_ppcb2() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SidekiqTransceiverConfig::set_has_ppcb2() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SidekiqTransceiverConfig::clear_has_ppcb2() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SidekiqTransceiverConfig::clear_ppcb2() {
  ppcb2_ = false;
  clear_has_ppcb2();
}
inline bool SidekiqTransceiverConfig::ppcb2() const {
  return ppcb2_;
}
inline void SidekiqTransceiverConfig::set_ppcb2(bool value) {
  set_has_ppcb2();
  ppcb2_ = value;
}

// optional string cardID = 15 [default = "0"];
inline bool SidekiqTransceiverConfig::has_cardid() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SidekiqTransceiverConfig::set_has_cardid() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SidekiqTransceiverConfig::clear_has_cardid() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SidekiqTransceiverConfig::clear_cardid() {
  if (cardid_ != _default_cardid_) {
    cardid_->assign(*_default_cardid_);
  }
  clear_has_cardid();
}
inline const ::std::string& SidekiqTransceiverConfig::cardid() const {
  return *cardid_;
}
inline void SidekiqTransceiverConfig::set_cardid(const ::std::string& value) {
  set_has_cardid();
  if (cardid_ == _default_cardid_) {
    cardid_ = new ::std::string;
  }
  cardid_->assign(value);
}
inline void SidekiqTransceiverConfig::set_cardid(const char* value) {
  set_has_cardid();
  if (cardid_ == _default_cardid_) {
    cardid_ = new ::std::string;
  }
  cardid_->assign(value);
}
inline void SidekiqTransceiverConfig::set_cardid(const char* value, size_t size) {
  set_has_cardid();
  if (cardid_ == _default_cardid_) {
    cardid_ = new ::std::string;
  }
  cardid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SidekiqTransceiverConfig::mutable_cardid() {
  set_has_cardid();
  if (cardid_ == _default_cardid_) {
    cardid_ = new ::std::string(*_default_cardid_);
  }
  return cardid_;
}
inline ::std::string* SidekiqTransceiverConfig::release_cardid() {
  clear_has_cardid();
  if (cardid_ == _default_cardid_) {
    return NULL;
  } else {
    ::std::string* temp = cardid_;
    cardid_ = const_cast< ::std::string*>(_default_cardid_);
    return temp;
  }
}
inline void SidekiqTransceiverConfig::set_allocated_cardid(::std::string* cardid) {
  if (cardid_ != _default_cardid_) {
    delete cardid_;
  }
  if (cardid) {
    set_has_cardid();
    cardid_ = cardid;
  } else {
    clear_has_cardid();
    cardid_ = const_cast< ::std::string*>(_default_cardid_);
  }
}

// optional float sampleRateA = 16 [default = 5e+07];
inline bool SidekiqTransceiverConfig::has_sampleratea() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SidekiqTransceiverConfig::set_has_sampleratea() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SidekiqTransceiverConfig::clear_has_sampleratea() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SidekiqTransceiverConfig::clear_sampleratea() {
  sampleratea_ = 5e+07f;
  clear_has_sampleratea();
}
inline float SidekiqTransceiverConfig::sampleratea() const {
  return sampleratea_;
}
inline void SidekiqTransceiverConfig::set_sampleratea(float value) {
  set_has_sampleratea();
  sampleratea_ = value;
}

// optional float sampleRateB = 17 [default = 5e+07];
inline bool SidekiqTransceiverConfig::has_samplerateb() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SidekiqTransceiverConfig::set_has_samplerateb() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SidekiqTransceiverConfig::clear_has_samplerateb() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SidekiqTransceiverConfig::clear_samplerateb() {
  samplerateb_ = 5e+07f;
  clear_has_samplerateb();
}
inline float SidekiqTransceiverConfig::samplerateb() const {
  return samplerateb_;
}
inline void SidekiqTransceiverConfig::set_samplerateb(float value) {
  set_has_samplerateb();
  samplerateb_ = value;
}

// optional float energyThreshA = 18 [default = -70];
inline bool SidekiqTransceiverConfig::has_energythresha() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SidekiqTransceiverConfig::set_has_energythresha() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SidekiqTransceiverConfig::clear_has_energythresha() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SidekiqTransceiverConfig::clear_energythresha() {
  energythresha_ = -70;
  clear_has_energythresha();
}
inline float SidekiqTransceiverConfig::energythresha() const {
  return energythresha_;
}
inline void SidekiqTransceiverConfig::set_energythresha(float value) {
  set_has_energythresha();
  energythresha_ = value;
}

// optional float energyThreshB = 19 [default = -70];
inline bool SidekiqTransceiverConfig::has_energythreshb() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SidekiqTransceiverConfig::set_has_energythreshb() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SidekiqTransceiverConfig::clear_has_energythreshb() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SidekiqTransceiverConfig::clear_energythreshb() {
  energythreshb_ = -70;
  clear_has_energythreshb();
}
inline float SidekiqTransceiverConfig::energythreshb() const {
  return energythreshb_;
}
inline void SidekiqTransceiverConfig::set_energythreshb(float value) {
  set_has_energythreshb();
  energythreshb_ = value;
}

// optional int32 energyThreshNumA = 20 [default = 200];
inline bool SidekiqTransceiverConfig::has_energythreshnuma() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SidekiqTransceiverConfig::set_has_energythreshnuma() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SidekiqTransceiverConfig::clear_has_energythreshnuma() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SidekiqTransceiverConfig::clear_energythreshnuma() {
  energythreshnuma_ = 200;
  clear_has_energythreshnuma();
}
inline ::google::protobuf::int32 SidekiqTransceiverConfig::energythreshnuma() const {
  return energythreshnuma_;
}
inline void SidekiqTransceiverConfig::set_energythreshnuma(::google::protobuf::int32 value) {
  set_has_energythreshnuma();
  energythreshnuma_ = value;
}

// optional int32 energyThreshNumB = 21 [default = 200];
inline bool SidekiqTransceiverConfig::has_energythreshnumb() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SidekiqTransceiverConfig::set_has_energythreshnumb() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SidekiqTransceiverConfig::clear_has_energythreshnumb() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SidekiqTransceiverConfig::clear_energythreshnumb() {
  energythreshnumb_ = 200;
  clear_has_energythreshnumb();
}
inline ::google::protobuf::int32 SidekiqTransceiverConfig::energythreshnumb() const {
  return energythreshnumb_;
}
inline void SidekiqTransceiverConfig::set_energythreshnumb(::google::protobuf::int32 value) {
  set_has_energythreshnumb();
  energythreshnumb_ = value;
}

// optional int32 rxBufferSize = 22 [default = 512];
inline bool SidekiqTransceiverConfig::has_rxbuffersize() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void SidekiqTransceiverConfig::set_has_rxbuffersize() {
  _has_bits_[0] |= 0x00200000u;
}
inline void SidekiqTransceiverConfig::clear_has_rxbuffersize() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void SidekiqTransceiverConfig::clear_rxbuffersize() {
  rxbuffersize_ = 512;
  clear_has_rxbuffersize();
}
inline ::google::protobuf::int32 SidekiqTransceiverConfig::rxbuffersize() const {
  return rxbuffersize_;
}
inline void SidekiqTransceiverConfig::set_rxbuffersize(::google::protobuf::int32 value) {
  set_has_rxbuffersize();
  rxbuffersize_ = value;
}

// optional int32 debuglvl = 23 [default = 0];
inline bool SidekiqTransceiverConfig::has_debuglvl() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void SidekiqTransceiverConfig::set_has_debuglvl() {
  _has_bits_[0] |= 0x00400000u;
}
inline void SidekiqTransceiverConfig::clear_has_debuglvl() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void SidekiqTransceiverConfig::clear_debuglvl() {
  debuglvl_ = 0;
  clear_has_debuglvl();
}
inline ::google::protobuf::int32 SidekiqTransceiverConfig::debuglvl() const {
  return debuglvl_;
}
inline void SidekiqTransceiverConfig::set_debuglvl(::google::protobuf::int32 value) {
  set_has_debuglvl();
  debuglvl_ = value;
}

// optional bool externalReference = 24 [default = true];
inline bool SidekiqTransceiverConfig::has_externalreference() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void SidekiqTransceiverConfig::set_has_externalreference() {
  _has_bits_[0] |= 0x00800000u;
}
inline void SidekiqTransceiverConfig::clear_has_externalreference() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void SidekiqTransceiverConfig::clear_externalreference() {
  externalreference_ = true;
  clear_has_externalreference();
}
inline bool SidekiqTransceiverConfig::externalreference() const {
  return externalreference_;
}
inline void SidekiqTransceiverConfig::set_externalreference(bool value) {
  set_has_externalreference();
  externalreference_ = value;
}

// -------------------------------------------------------------------

// MMSTunerConfig

// optional string msgName = 1 [default = "MMSTUNERCONFIG"];
inline bool MMSTunerConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MMSTunerConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MMSTunerConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MMSTunerConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& MMSTunerConfig::msgname() const {
  return *msgname_;
}
inline void MMSTunerConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void MMSTunerConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void MMSTunerConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSTunerConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* MMSTunerConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void MMSTunerConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 snapshotRingCapacity = 2 [default = 50];
inline bool MMSTunerConfig::has_snapshotringcapacity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MMSTunerConfig::set_has_snapshotringcapacity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MMSTunerConfig::clear_has_snapshotringcapacity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MMSTunerConfig::clear_snapshotringcapacity() {
  snapshotringcapacity_ = 50;
  clear_has_snapshotringcapacity();
}
inline ::google::protobuf::int32 MMSTunerConfig::snapshotringcapacity() const {
  return snapshotringcapacity_;
}
inline void MMSTunerConfig::set_snapshotringcapacity(::google::protobuf::int32 value) {
  set_has_snapshotringcapacity();
  snapshotringcapacity_ = value;
}

// optional int32 channel = 3;
inline bool MMSTunerConfig::has_channel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MMSTunerConfig::set_has_channel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MMSTunerConfig::clear_has_channel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MMSTunerConfig::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 MMSTunerConfig::channel() const {
  return channel_;
}
inline void MMSTunerConfig::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// optional string ip = 4;
inline bool MMSTunerConfig::has_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MMSTunerConfig::set_has_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MMSTunerConfig::clear_has_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MMSTunerConfig::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& MMSTunerConfig::ip() const {
  return *ip_;
}
inline void MMSTunerConfig::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void MMSTunerConfig::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void MMSTunerConfig::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSTunerConfig::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* MMSTunerConfig::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MMSTunerConfig::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string interface = 5;
inline bool MMSTunerConfig::has_interface() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MMSTunerConfig::set_has_interface() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MMSTunerConfig::clear_has_interface() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MMSTunerConfig::clear_interface() {
  if (interface_ != &::google::protobuf::internal::kEmptyString) {
    interface_->clear();
  }
  clear_has_interface();
}
inline const ::std::string& MMSTunerConfig::interface() const {
  return *interface_;
}
inline void MMSTunerConfig::set_interface(const ::std::string& value) {
  set_has_interface();
  if (interface_ == &::google::protobuf::internal::kEmptyString) {
    interface_ = new ::std::string;
  }
  interface_->assign(value);
}
inline void MMSTunerConfig::set_interface(const char* value) {
  set_has_interface();
  if (interface_ == &::google::protobuf::internal::kEmptyString) {
    interface_ = new ::std::string;
  }
  interface_->assign(value);
}
inline void MMSTunerConfig::set_interface(const char* value, size_t size) {
  set_has_interface();
  if (interface_ == &::google::protobuf::internal::kEmptyString) {
    interface_ = new ::std::string;
  }
  interface_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSTunerConfig::mutable_interface() {
  set_has_interface();
  if (interface_ == &::google::protobuf::internal::kEmptyString) {
    interface_ = new ::std::string;
  }
  return interface_;
}
inline ::std::string* MMSTunerConfig::release_interface() {
  clear_has_interface();
  if (interface_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = interface_;
    interface_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MMSTunerConfig::set_allocated_interface(::std::string* interface) {
  if (interface_ != &::google::protobuf::internal::kEmptyString) {
    delete interface_;
  }
  if (interface) {
    set_has_interface();
    interface_ = interface;
  } else {
    clear_has_interface();
    interface_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float bandwidth = 6;
inline bool MMSTunerConfig::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MMSTunerConfig::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MMSTunerConfig::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MMSTunerConfig::clear_bandwidth() {
  bandwidth_ = 0;
  clear_has_bandwidth();
}
inline float MMSTunerConfig::bandwidth() const {
  return bandwidth_;
}
inline void MMSTunerConfig::set_bandwidth(float value) {
  set_has_bandwidth();
  bandwidth_ = value;
}

// optional float sampleRate = 7;
inline bool MMSTunerConfig::has_samplerate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MMSTunerConfig::set_has_samplerate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MMSTunerConfig::clear_has_samplerate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MMSTunerConfig::clear_samplerate() {
  samplerate_ = 0;
  clear_has_samplerate();
}
inline float MMSTunerConfig::samplerate() const {
  return samplerate_;
}
inline void MMSTunerConfig::set_samplerate(float value) {
  set_has_samplerate();
  samplerate_ = value;
}

// optional int32 mmsRcvrNum = 8;
inline bool MMSTunerConfig::has_mmsrcvrnum() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MMSTunerConfig::set_has_mmsrcvrnum() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MMSTunerConfig::clear_has_mmsrcvrnum() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MMSTunerConfig::clear_mmsrcvrnum() {
  mmsrcvrnum_ = 0;
  clear_has_mmsrcvrnum();
}
inline ::google::protobuf::int32 MMSTunerConfig::mmsrcvrnum() const {
  return mmsrcvrnum_;
}
inline void MMSTunerConfig::set_mmsrcvrnum(::google::protobuf::int32 value) {
  set_has_mmsrcvrnum();
  mmsrcvrnum_ = value;
}

// optional bool usehwffts = 9 [default = false];
inline bool MMSTunerConfig::has_usehwffts() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MMSTunerConfig::set_has_usehwffts() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MMSTunerConfig::clear_has_usehwffts() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MMSTunerConfig::clear_usehwffts() {
  usehwffts_ = false;
  clear_has_usehwffts();
}
inline bool MMSTunerConfig::usehwffts() const {
  return usehwffts_;
}
inline void MMSTunerConfig::set_usehwffts(bool value) {
  set_has_usehwffts();
  usehwffts_ = value;
}

// optional bool mmsWatchdogEnabled = 10 [default = true];
inline bool MMSTunerConfig::has_mmswatchdogenabled() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MMSTunerConfig::set_has_mmswatchdogenabled() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MMSTunerConfig::clear_has_mmswatchdogenabled() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MMSTunerConfig::clear_mmswatchdogenabled() {
  mmswatchdogenabled_ = true;
  clear_has_mmswatchdogenabled();
}
inline bool MMSTunerConfig::mmswatchdogenabled() const {
  return mmswatchdogenabled_;
}
inline void MMSTunerConfig::set_mmswatchdogenabled(bool value) {
  set_has_mmswatchdogenabled();
  mmswatchdogenabled_ = value;
}

// optional float mmsWatchdogPetDeltaWarningThreshold = 11 [default = 20];
inline bool MMSTunerConfig::has_mmswatchdogpetdeltawarningthreshold() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MMSTunerConfig::set_has_mmswatchdogpetdeltawarningthreshold() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MMSTunerConfig::clear_has_mmswatchdogpetdeltawarningthreshold() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MMSTunerConfig::clear_mmswatchdogpetdeltawarningthreshold() {
  mmswatchdogpetdeltawarningthreshold_ = 20;
  clear_has_mmswatchdogpetdeltawarningthreshold();
}
inline float MMSTunerConfig::mmswatchdogpetdeltawarningthreshold() const {
  return mmswatchdogpetdeltawarningthreshold_;
}
inline void MMSTunerConfig::set_mmswatchdogpetdeltawarningthreshold(float value) {
  set_has_mmswatchdogpetdeltawarningthreshold();
  mmswatchdogpetdeltawarningthreshold_ = value;
}

// optional float mmsWatchdogPetInterval = 12 [default = 5];
inline bool MMSTunerConfig::has_mmswatchdogpetinterval() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MMSTunerConfig::set_has_mmswatchdogpetinterval() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MMSTunerConfig::clear_has_mmswatchdogpetinterval() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MMSTunerConfig::clear_mmswatchdogpetinterval() {
  mmswatchdogpetinterval_ = 5;
  clear_has_mmswatchdogpetinterval();
}
inline float MMSTunerConfig::mmswatchdogpetinterval() const {
  return mmswatchdogpetinterval_;
}
inline void MMSTunerConfig::set_mmswatchdogpetinterval(float value) {
  set_has_mmswatchdogpetinterval();
  mmswatchdogpetinterval_ = value;
}

// optional int32 mmsWatchdogTimeout = 13 [default = 30];
inline bool MMSTunerConfig::has_mmswatchdogtimeout() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MMSTunerConfig::set_has_mmswatchdogtimeout() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MMSTunerConfig::clear_has_mmswatchdogtimeout() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MMSTunerConfig::clear_mmswatchdogtimeout() {
  mmswatchdogtimeout_ = 30;
  clear_has_mmswatchdogtimeout();
}
inline ::google::protobuf::int32 MMSTunerConfig::mmswatchdogtimeout() const {
  return mmswatchdogtimeout_;
}
inline void MMSTunerConfig::set_mmswatchdogtimeout(::google::protobuf::int32 value) {
  set_has_mmswatchdogtimeout();
  mmswatchdogtimeout_ = value;
}

// optional bool xpipemonitorEnabled = 14 [default = false];
inline bool MMSTunerConfig::has_xpipemonitorenabled() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MMSTunerConfig::set_has_xpipemonitorenabled() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MMSTunerConfig::clear_has_xpipemonitorenabled() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MMSTunerConfig::clear_xpipemonitorenabled() {
  xpipemonitorenabled_ = false;
  clear_has_xpipemonitorenabled();
}
inline bool MMSTunerConfig::xpipemonitorenabled() const {
  return xpipemonitorenabled_;
}
inline void MMSTunerConfig::set_xpipemonitorenabled(bool value) {
  set_has_xpipemonitorenabled();
  xpipemonitorenabled_ = value;
}

// -------------------------------------------------------------------

// DFServiceConfig

// optional string msgName = 1 [default = "DFSERVICECONFIG"];
inline bool DFServiceConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DFServiceConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DFServiceConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DFServiceConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& DFServiceConfig::msgname() const {
  return *msgname_;
}
inline void DFServiceConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void DFServiceConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void DFServiceConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DFServiceConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* DFServiceConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void DFServiceConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 interceptTimeout = 2 [default = 300];
inline bool DFServiceConfig::has_intercepttimeout() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DFServiceConfig::set_has_intercepttimeout() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DFServiceConfig::clear_has_intercepttimeout() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DFServiceConfig::clear_intercepttimeout() {
  intercepttimeout_ = 300;
  clear_has_intercepttimeout();
}
inline ::google::protobuf::int32 DFServiceConfig::intercepttimeout() const {
  return intercepttimeout_;
}
inline void DFServiceConfig::set_intercepttimeout(::google::protobuf::int32 value) {
  set_has_intercepttimeout();
  intercepttimeout_ = value;
}

// optional int32 sigupTimeout = 3 [default = 7200];
inline bool DFServiceConfig::has_siguptimeout() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DFServiceConfig::set_has_siguptimeout() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DFServiceConfig::clear_has_siguptimeout() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DFServiceConfig::clear_siguptimeout() {
  siguptimeout_ = 7200;
  clear_has_siguptimeout();
}
inline ::google::protobuf::int32 DFServiceConfig::siguptimeout() const {
  return siguptimeout_;
}
inline void DFServiceConfig::set_siguptimeout(::google::protobuf::int32 value) {
  set_has_siguptimeout();
  siguptimeout_ = value;
}

// optional int32 sigdownTimeout = 4 [default = 120];
inline bool DFServiceConfig::has_sigdowntimeout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DFServiceConfig::set_has_sigdowntimeout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DFServiceConfig::clear_has_sigdowntimeout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DFServiceConfig::clear_sigdowntimeout() {
  sigdowntimeout_ = 120;
  clear_has_sigdowntimeout();
}
inline ::google::protobuf::int32 DFServiceConfig::sigdowntimeout() const {
  return sigdowntimeout_;
}
inline void DFServiceConfig::set_sigdowntimeout(::google::protobuf::int32 value) {
  set_has_sigdowntimeout();
  sigdowntimeout_ = value;
}

// optional string additionalBox1 = 5;
inline bool DFServiceConfig::has_additionalbox1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DFServiceConfig::set_has_additionalbox1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DFServiceConfig::clear_has_additionalbox1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DFServiceConfig::clear_additionalbox1() {
  if (additionalbox1_ != &::google::protobuf::internal::kEmptyString) {
    additionalbox1_->clear();
  }
  clear_has_additionalbox1();
}
inline const ::std::string& DFServiceConfig::additionalbox1() const {
  return *additionalbox1_;
}
inline void DFServiceConfig::set_additionalbox1(const ::std::string& value) {
  set_has_additionalbox1();
  if (additionalbox1_ == &::google::protobuf::internal::kEmptyString) {
    additionalbox1_ = new ::std::string;
  }
  additionalbox1_->assign(value);
}
inline void DFServiceConfig::set_additionalbox1(const char* value) {
  set_has_additionalbox1();
  if (additionalbox1_ == &::google::protobuf::internal::kEmptyString) {
    additionalbox1_ = new ::std::string;
  }
  additionalbox1_->assign(value);
}
inline void DFServiceConfig::set_additionalbox1(const char* value, size_t size) {
  set_has_additionalbox1();
  if (additionalbox1_ == &::google::protobuf::internal::kEmptyString) {
    additionalbox1_ = new ::std::string;
  }
  additionalbox1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DFServiceConfig::mutable_additionalbox1() {
  set_has_additionalbox1();
  if (additionalbox1_ == &::google::protobuf::internal::kEmptyString) {
    additionalbox1_ = new ::std::string;
  }
  return additionalbox1_;
}
inline ::std::string* DFServiceConfig::release_additionalbox1() {
  clear_has_additionalbox1();
  if (additionalbox1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = additionalbox1_;
    additionalbox1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DFServiceConfig::set_allocated_additionalbox1(::std::string* additionalbox1) {
  if (additionalbox1_ != &::google::protobuf::internal::kEmptyString) {
    delete additionalbox1_;
  }
  if (additionalbox1) {
    set_has_additionalbox1();
    additionalbox1_ = additionalbox1;
  } else {
    clear_has_additionalbox1();
    additionalbox1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string additionalBox2 = 6;
inline bool DFServiceConfig::has_additionalbox2() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DFServiceConfig::set_has_additionalbox2() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DFServiceConfig::clear_has_additionalbox2() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DFServiceConfig::clear_additionalbox2() {
  if (additionalbox2_ != &::google::protobuf::internal::kEmptyString) {
    additionalbox2_->clear();
  }
  clear_has_additionalbox2();
}
inline const ::std::string& DFServiceConfig::additionalbox2() const {
  return *additionalbox2_;
}
inline void DFServiceConfig::set_additionalbox2(const ::std::string& value) {
  set_has_additionalbox2();
  if (additionalbox2_ == &::google::protobuf::internal::kEmptyString) {
    additionalbox2_ = new ::std::string;
  }
  additionalbox2_->assign(value);
}
inline void DFServiceConfig::set_additionalbox2(const char* value) {
  set_has_additionalbox2();
  if (additionalbox2_ == &::google::protobuf::internal::kEmptyString) {
    additionalbox2_ = new ::std::string;
  }
  additionalbox2_->assign(value);
}
inline void DFServiceConfig::set_additionalbox2(const char* value, size_t size) {
  set_has_additionalbox2();
  if (additionalbox2_ == &::google::protobuf::internal::kEmptyString) {
    additionalbox2_ = new ::std::string;
  }
  additionalbox2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DFServiceConfig::mutable_additionalbox2() {
  set_has_additionalbox2();
  if (additionalbox2_ == &::google::protobuf::internal::kEmptyString) {
    additionalbox2_ = new ::std::string;
  }
  return additionalbox2_;
}
inline ::std::string* DFServiceConfig::release_additionalbox2() {
  clear_has_additionalbox2();
  if (additionalbox2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = additionalbox2_;
    additionalbox2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DFServiceConfig::set_allocated_additionalbox2(::std::string* additionalbox2) {
  if (additionalbox2_ != &::google::protobuf::internal::kEmptyString) {
    delete additionalbox2_;
  }
  if (additionalbox2) {
    set_has_additionalbox2();
    additionalbox2_ = additionalbox2;
  } else {
    clear_has_additionalbox2();
    additionalbox2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TechniqueConfig

// optional string msgName = 1 [default = "TECHNIQUECONFIG"];
inline bool TechniqueConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TechniqueConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TechniqueConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TechniqueConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& TechniqueConfig::msgname() const {
  return *msgname_;
}
inline void TechniqueConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void TechniqueConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void TechniqueConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TechniqueConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* TechniqueConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void TechniqueConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string platform = 2;
inline bool TechniqueConfig::has_platform() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TechniqueConfig::set_has_platform() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TechniqueConfig::clear_has_platform() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TechniqueConfig::clear_platform() {
  if (platform_ != &::google::protobuf::internal::kEmptyString) {
    platform_->clear();
  }
  clear_has_platform();
}
inline const ::std::string& TechniqueConfig::platform() const {
  return *platform_;
}
inline void TechniqueConfig::set_platform(const ::std::string& value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void TechniqueConfig::set_platform(const char* value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void TechniqueConfig::set_platform(const char* value, size_t size) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TechniqueConfig::mutable_platform() {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  return platform_;
}
inline ::std::string* TechniqueConfig::release_platform() {
  clear_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = platform_;
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TechniqueConfig::set_allocated_platform(::std::string* platform) {
  if (platform_ != &::google::protobuf::internal::kEmptyString) {
    delete platform_;
  }
  if (platform) {
    set_has_platform();
    platform_ = platform;
  } else {
    clear_has_platform();
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string method = 3;
inline bool TechniqueConfig::has_method() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TechniqueConfig::set_has_method() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TechniqueConfig::clear_has_method() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TechniqueConfig::clear_method() {
  if (method_ != &::google::protobuf::internal::kEmptyString) {
    method_->clear();
  }
  clear_has_method();
}
inline const ::std::string& TechniqueConfig::method() const {
  return *method_;
}
inline void TechniqueConfig::set_method(const ::std::string& value) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::kEmptyString) {
    method_ = new ::std::string;
  }
  method_->assign(value);
}
inline void TechniqueConfig::set_method(const char* value) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::kEmptyString) {
    method_ = new ::std::string;
  }
  method_->assign(value);
}
inline void TechniqueConfig::set_method(const char* value, size_t size) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::kEmptyString) {
    method_ = new ::std::string;
  }
  method_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TechniqueConfig::mutable_method() {
  set_has_method();
  if (method_ == &::google::protobuf::internal::kEmptyString) {
    method_ = new ::std::string;
  }
  return method_;
}
inline ::std::string* TechniqueConfig::release_method() {
  clear_has_method();
  if (method_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = method_;
    method_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TechniqueConfig::set_allocated_method(::std::string* method) {
  if (method_ != &::google::protobuf::internal::kEmptyString) {
    delete method_;
  }
  if (method) {
    set_has_method();
    method_ = method;
  } else {
    clear_has_method();
    method_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string script = 4;
inline bool TechniqueConfig::has_script() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TechniqueConfig::set_has_script() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TechniqueConfig::clear_has_script() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TechniqueConfig::clear_script() {
  if (script_ != &::google::protobuf::internal::kEmptyString) {
    script_->clear();
  }
  clear_has_script();
}
inline const ::std::string& TechniqueConfig::script() const {
  return *script_;
}
inline void TechniqueConfig::set_script(const ::std::string& value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(value);
}
inline void TechniqueConfig::set_script(const char* value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(value);
}
inline void TechniqueConfig::set_script(const char* value, size_t size) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TechniqueConfig::mutable_script() {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  return script_;
}
inline ::std::string* TechniqueConfig::release_script() {
  clear_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = script_;
    script_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TechniqueConfig::set_allocated_script(::std::string* script) {
  if (script_ != &::google::protobuf::internal::kEmptyString) {
    delete script_;
  }
  if (script) {
    set_has_script();
    script_ = script;
  } else {
    clear_has_script();
    script_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float samplerate = 5;
inline bool TechniqueConfig::has_samplerate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TechniqueConfig::set_has_samplerate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TechniqueConfig::clear_has_samplerate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TechniqueConfig::clear_samplerate() {
  samplerate_ = 0;
  clear_has_samplerate();
}
inline float TechniqueConfig::samplerate() const {
  return samplerate_;
}
inline void TechniqueConfig::set_samplerate(float value) {
  set_has_samplerate();
  samplerate_ = value;
}

// optional float inputsamplerate = 6;
inline bool TechniqueConfig::has_inputsamplerate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TechniqueConfig::set_has_inputsamplerate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TechniqueConfig::clear_has_inputsamplerate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TechniqueConfig::clear_inputsamplerate() {
  inputsamplerate_ = 0;
  clear_has_inputsamplerate();
}
inline float TechniqueConfig::inputsamplerate() const {
  return inputsamplerate_;
}
inline void TechniqueConfig::set_inputsamplerate(float value) {
  set_has_inputsamplerate();
  inputsamplerate_ = value;
}

// optional string host = 7;
inline bool TechniqueConfig::has_host() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TechniqueConfig::set_has_host() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TechniqueConfig::clear_has_host() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TechniqueConfig::clear_host() {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    host_->clear();
  }
  clear_has_host();
}
inline const ::std::string& TechniqueConfig::host() const {
  return *host_;
}
inline void TechniqueConfig::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void TechniqueConfig::set_host(const char* value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void TechniqueConfig::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TechniqueConfig::mutable_host() {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  return host_;
}
inline ::std::string* TechniqueConfig::release_host() {
  clear_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TechniqueConfig::set_allocated_host(::std::string* host) {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    delete host_;
  }
  if (host) {
    set_has_host();
    host_ = host;
  } else {
    clear_has_host();
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 port = 8;
inline bool TechniqueConfig::has_port() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TechniqueConfig::set_has_port() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TechniqueConfig::clear_has_port() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TechniqueConfig::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 TechniqueConfig::port() const {
  return port_;
}
inline void TechniqueConfig::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// optional float if_freq = 9 [default = 0];
inline bool TechniqueConfig::has_if_freq() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TechniqueConfig::set_has_if_freq() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TechniqueConfig::clear_has_if_freq() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TechniqueConfig::clear_if_freq() {
  if_freq_ = 0;
  clear_has_if_freq();
}
inline float TechniqueConfig::if_freq() const {
  return if_freq_;
}
inline void TechniqueConfig::set_if_freq(float value) {
  set_has_if_freq();
  if_freq_ = value;
}

// optional float estimatedRFMHz = 10 [default = 433];
inline bool TechniqueConfig::has_estimatedrfmhz() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TechniqueConfig::set_has_estimatedrfmhz() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TechniqueConfig::clear_has_estimatedrfmhz() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TechniqueConfig::clear_estimatedrfmhz() {
  estimatedrfmhz_ = 433;
  clear_has_estimatedrfmhz();
}
inline float TechniqueConfig::estimatedrfmhz() const {
  return estimatedrfmhz_;
}
inline void TechniqueConfig::set_estimatedrfmhz(float value) {
  set_has_estimatedrfmhz();
  estimatedrfmhz_ = value;
}

// optional int32 overrideChannel = 11 [default = -1];
inline bool TechniqueConfig::has_overridechannel() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TechniqueConfig::set_has_overridechannel() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TechniqueConfig::clear_has_overridechannel() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TechniqueConfig::clear_overridechannel() {
  overridechannel_ = -1;
  clear_has_overridechannel();
}
inline ::google::protobuf::int32 TechniqueConfig::overridechannel() const {
  return overridechannel_;
}
inline void TechniqueConfig::set_overridechannel(::google::protobuf::int32 value) {
  set_has_overridechannel();
  overridechannel_ = value;
}

// optional string capabilityId = 12 [default = "<DERIVE>"];
inline bool TechniqueConfig::has_capabilityid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TechniqueConfig::set_has_capabilityid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TechniqueConfig::clear_has_capabilityid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TechniqueConfig::clear_capabilityid() {
  if (capabilityid_ != _default_capabilityid_) {
    capabilityid_->assign(*_default_capabilityid_);
  }
  clear_has_capabilityid();
}
inline const ::std::string& TechniqueConfig::capabilityid() const {
  return *capabilityid_;
}
inline void TechniqueConfig::set_capabilityid(const ::std::string& value) {
  set_has_capabilityid();
  if (capabilityid_ == _default_capabilityid_) {
    capabilityid_ = new ::std::string;
  }
  capabilityid_->assign(value);
}
inline void TechniqueConfig::set_capabilityid(const char* value) {
  set_has_capabilityid();
  if (capabilityid_ == _default_capabilityid_) {
    capabilityid_ = new ::std::string;
  }
  capabilityid_->assign(value);
}
inline void TechniqueConfig::set_capabilityid(const char* value, size_t size) {
  set_has_capabilityid();
  if (capabilityid_ == _default_capabilityid_) {
    capabilityid_ = new ::std::string;
  }
  capabilityid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TechniqueConfig::mutable_capabilityid() {
  set_has_capabilityid();
  if (capabilityid_ == _default_capabilityid_) {
    capabilityid_ = new ::std::string(*_default_capabilityid_);
  }
  return capabilityid_;
}
inline ::std::string* TechniqueConfig::release_capabilityid() {
  clear_has_capabilityid();
  if (capabilityid_ == _default_capabilityid_) {
    return NULL;
  } else {
    ::std::string* temp = capabilityid_;
    capabilityid_ = const_cast< ::std::string*>(_default_capabilityid_);
    return temp;
  }
}
inline void TechniqueConfig::set_allocated_capabilityid(::std::string* capabilityid) {
  if (capabilityid_ != _default_capabilityid_) {
    delete capabilityid_;
  }
  if (capabilityid) {
    set_has_capabilityid();
    capabilityid_ = capabilityid;
  } else {
    clear_has_capabilityid();
    capabilityid_ = const_cast< ::std::string*>(_default_capabilityid_);
  }
}

// -------------------------------------------------------------------

// RulesEngineConfig

// optional string msgName = 1 [default = "RULESENGINECONFIG"];
inline bool RulesEngineConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RulesEngineConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RulesEngineConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RulesEngineConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& RulesEngineConfig::msgname() const {
  return *msgname_;
}
inline void RulesEngineConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RulesEngineConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RulesEngineConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RulesEngineConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* RulesEngineConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void RulesEngineConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// repeated string xmlRules = 2;
inline int RulesEngineConfig::xmlrules_size() const {
  return xmlrules_.size();
}
inline void RulesEngineConfig::clear_xmlrules() {
  xmlrules_.Clear();
}
inline const ::std::string& RulesEngineConfig::xmlrules(int index) const {
  return xmlrules_.Get(index);
}
inline ::std::string* RulesEngineConfig::mutable_xmlrules(int index) {
  return xmlrules_.Mutable(index);
}
inline void RulesEngineConfig::set_xmlrules(int index, const ::std::string& value) {
  xmlrules_.Mutable(index)->assign(value);
}
inline void RulesEngineConfig::set_xmlrules(int index, const char* value) {
  xmlrules_.Mutable(index)->assign(value);
}
inline void RulesEngineConfig::set_xmlrules(int index, const char* value, size_t size) {
  xmlrules_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RulesEngineConfig::add_xmlrules() {
  return xmlrules_.Add();
}
inline void RulesEngineConfig::add_xmlrules(const ::std::string& value) {
  xmlrules_.Add()->assign(value);
}
inline void RulesEngineConfig::add_xmlrules(const char* value) {
  xmlrules_.Add()->assign(value);
}
inline void RulesEngineConfig::add_xmlrules(const char* value, size_t size) {
  xmlrules_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RulesEngineConfig::xmlrules() const {
  return xmlrules_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RulesEngineConfig::mutable_xmlrules() {
  return &xmlrules_;
}

// -------------------------------------------------------------------

// DatabaseKeeperConfig

// optional string msgName = 1 [default = "DATABASEKEEPERCONFIG"];
inline bool DatabaseKeeperConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DatabaseKeeperConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DatabaseKeeperConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DatabaseKeeperConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& DatabaseKeeperConfig::msgname() const {
  return *msgname_;
}
inline void DatabaseKeeperConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void DatabaseKeeperConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void DatabaseKeeperConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DatabaseKeeperConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* DatabaseKeeperConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void DatabaseKeeperConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 writeInterval = 2 [default = 1];
inline bool DatabaseKeeperConfig::has_writeinterval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DatabaseKeeperConfig::set_has_writeinterval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DatabaseKeeperConfig::clear_has_writeinterval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DatabaseKeeperConfig::clear_writeinterval() {
  writeinterval_ = 1;
  clear_has_writeinterval();
}
inline ::google::protobuf::int32 DatabaseKeeperConfig::writeinterval() const {
  return writeinterval_;
}
inline void DatabaseKeeperConfig::set_writeinterval(::google::protobuf::int32 value) {
  set_has_writeinterval();
  writeinterval_ = value;
}

// optional bool disableWrite = 3 [default = false];
inline bool DatabaseKeeperConfig::has_disablewrite() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DatabaseKeeperConfig::set_has_disablewrite() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DatabaseKeeperConfig::clear_has_disablewrite() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DatabaseKeeperConfig::clear_disablewrite() {
  disablewrite_ = false;
  clear_has_disablewrite();
}
inline bool DatabaseKeeperConfig::disablewrite() const {
  return disablewrite_;
}
inline void DatabaseKeeperConfig::set_disablewrite(bool value) {
  set_has_disablewrite();
  disablewrite_ = value;
}

// -------------------------------------------------------------------

// KeplerUIConnectionConfig

// optional string msgName = 1 [default = "KEPLERUICONNECTIONCONFIG"];
inline bool KeplerUIConnectionConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeplerUIConnectionConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeplerUIConnectionConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeplerUIConnectionConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& KeplerUIConnectionConfig::msgname() const {
  return *msgname_;
}
inline void KeplerUIConnectionConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void KeplerUIConnectionConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void KeplerUIConnectionConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeplerUIConnectionConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* KeplerUIConnectionConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void KeplerUIConnectionConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// -------------------------------------------------------------------

// SensorStatusConfig

// optional string msgName = 1 [default = "SENSORSTATUSCONFIG"];
inline bool SensorStatusConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorStatusConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SensorStatusConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SensorStatusConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SensorStatusConfig::msgname() const {
  return *msgname_;
}
inline void SensorStatusConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SensorStatusConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SensorStatusConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SensorStatusConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SensorStatusConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SensorStatusConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional float lat = 2;
inline bool SensorStatusConfig::has_lat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorStatusConfig::set_has_lat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SensorStatusConfig::clear_has_lat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SensorStatusConfig::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline float SensorStatusConfig::lat() const {
  return lat_;
}
inline void SensorStatusConfig::set_lat(float value) {
  set_has_lat();
  lat_ = value;
}

// optional float lon = 3;
inline bool SensorStatusConfig::has_lon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SensorStatusConfig::set_has_lon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SensorStatusConfig::clear_has_lon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SensorStatusConfig::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline float SensorStatusConfig::lon() const {
  return lon_;
}
inline void SensorStatusConfig::set_lon(float value) {
  set_has_lon();
  lon_ = value;
}

// optional float alt = 4;
inline bool SensorStatusConfig::has_alt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SensorStatusConfig::set_has_alt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SensorStatusConfig::clear_has_alt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SensorStatusConfig::clear_alt() {
  alt_ = 0;
  clear_has_alt();
}
inline float SensorStatusConfig::alt() const {
  return alt_;
}
inline void SensorStatusConfig::set_alt(float value) {
  set_has_alt();
  alt_ = value;
}

// optional string siteId = 5;
inline bool SensorStatusConfig::has_siteid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SensorStatusConfig::set_has_siteid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SensorStatusConfig::clear_has_siteid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SensorStatusConfig::clear_siteid() {
  if (siteid_ != &::google::protobuf::internal::kEmptyString) {
    siteid_->clear();
  }
  clear_has_siteid();
}
inline const ::std::string& SensorStatusConfig::siteid() const {
  return *siteid_;
}
inline void SensorStatusConfig::set_siteid(const ::std::string& value) {
  set_has_siteid();
  if (siteid_ == &::google::protobuf::internal::kEmptyString) {
    siteid_ = new ::std::string;
  }
  siteid_->assign(value);
}
inline void SensorStatusConfig::set_siteid(const char* value) {
  set_has_siteid();
  if (siteid_ == &::google::protobuf::internal::kEmptyString) {
    siteid_ = new ::std::string;
  }
  siteid_->assign(value);
}
inline void SensorStatusConfig::set_siteid(const char* value, size_t size) {
  set_has_siteid();
  if (siteid_ == &::google::protobuf::internal::kEmptyString) {
    siteid_ = new ::std::string;
  }
  siteid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SensorStatusConfig::mutable_siteid() {
  set_has_siteid();
  if (siteid_ == &::google::protobuf::internal::kEmptyString) {
    siteid_ = new ::std::string;
  }
  return siteid_;
}
inline ::std::string* SensorStatusConfig::release_siteid() {
  clear_has_siteid();
  if (siteid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = siteid_;
    siteid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SensorStatusConfig::set_allocated_siteid(::std::string* siteid) {
  if (siteid_ != &::google::protobuf::internal::kEmptyString) {
    delete siteid_;
  }
  if (siteid) {
    set_has_siteid();
    siteid_ = siteid;
  } else {
    clear_has_siteid();
    siteid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sigAd = 6;
inline bool SensorStatusConfig::has_sigad() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SensorStatusConfig::set_has_sigad() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SensorStatusConfig::clear_has_sigad() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SensorStatusConfig::clear_sigad() {
  if (sigad_ != &::google::protobuf::internal::kEmptyString) {
    sigad_->clear();
  }
  clear_has_sigad();
}
inline const ::std::string& SensorStatusConfig::sigad() const {
  return *sigad_;
}
inline void SensorStatusConfig::set_sigad(const ::std::string& value) {
  set_has_sigad();
  if (sigad_ == &::google::protobuf::internal::kEmptyString) {
    sigad_ = new ::std::string;
  }
  sigad_->assign(value);
}
inline void SensorStatusConfig::set_sigad(const char* value) {
  set_has_sigad();
  if (sigad_ == &::google::protobuf::internal::kEmptyString) {
    sigad_ = new ::std::string;
  }
  sigad_->assign(value);
}
inline void SensorStatusConfig::set_sigad(const char* value, size_t size) {
  set_has_sigad();
  if (sigad_ == &::google::protobuf::internal::kEmptyString) {
    sigad_ = new ::std::string;
  }
  sigad_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SensorStatusConfig::mutable_sigad() {
  set_has_sigad();
  if (sigad_ == &::google::protobuf::internal::kEmptyString) {
    sigad_ = new ::std::string;
  }
  return sigad_;
}
inline ::std::string* SensorStatusConfig::release_sigad() {
  clear_has_sigad();
  if (sigad_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sigad_;
    sigad_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SensorStatusConfig::set_allocated_sigad(::std::string* sigad) {
  if (sigad_ != &::google::protobuf::internal::kEmptyString) {
    delete sigad_;
  }
  if (sigad) {
    set_has_sigad();
    sigad_ = sigad;
  } else {
    clear_has_sigad();
    sigad_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float elevation = 7;
inline bool SensorStatusConfig::has_elevation() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SensorStatusConfig::set_has_elevation() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SensorStatusConfig::clear_has_elevation() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SensorStatusConfig::clear_elevation() {
  elevation_ = 0;
  clear_has_elevation();
}
inline float SensorStatusConfig::elevation() const {
  return elevation_;
}
inline void SensorStatusConfig::set_elevation(float value) {
  set_has_elevation();
  elevation_ = value;
}

// optional float azimuth = 8;
inline bool SensorStatusConfig::has_azimuth() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SensorStatusConfig::set_has_azimuth() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SensorStatusConfig::clear_has_azimuth() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SensorStatusConfig::clear_azimuth() {
  azimuth_ = 0;
  clear_has_azimuth();
}
inline float SensorStatusConfig::azimuth() const {
  return azimuth_;
}
inline void SensorStatusConfig::set_azimuth(float value) {
  set_has_azimuth();
  azimuth_ = value;
}

// optional float beamWidth = 9;
inline bool SensorStatusConfig::has_beamwidth() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SensorStatusConfig::set_has_beamwidth() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SensorStatusConfig::clear_has_beamwidth() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SensorStatusConfig::clear_beamwidth() {
  beamwidth_ = 0;
  clear_has_beamwidth();
}
inline float SensorStatusConfig::beamwidth() const {
  return beamwidth_;
}
inline void SensorStatusConfig::set_beamwidth(float value) {
  set_has_beamwidth();
  beamwidth_ = value;
}

// optional float boreSite = 10;
inline bool SensorStatusConfig::has_boresite() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SensorStatusConfig::set_has_boresite() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SensorStatusConfig::clear_has_boresite() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SensorStatusConfig::clear_boresite() {
  boresite_ = 0;
  clear_has_boresite();
}
inline float SensorStatusConfig::boresite() const {
  return boresite_;
}
inline void SensorStatusConfig::set_boresite(float value) {
  set_has_boresite();
  boresite_ = value;
}

// -------------------------------------------------------------------

// GeoTipperConfig

// optional string msgName = 1 [default = "GEOTIPPERCONFIG"];
inline bool GeoTipperConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GeoTipperConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GeoTipperConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GeoTipperConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& GeoTipperConfig::msgname() const {
  return *msgname_;
}
inline void GeoTipperConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GeoTipperConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GeoTipperConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoTipperConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* GeoTipperConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void GeoTipperConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// repeated string sensorName = 2;
inline int GeoTipperConfig::sensorname_size() const {
  return sensorname_.size();
}
inline void GeoTipperConfig::clear_sensorname() {
  sensorname_.Clear();
}
inline const ::std::string& GeoTipperConfig::sensorname(int index) const {
  return sensorname_.Get(index);
}
inline ::std::string* GeoTipperConfig::mutable_sensorname(int index) {
  return sensorname_.Mutable(index);
}
inline void GeoTipperConfig::set_sensorname(int index, const ::std::string& value) {
  sensorname_.Mutable(index)->assign(value);
}
inline void GeoTipperConfig::set_sensorname(int index, const char* value) {
  sensorname_.Mutable(index)->assign(value);
}
inline void GeoTipperConfig::set_sensorname(int index, const char* value, size_t size) {
  sensorname_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoTipperConfig::add_sensorname() {
  return sensorname_.Add();
}
inline void GeoTipperConfig::add_sensorname(const ::std::string& value) {
  sensorname_.Add()->assign(value);
}
inline void GeoTipperConfig::add_sensorname(const char* value) {
  sensorname_.Add()->assign(value);
}
inline void GeoTipperConfig::add_sensorname(const char* value, size_t size) {
  sensorname_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GeoTipperConfig::sensorname() const {
  return sensorname_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GeoTipperConfig::mutable_sensorname() {
  return &sensorname_;
}

// optional int64 lookBack = 3 [default = 2];
inline bool GeoTipperConfig::has_lookback() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GeoTipperConfig::set_has_lookback() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GeoTipperConfig::clear_has_lookback() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GeoTipperConfig::clear_lookback() {
  lookback_ = GOOGLE_LONGLONG(2);
  clear_has_lookback();
}
inline ::google::protobuf::int64 GeoTipperConfig::lookback() const {
  return lookback_;
}
inline void GeoTipperConfig::set_lookback(::google::protobuf::int64 value) {
  set_has_lookback();
  lookback_ = value;
}

// optional bool autoAdjust = 4 [default = false];
inline bool GeoTipperConfig::has_autoadjust() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GeoTipperConfig::set_has_autoadjust() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GeoTipperConfig::clear_has_autoadjust() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GeoTipperConfig::clear_autoadjust() {
  autoadjust_ = false;
  clear_has_autoadjust();
}
inline bool GeoTipperConfig::autoadjust() const {
  return autoadjust_;
}
inline void GeoTipperConfig::set_autoadjust(bool value) {
  set_has_autoadjust();
  autoadjust_ = value;
}

// optional int64 queryInterval = 5 [default = 1];
inline bool GeoTipperConfig::has_queryinterval() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GeoTipperConfig::set_has_queryinterval() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GeoTipperConfig::clear_has_queryinterval() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GeoTipperConfig::clear_queryinterval() {
  queryinterval_ = GOOGLE_LONGLONG(1);
  clear_has_queryinterval();
}
inline ::google::protobuf::int64 GeoTipperConfig::queryinterval() const {
  return queryinterval_;
}
inline void GeoTipperConfig::set_queryinterval(::google::protobuf::int64 value) {
  set_has_queryinterval();
  queryinterval_ = value;
}

// optional int64 tipTimeout = 6 [default = 2];
inline bool GeoTipperConfig::has_tiptimeout() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GeoTipperConfig::set_has_tiptimeout() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GeoTipperConfig::clear_has_tiptimeout() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GeoTipperConfig::clear_tiptimeout() {
  tiptimeout_ = GOOGLE_LONGLONG(2);
  clear_has_tiptimeout();
}
inline ::google::protobuf::int64 GeoTipperConfig::tiptimeout() const {
  return tiptimeout_;
}
inline void GeoTipperConfig::set_tiptimeout(::google::protobuf::int64 value) {
  set_has_tiptimeout();
  tiptimeout_ = value;
}

// -------------------------------------------------------------------

// PreDClipperConfig

// optional string msgName = 1 [default = "PREDCLIPPERCONFIG"];
inline bool PreDClipperConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PreDClipperConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PreDClipperConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PreDClipperConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& PreDClipperConfig::msgname() const {
  return *msgname_;
}
inline void PreDClipperConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void PreDClipperConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void PreDClipperConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PreDClipperConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* PreDClipperConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void PreDClipperConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string fileHost = 2;
inline bool PreDClipperConfig::has_filehost() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PreDClipperConfig::set_has_filehost() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PreDClipperConfig::clear_has_filehost() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PreDClipperConfig::clear_filehost() {
  if (filehost_ != &::google::protobuf::internal::kEmptyString) {
    filehost_->clear();
  }
  clear_has_filehost();
}
inline const ::std::string& PreDClipperConfig::filehost() const {
  return *filehost_;
}
inline void PreDClipperConfig::set_filehost(const ::std::string& value) {
  set_has_filehost();
  if (filehost_ == &::google::protobuf::internal::kEmptyString) {
    filehost_ = new ::std::string;
  }
  filehost_->assign(value);
}
inline void PreDClipperConfig::set_filehost(const char* value) {
  set_has_filehost();
  if (filehost_ == &::google::protobuf::internal::kEmptyString) {
    filehost_ = new ::std::string;
  }
  filehost_->assign(value);
}
inline void PreDClipperConfig::set_filehost(const char* value, size_t size) {
  set_has_filehost();
  if (filehost_ == &::google::protobuf::internal::kEmptyString) {
    filehost_ = new ::std::string;
  }
  filehost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PreDClipperConfig::mutable_filehost() {
  set_has_filehost();
  if (filehost_ == &::google::protobuf::internal::kEmptyString) {
    filehost_ = new ::std::string;
  }
  return filehost_;
}
inline ::std::string* PreDClipperConfig::release_filehost() {
  clear_has_filehost();
  if (filehost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filehost_;
    filehost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PreDClipperConfig::set_allocated_filehost(::std::string* filehost) {
  if (filehost_ != &::google::protobuf::internal::kEmptyString) {
    delete filehost_;
  }
  if (filehost) {
    set_has_filehost();
    filehost_ = filehost;
  } else {
    clear_has_filehost();
    filehost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AmplifierConfig

// optional string msgName = 1 [default = "AMPLIFIERCONFIG"];
inline bool AmplifierConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AmplifierConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AmplifierConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AmplifierConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& AmplifierConfig::msgname() const {
  return *msgname_;
}
inline void AmplifierConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AmplifierConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AmplifierConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AmplifierConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* AmplifierConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void AmplifierConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string name = 2;
inline bool AmplifierConfig::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AmplifierConfig::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AmplifierConfig::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AmplifierConfig::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AmplifierConfig::name() const {
  return *name_;
}
inline void AmplifierConfig::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AmplifierConfig::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AmplifierConfig::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AmplifierConfig::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AmplifierConfig::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AmplifierConfig::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ip = 3;
inline bool AmplifierConfig::has_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AmplifierConfig::set_has_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AmplifierConfig::clear_has_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AmplifierConfig::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& AmplifierConfig::ip() const {
  return *ip_;
}
inline void AmplifierConfig::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void AmplifierConfig::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void AmplifierConfig::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AmplifierConfig::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* AmplifierConfig::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AmplifierConfig::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 port = 4;
inline bool AmplifierConfig::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AmplifierConfig::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AmplifierConfig::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AmplifierConfig::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 AmplifierConfig::port() const {
  return port_;
}
inline void AmplifierConfig::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// SiggenConfig

// optional string msgName = 1 [default = "SIGGENCONFIG"];
inline bool SiggenConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SiggenConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SiggenConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SiggenConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SiggenConfig::msgname() const {
  return *msgname_;
}
inline void SiggenConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SiggenConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SiggenConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SiggenConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SiggenConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SiggenConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string type = 2;
inline bool SiggenConfig::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SiggenConfig::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SiggenConfig::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SiggenConfig::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& SiggenConfig::type() const {
  return *type_;
}
inline void SiggenConfig::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void SiggenConfig::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void SiggenConfig::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SiggenConfig::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* SiggenConfig::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SiggenConfig::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 chan = 3;
inline bool SiggenConfig::has_chan() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SiggenConfig::set_has_chan() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SiggenConfig::clear_has_chan() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SiggenConfig::clear_chan() {
  chan_ = 0;
  clear_has_chan();
}
inline ::google::protobuf::int32 SiggenConfig::chan() const {
  return chan_;
}
inline void SiggenConfig::set_chan(::google::protobuf::int32 value) {
  set_has_chan();
  chan_ = value;
}

// optional string ip = 4;
inline bool SiggenConfig::has_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SiggenConfig::set_has_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SiggenConfig::clear_has_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SiggenConfig::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& SiggenConfig::ip() const {
  return *ip_;
}
inline void SiggenConfig::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void SiggenConfig::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void SiggenConfig::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SiggenConfig::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* SiggenConfig::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SiggenConfig::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float freqMHz = 5;
inline bool SiggenConfig::has_freqmhz() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SiggenConfig::set_has_freqmhz() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SiggenConfig::clear_has_freqmhz() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SiggenConfig::clear_freqmhz() {
  freqmhz_ = 0;
  clear_has_freqmhz();
}
inline float SiggenConfig::freqmhz() const {
  return freqmhz_;
}
inline void SiggenConfig::set_freqmhz(float value) {
  set_has_freqmhz();
  freqmhz_ = value;
}

// optional float powerdBm = 6;
inline bool SiggenConfig::has_powerdbm() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SiggenConfig::set_has_powerdbm() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SiggenConfig::clear_has_powerdbm() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SiggenConfig::clear_powerdbm() {
  powerdbm_ = 0;
  clear_has_powerdbm();
}
inline float SiggenConfig::powerdbm() const {
  return powerdbm_;
}
inline void SiggenConfig::set_powerdbm(float value) {
  set_has_powerdbm();
  powerdbm_ = value;
}

// -------------------------------------------------------------------

// CurrPosConfig

// optional string msgName = 1 [default = "CURRPOSCONFIG"];
inline bool CurrPosConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CurrPosConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CurrPosConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CurrPosConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& CurrPosConfig::msgname() const {
  return *msgname_;
}
inline void CurrPosConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void CurrPosConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void CurrPosConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CurrPosConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* CurrPosConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void CurrPosConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string hostname = 2;
inline bool CurrPosConfig::has_hostname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CurrPosConfig::set_has_hostname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CurrPosConfig::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CurrPosConfig::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& CurrPosConfig::hostname() const {
  return *hostname_;
}
inline void CurrPosConfig::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void CurrPosConfig::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void CurrPosConfig::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CurrPosConfig::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* CurrPosConfig::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CurrPosConfig::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 port = 3;
inline bool CurrPosConfig::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CurrPosConfig::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CurrPosConfig::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CurrPosConfig::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 CurrPosConfig::port() const {
  return port_;
}
inline void CurrPosConfig::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// optional string method = 4;
inline bool CurrPosConfig::has_method() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CurrPosConfig::set_has_method() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CurrPosConfig::clear_has_method() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CurrPosConfig::clear_method() {
  if (method_ != &::google::protobuf::internal::kEmptyString) {
    method_->clear();
  }
  clear_has_method();
}
inline const ::std::string& CurrPosConfig::method() const {
  return *method_;
}
inline void CurrPosConfig::set_method(const ::std::string& value) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::kEmptyString) {
    method_ = new ::std::string;
  }
  method_->assign(value);
}
inline void CurrPosConfig::set_method(const char* value) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::kEmptyString) {
    method_ = new ::std::string;
  }
  method_->assign(value);
}
inline void CurrPosConfig::set_method(const char* value, size_t size) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::kEmptyString) {
    method_ = new ::std::string;
  }
  method_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CurrPosConfig::mutable_method() {
  set_has_method();
  if (method_ == &::google::protobuf::internal::kEmptyString) {
    method_ = new ::std::string;
  }
  return method_;
}
inline ::std::string* CurrPosConfig::release_method() {
  clear_has_method();
  if (method_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = method_;
    method_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CurrPosConfig::set_allocated_method(::std::string* method) {
  if (method_ != &::google::protobuf::internal::kEmptyString) {
    delete method_;
  }
  if (method) {
    set_has_method();
    method_ = method;
  } else {
    clear_has_method();
    method_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ins_hostname = 5;
inline bool CurrPosConfig::has_ins_hostname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CurrPosConfig::set_has_ins_hostname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CurrPosConfig::clear_has_ins_hostname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CurrPosConfig::clear_ins_hostname() {
  if (ins_hostname_ != &::google::protobuf::internal::kEmptyString) {
    ins_hostname_->clear();
  }
  clear_has_ins_hostname();
}
inline const ::std::string& CurrPosConfig::ins_hostname() const {
  return *ins_hostname_;
}
inline void CurrPosConfig::set_ins_hostname(const ::std::string& value) {
  set_has_ins_hostname();
  if (ins_hostname_ == &::google::protobuf::internal::kEmptyString) {
    ins_hostname_ = new ::std::string;
  }
  ins_hostname_->assign(value);
}
inline void CurrPosConfig::set_ins_hostname(const char* value) {
  set_has_ins_hostname();
  if (ins_hostname_ == &::google::protobuf::internal::kEmptyString) {
    ins_hostname_ = new ::std::string;
  }
  ins_hostname_->assign(value);
}
inline void CurrPosConfig::set_ins_hostname(const char* value, size_t size) {
  set_has_ins_hostname();
  if (ins_hostname_ == &::google::protobuf::internal::kEmptyString) {
    ins_hostname_ = new ::std::string;
  }
  ins_hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CurrPosConfig::mutable_ins_hostname() {
  set_has_ins_hostname();
  if (ins_hostname_ == &::google::protobuf::internal::kEmptyString) {
    ins_hostname_ = new ::std::string;
  }
  return ins_hostname_;
}
inline ::std::string* CurrPosConfig::release_ins_hostname() {
  clear_has_ins_hostname();
  if (ins_hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ins_hostname_;
    ins_hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CurrPosConfig::set_allocated_ins_hostname(::std::string* ins_hostname) {
  if (ins_hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete ins_hostname_;
  }
  if (ins_hostname) {
    set_has_ins_hostname();
    ins_hostname_ = ins_hostname;
  } else {
    clear_has_ins_hostname();
    ins_hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 ins_port = 6;
inline bool CurrPosConfig::has_ins_port() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CurrPosConfig::set_has_ins_port() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CurrPosConfig::clear_has_ins_port() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CurrPosConfig::clear_ins_port() {
  ins_port_ = 0;
  clear_has_ins_port();
}
inline ::google::protobuf::int32 CurrPosConfig::ins_port() const {
  return ins_port_;
}
inline void CurrPosConfig::set_ins_port(::google::protobuf::int32 value) {
  set_has_ins_port();
  ins_port_ = value;
}

// optional bool orientation_enable = 7 [default = false];
inline bool CurrPosConfig::has_orientation_enable() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CurrPosConfig::set_has_orientation_enable() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CurrPosConfig::clear_has_orientation_enable() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CurrPosConfig::clear_orientation_enable() {
  orientation_enable_ = false;
  clear_has_orientation_enable();
}
inline bool CurrPosConfig::orientation_enable() const {
  return orientation_enable_;
}
inline void CurrPosConfig::set_orientation_enable(bool value) {
  set_has_orientation_enable();
  orientation_enable_ = value;
}

// optional bool vector_enable = 8 [default = false];
inline bool CurrPosConfig::has_vector_enable() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CurrPosConfig::set_has_vector_enable() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CurrPosConfig::clear_has_vector_enable() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CurrPosConfig::clear_vector_enable() {
  vector_enable_ = false;
  clear_has_vector_enable();
}
inline bool CurrPosConfig::vector_enable() const {
  return vector_enable_;
}
inline void CurrPosConfig::set_vector_enable(bool value) {
  set_has_vector_enable();
  vector_enable_ = value;
}

// optional float sim_lat = 9;
inline bool CurrPosConfig::has_sim_lat() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CurrPosConfig::set_has_sim_lat() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CurrPosConfig::clear_has_sim_lat() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CurrPosConfig::clear_sim_lat() {
  sim_lat_ = 0;
  clear_has_sim_lat();
}
inline float CurrPosConfig::sim_lat() const {
  return sim_lat_;
}
inline void CurrPosConfig::set_sim_lat(float value) {
  set_has_sim_lat();
  sim_lat_ = value;
}

// optional float sim_lon = 10;
inline bool CurrPosConfig::has_sim_lon() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CurrPosConfig::set_has_sim_lon() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CurrPosConfig::clear_has_sim_lon() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CurrPosConfig::clear_sim_lon() {
  sim_lon_ = 0;
  clear_has_sim_lon();
}
inline float CurrPosConfig::sim_lon() const {
  return sim_lon_;
}
inline void CurrPosConfig::set_sim_lon(float value) {
  set_has_sim_lon();
  sim_lon_ = value;
}

// optional float sim_alt = 11;
inline bool CurrPosConfig::has_sim_alt() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CurrPosConfig::set_has_sim_alt() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CurrPosConfig::clear_has_sim_alt() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CurrPosConfig::clear_sim_alt() {
  sim_alt_ = 0;
  clear_has_sim_alt();
}
inline float CurrPosConfig::sim_alt() const {
  return sim_alt_;
}
inline void CurrPosConfig::set_sim_alt(float value) {
  set_has_sim_alt();
  sim_alt_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace falcon_svc_msg

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_svc_msg::MacroOptions_AutoControl>() {
  return ::falcon_svc_msg::MacroOptions_AutoControl_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_svc_msg::MacroOptions_PPS>() {
  return ::falcon_svc_msg::MacroOptions_PPS_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_svc_msg::MacroOptions_Ref10m>() {
  return ::falcon_svc_msg::MacroOptions_Ref10m_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_svc_msg::MacroOptions_ExportFlags>() {
  return ::falcon_svc_msg::MacroOptions_ExportFlags_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_FalconServiceMessages_2eproto__INCLUDED
