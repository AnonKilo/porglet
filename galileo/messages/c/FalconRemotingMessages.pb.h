// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FalconRemotingMessages.proto

#ifndef PROTOBUF_FalconRemotingMessages_2eproto__INCLUDED
#define PROTOBUF_FalconRemotingMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "FalconCommonMessages.pb.h"
#include "FalconTriggerMessages.pb.h"
#include "FalconExternalsMessages.pb.h"
// @@protoc_insertion_point(includes)

namespace falcon_remoting_msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

class StatusReport;
class BlacklistStatus;
class InterceptListStatus;
class ExternalsHitListStatus;
class GlobalSignalListStatus;
class StatusChannel;
class HealthStatus;
class HealthMessage;
class HealthTest;
class SignalEvent;
class GPSPosition;
class MetadataPOF;
class KVPMetaData;
class WaypointMetaData;
class GndpointMetaData;
class RemoteMessage;
class GPSPlatPos;
class RequestPsd;
class SetAtten;
class SearchControl;
class FrequencyTune;
class PredRecord;
class PredSnap;
class VideoControl;
class FhopSettings;
class TunerLock;
class AntennaScanStatus;
class QueryMidasAppStatus;
class MidasAppStatus;
class RxStatus;
class RecordingStatus;
class SignalStatus;
class DetectionStatus;
class SearchStatus;
class VideoStatus;
class FreqHopStatus;
class FreqHopTunerStatus;
class SpecialG;
class SensorPosition;
class SensorHealth;
class HardwareStatus;
class SensorStatus;
class OrientationStatus;
class ReceiverStatus;
class FieldofView;

enum StatusReport_LogLevel {
  StatusReport_LogLevel_INFO = 0,
  StatusReport_LogLevel_WARNING = 1,
  StatusReport_LogLevel_ERROR = 2
};
bool StatusReport_LogLevel_IsValid(int value);
const StatusReport_LogLevel StatusReport_LogLevel_LogLevel_MIN = StatusReport_LogLevel_INFO;
const StatusReport_LogLevel StatusReport_LogLevel_LogLevel_MAX = StatusReport_LogLevel_ERROR;
const int StatusReport_LogLevel_LogLevel_ARRAYSIZE = StatusReport_LogLevel_LogLevel_MAX + 1;

const ::google::protobuf::EnumDescriptor* StatusReport_LogLevel_descriptor();
inline const ::std::string& StatusReport_LogLevel_Name(StatusReport_LogLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    StatusReport_LogLevel_descriptor(), value);
}
inline bool StatusReport_LogLevel_Parse(
    const ::std::string& name, StatusReport_LogLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StatusReport_LogLevel>(
    StatusReport_LogLevel_descriptor(), name, value);
}
enum StatusChannel_Status {
  StatusChannel_Status_DISABLED = -3,
  StatusChannel_Status_OPEN = -2,
  StatusChannel_Status_LAUNCHING = -1,
  StatusChannel_Status_CRASHED = 0,
  StatusChannel_Status_IDLE = 1,
  StatusChannel_Status_SEARCHING = 2,
  StatusChannel_Status_PROCESSING = 3
};
bool StatusChannel_Status_IsValid(int value);
const StatusChannel_Status StatusChannel_Status_Status_MIN = StatusChannel_Status_DISABLED;
const StatusChannel_Status StatusChannel_Status_Status_MAX = StatusChannel_Status_PROCESSING;
const int StatusChannel_Status_Status_ARRAYSIZE = StatusChannel_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* StatusChannel_Status_descriptor();
inline const ::std::string& StatusChannel_Status_Name(StatusChannel_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    StatusChannel_Status_descriptor(), value);
}
inline bool StatusChannel_Status_Parse(
    const ::std::string& name, StatusChannel_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StatusChannel_Status>(
    StatusChannel_Status_descriptor(), name, value);
}
enum HealthMessage_Code {
  HealthMessage_Code_OK = 0,
  HealthMessage_Code_WARNING = 1,
  HealthMessage_Code_CRITICAL = 2,
  HealthMessage_Code_UNKNOWN = 3
};
bool HealthMessage_Code_IsValid(int value);
const HealthMessage_Code HealthMessage_Code_Code_MIN = HealthMessage_Code_OK;
const HealthMessage_Code HealthMessage_Code_Code_MAX = HealthMessage_Code_UNKNOWN;
const int HealthMessage_Code_Code_ARRAYSIZE = HealthMessage_Code_Code_MAX + 1;

const ::google::protobuf::EnumDescriptor* HealthMessage_Code_descriptor();
inline const ::std::string& HealthMessage_Code_Name(HealthMessage_Code value) {
  return ::google::protobuf::internal::NameOfEnum(
    HealthMessage_Code_descriptor(), value);
}
inline bool HealthMessage_Code_Parse(
    const ::std::string& name, HealthMessage_Code* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HealthMessage_Code>(
    HealthMessage_Code_descriptor(), name, value);
}
enum HealthTest_Status {
  HealthTest_Status_FAILURE = -1,
  HealthTest_Status_RUNNING = 0,
  HealthTest_Status_COMPLETED = 1,
  HealthTest_Status_QUERY = 2
};
bool HealthTest_Status_IsValid(int value);
const HealthTest_Status HealthTest_Status_Status_MIN = HealthTest_Status_FAILURE;
const HealthTest_Status HealthTest_Status_Status_MAX = HealthTest_Status_QUERY;
const int HealthTest_Status_Status_ARRAYSIZE = HealthTest_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* HealthTest_Status_descriptor();
inline const ::std::string& HealthTest_Status_Name(HealthTest_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    HealthTest_Status_descriptor(), value);
}
inline bool HealthTest_Status_Parse(
    const ::std::string& name, HealthTest_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HealthTest_Status>(
    HealthTest_Status_descriptor(), name, value);
}
enum SignalEvent_Type {
  SignalEvent_Type_SIGDET = 0,
  SignalEvent_Type_SIGUP = 1,
  SignalEvent_Type_SIGDOWN = 2,
  SignalEvent_Type_SIGTIMEOUT = 3
};
bool SignalEvent_Type_IsValid(int value);
const SignalEvent_Type SignalEvent_Type_Type_MIN = SignalEvent_Type_SIGDET;
const SignalEvent_Type SignalEvent_Type_Type_MAX = SignalEvent_Type_SIGTIMEOUT;
const int SignalEvent_Type_Type_ARRAYSIZE = SignalEvent_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* SignalEvent_Type_descriptor();
inline const ::std::string& SignalEvent_Type_Name(SignalEvent_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    SignalEvent_Type_descriptor(), value);
}
inline bool SignalEvent_Type_Parse(
    const ::std::string& name, SignalEvent_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SignalEvent_Type>(
    SignalEvent_Type_descriptor(), name, value);
}
enum SetAtten_AutoAtten {
  SetAtten_AutoAtten_OFF = 1,
  SetAtten_AutoAtten_ON = 2
};
bool SetAtten_AutoAtten_IsValid(int value);
const SetAtten_AutoAtten SetAtten_AutoAtten_AutoAtten_MIN = SetAtten_AutoAtten_OFF;
const SetAtten_AutoAtten SetAtten_AutoAtten_AutoAtten_MAX = SetAtten_AutoAtten_ON;
const int SetAtten_AutoAtten_AutoAtten_ARRAYSIZE = SetAtten_AutoAtten_AutoAtten_MAX + 1;

const ::google::protobuf::EnumDescriptor* SetAtten_AutoAtten_descriptor();
inline const ::std::string& SetAtten_AutoAtten_Name(SetAtten_AutoAtten value) {
  return ::google::protobuf::internal::NameOfEnum(
    SetAtten_AutoAtten_descriptor(), value);
}
inline bool SetAtten_AutoAtten_Parse(
    const ::std::string& name, SetAtten_AutoAtten* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SetAtten_AutoAtten>(
    SetAtten_AutoAtten_descriptor(), name, value);
}
enum SearchControl_Action {
  SearchControl_Action_START = 1,
  SearchControl_Action_PAUSE = 2,
  SearchControl_Action_STEPFORWARD = 3,
  SearchControl_Action_STEPBACKWARD = 4
};
bool SearchControl_Action_IsValid(int value);
const SearchControl_Action SearchControl_Action_Action_MIN = SearchControl_Action_START;
const SearchControl_Action SearchControl_Action_Action_MAX = SearchControl_Action_STEPBACKWARD;
const int SearchControl_Action_Action_ARRAYSIZE = SearchControl_Action_Action_MAX + 1;

const ::google::protobuf::EnumDescriptor* SearchControl_Action_descriptor();
inline const ::std::string& SearchControl_Action_Name(SearchControl_Action value) {
  return ::google::protobuf::internal::NameOfEnum(
    SearchControl_Action_descriptor(), value);
}
inline bool SearchControl_Action_Parse(
    const ::std::string& name, SearchControl_Action* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SearchControl_Action>(
    SearchControl_Action_descriptor(), name, value);
}
enum PredRecord_Action {
  PredRecord_Action_START = 1,
  PredRecord_Action_STOP = 2
};
bool PredRecord_Action_IsValid(int value);
const PredRecord_Action PredRecord_Action_Action_MIN = PredRecord_Action_START;
const PredRecord_Action PredRecord_Action_Action_MAX = PredRecord_Action_STOP;
const int PredRecord_Action_Action_ARRAYSIZE = PredRecord_Action_Action_MAX + 1;

const ::google::protobuf::EnumDescriptor* PredRecord_Action_descriptor();
inline const ::std::string& PredRecord_Action_Name(PredRecord_Action value) {
  return ::google::protobuf::internal::NameOfEnum(
    PredRecord_Action_descriptor(), value);
}
inline bool PredRecord_Action_Parse(
    const ::std::string& name, PredRecord_Action* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PredRecord_Action>(
    PredRecord_Action_descriptor(), name, value);
}
enum VideoControl_Record {
  VideoControl_Record_START = 1,
  VideoControl_Record_STOP = 2
};
bool VideoControl_Record_IsValid(int value);
const VideoControl_Record VideoControl_Record_Record_MIN = VideoControl_Record_START;
const VideoControl_Record VideoControl_Record_Record_MAX = VideoControl_Record_STOP;
const int VideoControl_Record_Record_ARRAYSIZE = VideoControl_Record_Record_MAX + 1;

const ::google::protobuf::EnumDescriptor* VideoControl_Record_descriptor();
inline const ::std::string& VideoControl_Record_Name(VideoControl_Record value) {
  return ::google::protobuf::internal::NameOfEnum(
    VideoControl_Record_descriptor(), value);
}
inline bool VideoControl_Record_Parse(
    const ::std::string& name, VideoControl_Record* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VideoControl_Record>(
    VideoControl_Record_descriptor(), name, value);
}
enum VideoControl_Sync {
  VideoControl_Sync_OFF = 1,
  VideoControl_Sync_ON = 2
};
bool VideoControl_Sync_IsValid(int value);
const VideoControl_Sync VideoControl_Sync_Sync_MIN = VideoControl_Sync_OFF;
const VideoControl_Sync VideoControl_Sync_Sync_MAX = VideoControl_Sync_ON;
const int VideoControl_Sync_Sync_ARRAYSIZE = VideoControl_Sync_Sync_MAX + 1;

const ::google::protobuf::EnumDescriptor* VideoControl_Sync_descriptor();
inline const ::std::string& VideoControl_Sync_Name(VideoControl_Sync value) {
  return ::google::protobuf::internal::NameOfEnum(
    VideoControl_Sync_descriptor(), value);
}
inline bool VideoControl_Sync_Parse(
    const ::std::string& name, VideoControl_Sync* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VideoControl_Sync>(
    VideoControl_Sync_descriptor(), name, value);
}
enum VideoControl_Mode {
  VideoControl_Mode_DISABLE = 1,
  VideoControl_Mode_CONTINUOUS = 2,
  VideoControl_Mode_SNAPSHOT = 3
};
bool VideoControl_Mode_IsValid(int value);
const VideoControl_Mode VideoControl_Mode_Mode_MIN = VideoControl_Mode_DISABLE;
const VideoControl_Mode VideoControl_Mode_Mode_MAX = VideoControl_Mode_SNAPSHOT;
const int VideoControl_Mode_Mode_ARRAYSIZE = VideoControl_Mode_Mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* VideoControl_Mode_descriptor();
inline const ::std::string& VideoControl_Mode_Name(VideoControl_Mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    VideoControl_Mode_descriptor(), value);
}
inline bool VideoControl_Mode_Parse(
    const ::std::string& name, VideoControl_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VideoControl_Mode>(
    VideoControl_Mode_descriptor(), name, value);
}
enum FhopSettings_FreqHopMode {
  FhopSettings_FreqHopMode_AUTOMATIC = 1,
  FhopSettings_FreqHopMode_USER_CLICKS = 2,
  FhopSettings_FreqHopMode_MANUALLY_ENTER = 3,
  FhopSettings_FreqHopMode_RESET = 4
};
bool FhopSettings_FreqHopMode_IsValid(int value);
const FhopSettings_FreqHopMode FhopSettings_FreqHopMode_FreqHopMode_MIN = FhopSettings_FreqHopMode_AUTOMATIC;
const FhopSettings_FreqHopMode FhopSettings_FreqHopMode_FreqHopMode_MAX = FhopSettings_FreqHopMode_RESET;
const int FhopSettings_FreqHopMode_FreqHopMode_ARRAYSIZE = FhopSettings_FreqHopMode_FreqHopMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* FhopSettings_FreqHopMode_descriptor();
inline const ::std::string& FhopSettings_FreqHopMode_Name(FhopSettings_FreqHopMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    FhopSettings_FreqHopMode_descriptor(), value);
}
inline bool FhopSettings_FreqHopMode_Parse(
    const ::std::string& name, FhopSettings_FreqHopMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FhopSettings_FreqHopMode>(
    FhopSettings_FreqHopMode_descriptor(), name, value);
}
enum AntennaScanStatus_ScanStatus {
  AntennaScanStatus_ScanStatus_STANDBY = 0,
  AntennaScanStatus_ScanStatus_SCANNING = 1,
  AntennaScanStatus_ScanStatus_ENERGY = 2,
  AntennaScanStatus_ScanStatus_TRACKING = 3,
  AntennaScanStatus_ScanStatus_MOVING = 4
};
bool AntennaScanStatus_ScanStatus_IsValid(int value);
const AntennaScanStatus_ScanStatus AntennaScanStatus_ScanStatus_ScanStatus_MIN = AntennaScanStatus_ScanStatus_STANDBY;
const AntennaScanStatus_ScanStatus AntennaScanStatus_ScanStatus_ScanStatus_MAX = AntennaScanStatus_ScanStatus_MOVING;
const int AntennaScanStatus_ScanStatus_ScanStatus_ARRAYSIZE = AntennaScanStatus_ScanStatus_ScanStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* AntennaScanStatus_ScanStatus_descriptor();
inline const ::std::string& AntennaScanStatus_ScanStatus_Name(AntennaScanStatus_ScanStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    AntennaScanStatus_ScanStatus_descriptor(), value);
}
inline bool AntennaScanStatus_ScanStatus_Parse(
    const ::std::string& name, AntennaScanStatus_ScanStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AntennaScanStatus_ScanStatus>(
    AntennaScanStatus_ScanStatus_descriptor(), name, value);
}
enum AntennaScanStatus_TrackStatus {
  AntennaScanStatus_TrackStatus_OFF = 0,
  AntennaScanStatus_TrackStatus_ON = 1
};
bool AntennaScanStatus_TrackStatus_IsValid(int value);
const AntennaScanStatus_TrackStatus AntennaScanStatus_TrackStatus_TrackStatus_MIN = AntennaScanStatus_TrackStatus_OFF;
const AntennaScanStatus_TrackStatus AntennaScanStatus_TrackStatus_TrackStatus_MAX = AntennaScanStatus_TrackStatus_ON;
const int AntennaScanStatus_TrackStatus_TrackStatus_ARRAYSIZE = AntennaScanStatus_TrackStatus_TrackStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* AntennaScanStatus_TrackStatus_descriptor();
inline const ::std::string& AntennaScanStatus_TrackStatus_Name(AntennaScanStatus_TrackStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    AntennaScanStatus_TrackStatus_descriptor(), value);
}
inline bool AntennaScanStatus_TrackStatus_Parse(
    const ::std::string& name, AntennaScanStatus_TrackStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AntennaScanStatus_TrackStatus>(
    AntennaScanStatus_TrackStatus_descriptor(), name, value);
}
enum MidasAppStatus_SearchSetting {
  MidasAppStatus_SearchSetting_SEARCHING = 1,
  MidasAppStatus_SearchSetting_PAUSED = 2
};
bool MidasAppStatus_SearchSetting_IsValid(int value);
const MidasAppStatus_SearchSetting MidasAppStatus_SearchSetting_SearchSetting_MIN = MidasAppStatus_SearchSetting_SEARCHING;
const MidasAppStatus_SearchSetting MidasAppStatus_SearchSetting_SearchSetting_MAX = MidasAppStatus_SearchSetting_PAUSED;
const int MidasAppStatus_SearchSetting_SearchSetting_ARRAYSIZE = MidasAppStatus_SearchSetting_SearchSetting_MAX + 1;

const ::google::protobuf::EnumDescriptor* MidasAppStatus_SearchSetting_descriptor();
inline const ::std::string& MidasAppStatus_SearchSetting_Name(MidasAppStatus_SearchSetting value) {
  return ::google::protobuf::internal::NameOfEnum(
    MidasAppStatus_SearchSetting_descriptor(), value);
}
inline bool MidasAppStatus_SearchSetting_Parse(
    const ::std::string& name, MidasAppStatus_SearchSetting* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MidasAppStatus_SearchSetting>(
    MidasAppStatus_SearchSetting_descriptor(), name, value);
}
enum RxStatus_Status {
  RxStatus_Status_AUTOMATIC = 2,
  RxStatus_Status_MANUAL = 1
};
bool RxStatus_Status_IsValid(int value);
const RxStatus_Status RxStatus_Status_Status_MIN = RxStatus_Status_MANUAL;
const RxStatus_Status RxStatus_Status_Status_MAX = RxStatus_Status_AUTOMATIC;
const int RxStatus_Status_Status_ARRAYSIZE = RxStatus_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* RxStatus_Status_descriptor();
inline const ::std::string& RxStatus_Status_Name(RxStatus_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    RxStatus_Status_descriptor(), value);
}
inline bool RxStatus_Status_Parse(
    const ::std::string& name, RxStatus_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RxStatus_Status>(
    RxStatus_Status_descriptor(), name, value);
}
enum RecordingStatus_Status {
  RecordingStatus_Status_OFF = 0,
  RecordingStatus_Status_ON = 1
};
bool RecordingStatus_Status_IsValid(int value);
const RecordingStatus_Status RecordingStatus_Status_Status_MIN = RecordingStatus_Status_OFF;
const RecordingStatus_Status RecordingStatus_Status_Status_MAX = RecordingStatus_Status_ON;
const int RecordingStatus_Status_Status_ARRAYSIZE = RecordingStatus_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* RecordingStatus_Status_descriptor();
inline const ::std::string& RecordingStatus_Status_Name(RecordingStatus_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    RecordingStatus_Status_descriptor(), value);
}
inline bool RecordingStatus_Status_Parse(
    const ::std::string& name, RecordingStatus_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RecordingStatus_Status>(
    RecordingStatus_Status_descriptor(), name, value);
}
enum DetectionStatus_Color {
  DetectionStatus_Color_RED = 1,
  DetectionStatus_Color_YELLOW = 2,
  DetectionStatus_Color_GREEN = 3
};
bool DetectionStatus_Color_IsValid(int value);
const DetectionStatus_Color DetectionStatus_Color_Color_MIN = DetectionStatus_Color_RED;
const DetectionStatus_Color DetectionStatus_Color_Color_MAX = DetectionStatus_Color_GREEN;
const int DetectionStatus_Color_Color_ARRAYSIZE = DetectionStatus_Color_Color_MAX + 1;

const ::google::protobuf::EnumDescriptor* DetectionStatus_Color_descriptor();
inline const ::std::string& DetectionStatus_Color_Name(DetectionStatus_Color value) {
  return ::google::protobuf::internal::NameOfEnum(
    DetectionStatus_Color_descriptor(), value);
}
inline bool DetectionStatus_Color_Parse(
    const ::std::string& name, DetectionStatus_Color* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DetectionStatus_Color>(
    DetectionStatus_Color_descriptor(), name, value);
}
enum SearchStatus_Color {
  SearchStatus_Color_RED = 1,
  SearchStatus_Color_YELLOW = 2,
  SearchStatus_Color_GREEN = 3
};
bool SearchStatus_Color_IsValid(int value);
const SearchStatus_Color SearchStatus_Color_Color_MIN = SearchStatus_Color_RED;
const SearchStatus_Color SearchStatus_Color_Color_MAX = SearchStatus_Color_GREEN;
const int SearchStatus_Color_Color_ARRAYSIZE = SearchStatus_Color_Color_MAX + 1;

const ::google::protobuf::EnumDescriptor* SearchStatus_Color_descriptor();
inline const ::std::string& SearchStatus_Color_Name(SearchStatus_Color value) {
  return ::google::protobuf::internal::NameOfEnum(
    SearchStatus_Color_descriptor(), value);
}
inline bool SearchStatus_Color_Parse(
    const ::std::string& name, SearchStatus_Color* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SearchStatus_Color>(
    SearchStatus_Color_descriptor(), name, value);
}
enum VideoStatus_RecStatus {
  VideoStatus_RecStatus_VID_OFF = 0,
  VideoStatus_RecStatus_VID_ON = 1
};
bool VideoStatus_RecStatus_IsValid(int value);
const VideoStatus_RecStatus VideoStatus_RecStatus_RecStatus_MIN = VideoStatus_RecStatus_VID_OFF;
const VideoStatus_RecStatus VideoStatus_RecStatus_RecStatus_MAX = VideoStatus_RecStatus_VID_ON;
const int VideoStatus_RecStatus_RecStatus_ARRAYSIZE = VideoStatus_RecStatus_RecStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* VideoStatus_RecStatus_descriptor();
inline const ::std::string& VideoStatus_RecStatus_Name(VideoStatus_RecStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    VideoStatus_RecStatus_descriptor(), value);
}
inline bool VideoStatus_RecStatus_Parse(
    const ::std::string& name, VideoStatus_RecStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VideoStatus_RecStatus>(
    VideoStatus_RecStatus_descriptor(), name, value);
}
enum VideoStatus_SyncStatus {
  VideoStatus_SyncStatus_SYNC_OFF = 1,
  VideoStatus_SyncStatus_SYNC_ON = 2
};
bool VideoStatus_SyncStatus_IsValid(int value);
const VideoStatus_SyncStatus VideoStatus_SyncStatus_SyncStatus_MIN = VideoStatus_SyncStatus_SYNC_OFF;
const VideoStatus_SyncStatus VideoStatus_SyncStatus_SyncStatus_MAX = VideoStatus_SyncStatus_SYNC_ON;
const int VideoStatus_SyncStatus_SyncStatus_ARRAYSIZE = VideoStatus_SyncStatus_SyncStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* VideoStatus_SyncStatus_descriptor();
inline const ::std::string& VideoStatus_SyncStatus_Name(VideoStatus_SyncStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    VideoStatus_SyncStatus_descriptor(), value);
}
inline bool VideoStatus_SyncStatus_Parse(
    const ::std::string& name, VideoStatus_SyncStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VideoStatus_SyncStatus>(
    VideoStatus_SyncStatus_descriptor(), name, value);
}
enum VideoStatus_JpegMode {
  VideoStatus_JpegMode_JPEG_OFF = 1,
  VideoStatus_JpegMode_JPEG_ON = 2,
  VideoStatus_JpegMode_JPEG_SINGLE = 3
};
bool VideoStatus_JpegMode_IsValid(int value);
const VideoStatus_JpegMode VideoStatus_JpegMode_JpegMode_MIN = VideoStatus_JpegMode_JPEG_OFF;
const VideoStatus_JpegMode VideoStatus_JpegMode_JpegMode_MAX = VideoStatus_JpegMode_JPEG_SINGLE;
const int VideoStatus_JpegMode_JpegMode_ARRAYSIZE = VideoStatus_JpegMode_JpegMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* VideoStatus_JpegMode_descriptor();
inline const ::std::string& VideoStatus_JpegMode_Name(VideoStatus_JpegMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    VideoStatus_JpegMode_descriptor(), value);
}
inline bool VideoStatus_JpegMode_Parse(
    const ::std::string& name, VideoStatus_JpegMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VideoStatus_JpegMode>(
    VideoStatus_JpegMode_descriptor(), name, value);
}
enum FreqHopStatus_Mode {
  FreqHopStatus_Mode_AUTOMATIC = 1,
  FreqHopStatus_Mode_USER_CLICKS = 2,
  FreqHopStatus_Mode_MANUAL = 3
};
bool FreqHopStatus_Mode_IsValid(int value);
const FreqHopStatus_Mode FreqHopStatus_Mode_Mode_MIN = FreqHopStatus_Mode_AUTOMATIC;
const FreqHopStatus_Mode FreqHopStatus_Mode_Mode_MAX = FreqHopStatus_Mode_MANUAL;
const int FreqHopStatus_Mode_Mode_ARRAYSIZE = FreqHopStatus_Mode_Mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* FreqHopStatus_Mode_descriptor();
inline const ::std::string& FreqHopStatus_Mode_Name(FreqHopStatus_Mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    FreqHopStatus_Mode_descriptor(), value);
}
inline bool FreqHopStatus_Mode_Parse(
    const ::std::string& name, FreqHopStatus_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FreqHopStatus_Mode>(
    FreqHopStatus_Mode_descriptor(), name, value);
}
enum ReceiverStatus_GainMode {
  ReceiverStatus_GainMode_AGC = 0,
  ReceiverStatus_GainMode_MANUAL = 1
};
bool ReceiverStatus_GainMode_IsValid(int value);
const ReceiverStatus_GainMode ReceiverStatus_GainMode_GainMode_MIN = ReceiverStatus_GainMode_AGC;
const ReceiverStatus_GainMode ReceiverStatus_GainMode_GainMode_MAX = ReceiverStatus_GainMode_MANUAL;
const int ReceiverStatus_GainMode_GainMode_ARRAYSIZE = ReceiverStatus_GainMode_GainMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReceiverStatus_GainMode_descriptor();
inline const ::std::string& ReceiverStatus_GainMode_Name(ReceiverStatus_GainMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReceiverStatus_GainMode_descriptor(), value);
}
inline bool ReceiverStatus_GainMode_Parse(
    const ::std::string& name, ReceiverStatus_GainMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReceiverStatus_GainMode>(
    ReceiverStatus_GainMode_descriptor(), name, value);
}
// ===================================================================

class StatusReport : public ::google::protobuf::Message {
 public:
  StatusReport();
  virtual ~StatusReport();

  StatusReport(const StatusReport& from);

  inline StatusReport& operator=(const StatusReport& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusReport& default_instance();

  void Swap(StatusReport* other);

  // implements Message ----------------------------------------------

  StatusReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatusReport& from);
  void MergeFrom(const StatusReport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef StatusReport_LogLevel LogLevel;
  static const LogLevel INFO = StatusReport_LogLevel_INFO;
  static const LogLevel WARNING = StatusReport_LogLevel_WARNING;
  static const LogLevel ERROR = StatusReport_LogLevel_ERROR;
  static inline bool LogLevel_IsValid(int value) {
    return StatusReport_LogLevel_IsValid(value);
  }
  static const LogLevel LogLevel_MIN =
    StatusReport_LogLevel_LogLevel_MIN;
  static const LogLevel LogLevel_MAX =
    StatusReport_LogLevel_LogLevel_MAX;
  static const int LogLevel_ARRAYSIZE =
    StatusReport_LogLevel_LogLevel_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LogLevel_descriptor() {
    return StatusReport_LogLevel_descriptor();
  }
  static inline const ::std::string& LogLevel_Name(LogLevel value) {
    return StatusReport_LogLevel_Name(value);
  }
  static inline bool LogLevel_Parse(const ::std::string& name,
      LogLevel* value) {
    return StatusReport_LogLevel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "STATUS_REPORT"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional .falcon_remoting_msg.StatusReport.LogLevel level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::falcon_remoting_msg::StatusReport_LogLevel level() const;
  inline void set_level(::falcon_remoting_msg::StatusReport_LogLevel value);

  // optional string message = 4;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 4;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.StatusReport)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 channel_;
  int level_;
  ::std::string* message_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static StatusReport* default_instance_;
};
// -------------------------------------------------------------------

class BlacklistStatus : public ::google::protobuf::Message {
 public:
  BlacklistStatus();
  virtual ~BlacklistStatus();

  BlacklistStatus(const BlacklistStatus& from);

  inline BlacklistStatus& operator=(const BlacklistStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlacklistStatus& default_instance();

  void Swap(BlacklistStatus* other);

  // implements Message ----------------------------------------------

  BlacklistStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlacklistStatus& from);
  void MergeFrom(const BlacklistStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "BLACKLIST_STATUS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // repeated .falcon_common_msg.BlacklistEntry entries = 2;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 2;
  inline const ::falcon_common_msg::BlacklistEntry& entries(int index) const;
  inline ::falcon_common_msg::BlacklistEntry* mutable_entries(int index);
  inline ::falcon_common_msg::BlacklistEntry* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::BlacklistEntry >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::BlacklistEntry >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.BlacklistStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::BlacklistEntry > entries_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static BlacklistStatus* default_instance_;
};
// -------------------------------------------------------------------

class InterceptListStatus : public ::google::protobuf::Message {
 public:
  InterceptListStatus();
  virtual ~InterceptListStatus();

  InterceptListStatus(const InterceptListStatus& from);

  inline InterceptListStatus& operator=(const InterceptListStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InterceptListStatus& default_instance();

  void Swap(InterceptListStatus* other);

  // implements Message ----------------------------------------------

  InterceptListStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InterceptListStatus& from);
  void MergeFrom(const InterceptListStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "INTERCEPT_LIST_STATUS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // repeated .falcon_trigger_msg.Intercept entries = 2;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 2;
  inline const ::falcon_trigger_msg::Intercept& entries(int index) const;
  inline ::falcon_trigger_msg::Intercept* mutable_entries(int index);
  inline ::falcon_trigger_msg::Intercept* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::falcon_trigger_msg::Intercept >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::falcon_trigger_msg::Intercept >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.InterceptListStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::RepeatedPtrField< ::falcon_trigger_msg::Intercept > entries_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static InterceptListStatus* default_instance_;
};
// -------------------------------------------------------------------

class ExternalsHitListStatus : public ::google::protobuf::Message {
 public:
  ExternalsHitListStatus();
  virtual ~ExternalsHitListStatus();

  ExternalsHitListStatus(const ExternalsHitListStatus& from);

  inline ExternalsHitListStatus& operator=(const ExternalsHitListStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExternalsHitListStatus& default_instance();

  void Swap(ExternalsHitListStatus* other);

  // implements Message ----------------------------------------------

  ExternalsHitListStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExternalsHitListStatus& from);
  void MergeFrom(const ExternalsHitListStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EXTERNALS_HIT_LIST_STATUS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // repeated .falcon_externals_msg.ExternalsHit entries = 2;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 2;
  inline const ::falcon_externals_msg::ExternalsHit& entries(int index) const;
  inline ::falcon_externals_msg::ExternalsHit* mutable_entries(int index);
  inline ::falcon_externals_msg::ExternalsHit* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::falcon_externals_msg::ExternalsHit >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::falcon_externals_msg::ExternalsHit >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.ExternalsHitListStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::RepeatedPtrField< ::falcon_externals_msg::ExternalsHit > entries_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static ExternalsHitListStatus* default_instance_;
};
// -------------------------------------------------------------------

class GlobalSignalListStatus : public ::google::protobuf::Message {
 public:
  GlobalSignalListStatus();
  virtual ~GlobalSignalListStatus();

  GlobalSignalListStatus(const GlobalSignalListStatus& from);

  inline GlobalSignalListStatus& operator=(const GlobalSignalListStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GlobalSignalListStatus& default_instance();

  void Swap(GlobalSignalListStatus* other);

  // implements Message ----------------------------------------------

  GlobalSignalListStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GlobalSignalListStatus& from);
  void MergeFrom(const GlobalSignalListStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "GLOBAL_SIGNAL_LIST_STATUS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 feed_id = 2;
  inline bool has_feed_id() const;
  inline void clear_feed_id();
  static const int kFeedIdFieldNumber = 2;
  inline ::google::protobuf::int32 feed_id() const;
  inline void set_feed_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.GlobalSignalListStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_feed_id();
  inline void clear_has_feed_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 feed_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static GlobalSignalListStatus* default_instance_;
};
// -------------------------------------------------------------------

class StatusChannel : public ::google::protobuf::Message {
 public:
  StatusChannel();
  virtual ~StatusChannel();

  StatusChannel(const StatusChannel& from);

  inline StatusChannel& operator=(const StatusChannel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusChannel& default_instance();

  void Swap(StatusChannel* other);

  // implements Message ----------------------------------------------

  StatusChannel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatusChannel& from);
  void MergeFrom(const StatusChannel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef StatusChannel_Status Status;
  static const Status DISABLED = StatusChannel_Status_DISABLED;
  static const Status OPEN = StatusChannel_Status_OPEN;
  static const Status LAUNCHING = StatusChannel_Status_LAUNCHING;
  static const Status CRASHED = StatusChannel_Status_CRASHED;
  static const Status IDLE = StatusChannel_Status_IDLE;
  static const Status SEARCHING = StatusChannel_Status_SEARCHING;
  static const Status PROCESSING = StatusChannel_Status_PROCESSING;
  static inline bool Status_IsValid(int value) {
    return StatusChannel_Status_IsValid(value);
  }
  static const Status Status_MIN =
    StatusChannel_Status_Status_MIN;
  static const Status Status_MAX =
    StatusChannel_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    StatusChannel_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return StatusChannel_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return StatusChannel_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return StatusChannel_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "STATUS_CHANNEL"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 appID = 2;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 2;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional .falcon_remoting_msg.StatusChannel.Status status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::falcon_remoting_msg::StatusChannel_Status status() const;
  inline void set_status(::falcon_remoting_msg::StatusChannel_Status value);

  // optional string scrypt = 4;
  inline bool has_scrypt() const;
  inline void clear_scrypt();
  static const int kScryptFieldNumber = 4;
  inline const ::std::string& scrypt() const;
  inline void set_scrypt(const ::std::string& value);
  inline void set_scrypt(const char* value);
  inline void set_scrypt(const char* value, size_t size);
  inline ::std::string* mutable_scrypt();
  inline ::std::string* release_scrypt();
  inline void set_allocated_scrypt(::std::string* scrypt);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.StatusChannel)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_scrypt();
  inline void clear_has_scrypt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 appid_;
  int status_;
  ::std::string* scrypt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static StatusChannel* default_instance_;
};
// -------------------------------------------------------------------

class HealthStatus : public ::google::protobuf::Message {
 public:
  HealthStatus();
  virtual ~HealthStatus();

  HealthStatus(const HealthStatus& from);

  inline HealthStatus& operator=(const HealthStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HealthStatus& default_instance();

  void Swap(HealthStatus* other);

  // implements Message ----------------------------------------------

  HealthStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HealthStatus& from);
  void MergeFrom(const HealthStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "HEALTH_STATUS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional string pic = 3 [default = "NO_PIC"];
  inline bool has_pic() const;
  inline void clear_pic();
  static const int kPicFieldNumber = 3;
  inline const ::std::string& pic() const;
  inline void set_pic(const ::std::string& value);
  inline void set_pic(const char* value);
  inline void set_pic(const char* value, size_t size);
  inline ::std::string* mutable_pic();
  inline ::std::string* release_pic();
  inline void set_allocated_pic(::std::string* pic);

  // optional string ntp = 4 [default = "F"];
  inline bool has_ntp() const;
  inline void clear_ntp();
  static const int kNtpFieldNumber = 4;
  inline const ::std::string& ntp() const;
  inline void set_ntp(const ::std::string& value);
  inline void set_ntp(const char* value);
  inline void set_ntp(const char* value, size_t size);
  inline ::std::string* mutable_ntp();
  inline ::std::string* release_ntp();
  inline void set_allocated_ntp(::std::string* ntp);

  // optional string mhz = 5 [default = "F"];
  inline bool has_mhz() const;
  inline void clear_mhz();
  static const int kMhzFieldNumber = 5;
  inline const ::std::string& mhz() const;
  inline void set_mhz(const ::std::string& value);
  inline void set_mhz(const char* value);
  inline void set_mhz(const char* value, size_t size);
  inline ::std::string* mutable_mhz();
  inline ::std::string* release_mhz();
  inline void set_allocated_mhz(::std::string* mhz);

  // optional string pps = 6 [default = "F"];
  inline bool has_pps() const;
  inline void clear_pps();
  static const int kPpsFieldNumber = 6;
  inline const ::std::string& pps() const;
  inline void set_pps(const ::std::string& value);
  inline void set_pps(const char* value);
  inline void set_pps(const char* value, size_t size);
  inline ::std::string* mutable_pps();
  inline ::std::string* release_pps();
  inline void set_allocated_pps(::std::string* pps);

  // optional string serial = 7 [default = "F"];
  inline bool has_serial() const;
  inline void clear_serial();
  static const int kSerialFieldNumber = 7;
  inline const ::std::string& serial() const;
  inline void set_serial(const ::std::string& value);
  inline void set_serial(const char* value);
  inline void set_serial(const char* value, size_t size);
  inline ::std::string* mutable_serial();
  inline ::std::string* release_serial();
  inline void set_allocated_serial(::std::string* serial);

  // optional string rx = 8 [default = "F"];
  inline bool has_rx() const;
  inline void clear_rx();
  static const int kRxFieldNumber = 8;
  inline const ::std::string& rx() const;
  inline void set_rx(const ::std::string& value);
  inline void set_rx(const char* value);
  inline void set_rx(const char* value, size_t size);
  inline ::std::string* mutable_rx();
  inline ::std::string* release_rx();
  inline void set_allocated_rx(::std::string* rx);

  // optional string raid = 9 [default = "F"];
  inline bool has_raid() const;
  inline void clear_raid();
  static const int kRaidFieldNumber = 9;
  inline const ::std::string& raid() const;
  inline void set_raid(const ::std::string& value);
  inline void set_raid(const char* value);
  inline void set_raid(const char* value, size_t size);
  inline ::std::string* mutable_raid();
  inline ::std::string* release_raid();
  inline void set_allocated_raid(::std::string* raid);

  // optional string disabled = 10 [default = "UNKNOWN"];
  inline bool has_disabled() const;
  inline void clear_disabled();
  static const int kDisabledFieldNumber = 10;
  inline const ::std::string& disabled() const;
  inline void set_disabled(const ::std::string& value);
  inline void set_disabled(const char* value);
  inline void set_disabled(const char* value, size_t size);
  inline ::std::string* mutable_disabled();
  inline ::std::string* release_disabled();
  inline void set_allocated_disabled(::std::string* disabled);

  // optional int32 ssid = 11;
  inline bool has_ssid() const;
  inline void clear_ssid();
  static const int kSsidFieldNumber = 11;
  inline ::google::protobuf::int32 ssid() const;
  inline void set_ssid(::google::protobuf::int32 value);

  // optional string uniqrxid = 12;
  inline bool has_uniqrxid() const;
  inline void clear_uniqrxid();
  static const int kUniqrxidFieldNumber = 12;
  inline const ::std::string& uniqrxid() const;
  inline void set_uniqrxid(const ::std::string& value);
  inline void set_uniqrxid(const char* value);
  inline void set_uniqrxid(const char* value, size_t size);
  inline ::std::string* mutable_uniqrxid();
  inline ::std::string* release_uniqrxid();
  inline void set_allocated_uniqrxid(::std::string* uniqrxid);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.HealthStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_pic();
  inline void clear_has_pic();
  inline void set_has_ntp();
  inline void clear_has_ntp();
  inline void set_has_mhz();
  inline void clear_has_mhz();
  inline void set_has_pps();
  inline void clear_has_pps();
  inline void set_has_serial();
  inline void clear_has_serial();
  inline void set_has_rx();
  inline void clear_has_rx();
  inline void set_has_raid();
  inline void clear_has_raid();
  inline void set_has_disabled();
  inline void clear_has_disabled();
  inline void set_has_ssid();
  inline void clear_has_ssid();
  inline void set_has_uniqrxid();
  inline void clear_has_uniqrxid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* pic_;
  static ::std::string* _default_pic_;
  ::std::string* ntp_;
  static ::std::string* _default_ntp_;
  ::std::string* mhz_;
  static ::std::string* _default_mhz_;
  ::std::string* pps_;
  static ::std::string* _default_pps_;
  ::google::protobuf::int32 channel_;
  ::google::protobuf::int32 ssid_;
  ::std::string* serial_;
  static ::std::string* _default_serial_;
  ::std::string* rx_;
  static ::std::string* _default_rx_;
  ::std::string* raid_;
  static ::std::string* _default_raid_;
  ::std::string* disabled_;
  static ::std::string* _default_disabled_;
  ::std::string* uniqrxid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static HealthStatus* default_instance_;
};
// -------------------------------------------------------------------

class HealthMessage : public ::google::protobuf::Message {
 public:
  HealthMessage();
  virtual ~HealthMessage();

  HealthMessage(const HealthMessage& from);

  inline HealthMessage& operator=(const HealthMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HealthMessage& default_instance();

  void Swap(HealthMessage* other);

  // implements Message ----------------------------------------------

  HealthMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HealthMessage& from);
  void MergeFrom(const HealthMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef HealthMessage_Code Code;
  static const Code OK = HealthMessage_Code_OK;
  static const Code WARNING = HealthMessage_Code_WARNING;
  static const Code CRITICAL = HealthMessage_Code_CRITICAL;
  static const Code UNKNOWN = HealthMessage_Code_UNKNOWN;
  static inline bool Code_IsValid(int value) {
    return HealthMessage_Code_IsValid(value);
  }
  static const Code Code_MIN =
    HealthMessage_Code_Code_MIN;
  static const Code Code_MAX =
    HealthMessage_Code_Code_MAX;
  static const int Code_ARRAYSIZE =
    HealthMessage_Code_Code_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Code_descriptor() {
    return HealthMessage_Code_descriptor();
  }
  static inline const ::std::string& Code_Name(Code value) {
    return HealthMessage_Code_Name(value);
  }
  static inline bool Code_Parse(const ::std::string& name,
      Code* value) {
    return HealthMessage_Code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "HEALTH_MESSAGE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string description = 2;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 2;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional .falcon_remoting_msg.HealthMessage.Code code = 3;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 3;
  inline ::falcon_remoting_msg::HealthMessage_Code code() const;
  inline void set_code(::falcon_remoting_msg::HealthMessage_Code value);

  // optional string status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline const ::std::string& status() const;
  inline void set_status(const ::std::string& value);
  inline void set_status(const char* value);
  inline void set_status(const char* value, size_t size);
  inline ::std::string* mutable_status();
  inline ::std::string* release_status();
  inline void set_allocated_status(::std::string* status);

  // optional string type = 5 [default = "Functional"];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional string timestamp = 6;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 6;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  inline void set_allocated_timestamp(::std::string* timestamp);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.HealthMessage)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* description_;
  ::std::string* status_;
  ::std::string* type_;
  static ::std::string* _default_type_;
  ::std::string* timestamp_;
  int code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static HealthMessage* default_instance_;
};
// -------------------------------------------------------------------

class HealthTest : public ::google::protobuf::Message {
 public:
  HealthTest();
  virtual ~HealthTest();

  HealthTest(const HealthTest& from);

  inline HealthTest& operator=(const HealthTest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HealthTest& default_instance();

  void Swap(HealthTest* other);

  // implements Message ----------------------------------------------

  HealthTest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HealthTest& from);
  void MergeFrom(const HealthTest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef HealthTest_Status Status;
  static const Status FAILURE = HealthTest_Status_FAILURE;
  static const Status RUNNING = HealthTest_Status_RUNNING;
  static const Status COMPLETED = HealthTest_Status_COMPLETED;
  static const Status QUERY = HealthTest_Status_QUERY;
  static inline bool Status_IsValid(int value) {
    return HealthTest_Status_IsValid(value);
  }
  static const Status Status_MIN =
    HealthTest_Status_Status_MIN;
  static const Status Status_MAX =
    HealthTest_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    HealthTest_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return HealthTest_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return HealthTest_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return HealthTest_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "HEALTH_TEST"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional .falcon_remoting_msg.HealthTest.Status status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::falcon_remoting_msg::HealthTest_Status status() const;
  inline void set_status(::falcon_remoting_msg::HealthTest_Status value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.HealthTest)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static HealthTest* default_instance_;
};
// -------------------------------------------------------------------

class SignalEvent : public ::google::protobuf::Message {
 public:
  SignalEvent();
  virtual ~SignalEvent();

  SignalEvent(const SignalEvent& from);

  inline SignalEvent& operator=(const SignalEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignalEvent& default_instance();

  void Swap(SignalEvent* other);

  // implements Message ----------------------------------------------

  SignalEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignalEvent& from);
  void MergeFrom(const SignalEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SignalEvent_Type Type;
  static const Type SIGDET = SignalEvent_Type_SIGDET;
  static const Type SIGUP = SignalEvent_Type_SIGUP;
  static const Type SIGDOWN = SignalEvent_Type_SIGDOWN;
  static const Type SIGTIMEOUT = SignalEvent_Type_SIGTIMEOUT;
  static inline bool Type_IsValid(int value) {
    return SignalEvent_Type_IsValid(value);
  }
  static const Type Type_MIN =
    SignalEvent_Type_Type_MIN;
  static const Type Type_MAX =
    SignalEvent_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    SignalEvent_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return SignalEvent_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return SignalEvent_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return SignalEvent_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SIGNAL_EVENT"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional .falcon_remoting_msg.SignalEvent.Type eventType = 3;
  inline bool has_eventtype() const;
  inline void clear_eventtype();
  static const int kEventTypeFieldNumber = 3;
  inline ::falcon_remoting_msg::SignalEvent_Type eventtype() const;
  inline void set_eventtype(::falcon_remoting_msg::SignalEvent_Type value);

  // optional string eventID = 4;
  inline bool has_eventid() const;
  inline void clear_eventid();
  static const int kEventIDFieldNumber = 4;
  inline const ::std::string& eventid() const;
  inline void set_eventid(const ::std::string& value);
  inline void set_eventid(const char* value);
  inline void set_eventid(const char* value, size_t size);
  inline ::std::string* mutable_eventid();
  inline ::std::string* release_eventid();
  inline void set_allocated_eventid(::std::string* eventid);

  // optional string timestamp = 5;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  inline void set_allocated_timestamp(::std::string* timestamp);

  // optional string soiNum = 6;
  inline bool has_soinum() const;
  inline void clear_soinum();
  static const int kSoiNumFieldNumber = 6;
  inline const ::std::string& soinum() const;
  inline void set_soinum(const ::std::string& value);
  inline void set_soinum(const char* value);
  inline void set_soinum(const char* value, size_t size);
  inline ::std::string* mutable_soinum();
  inline ::std::string* release_soinum();
  inline void set_allocated_soinum(::std::string* soinum);

  // optional float rfMHz = 7;
  inline bool has_rfmhz() const;
  inline void clear_rfmhz();
  static const int kRfMHzFieldNumber = 7;
  inline float rfmhz() const;
  inline void set_rfmhz(float value);

  // optional float subcarMHz = 8;
  inline bool has_subcarmhz() const;
  inline void clear_subcarmhz();
  static const int kSubcarMHzFieldNumber = 8;
  inline float subcarmhz() const;
  inline void set_subcarmhz(float value);

  // optional float excurKHz = 9;
  inline bool has_excurkhz() const;
  inline void clear_excurkhz();
  static const int kExcurKHzFieldNumber = 9;
  inline float excurkhz() const;
  inline void set_excurkhz(float value);

  // optional int32 appID = 10;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 10;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional int32 antNum = 11;
  inline bool has_antnum() const;
  inline void clear_antnum();
  static const int kAntNumFieldNumber = 11;
  inline ::google::protobuf::int32 antnum() const;
  inline void set_antnum(::google::protobuf::int32 value);

  // optional float antAz = 12 [default = 0];
  inline bool has_antaz() const;
  inline void clear_antaz();
  static const int kAntAzFieldNumber = 12;
  inline float antaz() const;
  inline void set_antaz(float value);

  // optional float antEl = 13 [default = 0];
  inline bool has_antel() const;
  inline void clear_antel();
  static const int kAntElFieldNumber = 13;
  inline float antel() const;
  inline void set_antel(float value);

  // optional string globalID = 14;
  inline bool has_globalid() const;
  inline void clear_globalid();
  static const int kGlobalIDFieldNumber = 14;
  inline const ::std::string& globalid() const;
  inline void set_globalid(const ::std::string& value);
  inline void set_globalid(const char* value);
  inline void set_globalid(const char* value, size_t size);
  inline ::std::string* mutable_globalid();
  inline ::std::string* release_globalid();
  inline void set_allocated_globalid(::std::string* globalid);

  // optional string scrypt = 15;
  inline bool has_scrypt() const;
  inline void clear_scrypt();
  static const int kScryptFieldNumber = 15;
  inline const ::std::string& scrypt() const;
  inline void set_scrypt(const ::std::string& value);
  inline void set_scrypt(const char* value);
  inline void set_scrypt(const char* value, size_t size);
  inline ::std::string* mutable_scrypt();
  inline ::std::string* release_scrypt();
  inline void set_allocated_scrypt(::std::string* scrypt);

  // optional int32 exportPort = 16;
  inline bool has_exportport() const;
  inline void clear_exportport();
  static const int kExportPortFieldNumber = 16;
  inline ::google::protobuf::int32 exportport() const;
  inline void set_exportport(::google::protobuf::int32 value);

  // optional string eltex = 17;
  inline bool has_eltex() const;
  inline void clear_eltex();
  static const int kEltexFieldNumber = 17;
  inline const ::std::string& eltex() const;
  inline void set_eltex(const ::std::string& value);
  inline void set_eltex(const char* value);
  inline void set_eltex(const char* value, size_t size);
  inline ::std::string* mutable_eltex();
  inline ::std::string* release_eltex();
  inline void set_allocated_eltex(::std::string* eltex);

  // optional float bwMHz = 18;
  inline bool has_bwmhz() const;
  inline void clear_bwmhz();
  static const int kBwMHzFieldNumber = 18;
  inline float bwmhz() const;
  inline void set_bwmhz(float value);

  // optional string sensorName = 19 [default = ""];
  inline bool has_sensorname() const;
  inline void clear_sensorname();
  static const int kSensorNameFieldNumber = 19;
  inline const ::std::string& sensorname() const;
  inline void set_sensorname(const ::std::string& value);
  inline void set_sensorname(const char* value);
  inline void set_sensorname(const char* value, size_t size);
  inline ::std::string* mutable_sensorname();
  inline ::std::string* release_sensorname();
  inline void set_allocated_sensorname(::std::string* sensorname);

  // optional .falcon_externals_msg.ExternalsHit externals = 20;
  inline bool has_externals() const;
  inline void clear_externals();
  static const int kExternalsFieldNumber = 20;
  inline const ::falcon_externals_msg::ExternalsHit& externals() const;
  inline ::falcon_externals_msg::ExternalsHit* mutable_externals();
  inline ::falcon_externals_msg::ExternalsHit* release_externals();
  inline void set_allocated_externals(::falcon_externals_msg::ExternalsHit* externals);

  // optional .falcon_externals_msg.InternalsHit internals = 21;
  inline bool has_internals() const;
  inline void clear_internals();
  static const int kInternalsFieldNumber = 21;
  inline const ::falcon_externals_msg::InternalsHit& internals() const;
  inline ::falcon_externals_msg::InternalsHit* mutable_internals();
  inline ::falcon_externals_msg::InternalsHit* release_internals();
  inline void set_allocated_internals(::falcon_externals_msg::InternalsHit* internals);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.SignalEvent)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_eventtype();
  inline void clear_has_eventtype();
  inline void set_has_eventid();
  inline void clear_has_eventid();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_soinum();
  inline void clear_has_soinum();
  inline void set_has_rfmhz();
  inline void clear_has_rfmhz();
  inline void set_has_subcarmhz();
  inline void clear_has_subcarmhz();
  inline void set_has_excurkhz();
  inline void clear_has_excurkhz();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_antnum();
  inline void clear_has_antnum();
  inline void set_has_antaz();
  inline void clear_has_antaz();
  inline void set_has_antel();
  inline void clear_has_antel();
  inline void set_has_globalid();
  inline void clear_has_globalid();
  inline void set_has_scrypt();
  inline void clear_has_scrypt();
  inline void set_has_exportport();
  inline void clear_has_exportport();
  inline void set_has_eltex();
  inline void clear_has_eltex();
  inline void set_has_bwmhz();
  inline void clear_has_bwmhz();
  inline void set_has_sensorname();
  inline void clear_has_sensorname();
  inline void set_has_externals();
  inline void clear_has_externals();
  inline void set_has_internals();
  inline void clear_has_internals();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 channel_;
  int eventtype_;
  ::std::string* eventid_;
  ::std::string* timestamp_;
  ::std::string* soinum_;
  float rfmhz_;
  float subcarmhz_;
  float excurkhz_;
  ::google::protobuf::int32 appid_;
  ::google::protobuf::int32 antnum_;
  float antaz_;
  ::std::string* globalid_;
  float antel_;
  ::google::protobuf::int32 exportport_;
  ::std::string* scrypt_;
  ::std::string* eltex_;
  ::std::string* sensorname_;
  ::falcon_externals_msg::ExternalsHit* externals_;
  ::falcon_externals_msg::InternalsHit* internals_;
  float bwmhz_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static SignalEvent* default_instance_;
};
// -------------------------------------------------------------------

class GPSPosition : public ::google::protobuf::Message {
 public:
  GPSPosition();
  virtual ~GPSPosition();

  GPSPosition(const GPSPosition& from);

  inline GPSPosition& operator=(const GPSPosition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GPSPosition& default_instance();

  void Swap(GPSPosition* other);

  // implements Message ----------------------------------------------

  GPSPosition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPSPosition& from);
  void MergeFrom(const GPSPosition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "GPS_POSITION"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional string eventID = 3;
  inline bool has_eventid() const;
  inline void clear_eventid();
  static const int kEventIDFieldNumber = 3;
  inline const ::std::string& eventid() const;
  inline void set_eventid(const ::std::string& value);
  inline void set_eventid(const char* value);
  inline void set_eventid(const char* value, size_t size);
  inline ::std::string* mutable_eventid();
  inline ::std::string* release_eventid();
  inline void set_allocated_eventid(::std::string* eventid);

  // optional float latitude = 4;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 4;
  inline float latitude() const;
  inline void set_latitude(float value);

  // optional float longitude = 5;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 5;
  inline float longitude() const;
  inline void set_longitude(float value);

  // optional float altitude = 6;
  inline bool has_altitude() const;
  inline void clear_altitude();
  static const int kAltitudeFieldNumber = 6;
  inline float altitude() const;
  inline void set_altitude(float value);

  // optional float wpLatitude = 7;
  inline bool has_wplatitude() const;
  inline void clear_wplatitude();
  static const int kWpLatitudeFieldNumber = 7;
  inline float wplatitude() const;
  inline void set_wplatitude(float value);

  // optional float wpLongitude = 8;
  inline bool has_wplongitude() const;
  inline void clear_wplongitude();
  static const int kWpLongitudeFieldNumber = 8;
  inline float wplongitude() const;
  inline void set_wplongitude(float value);

  // optional float velocity = 9;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 9;
  inline float velocity() const;
  inline void set_velocity(float value);

  // optional float bearing = 10;
  inline bool has_bearing() const;
  inline void clear_bearing();
  static const int kBearingFieldNumber = 10;
  inline float bearing() const;
  inline void set_bearing(float value);

  // optional string timestamp = 11;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 11;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  inline void set_allocated_timestamp(::std::string* timestamp);

  // optional float seqnum = 12;
  inline bool has_seqnum() const;
  inline void clear_seqnum();
  static const int kSeqnumFieldNumber = 12;
  inline float seqnum() const;
  inline void set_seqnum(float value);

  // optional string soi = 13;
  inline bool has_soi() const;
  inline void clear_soi();
  static const int kSoiFieldNumber = 13;
  inline const ::std::string& soi() const;
  inline void set_soi(const ::std::string& value);
  inline void set_soi(const char* value);
  inline void set_soi(const char* value, size_t size);
  inline ::std::string* mutable_soi();
  inline ::std::string* release_soi();
  inline void set_allocated_soi(::std::string* soi);

  // optional bool isPrediction = 14 [default = false];
  inline bool has_isprediction() const;
  inline void clear_isprediction();
  static const int kIsPredictionFieldNumber = 14;
  inline bool isprediction() const;
  inline void set_isprediction(bool value);

  // optional float major = 15 [default = 0];
  inline bool has_major() const;
  inline void clear_major();
  static const int kMajorFieldNumber = 15;
  inline float major() const;
  inline void set_major(float value);

  // optional float minor = 16 [default = 0];
  inline bool has_minor() const;
  inline void clear_minor();
  static const int kMinorFieldNumber = 16;
  inline float minor() const;
  inline void set_minor(float value);

  // optional float vector = 17 [default = 0];
  inline bool has_vector() const;
  inline void clear_vector();
  static const int kVectorFieldNumber = 17;
  inline float vector() const;
  inline void set_vector(float value);

  // optional int32 antNum = 18;
  inline bool has_antnum() const;
  inline void clear_antnum();
  static const int kAntNumFieldNumber = 18;
  inline ::google::protobuf::int32 antnum() const;
  inline void set_antnum(::google::protobuf::int32 value);

  // optional float antAz = 19 [default = 0];
  inline bool has_antaz() const;
  inline void clear_antaz();
  static const int kAntAzFieldNumber = 19;
  inline float antaz() const;
  inline void set_antaz(float value);

  // optional float antEl = 20 [default = 0];
  inline bool has_antel() const;
  inline void clear_antel();
  static const int kAntElFieldNumber = 20;
  inline float antel() const;
  inline void set_antel(float value);

  // optional string globalID = 21;
  inline bool has_globalid() const;
  inline void clear_globalid();
  static const int kGlobalIDFieldNumber = 21;
  inline const ::std::string& globalid() const;
  inline void set_globalid(const ::std::string& value);
  inline void set_globalid(const char* value);
  inline void set_globalid(const char* value, size_t size);
  inline ::std::string* mutable_globalid();
  inline ::std::string* release_globalid();
  inline void set_allocated_globalid(::std::string* globalid);

  // optional int32 appID = 22;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 22;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional string sensorName = 23;
  inline bool has_sensorname() const;
  inline void clear_sensorname();
  static const int kSensorNameFieldNumber = 23;
  inline const ::std::string& sensorname() const;
  inline void set_sensorname(const ::std::string& value);
  inline void set_sensorname(const char* value);
  inline void set_sensorname(const char* value, size_t size);
  inline ::std::string* mutable_sensorname();
  inline ::std::string* release_sensorname();
  inline void set_allocated_sensorname(::std::string* sensorname);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.GPSPosition)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_eventid();
  inline void clear_has_eventid();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_altitude();
  inline void clear_has_altitude();
  inline void set_has_wplatitude();
  inline void clear_has_wplatitude();
  inline void set_has_wplongitude();
  inline void clear_has_wplongitude();
  inline void set_has_velocity();
  inline void clear_has_velocity();
  inline void set_has_bearing();
  inline void clear_has_bearing();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_seqnum();
  inline void clear_has_seqnum();
  inline void set_has_soi();
  inline void clear_has_soi();
  inline void set_has_isprediction();
  inline void clear_has_isprediction();
  inline void set_has_major();
  inline void clear_has_major();
  inline void set_has_minor();
  inline void clear_has_minor();
  inline void set_has_vector();
  inline void clear_has_vector();
  inline void set_has_antnum();
  inline void clear_has_antnum();
  inline void set_has_antaz();
  inline void clear_has_antaz();
  inline void set_has_antel();
  inline void clear_has_antel();
  inline void set_has_globalid();
  inline void clear_has_globalid();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_sensorname();
  inline void clear_has_sensorname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* eventid_;
  ::google::protobuf::int32 channel_;
  float latitude_;
  float longitude_;
  float altitude_;
  float wplatitude_;
  float wplongitude_;
  float velocity_;
  float bearing_;
  ::std::string* timestamp_;
  ::std::string* soi_;
  float seqnum_;
  bool isprediction_;
  float major_;
  float minor_;
  float vector_;
  ::google::protobuf::int32 antnum_;
  float antaz_;
  float antel_;
  ::std::string* globalid_;
  ::std::string* sensorname_;
  ::google::protobuf::int32 appid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(23 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static GPSPosition* default_instance_;
};
// -------------------------------------------------------------------

class MetadataPOF : public ::google::protobuf::Message {
 public:
  MetadataPOF();
  virtual ~MetadataPOF();

  MetadataPOF(const MetadataPOF& from);

  inline MetadataPOF& operator=(const MetadataPOF& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MetadataPOF& default_instance();

  void Swap(MetadataPOF* other);

  // implements Message ----------------------------------------------

  MetadataPOF* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MetadataPOF& from);
  void MergeFrom(const MetadataPOF& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "METADATA_POF"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional string eventID = 3;
  inline bool has_eventid() const;
  inline void clear_eventid();
  static const int kEventIDFieldNumber = 3;
  inline const ::std::string& eventid() const;
  inline void set_eventid(const ::std::string& value);
  inline void set_eventid(const char* value);
  inline void set_eventid(const char* value, size_t size);
  inline ::std::string* mutable_eventid();
  inline ::std::string* release_eventid();
  inline void set_allocated_eventid(::std::string* eventid);

  // optional int32 pof = 4;
  inline bool has_pof() const;
  inline void clear_pof();
  static const int kPofFieldNumber = 4;
  inline ::google::protobuf::int32 pof() const;
  inline void set_pof(::google::protobuf::int32 value);

  // optional int32 mode = 5;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 5;
  inline ::google::protobuf::int32 mode() const;
  inline void set_mode(::google::protobuf::int32 value);

  // optional int32 seqnum = 6;
  inline bool has_seqnum() const;
  inline void clear_seqnum();
  static const int kSeqnumFieldNumber = 6;
  inline ::google::protobuf::int32 seqnum() const;
  inline void set_seqnum(::google::protobuf::int32 value);

  // optional string soi = 7;
  inline bool has_soi() const;
  inline void clear_soi();
  static const int kSoiFieldNumber = 7;
  inline const ::std::string& soi() const;
  inline void set_soi(const ::std::string& value);
  inline void set_soi(const char* value);
  inline void set_soi(const char* value, size_t size);
  inline ::std::string* mutable_soi();
  inline ::std::string* release_soi();
  inline void set_allocated_soi(::std::string* soi);

  // optional int32 antNum = 8;
  inline bool has_antnum() const;
  inline void clear_antnum();
  static const int kAntNumFieldNumber = 8;
  inline ::google::protobuf::int32 antnum() const;
  inline void set_antnum(::google::protobuf::int32 value);

  // optional float antAz = 9 [default = 0];
  inline bool has_antaz() const;
  inline void clear_antaz();
  static const int kAntAzFieldNumber = 9;
  inline float antaz() const;
  inline void set_antaz(float value);

  // optional float antEl = 10 [default = 0];
  inline bool has_antel() const;
  inline void clear_antel();
  static const int kAntElFieldNumber = 10;
  inline float antel() const;
  inline void set_antel(float value);

  // optional string globalID = 11;
  inline bool has_globalid() const;
  inline void clear_globalid();
  static const int kGlobalIDFieldNumber = 11;
  inline const ::std::string& globalid() const;
  inline void set_globalid(const ::std::string& value);
  inline void set_globalid(const char* value);
  inline void set_globalid(const char* value, size_t size);
  inline ::std::string* mutable_globalid();
  inline ::std::string* release_globalid();
  inline void set_allocated_globalid(::std::string* globalid);

  // optional int32 appID = 12;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 12;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.MetadataPOF)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_eventid();
  inline void clear_has_eventid();
  inline void set_has_pof();
  inline void clear_has_pof();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_seqnum();
  inline void clear_has_seqnum();
  inline void set_has_soi();
  inline void clear_has_soi();
  inline void set_has_antnum();
  inline void clear_has_antnum();
  inline void set_has_antaz();
  inline void clear_has_antaz();
  inline void set_has_antel();
  inline void clear_has_antel();
  inline void set_has_globalid();
  inline void clear_has_globalid();
  inline void set_has_appid();
  inline void clear_has_appid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* eventid_;
  ::google::protobuf::int32 channel_;
  ::google::protobuf::int32 pof_;
  ::google::protobuf::int32 mode_;
  ::google::protobuf::int32 seqnum_;
  ::std::string* soi_;
  ::google::protobuf::int32 antnum_;
  float antaz_;
  ::std::string* globalid_;
  float antel_;
  ::google::protobuf::int32 appid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static MetadataPOF* default_instance_;
};
// -------------------------------------------------------------------

class KVPMetaData : public ::google::protobuf::Message {
 public:
  KVPMetaData();
  virtual ~KVPMetaData();

  KVPMetaData(const KVPMetaData& from);

  inline KVPMetaData& operator=(const KVPMetaData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KVPMetaData& default_instance();

  void Swap(KVPMetaData* other);

  // implements Message ----------------------------------------------

  KVPMetaData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KVPMetaData& from);
  void MergeFrom(const KVPMetaData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "KVP_METADATA"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string eventID = 2;
  inline bool has_eventid() const;
  inline void clear_eventid();
  static const int kEventIDFieldNumber = 2;
  inline const ::std::string& eventid() const;
  inline void set_eventid(const ::std::string& value);
  inline void set_eventid(const char* value);
  inline void set_eventid(const char* value, size_t size);
  inline ::std::string* mutable_eventid();
  inline ::std::string* release_eventid();
  inline void set_allocated_eventid(::std::string* eventid);

  // repeated string key = 3;
  inline int key_size() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 3;
  inline const ::std::string& key(int index) const;
  inline ::std::string* mutable_key(int index);
  inline void set_key(int index, const ::std::string& value);
  inline void set_key(int index, const char* value);
  inline void set_key(int index, const char* value, size_t size);
  inline ::std::string* add_key();
  inline void add_key(const ::std::string& value);
  inline void add_key(const char* value);
  inline void add_key(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& key() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_key();

  // repeated string value = 4;
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 4;
  inline const ::std::string& value(int index) const;
  inline ::std::string* mutable_value(int index);
  inline void set_value(int index, const ::std::string& value);
  inline void set_value(int index, const char* value);
  inline void set_value(int index, const char* value, size_t size);
  inline ::std::string* add_value();
  inline void add_value(const ::std::string& value);
  inline void add_value(const char* value);
  inline void add_value(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& value() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_value();

  // optional float update = 5;
  inline bool has_update() const;
  inline void clear_update();
  static const int kUpdateFieldNumber = 5;
  inline float update() const;
  inline void set_update(float value);

  // optional int32 seqnum = 6;
  inline bool has_seqnum() const;
  inline void clear_seqnum();
  static const int kSeqnumFieldNumber = 6;
  inline ::google::protobuf::int32 seqnum() const;
  inline void set_seqnum(::google::protobuf::int32 value);

  // optional string globalID = 7;
  inline bool has_globalid() const;
  inline void clear_globalid();
  static const int kGlobalIDFieldNumber = 7;
  inline const ::std::string& globalid() const;
  inline void set_globalid(const ::std::string& value);
  inline void set_globalid(const char* value);
  inline void set_globalid(const char* value, size_t size);
  inline ::std::string* mutable_globalid();
  inline ::std::string* release_globalid();
  inline void set_allocated_globalid(::std::string* globalid);

  // optional int32 appID = 8;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 8;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.KVPMetaData)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_eventid();
  inline void clear_has_eventid();
  inline void set_has_update();
  inline void clear_has_update();
  inline void set_has_seqnum();
  inline void clear_has_seqnum();
  inline void set_has_globalid();
  inline void clear_has_globalid();
  inline void set_has_appid();
  inline void clear_has_appid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* eventid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> key_;
  ::google::protobuf::RepeatedPtrField< ::std::string> value_;
  float update_;
  ::google::protobuf::int32 seqnum_;
  ::std::string* globalid_;
  ::google::protobuf::int32 appid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static KVPMetaData* default_instance_;
};
// -------------------------------------------------------------------

class WaypointMetaData : public ::google::protobuf::Message {
 public:
  WaypointMetaData();
  virtual ~WaypointMetaData();

  WaypointMetaData(const WaypointMetaData& from);

  inline WaypointMetaData& operator=(const WaypointMetaData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WaypointMetaData& default_instance();

  void Swap(WaypointMetaData* other);

  // implements Message ----------------------------------------------

  WaypointMetaData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WaypointMetaData& from);
  void MergeFrom(const WaypointMetaData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "WAYPOINT_METADATA"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string eventID = 2;
  inline bool has_eventid() const;
  inline void clear_eventid();
  static const int kEventIDFieldNumber = 2;
  inline const ::std::string& eventid() const;
  inline void set_eventid(const ::std::string& value);
  inline void set_eventid(const char* value);
  inline void set_eventid(const char* value, size_t size);
  inline ::std::string* mutable_eventid();
  inline ::std::string* release_eventid();
  inline void set_allocated_eventid(::std::string* eventid);

  // optional float waypointID = 3;
  inline bool has_waypointid() const;
  inline void clear_waypointid();
  static const int kWaypointIDFieldNumber = 3;
  inline float waypointid() const;
  inline void set_waypointid(float value);

  // optional float lat = 4;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 4;
  inline float lat() const;
  inline void set_lat(float value);

  // optional float lon = 5;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 5;
  inline float lon() const;
  inline void set_lon(float value);

  // optional float alt = 6;
  inline bool has_alt() const;
  inline void clear_alt();
  static const int kAltFieldNumber = 6;
  inline float alt() const;
  inline void set_alt(float value);

  // optional float update = 7;
  inline bool has_update() const;
  inline void clear_update();
  static const int kUpdateFieldNumber = 7;
  inline float update() const;
  inline void set_update(float value);

  // optional int32 seqnum = 8;
  inline bool has_seqnum() const;
  inline void clear_seqnum();
  static const int kSeqnumFieldNumber = 8;
  inline ::google::protobuf::int32 seqnum() const;
  inline void set_seqnum(::google::protobuf::int32 value);

  // optional string globalID = 9;
  inline bool has_globalid() const;
  inline void clear_globalid();
  static const int kGlobalIDFieldNumber = 9;
  inline const ::std::string& globalid() const;
  inline void set_globalid(const ::std::string& value);
  inline void set_globalid(const char* value);
  inline void set_globalid(const char* value, size_t size);
  inline ::std::string* mutable_globalid();
  inline ::std::string* release_globalid();
  inline void set_allocated_globalid(::std::string* globalid);

  // optional int32 appID = 10;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 10;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.WaypointMetaData)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_eventid();
  inline void clear_has_eventid();
  inline void set_has_waypointid();
  inline void clear_has_waypointid();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_alt();
  inline void clear_has_alt();
  inline void set_has_update();
  inline void clear_has_update();
  inline void set_has_seqnum();
  inline void clear_has_seqnum();
  inline void set_has_globalid();
  inline void clear_has_globalid();
  inline void set_has_appid();
  inline void clear_has_appid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* eventid_;
  float waypointid_;
  float lat_;
  float lon_;
  float alt_;
  float update_;
  ::google::protobuf::int32 seqnum_;
  ::std::string* globalid_;
  ::google::protobuf::int32 appid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static WaypointMetaData* default_instance_;
};
// -------------------------------------------------------------------

class GndpointMetaData : public ::google::protobuf::Message {
 public:
  GndpointMetaData();
  virtual ~GndpointMetaData();

  GndpointMetaData(const GndpointMetaData& from);

  inline GndpointMetaData& operator=(const GndpointMetaData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GndpointMetaData& default_instance();

  void Swap(GndpointMetaData* other);

  // implements Message ----------------------------------------------

  GndpointMetaData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GndpointMetaData& from);
  void MergeFrom(const GndpointMetaData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "GNDPOINT_METADATA"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string eventID = 2;
  inline bool has_eventid() const;
  inline void clear_eventid();
  static const int kEventIDFieldNumber = 2;
  inline const ::std::string& eventid() const;
  inline void set_eventid(const ::std::string& value);
  inline void set_eventid(const char* value);
  inline void set_eventid(const char* value, size_t size);
  inline ::std::string* mutable_eventid();
  inline ::std::string* release_eventid();
  inline void set_allocated_eventid(::std::string* eventid);

  // optional string pointID = 3;
  inline bool has_pointid() const;
  inline void clear_pointid();
  static const int kPointIDFieldNumber = 3;
  inline const ::std::string& pointid() const;
  inline void set_pointid(const ::std::string& value);
  inline void set_pointid(const char* value);
  inline void set_pointid(const char* value, size_t size);
  inline ::std::string* mutable_pointid();
  inline ::std::string* release_pointid();
  inline void set_allocated_pointid(::std::string* pointid);

  // optional float lat = 4;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 4;
  inline float lat() const;
  inline void set_lat(float value);

  // optional float lon = 5;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 5;
  inline float lon() const;
  inline void set_lon(float value);

  // optional float alt = 6;
  inline bool has_alt() const;
  inline void clear_alt();
  static const int kAltFieldNumber = 6;
  inline float alt() const;
  inline void set_alt(float value);

  // optional float update = 7;
  inline bool has_update() const;
  inline void clear_update();
  static const int kUpdateFieldNumber = 7;
  inline float update() const;
  inline void set_update(float value);

  // optional int32 seqnum = 8;
  inline bool has_seqnum() const;
  inline void clear_seqnum();
  static const int kSeqnumFieldNumber = 8;
  inline ::google::protobuf::int32 seqnum() const;
  inline void set_seqnum(::google::protobuf::int32 value);

  // optional string globalID = 9;
  inline bool has_globalid() const;
  inline void clear_globalid();
  static const int kGlobalIDFieldNumber = 9;
  inline const ::std::string& globalid() const;
  inline void set_globalid(const ::std::string& value);
  inline void set_globalid(const char* value);
  inline void set_globalid(const char* value, size_t size);
  inline ::std::string* mutable_globalid();
  inline ::std::string* release_globalid();
  inline void set_allocated_globalid(::std::string* globalid);

  // optional int32 appID = 10;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 10;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.GndpointMetaData)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_eventid();
  inline void clear_has_eventid();
  inline void set_has_pointid();
  inline void clear_has_pointid();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_alt();
  inline void clear_has_alt();
  inline void set_has_update();
  inline void clear_has_update();
  inline void set_has_seqnum();
  inline void clear_has_seqnum();
  inline void set_has_globalid();
  inline void clear_has_globalid();
  inline void set_has_appid();
  inline void clear_has_appid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* eventid_;
  ::std::string* pointid_;
  float lat_;
  float lon_;
  float alt_;
  float update_;
  ::std::string* globalid_;
  ::google::protobuf::int32 seqnum_;
  ::google::protobuf::int32 appid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static GndpointMetaData* default_instance_;
};
// -------------------------------------------------------------------

class RemoteMessage : public ::google::protobuf::Message {
 public:
  RemoteMessage();
  virtual ~RemoteMessage();

  RemoteMessage(const RemoteMessage& from);

  inline RemoteMessage& operator=(const RemoteMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoteMessage& default_instance();

  void Swap(RemoteMessage* other);

  // implements Message ----------------------------------------------

  RemoteMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoteMessage& from);
  void MergeFrom(const RemoteMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "REMOTE_MESSAGE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional bool msgPass = 2 [default = true];
  inline bool has_msgpass() const;
  inline void clear_msgpass();
  static const int kMsgPassFieldNumber = 2;
  inline bool msgpass() const;
  inline void set_msgpass(bool value);

  // optional string format = 3;
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 3;
  inline const ::std::string& format() const;
  inline void set_format(const ::std::string& value);
  inline void set_format(const char* value);
  inline void set_format(const char* value, size_t size);
  inline ::std::string* mutable_format();
  inline ::std::string* release_format();
  inline void set_allocated_format(::std::string* format);

  // repeated string content = 4;
  inline int content_size() const;
  inline void clear_content();
  static const int kContentFieldNumber = 4;
  inline const ::std::string& content(int index) const;
  inline ::std::string* mutable_content(int index);
  inline void set_content(int index, const ::std::string& value);
  inline void set_content(int index, const char* value);
  inline void set_content(int index, const char* value, size_t size);
  inline ::std::string* add_content();
  inline void add_content(const ::std::string& value);
  inline void add_content(const char* value);
  inline void add_content(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& content() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_content();

  // optional double msgID = 5;
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgIDFieldNumber = 5;
  inline double msgid() const;
  inline void set_msgid(double value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.RemoteMessage)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_msgpass();
  inline void clear_has_msgpass();
  inline void set_has_format();
  inline void clear_has_format();
  inline void set_has_msgid();
  inline void clear_has_msgid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* format_;
  ::google::protobuf::RepeatedPtrField< ::std::string> content_;
  double msgid_;
  bool msgpass_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static RemoteMessage* default_instance_;
};
// -------------------------------------------------------------------

class GPSPlatPos : public ::google::protobuf::Message {
 public:
  GPSPlatPos();
  virtual ~GPSPlatPos();

  GPSPlatPos(const GPSPlatPos& from);

  inline GPSPlatPos& operator=(const GPSPlatPos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GPSPlatPos& default_instance();

  void Swap(GPSPlatPos* other);

  // implements Message ----------------------------------------------

  GPSPlatPos* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPSPlatPos& from);
  void MergeFrom(const GPSPlatPos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "GPS_CURRENT_POSITION"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional float latitude = 2;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 2;
  inline float latitude() const;
  inline void set_latitude(float value);

  // optional float longitude = 3;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 3;
  inline float longitude() const;
  inline void set_longitude(float value);

  // optional float heading = 4;
  inline bool has_heading() const;
  inline void clear_heading();
  static const int kHeadingFieldNumber = 4;
  inline float heading() const;
  inline void set_heading(float value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.GPSPlatPos)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_heading();
  inline void clear_has_heading();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  float latitude_;
  float longitude_;
  float heading_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static GPSPlatPos* default_instance_;
};
// -------------------------------------------------------------------

class RequestPsd : public ::google::protobuf::Message {
 public:
  RequestPsd();
  virtual ~RequestPsd();

  RequestPsd(const RequestPsd& from);

  inline RequestPsd& operator=(const RequestPsd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestPsd& default_instance();

  void Swap(RequestPsd* other);

  // implements Message ----------------------------------------------

  RequestPsd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestPsd& from);
  void MergeFrom(const RequestPsd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "REQUEST_PSD"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string resID = 2;
  inline bool has_resid() const;
  inline void clear_resid();
  static const int kResIDFieldNumber = 2;
  inline const ::std::string& resid() const;
  inline void set_resid(const ::std::string& value);
  inline void set_resid(const char* value);
  inline void set_resid(const char* value, size_t size);
  inline ::std::string* mutable_resid();
  inline ::std::string* release_resid();
  inline void set_allocated_resid(::std::string* resid);

  // optional int32 archiveNum = 3;
  inline bool has_archivenum() const;
  inline void clear_archivenum();
  static const int kArchiveNumFieldNumber = 3;
  inline ::google::protobuf::int32 archivenum() const;
  inline void set_archivenum(::google::protobuf::int32 value);

  // optional int32 returnChan = 4;
  inline bool has_returnchan() const;
  inline void clear_returnchan();
  static const int kReturnChanFieldNumber = 4;
  inline ::google::protobuf::int32 returnchan() const;
  inline void set_returnchan(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.RequestPsd)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_resid();
  inline void clear_has_resid();
  inline void set_has_archivenum();
  inline void clear_has_archivenum();
  inline void set_has_returnchan();
  inline void clear_has_returnchan();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* resid_;
  ::google::protobuf::int32 archivenum_;
  ::google::protobuf::int32 returnchan_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static RequestPsd* default_instance_;
};
// -------------------------------------------------------------------

class SetAtten : public ::google::protobuf::Message {
 public:
  SetAtten();
  virtual ~SetAtten();

  SetAtten(const SetAtten& from);

  inline SetAtten& operator=(const SetAtten& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetAtten& default_instance();

  void Swap(SetAtten* other);

  // implements Message ----------------------------------------------

  SetAtten* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetAtten& from);
  void MergeFrom(const SetAtten& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SetAtten_AutoAtten AutoAtten;
  static const AutoAtten OFF = SetAtten_AutoAtten_OFF;
  static const AutoAtten ON = SetAtten_AutoAtten_ON;
  static inline bool AutoAtten_IsValid(int value) {
    return SetAtten_AutoAtten_IsValid(value);
  }
  static const AutoAtten AutoAtten_MIN =
    SetAtten_AutoAtten_AutoAtten_MIN;
  static const AutoAtten AutoAtten_MAX =
    SetAtten_AutoAtten_AutoAtten_MAX;
  static const int AutoAtten_ARRAYSIZE =
    SetAtten_AutoAtten_AutoAtten_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AutoAtten_descriptor() {
    return SetAtten_AutoAtten_descriptor();
  }
  static inline const ::std::string& AutoAtten_Name(AutoAtten value) {
    return SetAtten_AutoAtten_Name(value);
  }
  static inline bool AutoAtten_Parse(const ::std::string& name,
      AutoAtten* value) {
    return SetAtten_AutoAtten_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SET_ATTEN"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 appID = 2;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 2;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional .falcon_remoting_msg.SetAtten.AutoAtten autoAtten = 3;
  inline bool has_autoatten() const;
  inline void clear_autoatten();
  static const int kAutoAttenFieldNumber = 3;
  inline ::falcon_remoting_msg::SetAtten_AutoAtten autoatten() const;
  inline void set_autoatten(::falcon_remoting_msg::SetAtten_AutoAtten value);

  // optional int32 atten = 4;
  inline bool has_atten() const;
  inline void clear_atten();
  static const int kAttenFieldNumber = 4;
  inline ::google::protobuf::int32 atten() const;
  inline void set_atten(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.SetAtten)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_autoatten();
  inline void clear_has_autoatten();
  inline void set_has_atten();
  inline void clear_has_atten();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 appid_;
  int autoatten_;
  ::google::protobuf::int32 atten_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static SetAtten* default_instance_;
};
// -------------------------------------------------------------------

class SearchControl : public ::google::protobuf::Message {
 public:
  SearchControl();
  virtual ~SearchControl();

  SearchControl(const SearchControl& from);

  inline SearchControl& operator=(const SearchControl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchControl& default_instance();

  void Swap(SearchControl* other);

  // implements Message ----------------------------------------------

  SearchControl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SearchControl& from);
  void MergeFrom(const SearchControl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SearchControl_Action Action;
  static const Action START = SearchControl_Action_START;
  static const Action PAUSE = SearchControl_Action_PAUSE;
  static const Action STEPFORWARD = SearchControl_Action_STEPFORWARD;
  static const Action STEPBACKWARD = SearchControl_Action_STEPBACKWARD;
  static inline bool Action_IsValid(int value) {
    return SearchControl_Action_IsValid(value);
  }
  static const Action Action_MIN =
    SearchControl_Action_Action_MIN;
  static const Action Action_MAX =
    SearchControl_Action_Action_MAX;
  static const int Action_ARRAYSIZE =
    SearchControl_Action_Action_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Action_descriptor() {
    return SearchControl_Action_descriptor();
  }
  static inline const ::std::string& Action_Name(Action value) {
    return SearchControl_Action_Name(value);
  }
  static inline bool Action_Parse(const ::std::string& name,
      Action* value) {
    return SearchControl_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SEARCH_CONTROL"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 appID = 2;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 2;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional .falcon_remoting_msg.SearchControl.Action action = 3;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 3;
  inline ::falcon_remoting_msg::SearchControl_Action action() const;
  inline void set_action(::falcon_remoting_msg::SearchControl_Action value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.SearchControl)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_action();
  inline void clear_has_action();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 appid_;
  int action_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static SearchControl* default_instance_;
};
// -------------------------------------------------------------------

class FrequencyTune : public ::google::protobuf::Message {
 public:
  FrequencyTune();
  virtual ~FrequencyTune();

  FrequencyTune(const FrequencyTune& from);

  inline FrequencyTune& operator=(const FrequencyTune& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FrequencyTune& default_instance();

  void Swap(FrequencyTune* other);

  // implements Message ----------------------------------------------

  FrequencyTune* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrequencyTune& from);
  void MergeFrom(const FrequencyTune& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "FREQUENCY_TUNE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 appID = 2;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 2;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional float freq = 3;
  inline bool has_freq() const;
  inline void clear_freq();
  static const int kFreqFieldNumber = 3;
  inline float freq() const;
  inline void set_freq(float value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.FrequencyTune)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_freq();
  inline void clear_has_freq();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 appid_;
  float freq_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static FrequencyTune* default_instance_;
};
// -------------------------------------------------------------------

class PredRecord : public ::google::protobuf::Message {
 public:
  PredRecord();
  virtual ~PredRecord();

  PredRecord(const PredRecord& from);

  inline PredRecord& operator=(const PredRecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PredRecord& default_instance();

  void Swap(PredRecord* other);

  // implements Message ----------------------------------------------

  PredRecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PredRecord& from);
  void MergeFrom(const PredRecord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PredRecord_Action Action;
  static const Action START = PredRecord_Action_START;
  static const Action STOP = PredRecord_Action_STOP;
  static inline bool Action_IsValid(int value) {
    return PredRecord_Action_IsValid(value);
  }
  static const Action Action_MIN =
    PredRecord_Action_Action_MIN;
  static const Action Action_MAX =
    PredRecord_Action_Action_MAX;
  static const int Action_ARRAYSIZE =
    PredRecord_Action_Action_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Action_descriptor() {
    return PredRecord_Action_descriptor();
  }
  static inline const ::std::string& Action_Name(Action value) {
    return PredRecord_Action_Name(value);
  }
  static inline bool Action_Parse(const ::std::string& name,
      Action* value) {
    return PredRecord_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "PRED_RECORD"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 appID = 2;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 2;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional .falcon_remoting_msg.PredRecord.Action predRecord = 3;
  inline bool has_predrecord() const;
  inline void clear_predrecord();
  static const int kPredRecordFieldNumber = 3;
  inline ::falcon_remoting_msg::PredRecord_Action predrecord() const;
  inline void set_predrecord(::falcon_remoting_msg::PredRecord_Action value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.PredRecord)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_predrecord();
  inline void clear_has_predrecord();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 appid_;
  int predrecord_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static PredRecord* default_instance_;
};
// -------------------------------------------------------------------

class PredSnap : public ::google::protobuf::Message {
 public:
  PredSnap();
  virtual ~PredSnap();

  PredSnap(const PredSnap& from);

  inline PredSnap& operator=(const PredSnap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PredSnap& default_instance();

  void Swap(PredSnap* other);

  // implements Message ----------------------------------------------

  PredSnap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PredSnap& from);
  void MergeFrom(const PredSnap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "PRED_SNAP"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 appID = 2;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 2;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional int32 snapLength = 3;
  inline bool has_snaplength() const;
  inline void clear_snaplength();
  static const int kSnapLengthFieldNumber = 3;
  inline ::google::protobuf::int32 snaplength() const;
  inline void set_snaplength(::google::protobuf::int32 value);

  // optional bool takeSnap = 4;
  inline bool has_takesnap() const;
  inline void clear_takesnap();
  static const int kTakeSnapFieldNumber = 4;
  inline bool takesnap() const;
  inline void set_takesnap(bool value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.PredSnap)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_snaplength();
  inline void clear_has_snaplength();
  inline void set_has_takesnap();
  inline void clear_has_takesnap();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 appid_;
  ::google::protobuf::int32 snaplength_;
  bool takesnap_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static PredSnap* default_instance_;
};
// -------------------------------------------------------------------

class VideoControl : public ::google::protobuf::Message {
 public:
  VideoControl();
  virtual ~VideoControl();

  VideoControl(const VideoControl& from);

  inline VideoControl& operator=(const VideoControl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VideoControl& default_instance();

  void Swap(VideoControl* other);

  // implements Message ----------------------------------------------

  VideoControl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VideoControl& from);
  void MergeFrom(const VideoControl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef VideoControl_Record Record;
  static const Record START = VideoControl_Record_START;
  static const Record STOP = VideoControl_Record_STOP;
  static inline bool Record_IsValid(int value) {
    return VideoControl_Record_IsValid(value);
  }
  static const Record Record_MIN =
    VideoControl_Record_Record_MIN;
  static const Record Record_MAX =
    VideoControl_Record_Record_MAX;
  static const int Record_ARRAYSIZE =
    VideoControl_Record_Record_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Record_descriptor() {
    return VideoControl_Record_descriptor();
  }
  static inline const ::std::string& Record_Name(Record value) {
    return VideoControl_Record_Name(value);
  }
  static inline bool Record_Parse(const ::std::string& name,
      Record* value) {
    return VideoControl_Record_Parse(name, value);
  }

  typedef VideoControl_Sync Sync;
  static const Sync OFF = VideoControl_Sync_OFF;
  static const Sync ON = VideoControl_Sync_ON;
  static inline bool Sync_IsValid(int value) {
    return VideoControl_Sync_IsValid(value);
  }
  static const Sync Sync_MIN =
    VideoControl_Sync_Sync_MIN;
  static const Sync Sync_MAX =
    VideoControl_Sync_Sync_MAX;
  static const int Sync_ARRAYSIZE =
    VideoControl_Sync_Sync_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Sync_descriptor() {
    return VideoControl_Sync_descriptor();
  }
  static inline const ::std::string& Sync_Name(Sync value) {
    return VideoControl_Sync_Name(value);
  }
  static inline bool Sync_Parse(const ::std::string& name,
      Sync* value) {
    return VideoControl_Sync_Parse(name, value);
  }

  typedef VideoControl_Mode Mode;
  static const Mode DISABLE = VideoControl_Mode_DISABLE;
  static const Mode CONTINUOUS = VideoControl_Mode_CONTINUOUS;
  static const Mode SNAPSHOT = VideoControl_Mode_SNAPSHOT;
  static inline bool Mode_IsValid(int value) {
    return VideoControl_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    VideoControl_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    VideoControl_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    VideoControl_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Mode_descriptor() {
    return VideoControl_Mode_descriptor();
  }
  static inline const ::std::string& Mode_Name(Mode value) {
    return VideoControl_Mode_Name(value);
  }
  static inline bool Mode_Parse(const ::std::string& name,
      Mode* value) {
    return VideoControl_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "VIDEO_CONTROL"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 appID = 2;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 2;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional .falcon_remoting_msg.VideoControl.Record videoRecord = 3;
  inline bool has_videorecord() const;
  inline void clear_videorecord();
  static const int kVideoRecordFieldNumber = 3;
  inline ::falcon_remoting_msg::VideoControl_Record videorecord() const;
  inline void set_videorecord(::falcon_remoting_msg::VideoControl_Record value);

  // optional .falcon_remoting_msg.VideoControl.Sync videoSync = 4;
  inline bool has_videosync() const;
  inline void clear_videosync();
  static const int kVideoSyncFieldNumber = 4;
  inline ::falcon_remoting_msg::VideoControl_Sync videosync() const;
  inline void set_videosync(::falcon_remoting_msg::VideoControl_Sync value);

  // optional int32 videoIntegration = 5;
  inline bool has_videointegration() const;
  inline void clear_videointegration();
  static const int kVideoIntegrationFieldNumber = 5;
  inline ::google::protobuf::int32 videointegration() const;
  inline void set_videointegration(::google::protobuf::int32 value);

  // optional .falcon_remoting_msg.VideoControl.Mode jpegCommand = 6;
  inline bool has_jpegcommand() const;
  inline void clear_jpegcommand();
  static const int kJpegCommandFieldNumber = 6;
  inline ::falcon_remoting_msg::VideoControl_Mode jpegcommand() const;
  inline void set_jpegcommand(::falcon_remoting_msg::VideoControl_Mode value);

  // optional int32 jpegRate = 7;
  inline bool has_jpegrate() const;
  inline void clear_jpegrate();
  static const int kJpegRateFieldNumber = 7;
  inline ::google::protobuf::int32 jpegrate() const;
  inline void set_jpegrate(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.VideoControl)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_videorecord();
  inline void clear_has_videorecord();
  inline void set_has_videosync();
  inline void clear_has_videosync();
  inline void set_has_videointegration();
  inline void clear_has_videointegration();
  inline void set_has_jpegcommand();
  inline void clear_has_jpegcommand();
  inline void set_has_jpegrate();
  inline void clear_has_jpegrate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 appid_;
  int videorecord_;
  int videosync_;
  ::google::protobuf::int32 videointegration_;
  int jpegcommand_;
  ::google::protobuf::int32 jpegrate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static VideoControl* default_instance_;
};
// -------------------------------------------------------------------

class FhopSettings : public ::google::protobuf::Message {
 public:
  FhopSettings();
  virtual ~FhopSettings();

  FhopSettings(const FhopSettings& from);

  inline FhopSettings& operator=(const FhopSettings& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FhopSettings& default_instance();

  void Swap(FhopSettings* other);

  // implements Message ----------------------------------------------

  FhopSettings* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FhopSettings& from);
  void MergeFrom(const FhopSettings& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef FhopSettings_FreqHopMode FreqHopMode;
  static const FreqHopMode AUTOMATIC = FhopSettings_FreqHopMode_AUTOMATIC;
  static const FreqHopMode USER_CLICKS = FhopSettings_FreqHopMode_USER_CLICKS;
  static const FreqHopMode MANUALLY_ENTER = FhopSettings_FreqHopMode_MANUALLY_ENTER;
  static const FreqHopMode RESET = FhopSettings_FreqHopMode_RESET;
  static inline bool FreqHopMode_IsValid(int value) {
    return FhopSettings_FreqHopMode_IsValid(value);
  }
  static const FreqHopMode FreqHopMode_MIN =
    FhopSettings_FreqHopMode_FreqHopMode_MIN;
  static const FreqHopMode FreqHopMode_MAX =
    FhopSettings_FreqHopMode_FreqHopMode_MAX;
  static const int FreqHopMode_ARRAYSIZE =
    FhopSettings_FreqHopMode_FreqHopMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FreqHopMode_descriptor() {
    return FhopSettings_FreqHopMode_descriptor();
  }
  static inline const ::std::string& FreqHopMode_Name(FreqHopMode value) {
    return FhopSettings_FreqHopMode_Name(value);
  }
  static inline bool FreqHopMode_Parse(const ::std::string& name,
      FreqHopMode* value) {
    return FhopSettings_FreqHopMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "FHOP_SETTINGS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 appID = 2;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 2;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional .falcon_remoting_msg.FhopSettings.FreqHopMode freqHopMode = 3;
  inline bool has_freqhopmode() const;
  inline void clear_freqhopmode();
  static const int kFreqHopModeFieldNumber = 3;
  inline ::falcon_remoting_msg::FhopSettings_FreqHopMode freqhopmode() const;
  inline void set_freqhopmode(::falcon_remoting_msg::FhopSettings_FreqHopMode value);

  // repeated .falcon_remoting_msg.TunerLock tunerLock = 4;
  inline int tunerlock_size() const;
  inline void clear_tunerlock();
  static const int kTunerLockFieldNumber = 4;
  inline const ::falcon_remoting_msg::TunerLock& tunerlock(int index) const;
  inline ::falcon_remoting_msg::TunerLock* mutable_tunerlock(int index);
  inline ::falcon_remoting_msg::TunerLock* add_tunerlock();
  inline const ::google::protobuf::RepeatedPtrField< ::falcon_remoting_msg::TunerLock >&
      tunerlock() const;
  inline ::google::protobuf::RepeatedPtrField< ::falcon_remoting_msg::TunerLock >*
      mutable_tunerlock();

  // repeated float tunerFreq = 5;
  inline int tunerfreq_size() const;
  inline void clear_tunerfreq();
  static const int kTunerFreqFieldNumber = 5;
  inline float tunerfreq(int index) const;
  inline void set_tunerfreq(int index, float value);
  inline void add_tunerfreq(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      tunerfreq() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_tunerfreq();

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.FhopSettings)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_freqhopmode();
  inline void clear_has_freqhopmode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 appid_;
  int freqhopmode_;
  ::google::protobuf::RepeatedPtrField< ::falcon_remoting_msg::TunerLock > tunerlock_;
  ::google::protobuf::RepeatedField< float > tunerfreq_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static FhopSettings* default_instance_;
};
// -------------------------------------------------------------------

class TunerLock : public ::google::protobuf::Message {
 public:
  TunerLock();
  virtual ~TunerLock();

  TunerLock(const TunerLock& from);

  inline TunerLock& operator=(const TunerLock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TunerLock& default_instance();

  void Swap(TunerLock* other);

  // implements Message ----------------------------------------------

  TunerLock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TunerLock& from);
  void MergeFrom(const TunerLock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 tuner = 1;
  inline bool has_tuner() const;
  inline void clear_tuner();
  static const int kTunerFieldNumber = 1;
  inline ::google::protobuf::int32 tuner() const;
  inline void set_tuner(::google::protobuf::int32 value);

  // optional bool lock = 2;
  inline bool has_lock() const;
  inline void clear_lock();
  static const int kLockFieldNumber = 2;
  inline bool lock() const;
  inline void set_lock(bool value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.TunerLock)
 private:
  inline void set_has_tuner();
  inline void clear_has_tuner();
  inline void set_has_lock();
  inline void clear_has_lock();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 tuner_;
  bool lock_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static TunerLock* default_instance_;
};
// -------------------------------------------------------------------

class AntennaScanStatus : public ::google::protobuf::Message {
 public:
  AntennaScanStatus();
  virtual ~AntennaScanStatus();

  AntennaScanStatus(const AntennaScanStatus& from);

  inline AntennaScanStatus& operator=(const AntennaScanStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AntennaScanStatus& default_instance();

  void Swap(AntennaScanStatus* other);

  // implements Message ----------------------------------------------

  AntennaScanStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AntennaScanStatus& from);
  void MergeFrom(const AntennaScanStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AntennaScanStatus_ScanStatus ScanStatus;
  static const ScanStatus STANDBY = AntennaScanStatus_ScanStatus_STANDBY;
  static const ScanStatus SCANNING = AntennaScanStatus_ScanStatus_SCANNING;
  static const ScanStatus ENERGY = AntennaScanStatus_ScanStatus_ENERGY;
  static const ScanStatus TRACKING = AntennaScanStatus_ScanStatus_TRACKING;
  static const ScanStatus MOVING = AntennaScanStatus_ScanStatus_MOVING;
  static inline bool ScanStatus_IsValid(int value) {
    return AntennaScanStatus_ScanStatus_IsValid(value);
  }
  static const ScanStatus ScanStatus_MIN =
    AntennaScanStatus_ScanStatus_ScanStatus_MIN;
  static const ScanStatus ScanStatus_MAX =
    AntennaScanStatus_ScanStatus_ScanStatus_MAX;
  static const int ScanStatus_ARRAYSIZE =
    AntennaScanStatus_ScanStatus_ScanStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ScanStatus_descriptor() {
    return AntennaScanStatus_ScanStatus_descriptor();
  }
  static inline const ::std::string& ScanStatus_Name(ScanStatus value) {
    return AntennaScanStatus_ScanStatus_Name(value);
  }
  static inline bool ScanStatus_Parse(const ::std::string& name,
      ScanStatus* value) {
    return AntennaScanStatus_ScanStatus_Parse(name, value);
  }

  typedef AntennaScanStatus_TrackStatus TrackStatus;
  static const TrackStatus OFF = AntennaScanStatus_TrackStatus_OFF;
  static const TrackStatus ON = AntennaScanStatus_TrackStatus_ON;
  static inline bool TrackStatus_IsValid(int value) {
    return AntennaScanStatus_TrackStatus_IsValid(value);
  }
  static const TrackStatus TrackStatus_MIN =
    AntennaScanStatus_TrackStatus_TrackStatus_MIN;
  static const TrackStatus TrackStatus_MAX =
    AntennaScanStatus_TrackStatus_TrackStatus_MAX;
  static const int TrackStatus_ARRAYSIZE =
    AntennaScanStatus_TrackStatus_TrackStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TrackStatus_descriptor() {
    return AntennaScanStatus_TrackStatus_descriptor();
  }
  static inline const ::std::string& TrackStatus_Name(TrackStatus value) {
    return AntennaScanStatus_TrackStatus_Name(value);
  }
  static inline bool TrackStatus_Parse(const ::std::string& name,
      TrackStatus* value) {
    return AntennaScanStatus_TrackStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ANTENNA_SCAN_STATUS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 appID = 2;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 2;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional .falcon_remoting_msg.AntennaScanStatus.ScanStatus scanStatus = 3 [default = STANDBY];
  inline bool has_scanstatus() const;
  inline void clear_scanstatus();
  static const int kScanStatusFieldNumber = 3;
  inline ::falcon_remoting_msg::AntennaScanStatus_ScanStatus scanstatus() const;
  inline void set_scanstatus(::falcon_remoting_msg::AntennaScanStatus_ScanStatus value);

  // optional .falcon_remoting_msg.AntennaScanStatus.TrackStatus trackStatus = 4 [default = OFF];
  inline bool has_trackstatus() const;
  inline void clear_trackstatus();
  static const int kTrackStatusFieldNumber = 4;
  inline ::falcon_remoting_msg::AntennaScanStatus_TrackStatus trackstatus() const;
  inline void set_trackstatus(::falcon_remoting_msg::AntennaScanStatus_TrackStatus value);

  // optional float minScanAngle = 5;
  inline bool has_minscanangle() const;
  inline void clear_minscanangle();
  static const int kMinScanAngleFieldNumber = 5;
  inline float minscanangle() const;
  inline void set_minscanangle(float value);

  // optional float maxScanAngle = 6;
  inline bool has_maxscanangle() const;
  inline void clear_maxscanangle();
  static const int kMaxScanAngleFieldNumber = 6;
  inline float maxscanangle() const;
  inline void set_maxscanangle(float value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.AntennaScanStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_scanstatus();
  inline void clear_has_scanstatus();
  inline void set_has_trackstatus();
  inline void clear_has_trackstatus();
  inline void set_has_minscanangle();
  inline void clear_has_minscanangle();
  inline void set_has_maxscanangle();
  inline void clear_has_maxscanangle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 appid_;
  int scanstatus_;
  int trackstatus_;
  float minscanangle_;
  float maxscanangle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static AntennaScanStatus* default_instance_;
};
// -------------------------------------------------------------------

class QueryMidasAppStatus : public ::google::protobuf::Message {
 public:
  QueryMidasAppStatus();
  virtual ~QueryMidasAppStatus();

  QueryMidasAppStatus(const QueryMidasAppStatus& from);

  inline QueryMidasAppStatus& operator=(const QueryMidasAppStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryMidasAppStatus& default_instance();

  void Swap(QueryMidasAppStatus* other);

  // implements Message ----------------------------------------------

  QueryMidasAppStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryMidasAppStatus& from);
  void MergeFrom(const QueryMidasAppStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "QUERY_MIDAS_APP_STATUS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 appID = 2;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 2;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.QueryMidasAppStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_appid();
  inline void clear_has_appid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 appid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static QueryMidasAppStatus* default_instance_;
};
// -------------------------------------------------------------------

class MidasAppStatus : public ::google::protobuf::Message {
 public:
  MidasAppStatus();
  virtual ~MidasAppStatus();

  MidasAppStatus(const MidasAppStatus& from);

  inline MidasAppStatus& operator=(const MidasAppStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MidasAppStatus& default_instance();

  void Swap(MidasAppStatus* other);

  // implements Message ----------------------------------------------

  MidasAppStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MidasAppStatus& from);
  void MergeFrom(const MidasAppStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MidasAppStatus_SearchSetting SearchSetting;
  static const SearchSetting SEARCHING = MidasAppStatus_SearchSetting_SEARCHING;
  static const SearchSetting PAUSED = MidasAppStatus_SearchSetting_PAUSED;
  static inline bool SearchSetting_IsValid(int value) {
    return MidasAppStatus_SearchSetting_IsValid(value);
  }
  static const SearchSetting SearchSetting_MIN =
    MidasAppStatus_SearchSetting_SearchSetting_MIN;
  static const SearchSetting SearchSetting_MAX =
    MidasAppStatus_SearchSetting_SearchSetting_MAX;
  static const int SearchSetting_ARRAYSIZE =
    MidasAppStatus_SearchSetting_SearchSetting_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SearchSetting_descriptor() {
    return MidasAppStatus_SearchSetting_descriptor();
  }
  static inline const ::std::string& SearchSetting_Name(SearchSetting value) {
    return MidasAppStatus_SearchSetting_Name(value);
  }
  static inline bool SearchSetting_Parse(const ::std::string& name,
      SearchSetting* value) {
    return MidasAppStatus_SearchSetting_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "MIDAS_APP_STATUS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 appID = 2;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 2;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional .falcon_remoting_msg.RxStatus rxStat = 3;
  inline bool has_rxstat() const;
  inline void clear_rxstat();
  static const int kRxStatFieldNumber = 3;
  inline const ::falcon_remoting_msg::RxStatus& rxstat() const;
  inline ::falcon_remoting_msg::RxStatus* mutable_rxstat();
  inline ::falcon_remoting_msg::RxStatus* release_rxstat();
  inline void set_allocated_rxstat(::falcon_remoting_msg::RxStatus* rxstat);

  // optional .falcon_remoting_msg.RecordingStatus recStat = 4;
  inline bool has_recstat() const;
  inline void clear_recstat();
  static const int kRecStatFieldNumber = 4;
  inline const ::falcon_remoting_msg::RecordingStatus& recstat() const;
  inline ::falcon_remoting_msg::RecordingStatus* mutable_recstat();
  inline ::falcon_remoting_msg::RecordingStatus* release_recstat();
  inline void set_allocated_recstat(::falcon_remoting_msg::RecordingStatus* recstat);

  // optional .falcon_remoting_msg.SignalStatus sigStat = 5;
  inline bool has_sigstat() const;
  inline void clear_sigstat();
  static const int kSigStatFieldNumber = 5;
  inline const ::falcon_remoting_msg::SignalStatus& sigstat() const;
  inline ::falcon_remoting_msg::SignalStatus* mutable_sigstat();
  inline ::falcon_remoting_msg::SignalStatus* release_sigstat();
  inline void set_allocated_sigstat(::falcon_remoting_msg::SignalStatus* sigstat);

  // optional .falcon_remoting_msg.VideoStatus vidStat = 6;
  inline bool has_vidstat() const;
  inline void clear_vidstat();
  static const int kVidStatFieldNumber = 6;
  inline const ::falcon_remoting_msg::VideoStatus& vidstat() const;
  inline ::falcon_remoting_msg::VideoStatus* mutable_vidstat();
  inline ::falcon_remoting_msg::VideoStatus* release_vidstat();
  inline void set_allocated_vidstat(::falcon_remoting_msg::VideoStatus* vidstat);

  // optional .falcon_remoting_msg.FreqHopStatus fhStat = 7;
  inline bool has_fhstat() const;
  inline void clear_fhstat();
  static const int kFhStatFieldNumber = 7;
  inline const ::falcon_remoting_msg::FreqHopStatus& fhstat() const;
  inline ::falcon_remoting_msg::FreqHopStatus* mutable_fhstat();
  inline ::falcon_remoting_msg::FreqHopStatus* release_fhstat();
  inline void set_allocated_fhstat(::falcon_remoting_msg::FreqHopStatus* fhstat);

  // optional .falcon_remoting_msg.MidasAppStatus.SearchSetting searchStat = 8;
  inline bool has_searchstat() const;
  inline void clear_searchstat();
  static const int kSearchStatFieldNumber = 8;
  inline ::falcon_remoting_msg::MidasAppStatus_SearchSetting searchstat() const;
  inline void set_searchstat(::falcon_remoting_msg::MidasAppStatus_SearchSetting value);

  // optional .falcon_remoting_msg.SpecialG specialG = 9;
  inline bool has_specialg() const;
  inline void clear_specialg();
  static const int kSpecialGFieldNumber = 9;
  inline const ::falcon_remoting_msg::SpecialG& specialg() const;
  inline ::falcon_remoting_msg::SpecialG* mutable_specialg();
  inline ::falcon_remoting_msg::SpecialG* release_specialg();
  inline void set_allocated_specialg(::falcon_remoting_msg::SpecialG* specialg);

  // optional float threshold = 10;
  inline bool has_threshold() const;
  inline void clear_threshold();
  static const int kThresholdFieldNumber = 10;
  inline float threshold() const;
  inline void set_threshold(float value);

  // optional bool skyScraperProduct = 11;
  inline bool has_skyscraperproduct() const;
  inline void clear_skyscraperproduct();
  static const int kSkyScraperProductFieldNumber = 11;
  inline bool skyscraperproduct() const;
  inline void set_skyscraperproduct(bool value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.MidasAppStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_rxstat();
  inline void clear_has_rxstat();
  inline void set_has_recstat();
  inline void clear_has_recstat();
  inline void set_has_sigstat();
  inline void clear_has_sigstat();
  inline void set_has_vidstat();
  inline void clear_has_vidstat();
  inline void set_has_fhstat();
  inline void clear_has_fhstat();
  inline void set_has_searchstat();
  inline void clear_has_searchstat();
  inline void set_has_specialg();
  inline void clear_has_specialg();
  inline void set_has_threshold();
  inline void clear_has_threshold();
  inline void set_has_skyscraperproduct();
  inline void clear_has_skyscraperproduct();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::falcon_remoting_msg::RxStatus* rxstat_;
  ::falcon_remoting_msg::RecordingStatus* recstat_;
  ::falcon_remoting_msg::SignalStatus* sigstat_;
  ::google::protobuf::int32 appid_;
  int searchstat_;
  ::falcon_remoting_msg::VideoStatus* vidstat_;
  ::falcon_remoting_msg::FreqHopStatus* fhstat_;
  ::falcon_remoting_msg::SpecialG* specialg_;
  float threshold_;
  bool skyscraperproduct_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static MidasAppStatus* default_instance_;
};
// -------------------------------------------------------------------

class RxStatus : public ::google::protobuf::Message {
 public:
  RxStatus();
  virtual ~RxStatus();

  RxStatus(const RxStatus& from);

  inline RxStatus& operator=(const RxStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RxStatus& default_instance();

  void Swap(RxStatus* other);

  // implements Message ----------------------------------------------

  RxStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RxStatus& from);
  void MergeFrom(const RxStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RxStatus_Status Status;
  static const Status AUTOMATIC = RxStatus_Status_AUTOMATIC;
  static const Status MANUAL = RxStatus_Status_MANUAL;
  static inline bool Status_IsValid(int value) {
    return RxStatus_Status_IsValid(value);
  }
  static const Status Status_MIN =
    RxStatus_Status_Status_MIN;
  static const Status Status_MAX =
    RxStatus_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    RxStatus_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return RxStatus_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return RxStatus_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return RxStatus_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional float freq = 1;
  inline bool has_freq() const;
  inline void clear_freq();
  static const int kFreqFieldNumber = 1;
  inline float freq() const;
  inline void set_freq(float value);

  // optional int32 atten = 2;
  inline bool has_atten() const;
  inline void clear_atten();
  static const int kAttenFieldNumber = 2;
  inline ::google::protobuf::int32 atten() const;
  inline void set_atten(::google::protobuf::int32 value);

  // optional .falcon_remoting_msg.RxStatus.Status autoAtten = 3;
  inline bool has_autoatten() const;
  inline void clear_autoatten();
  static const int kAutoAttenFieldNumber = 3;
  inline ::falcon_remoting_msg::RxStatus_Status autoatten() const;
  inline void set_autoatten(::falcon_remoting_msg::RxStatus_Status value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.RxStatus)
 private:
  inline void set_has_freq();
  inline void clear_has_freq();
  inline void set_has_atten();
  inline void clear_has_atten();
  inline void set_has_autoatten();
  inline void clear_has_autoatten();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float freq_;
  ::google::protobuf::int32 atten_;
  int autoatten_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static RxStatus* default_instance_;
};
// -------------------------------------------------------------------

class RecordingStatus : public ::google::protobuf::Message {
 public:
  RecordingStatus();
  virtual ~RecordingStatus();

  RecordingStatus(const RecordingStatus& from);

  inline RecordingStatus& operator=(const RecordingStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecordingStatus& default_instance();

  void Swap(RecordingStatus* other);

  // implements Message ----------------------------------------------

  RecordingStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecordingStatus& from);
  void MergeFrom(const RecordingStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RecordingStatus_Status Status;
  static const Status OFF = RecordingStatus_Status_OFF;
  static const Status ON = RecordingStatus_Status_ON;
  static inline bool Status_IsValid(int value) {
    return RecordingStatus_Status_IsValid(value);
  }
  static const Status Status_MIN =
    RecordingStatus_Status_Status_MIN;
  static const Status Status_MAX =
    RecordingStatus_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    RecordingStatus_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return RecordingStatus_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return RecordingStatus_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return RecordingStatus_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .falcon_remoting_msg.RecordingStatus.Status predRecStat = 1;
  inline bool has_predrecstat() const;
  inline void clear_predrecstat();
  static const int kPredRecStatFieldNumber = 1;
  inline ::falcon_remoting_msg::RecordingStatus_Status predrecstat() const;
  inline void set_predrecstat(::falcon_remoting_msg::RecordingStatus_Status value);

  // optional float diskUse = 2;
  inline bool has_diskuse() const;
  inline void clear_diskuse();
  static const int kDiskUseFieldNumber = 2;
  inline float diskuse() const;
  inline void set_diskuse(float value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.RecordingStatus)
 private:
  inline void set_has_predrecstat();
  inline void clear_has_predrecstat();
  inline void set_has_diskuse();
  inline void clear_has_diskuse();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int predrecstat_;
  float diskuse_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static RecordingStatus* default_instance_;
};
// -------------------------------------------------------------------

class SignalStatus : public ::google::protobuf::Message {
 public:
  SignalStatus();
  virtual ~SignalStatus();

  SignalStatus(const SignalStatus& from);

  inline SignalStatus& operator=(const SignalStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignalStatus& default_instance();

  void Swap(SignalStatus* other);

  // implements Message ----------------------------------------------

  SignalStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignalStatus& from);
  void MergeFrom(const SignalStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .falcon_remoting_msg.DetectionStatus detStat = 1;
  inline int detstat_size() const;
  inline void clear_detstat();
  static const int kDetStatFieldNumber = 1;
  inline const ::falcon_remoting_msg::DetectionStatus& detstat(int index) const;
  inline ::falcon_remoting_msg::DetectionStatus* mutable_detstat(int index);
  inline ::falcon_remoting_msg::DetectionStatus* add_detstat();
  inline const ::google::protobuf::RepeatedPtrField< ::falcon_remoting_msg::DetectionStatus >&
      detstat() const;
  inline ::google::protobuf::RepeatedPtrField< ::falcon_remoting_msg::DetectionStatus >*
      mutable_detstat();

  // optional float ber = 2;
  inline bool has_ber() const;
  inline void clear_ber();
  static const int kBerFieldNumber = 2;
  inline float ber() const;
  inline void set_ber(float value);

  // optional float centerFreqEst = 3;
  inline bool has_centerfreqest() const;
  inline void clear_centerfreqest();
  static const int kCenterFreqEstFieldNumber = 3;
  inline float centerfreqest() const;
  inline void set_centerfreqest(float value);

  // optional float excurEst = 4;
  inline bool has_excurest() const;
  inline void clear_excurest();
  static const int kExcurEstFieldNumber = 4;
  inline float excurest() const;
  inline void set_excurest(float value);

  // optional int32 packetCount = 5;
  inline bool has_packetcount() const;
  inline void clear_packetcount();
  static const int kPacketCountFieldNumber = 5;
  inline ::google::protobuf::int32 packetcount() const;
  inline void set_packetcount(::google::protobuf::int32 value);

  // optional int32 timeWindow = 6;
  inline bool has_timewindow() const;
  inline void clear_timewindow();
  static const int kTimeWindowFieldNumber = 6;
  inline ::google::protobuf::int32 timewindow() const;
  inline void set_timewindow(::google::protobuf::int32 value);

  // optional int64 timeStamp = 7;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimeStampFieldNumber = 7;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.SignalStatus)
 private:
  inline void set_has_ber();
  inline void clear_has_ber();
  inline void set_has_centerfreqest();
  inline void clear_has_centerfreqest();
  inline void set_has_excurest();
  inline void clear_has_excurest();
  inline void set_has_packetcount();
  inline void clear_has_packetcount();
  inline void set_has_timewindow();
  inline void clear_has_timewindow();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::falcon_remoting_msg::DetectionStatus > detstat_;
  float ber_;
  float centerfreqest_;
  float excurest_;
  ::google::protobuf::int32 packetcount_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int32 timewindow_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static SignalStatus* default_instance_;
};
// -------------------------------------------------------------------

class DetectionStatus : public ::google::protobuf::Message {
 public:
  DetectionStatus();
  virtual ~DetectionStatus();

  DetectionStatus(const DetectionStatus& from);

  inline DetectionStatus& operator=(const DetectionStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DetectionStatus& default_instance();

  void Swap(DetectionStatus* other);

  // implements Message ----------------------------------------------

  DetectionStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DetectionStatus& from);
  void MergeFrom(const DetectionStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DetectionStatus_Color Color;
  static const Color RED = DetectionStatus_Color_RED;
  static const Color YELLOW = DetectionStatus_Color_YELLOW;
  static const Color GREEN = DetectionStatus_Color_GREEN;
  static inline bool Color_IsValid(int value) {
    return DetectionStatus_Color_IsValid(value);
  }
  static const Color Color_MIN =
    DetectionStatus_Color_Color_MIN;
  static const Color Color_MAX =
    DetectionStatus_Color_Color_MAX;
  static const int Color_ARRAYSIZE =
    DetectionStatus_Color_Color_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Color_descriptor() {
    return DetectionStatus_Color_descriptor();
  }
  static inline const ::std::string& Color_Name(Color value) {
    return DetectionStatus_Color_Name(value);
  }
  static inline bool Color_Parse(const ::std::string& name,
      Color* value) {
    return DetectionStatus_Color_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string sigName = 1;
  inline bool has_signame() const;
  inline void clear_signame();
  static const int kSigNameFieldNumber = 1;
  inline const ::std::string& signame() const;
  inline void set_signame(const ::std::string& value);
  inline void set_signame(const char* value);
  inline void set_signame(const char* value, size_t size);
  inline ::std::string* mutable_signame();
  inline ::std::string* release_signame();
  inline void set_allocated_signame(::std::string* signame);

  // optional string detState = 2;
  inline bool has_detstate() const;
  inline void clear_detstate();
  static const int kDetStateFieldNumber = 2;
  inline const ::std::string& detstate() const;
  inline void set_detstate(const ::std::string& value);
  inline void set_detstate(const char* value);
  inline void set_detstate(const char* value, size_t size);
  inline ::std::string* mutable_detstate();
  inline ::std::string* release_detstate();
  inline void set_allocated_detstate(::std::string* detstate);

  // optional .falcon_remoting_msg.DetectionStatus.Color color = 3;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 3;
  inline ::falcon_remoting_msg::DetectionStatus_Color color() const;
  inline void set_color(::falcon_remoting_msg::DetectionStatus_Color value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.DetectionStatus)
 private:
  inline void set_has_signame();
  inline void clear_has_signame();
  inline void set_has_detstate();
  inline void clear_has_detstate();
  inline void set_has_color();
  inline void clear_has_color();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* signame_;
  ::std::string* detstate_;
  int color_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static DetectionStatus* default_instance_;
};
// -------------------------------------------------------------------

class SearchStatus : public ::google::protobuf::Message {
 public:
  SearchStatus();
  virtual ~SearchStatus();

  SearchStatus(const SearchStatus& from);

  inline SearchStatus& operator=(const SearchStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchStatus& default_instance();

  void Swap(SearchStatus* other);

  // implements Message ----------------------------------------------

  SearchStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SearchStatus& from);
  void MergeFrom(const SearchStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SearchStatus_Color Color;
  static const Color RED = SearchStatus_Color_RED;
  static const Color YELLOW = SearchStatus_Color_YELLOW;
  static const Color GREEN = SearchStatus_Color_GREEN;
  static inline bool Color_IsValid(int value) {
    return SearchStatus_Color_IsValid(value);
  }
  static const Color Color_MIN =
    SearchStatus_Color_Color_MIN;
  static const Color Color_MAX =
    SearchStatus_Color_Color_MAX;
  static const int Color_ARRAYSIZE =
    SearchStatus_Color_Color_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Color_descriptor() {
    return SearchStatus_Color_descriptor();
  }
  static inline const ::std::string& Color_Name(Color value) {
    return SearchStatus_Color_Name(value);
  }
  static inline bool Color_Parse(const ::std::string& name,
      Color* value) {
    return SearchStatus_Color_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SEARCH_STATUS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 appID = 2;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 2;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional string status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline const ::std::string& status() const;
  inline void set_status(const ::std::string& value);
  inline void set_status(const char* value);
  inline void set_status(const char* value, size_t size);
  inline ::std::string* mutable_status();
  inline ::std::string* release_status();
  inline void set_allocated_status(::std::string* status);

  // optional .falcon_remoting_msg.SearchStatus.Color color = 4;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 4;
  inline ::falcon_remoting_msg::SearchStatus_Color color() const;
  inline void set_color(::falcon_remoting_msg::SearchStatus_Color value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.SearchStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_color();
  inline void clear_has_color();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* status_;
  ::google::protobuf::int32 appid_;
  int color_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static SearchStatus* default_instance_;
};
// -------------------------------------------------------------------

class VideoStatus : public ::google::protobuf::Message {
 public:
  VideoStatus();
  virtual ~VideoStatus();

  VideoStatus(const VideoStatus& from);

  inline VideoStatus& operator=(const VideoStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VideoStatus& default_instance();

  void Swap(VideoStatus* other);

  // implements Message ----------------------------------------------

  VideoStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VideoStatus& from);
  void MergeFrom(const VideoStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef VideoStatus_RecStatus RecStatus;
  static const RecStatus VID_OFF = VideoStatus_RecStatus_VID_OFF;
  static const RecStatus VID_ON = VideoStatus_RecStatus_VID_ON;
  static inline bool RecStatus_IsValid(int value) {
    return VideoStatus_RecStatus_IsValid(value);
  }
  static const RecStatus RecStatus_MIN =
    VideoStatus_RecStatus_RecStatus_MIN;
  static const RecStatus RecStatus_MAX =
    VideoStatus_RecStatus_RecStatus_MAX;
  static const int RecStatus_ARRAYSIZE =
    VideoStatus_RecStatus_RecStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RecStatus_descriptor() {
    return VideoStatus_RecStatus_descriptor();
  }
  static inline const ::std::string& RecStatus_Name(RecStatus value) {
    return VideoStatus_RecStatus_Name(value);
  }
  static inline bool RecStatus_Parse(const ::std::string& name,
      RecStatus* value) {
    return VideoStatus_RecStatus_Parse(name, value);
  }

  typedef VideoStatus_SyncStatus SyncStatus;
  static const SyncStatus SYNC_OFF = VideoStatus_SyncStatus_SYNC_OFF;
  static const SyncStatus SYNC_ON = VideoStatus_SyncStatus_SYNC_ON;
  static inline bool SyncStatus_IsValid(int value) {
    return VideoStatus_SyncStatus_IsValid(value);
  }
  static const SyncStatus SyncStatus_MIN =
    VideoStatus_SyncStatus_SyncStatus_MIN;
  static const SyncStatus SyncStatus_MAX =
    VideoStatus_SyncStatus_SyncStatus_MAX;
  static const int SyncStatus_ARRAYSIZE =
    VideoStatus_SyncStatus_SyncStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SyncStatus_descriptor() {
    return VideoStatus_SyncStatus_descriptor();
  }
  static inline const ::std::string& SyncStatus_Name(SyncStatus value) {
    return VideoStatus_SyncStatus_Name(value);
  }
  static inline bool SyncStatus_Parse(const ::std::string& name,
      SyncStatus* value) {
    return VideoStatus_SyncStatus_Parse(name, value);
  }

  typedef VideoStatus_JpegMode JpegMode;
  static const JpegMode JPEG_OFF = VideoStatus_JpegMode_JPEG_OFF;
  static const JpegMode JPEG_ON = VideoStatus_JpegMode_JPEG_ON;
  static const JpegMode JPEG_SINGLE = VideoStatus_JpegMode_JPEG_SINGLE;
  static inline bool JpegMode_IsValid(int value) {
    return VideoStatus_JpegMode_IsValid(value);
  }
  static const JpegMode JpegMode_MIN =
    VideoStatus_JpegMode_JpegMode_MIN;
  static const JpegMode JpegMode_MAX =
    VideoStatus_JpegMode_JpegMode_MAX;
  static const int JpegMode_ARRAYSIZE =
    VideoStatus_JpegMode_JpegMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  JpegMode_descriptor() {
    return VideoStatus_JpegMode_descriptor();
  }
  static inline const ::std::string& JpegMode_Name(JpegMode value) {
    return VideoStatus_JpegMode_Name(value);
  }
  static inline bool JpegMode_Parse(const ::std::string& name,
      JpegMode* value) {
    return VideoStatus_JpegMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .falcon_remoting_msg.VideoStatus.RecStatus vidRecStat = 1;
  inline bool has_vidrecstat() const;
  inline void clear_vidrecstat();
  static const int kVidRecStatFieldNumber = 1;
  inline ::falcon_remoting_msg::VideoStatus_RecStatus vidrecstat() const;
  inline void set_vidrecstat(::falcon_remoting_msg::VideoStatus_RecStatus value);

  // optional .falcon_remoting_msg.VideoStatus.SyncStatus vidSync = 2;
  inline bool has_vidsync() const;
  inline void clear_vidsync();
  static const int kVidSyncFieldNumber = 2;
  inline ::falcon_remoting_msg::VideoStatus_SyncStatus vidsync() const;
  inline void set_vidsync(::falcon_remoting_msg::VideoStatus_SyncStatus value);

  // optional int32 vidInt = 3;
  inline bool has_vidint() const;
  inline void clear_vidint();
  static const int kVidIntFieldNumber = 3;
  inline ::google::protobuf::int32 vidint() const;
  inline void set_vidint(::google::protobuf::int32 value);

  // optional .falcon_remoting_msg.VideoStatus.JpegMode jpegMode = 4;
  inline bool has_jpegmode() const;
  inline void clear_jpegmode();
  static const int kJpegModeFieldNumber = 4;
  inline ::falcon_remoting_msg::VideoStatus_JpegMode jpegmode() const;
  inline void set_jpegmode(::falcon_remoting_msg::VideoStatus_JpegMode value);

  // optional int32 jpegRate = 5;
  inline bool has_jpegrate() const;
  inline void clear_jpegrate();
  static const int kJpegRateFieldNumber = 5;
  inline ::google::protobuf::int32 jpegrate() const;
  inline void set_jpegrate(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.VideoStatus)
 private:
  inline void set_has_vidrecstat();
  inline void clear_has_vidrecstat();
  inline void set_has_vidsync();
  inline void clear_has_vidsync();
  inline void set_has_vidint();
  inline void clear_has_vidint();
  inline void set_has_jpegmode();
  inline void clear_has_jpegmode();
  inline void set_has_jpegrate();
  inline void clear_has_jpegrate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int vidrecstat_;
  int vidsync_;
  ::google::protobuf::int32 vidint_;
  int jpegmode_;
  ::google::protobuf::int32 jpegrate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static VideoStatus* default_instance_;
};
// -------------------------------------------------------------------

class FreqHopStatus : public ::google::protobuf::Message {
 public:
  FreqHopStatus();
  virtual ~FreqHopStatus();

  FreqHopStatus(const FreqHopStatus& from);

  inline FreqHopStatus& operator=(const FreqHopStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FreqHopStatus& default_instance();

  void Swap(FreqHopStatus* other);

  // implements Message ----------------------------------------------

  FreqHopStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FreqHopStatus& from);
  void MergeFrom(const FreqHopStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef FreqHopStatus_Mode Mode;
  static const Mode AUTOMATIC = FreqHopStatus_Mode_AUTOMATIC;
  static const Mode USER_CLICKS = FreqHopStatus_Mode_USER_CLICKS;
  static const Mode MANUAL = FreqHopStatus_Mode_MANUAL;
  static inline bool Mode_IsValid(int value) {
    return FreqHopStatus_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    FreqHopStatus_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    FreqHopStatus_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    FreqHopStatus_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Mode_descriptor() {
    return FreqHopStatus_Mode_descriptor();
  }
  static inline const ::std::string& Mode_Name(Mode value) {
    return FreqHopStatus_Mode_Name(value);
  }
  static inline bool Mode_Parse(const ::std::string& name,
      Mode* value) {
    return FreqHopStatus_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .falcon_remoting_msg.FreqHopStatus.Mode mode = 1;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline ::falcon_remoting_msg::FreqHopStatus_Mode mode() const;
  inline void set_mode(::falcon_remoting_msg::FreqHopStatus_Mode value);

  // repeated .falcon_remoting_msg.FreqHopTunerStatus fhopTuner = 2;
  inline int fhoptuner_size() const;
  inline void clear_fhoptuner();
  static const int kFhopTunerFieldNumber = 2;
  inline const ::falcon_remoting_msg::FreqHopTunerStatus& fhoptuner(int index) const;
  inline ::falcon_remoting_msg::FreqHopTunerStatus* mutable_fhoptuner(int index);
  inline ::falcon_remoting_msg::FreqHopTunerStatus* add_fhoptuner();
  inline const ::google::protobuf::RepeatedPtrField< ::falcon_remoting_msg::FreqHopTunerStatus >&
      fhoptuner() const;
  inline ::google::protobuf::RepeatedPtrField< ::falcon_remoting_msg::FreqHopTunerStatus >*
      mutable_fhoptuner();

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.FreqHopStatus)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::falcon_remoting_msg::FreqHopTunerStatus > fhoptuner_;
  int mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static FreqHopStatus* default_instance_;
};
// -------------------------------------------------------------------

class FreqHopTunerStatus : public ::google::protobuf::Message {
 public:
  FreqHopTunerStatus();
  virtual ~FreqHopTunerStatus();

  FreqHopTunerStatus(const FreqHopTunerStatus& from);

  inline FreqHopTunerStatus& operator=(const FreqHopTunerStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FreqHopTunerStatus& default_instance();

  void Swap(FreqHopTunerStatus* other);

  // implements Message ----------------------------------------------

  FreqHopTunerStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FreqHopTunerStatus& from);
  void MergeFrom(const FreqHopTunerStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 tuner = 1;
  inline bool has_tuner() const;
  inline void clear_tuner();
  static const int kTunerFieldNumber = 1;
  inline ::google::protobuf::int32 tuner() const;
  inline void set_tuner(::google::protobuf::int32 value);

  // optional double freq = 2;
  inline bool has_freq() const;
  inline void clear_freq();
  static const int kFreqFieldNumber = 2;
  inline double freq() const;
  inline void set_freq(double value);

  // optional int32 numHits = 3;
  inline bool has_numhits() const;
  inline void clear_numhits();
  static const int kNumHitsFieldNumber = 3;
  inline ::google::protobuf::int32 numhits() const;
  inline void set_numhits(::google::protobuf::int32 value);

  // optional bool locked = 4;
  inline bool has_locked() const;
  inline void clear_locked();
  static const int kLockedFieldNumber = 4;
  inline bool locked() const;
  inline void set_locked(bool value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.FreqHopTunerStatus)
 private:
  inline void set_has_tuner();
  inline void clear_has_tuner();
  inline void set_has_freq();
  inline void clear_has_freq();
  inline void set_has_numhits();
  inline void clear_has_numhits();
  inline void set_has_locked();
  inline void clear_has_locked();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double freq_;
  ::google::protobuf::int32 tuner_;
  ::google::protobuf::int32 numhits_;
  bool locked_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static FreqHopTunerStatus* default_instance_;
};
// -------------------------------------------------------------------

class SpecialG : public ::google::protobuf::Message {
 public:
  SpecialG();
  virtual ~SpecialG();

  SpecialG(const SpecialG& from);

  inline SpecialG& operator=(const SpecialG& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpecialG& default_instance();

  void Swap(SpecialG* other);

  // implements Message ----------------------------------------------

  SpecialG* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SpecialG& from);
  void MergeFrom(const SpecialG& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "PROCESS_SPECIAL_G"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional double lat = 2;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 2;
  inline double lat() const;
  inline void set_lat(double value);

  // optional double lon = 3;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 3;
  inline double lon() const;
  inline void set_lon(double value);

  // optional double alt = 4;
  inline bool has_alt() const;
  inline void clear_alt();
  static const int kAltFieldNumber = 4;
  inline double alt() const;
  inline void set_alt(double value);

  // optional double estAlt = 5;
  inline bool has_estalt() const;
  inline void clear_estalt();
  static const int kEstAltFieldNumber = 5;
  inline double estalt() const;
  inline void set_estalt(double value);

  // optional bool enable = 6;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 6;
  inline bool enable() const;
  inline void set_enable(bool value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.SpecialG)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_alt();
  inline void clear_has_alt();
  inline void set_has_estalt();
  inline void clear_has_estalt();
  inline void set_has_enable();
  inline void clear_has_enable();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  double lat_;
  double lon_;
  double alt_;
  double estalt_;
  bool enable_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static SpecialG* default_instance_;
};
// -------------------------------------------------------------------

class SensorPosition : public ::google::protobuf::Message {
 public:
  SensorPosition();
  virtual ~SensorPosition();

  SensorPosition(const SensorPosition& from);

  inline SensorPosition& operator=(const SensorPosition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorPosition& default_instance();

  void Swap(SensorPosition* other);

  // implements Message ----------------------------------------------

  SensorPosition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SensorPosition& from);
  void MergeFrom(const SensorPosition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SENSOR_POSITION"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional float lat = 2;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 2;
  inline float lat() const;
  inline void set_lat(float value);

  // optional float lon = 3;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 3;
  inline float lon() const;
  inline void set_lon(float value);

  // optional float alt = 4;
  inline bool has_alt() const;
  inline void clear_alt();
  static const int kAltFieldNumber = 4;
  inline float alt() const;
  inline void set_alt(float value);

  // optional .falcon_remoting_msg.OrientationStatus orientation = 5;
  inline bool has_orientation() const;
  inline void clear_orientation();
  static const int kOrientationFieldNumber = 5;
  inline const ::falcon_remoting_msg::OrientationStatus& orientation() const;
  inline ::falcon_remoting_msg::OrientationStatus* mutable_orientation();
  inline ::falcon_remoting_msg::OrientationStatus* release_orientation();
  inline void set_allocated_orientation(::falcon_remoting_msg::OrientationStatus* orientation);

  // optional int64 timestamp = 6;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 6;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // optional string sensorName = 7;
  inline bool has_sensorname() const;
  inline void clear_sensorname();
  static const int kSensorNameFieldNumber = 7;
  inline const ::std::string& sensorname() const;
  inline void set_sensorname(const ::std::string& value);
  inline void set_sensorname(const char* value);
  inline void set_sensorname(const char* value, size_t size);
  inline ::std::string* mutable_sensorname();
  inline ::std::string* release_sensorname();
  inline void set_allocated_sensorname(::std::string* sensorname);

  // optional string siteId = 8;
  inline bool has_siteid() const;
  inline void clear_siteid();
  static const int kSiteIdFieldNumber = 8;
  inline const ::std::string& siteid() const;
  inline void set_siteid(const ::std::string& value);
  inline void set_siteid(const char* value);
  inline void set_siteid(const char* value, size_t size);
  inline ::std::string* mutable_siteid();
  inline ::std::string* release_siteid();
  inline void set_allocated_siteid(::std::string* siteid);

  // optional string sigAd = 9;
  inline bool has_sigad() const;
  inline void clear_sigad();
  static const int kSigAdFieldNumber = 9;
  inline const ::std::string& sigad() const;
  inline void set_sigad(const ::std::string& value);
  inline void set_sigad(const char* value);
  inline void set_sigad(const char* value, size_t size);
  inline ::std::string* mutable_sigad();
  inline ::std::string* release_sigad();
  inline void set_allocated_sigad(::std::string* sigad);

  // repeated .falcon_remoting_msg.FieldofView fov = 10;
  inline int fov_size() const;
  inline void clear_fov();
  static const int kFovFieldNumber = 10;
  inline const ::falcon_remoting_msg::FieldofView& fov(int index) const;
  inline ::falcon_remoting_msg::FieldofView* mutable_fov(int index);
  inline ::falcon_remoting_msg::FieldofView* add_fov();
  inline const ::google::protobuf::RepeatedPtrField< ::falcon_remoting_msg::FieldofView >&
      fov() const;
  inline ::google::protobuf::RepeatedPtrField< ::falcon_remoting_msg::FieldofView >*
      mutable_fov();

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.SensorPosition)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_alt();
  inline void clear_has_alt();
  inline void set_has_orientation();
  inline void clear_has_orientation();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_sensorname();
  inline void clear_has_sensorname();
  inline void set_has_siteid();
  inline void clear_has_siteid();
  inline void set_has_sigad();
  inline void clear_has_sigad();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  float lat_;
  float lon_;
  ::falcon_remoting_msg::OrientationStatus* orientation_;
  ::google::protobuf::int64 timestamp_;
  ::std::string* sensorname_;
  ::std::string* siteid_;
  ::std::string* sigad_;
  ::google::protobuf::RepeatedPtrField< ::falcon_remoting_msg::FieldofView > fov_;
  float alt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static SensorPosition* default_instance_;
};
// -------------------------------------------------------------------

class SensorHealth : public ::google::protobuf::Message {
 public:
  SensorHealth();
  virtual ~SensorHealth();

  SensorHealth(const SensorHealth& from);

  inline SensorHealth& operator=(const SensorHealth& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorHealth& default_instance();

  void Swap(SensorHealth* other);

  // implements Message ----------------------------------------------

  SensorHealth* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SensorHealth& from);
  void MergeFrom(const SensorHealth& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SENSOR_HEALTH"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string sensorName = 2;
  inline bool has_sensorname() const;
  inline void clear_sensorname();
  static const int kSensorNameFieldNumber = 2;
  inline const ::std::string& sensorname() const;
  inline void set_sensorname(const ::std::string& value);
  inline void set_sensorname(const char* value);
  inline void set_sensorname(const char* value, size_t size);
  inline ::std::string* mutable_sensorname();
  inline ::std::string* release_sensorname();
  inline void set_allocated_sensorname(::std::string* sensorname);

  // optional int32 pollTime = 3;
  inline bool has_polltime() const;
  inline void clear_polltime();
  static const int kPollTimeFieldNumber = 3;
  inline ::google::protobuf::int32 polltime() const;
  inline void set_polltime(::google::protobuf::int32 value);

  // optional int32 averageCount = 4;
  inline bool has_averagecount() const;
  inline void clear_averagecount();
  static const int kAverageCountFieldNumber = 4;
  inline ::google::protobuf::int32 averagecount() const;
  inline void set_averagecount(::google::protobuf::int32 value);

  // optional float cpuUsage = 5;
  inline bool has_cpuusage() const;
  inline void clear_cpuusage();
  static const int kCpuUsageFieldNumber = 5;
  inline float cpuusage() const;
  inline void set_cpuusage(float value);

  // optional float cpuAverage = 6;
  inline bool has_cpuaverage() const;
  inline void clear_cpuaverage();
  static const int kCpuAverageFieldNumber = 6;
  inline float cpuaverage() const;
  inline void set_cpuaverage(float value);

  // optional float ramUsage = 7;
  inline bool has_ramusage() const;
  inline void clear_ramusage();
  static const int kRamUsageFieldNumber = 7;
  inline float ramusage() const;
  inline void set_ramusage(float value);

  // optional float ramAverage = 8;
  inline bool has_ramaverage() const;
  inline void clear_ramaverage();
  static const int kRamAverageFieldNumber = 8;
  inline float ramaverage() const;
  inline void set_ramaverage(float value);

  // optional float diskUsage = 9;
  inline bool has_diskusage() const;
  inline void clear_diskusage();
  static const int kDiskUsageFieldNumber = 9;
  inline float diskusage() const;
  inline void set_diskusage(float value);

  // optional float diskAverage = 10;
  inline bool has_diskaverage() const;
  inline void clear_diskaverage();
  static const int kDiskAverageFieldNumber = 10;
  inline float diskaverage() const;
  inline void set_diskaverage(float value);

  // optional float cpuTempAvg = 11;
  inline bool has_cputempavg() const;
  inline void clear_cputempavg();
  static const int kCpuTempAvgFieldNumber = 11;
  inline float cputempavg() const;
  inline void set_cputempavg(float value);

  // optional float cpuTempMin = 12;
  inline bool has_cputempmin() const;
  inline void clear_cputempmin();
  static const int kCpuTempMinFieldNumber = 12;
  inline float cputempmin() const;
  inline void set_cputempmin(float value);

  // optional float cpuTempMax = 13;
  inline bool has_cputempmax() const;
  inline void clear_cputempmax();
  static const int kCpuTempMaxFieldNumber = 13;
  inline float cputempmax() const;
  inline void set_cputempmax(float value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.SensorHealth)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_sensorname();
  inline void clear_has_sensorname();
  inline void set_has_polltime();
  inline void clear_has_polltime();
  inline void set_has_averagecount();
  inline void clear_has_averagecount();
  inline void set_has_cpuusage();
  inline void clear_has_cpuusage();
  inline void set_has_cpuaverage();
  inline void clear_has_cpuaverage();
  inline void set_has_ramusage();
  inline void clear_has_ramusage();
  inline void set_has_ramaverage();
  inline void clear_has_ramaverage();
  inline void set_has_diskusage();
  inline void clear_has_diskusage();
  inline void set_has_diskaverage();
  inline void clear_has_diskaverage();
  inline void set_has_cputempavg();
  inline void clear_has_cputempavg();
  inline void set_has_cputempmin();
  inline void clear_has_cputempmin();
  inline void set_has_cputempmax();
  inline void clear_has_cputempmax();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* sensorname_;
  ::google::protobuf::int32 polltime_;
  ::google::protobuf::int32 averagecount_;
  float cpuusage_;
  float cpuaverage_;
  float ramusage_;
  float ramaverage_;
  float diskusage_;
  float diskaverage_;
  float cputempavg_;
  float cputempmin_;
  float cputempmax_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static SensorHealth* default_instance_;
};
// -------------------------------------------------------------------

class HardwareStatus : public ::google::protobuf::Message {
 public:
  HardwareStatus();
  virtual ~HardwareStatus();

  HardwareStatus(const HardwareStatus& from);

  inline HardwareStatus& operator=(const HardwareStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HardwareStatus& default_instance();

  void Swap(HardwareStatus* other);

  // implements Message ----------------------------------------------

  HardwareStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HardwareStatus& from);
  void MergeFrom(const HardwareStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "HARDWARE_STATUS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string IPAddress = 2;
  inline bool has_ipaddress() const;
  inline void clear_ipaddress();
  static const int kIPAddressFieldNumber = 2;
  inline const ::std::string& ipaddress() const;
  inline void set_ipaddress(const ::std::string& value);
  inline void set_ipaddress(const char* value);
  inline void set_ipaddress(const char* value, size_t size);
  inline ::std::string* mutable_ipaddress();
  inline ::std::string* release_ipaddress();
  inline void set_allocated_ipaddress(::std::string* ipaddress);

  // optional string sensorName = 3;
  inline bool has_sensorname() const;
  inline void clear_sensorname();
  static const int kSensorNameFieldNumber = 3;
  inline const ::std::string& sensorname() const;
  inline void set_sensorname(const ::std::string& value);
  inline void set_sensorname(const char* value);
  inline void set_sensorname(const char* value, size_t size);
  inline ::std::string* mutable_sensorname();
  inline ::std::string* release_sensorname();
  inline void set_allocated_sensorname(::std::string* sensorname);

  // optional float cpuAvgTemp = 4;
  inline bool has_cpuavgtemp() const;
  inline void clear_cpuavgtemp();
  static const int kCpuAvgTempFieldNumber = 4;
  inline float cpuavgtemp() const;
  inline void set_cpuavgtemp(float value);

  // repeated float cpuHighTemp = 5;
  inline int cpuhightemp_size() const;
  inline void clear_cpuhightemp();
  static const int kCpuHighTempFieldNumber = 5;
  inline float cpuhightemp(int index) const;
  inline void set_cpuhightemp(int index, float value);
  inline void add_cpuhightemp(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      cpuhightemp() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_cpuhightemp();

  // optional float cpuIdlePercent = 6;
  inline bool has_cpuidlepercent() const;
  inline void clear_cpuidlepercent();
  static const int kCpuIdlePercentFieldNumber = 6;
  inline float cpuidlepercent() const;
  inline void set_cpuidlepercent(float value);

  // optional float ramUsagePercent = 7;
  inline bool has_ramusagepercent() const;
  inline void clear_ramusagepercent();
  static const int kRamUsagePercentFieldNumber = 7;
  inline float ramusagepercent() const;
  inline void set_ramusagepercent(float value);

  // optional bool online = 8;
  inline bool has_online() const;
  inline void clear_online();
  static const int kOnlineFieldNumber = 8;
  inline bool online() const;
  inline void set_online(bool value);

  // optional string deviceType = 9;
  inline bool has_devicetype() const;
  inline void clear_devicetype();
  static const int kDeviceTypeFieldNumber = 9;
  inline const ::std::string& devicetype() const;
  inline void set_devicetype(const ::std::string& value);
  inline void set_devicetype(const char* value);
  inline void set_devicetype(const char* value, size_t size);
  inline ::std::string* mutable_devicetype();
  inline ::std::string* release_devicetype();
  inline void set_allocated_devicetype(::std::string* devicetype);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.HardwareStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_ipaddress();
  inline void clear_has_ipaddress();
  inline void set_has_sensorname();
  inline void clear_has_sensorname();
  inline void set_has_cpuavgtemp();
  inline void clear_has_cpuavgtemp();
  inline void set_has_cpuidlepercent();
  inline void clear_has_cpuidlepercent();
  inline void set_has_ramusagepercent();
  inline void clear_has_ramusagepercent();
  inline void set_has_online();
  inline void clear_has_online();
  inline void set_has_devicetype();
  inline void clear_has_devicetype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* ipaddress_;
  ::std::string* sensorname_;
  ::google::protobuf::RepeatedField< float > cpuhightemp_;
  float cpuavgtemp_;
  float cpuidlepercent_;
  float ramusagepercent_;
  bool online_;
  ::std::string* devicetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static HardwareStatus* default_instance_;
};
// -------------------------------------------------------------------

class SensorStatus : public ::google::protobuf::Message {
 public:
  SensorStatus();
  virtual ~SensorStatus();

  SensorStatus(const SensorStatus& from);

  inline SensorStatus& operator=(const SensorStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorStatus& default_instance();

  void Swap(SensorStatus* other);

  // implements Message ----------------------------------------------

  SensorStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SensorStatus& from);
  void MergeFrom(const SensorStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SENSOR_STATUS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional .falcon_remoting_msg.SensorHealth sensor_health = 2;
  inline bool has_sensor_health() const;
  inline void clear_sensor_health();
  static const int kSensorHealthFieldNumber = 2;
  inline const ::falcon_remoting_msg::SensorHealth& sensor_health() const;
  inline ::falcon_remoting_msg::SensorHealth* mutable_sensor_health();
  inline ::falcon_remoting_msg::SensorHealth* release_sensor_health();
  inline void set_allocated_sensor_health(::falcon_remoting_msg::SensorHealth* sensor_health);

  // repeated .falcon_remoting_msg.ReceiverStatus rx_status = 3;
  inline int rx_status_size() const;
  inline void clear_rx_status();
  static const int kRxStatusFieldNumber = 3;
  inline const ::falcon_remoting_msg::ReceiverStatus& rx_status(int index) const;
  inline ::falcon_remoting_msg::ReceiverStatus* mutable_rx_status(int index);
  inline ::falcon_remoting_msg::ReceiverStatus* add_rx_status();
  inline const ::google::protobuf::RepeatedPtrField< ::falcon_remoting_msg::ReceiverStatus >&
      rx_status() const;
  inline ::google::protobuf::RepeatedPtrField< ::falcon_remoting_msg::ReceiverStatus >*
      mutable_rx_status();

  // optional .falcon_remoting_msg.SensorPosition sensor_position = 4;
  inline bool has_sensor_position() const;
  inline void clear_sensor_position();
  static const int kSensorPositionFieldNumber = 4;
  inline const ::falcon_remoting_msg::SensorPosition& sensor_position() const;
  inline ::falcon_remoting_msg::SensorPosition* mutable_sensor_position();
  inline ::falcon_remoting_msg::SensorPosition* release_sensor_position();
  inline void set_allocated_sensor_position(::falcon_remoting_msg::SensorPosition* sensor_position);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.SensorStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_sensor_health();
  inline void clear_has_sensor_health();
  inline void set_has_sensor_position();
  inline void clear_has_sensor_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::falcon_remoting_msg::SensorHealth* sensor_health_;
  ::google::protobuf::RepeatedPtrField< ::falcon_remoting_msg::ReceiverStatus > rx_status_;
  ::falcon_remoting_msg::SensorPosition* sensor_position_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static SensorStatus* default_instance_;
};
// -------------------------------------------------------------------

class OrientationStatus : public ::google::protobuf::Message {
 public:
  OrientationStatus();
  virtual ~OrientationStatus();

  OrientationStatus(const OrientationStatus& from);

  inline OrientationStatus& operator=(const OrientationStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrientationStatus& default_instance();

  void Swap(OrientationStatus* other);

  // implements Message ----------------------------------------------

  OrientationStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrientationStatus& from);
  void MergeFrom(const OrientationStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ORIENTATION_STATUS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional float yaw = 2;
  inline bool has_yaw() const;
  inline void clear_yaw();
  static const int kYawFieldNumber = 2;
  inline float yaw() const;
  inline void set_yaw(float value);

  // optional float roll = 3;
  inline bool has_roll() const;
  inline void clear_roll();
  static const int kRollFieldNumber = 3;
  inline float roll() const;
  inline void set_roll(float value);

  // optional float pitch = 4;
  inline bool has_pitch() const;
  inline void clear_pitch();
  static const int kPitchFieldNumber = 4;
  inline float pitch() const;
  inline void set_pitch(float value);

  // optional float heading = 5;
  inline bool has_heading() const;
  inline void clear_heading();
  static const int kHeadingFieldNumber = 5;
  inline float heading() const;
  inline void set_heading(float value);

  // optional float speed = 6;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 6;
  inline float speed() const;
  inline void set_speed(float value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.OrientationStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_yaw();
  inline void clear_has_yaw();
  inline void set_has_roll();
  inline void clear_has_roll();
  inline void set_has_pitch();
  inline void clear_has_pitch();
  inline void set_has_heading();
  inline void clear_has_heading();
  inline void set_has_speed();
  inline void clear_has_speed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  float yaw_;
  float roll_;
  float pitch_;
  float heading_;
  float speed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static OrientationStatus* default_instance_;
};
// -------------------------------------------------------------------

class ReceiverStatus : public ::google::protobuf::Message {
 public:
  ReceiverStatus();
  virtual ~ReceiverStatus();

  ReceiverStatus(const ReceiverStatus& from);

  inline ReceiverStatus& operator=(const ReceiverStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiverStatus& default_instance();

  void Swap(ReceiverStatus* other);

  // implements Message ----------------------------------------------

  ReceiverStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReceiverStatus& from);
  void MergeFrom(const ReceiverStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ReceiverStatus_GainMode GainMode;
  static const GainMode AGC = ReceiverStatus_GainMode_AGC;
  static const GainMode MANUAL = ReceiverStatus_GainMode_MANUAL;
  static inline bool GainMode_IsValid(int value) {
    return ReceiverStatus_GainMode_IsValid(value);
  }
  static const GainMode GainMode_MIN =
    ReceiverStatus_GainMode_GainMode_MIN;
  static const GainMode GainMode_MAX =
    ReceiverStatus_GainMode_GainMode_MAX;
  static const int GainMode_ARRAYSIZE =
    ReceiverStatus_GainMode_GainMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GainMode_descriptor() {
    return ReceiverStatus_GainMode_descriptor();
  }
  static inline const ::std::string& GainMode_Name(GainMode value) {
    return ReceiverStatus_GainMode_Name(value);
  }
  static inline bool GainMode_Parse(const ::std::string& name,
      GainMode* value) {
    return ReceiverStatus_GainMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "RECEIVER_STATUS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 idNum = 2;
  inline bool has_idnum() const;
  inline void clear_idnum();
  static const int kIdNumFieldNumber = 2;
  inline ::google::protobuf::int32 idnum() const;
  inline void set_idnum(::google::protobuf::int32 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional float rxFreq = 5;
  inline bool has_rxfreq() const;
  inline void clear_rxfreq();
  static const int kRxFreqFieldNumber = 5;
  inline float rxfreq() const;
  inline void set_rxfreq(float value);

  // optional float rxBandwidth = 6;
  inline bool has_rxbandwidth() const;
  inline void clear_rxbandwidth();
  static const int kRxBandwidthFieldNumber = 6;
  inline float rxbandwidth() const;
  inline void set_rxbandwidth(float value);

  // optional int32 gain = 7;
  inline bool has_gain() const;
  inline void clear_gain();
  static const int kGainFieldNumber = 7;
  inline ::google::protobuf::int32 gain() const;
  inline void set_gain(::google::protobuf::int32 value);

  // optional .falcon_remoting_msg.ReceiverStatus.GainMode gainMode = 8;
  inline bool has_gainmode() const;
  inline void clear_gainmode();
  static const int kGainModeFieldNumber = 8;
  inline ::falcon_remoting_msg::ReceiverStatus_GainMode gainmode() const;
  inline void set_gainmode(::falcon_remoting_msg::ReceiverStatus_GainMode value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.ReceiverStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_idnum();
  inline void clear_has_idnum();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_rxfreq();
  inline void clear_has_rxfreq();
  inline void set_has_rxbandwidth();
  inline void clear_has_rxbandwidth();
  inline void set_has_gain();
  inline void clear_has_gain();
  inline void set_has_gainmode();
  inline void clear_has_gainmode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* name_;
  ::google::protobuf::int32 idnum_;
  float rxfreq_;
  ::std::string* type_;
  float rxbandwidth_;
  ::google::protobuf::int32 gain_;
  int gainmode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static ReceiverStatus* default_instance_;
};
// -------------------------------------------------------------------

class FieldofView : public ::google::protobuf::Message {
 public:
  FieldofView();
  virtual ~FieldofView();

  FieldofView(const FieldofView& from);

  inline FieldofView& operator=(const FieldofView& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FieldofView& default_instance();

  void Swap(FieldofView* other);

  // implements Message ----------------------------------------------

  FieldofView* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FieldofView& from);
  void MergeFrom(const FieldofView& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float boreSite = 1;
  inline bool has_boresite() const;
  inline void clear_boresite();
  static const int kBoreSiteFieldNumber = 1;
  inline float boresite() const;
  inline void set_boresite(float value);

  // optional float azimuth = 2;
  inline bool has_azimuth() const;
  inline void clear_azimuth();
  static const int kAzimuthFieldNumber = 2;
  inline float azimuth() const;
  inline void set_azimuth(float value);

  // optional float elevation = 3;
  inline bool has_elevation() const;
  inline void clear_elevation();
  static const int kElevationFieldNumber = 3;
  inline float elevation() const;
  inline void set_elevation(float value);

  // optional float beamWidth = 4;
  inline bool has_beamwidth() const;
  inline void clear_beamwidth();
  static const int kBeamWidthFieldNumber = 4;
  inline float beamwidth() const;
  inline void set_beamwidth(float value);

  // @@protoc_insertion_point(class_scope:falcon_remoting_msg.FieldofView)
 private:
  inline void set_has_boresite();
  inline void clear_has_boresite();
  inline void set_has_azimuth();
  inline void clear_has_azimuth();
  inline void set_has_elevation();
  inline void clear_has_elevation();
  inline void set_has_beamwidth();
  inline void clear_has_beamwidth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float boresite_;
  float azimuth_;
  float elevation_;
  float beamwidth_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_AssignDesc_FalconRemotingMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconRemotingMessages_2eproto();

  void InitAsDefaultInstance();
  static FieldofView* default_instance_;
};
// ===================================================================


// ===================================================================

// StatusReport

// optional string msgName = 1 [default = "STATUS_REPORT"];
inline bool StatusReport::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatusReport::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StatusReport::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StatusReport::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& StatusReport::msgname() const {
  return *msgname_;
}
inline void StatusReport::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void StatusReport::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void StatusReport::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatusReport::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* StatusReport::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void StatusReport::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 channel = 2;
inline bool StatusReport::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StatusReport::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StatusReport::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StatusReport::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 StatusReport::channel() const {
  return channel_;
}
inline void StatusReport::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// optional .falcon_remoting_msg.StatusReport.LogLevel level = 3;
inline bool StatusReport::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StatusReport::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StatusReport::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StatusReport::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::falcon_remoting_msg::StatusReport_LogLevel StatusReport::level() const {
  return static_cast< ::falcon_remoting_msg::StatusReport_LogLevel >(level_);
}
inline void StatusReport::set_level(::falcon_remoting_msg::StatusReport_LogLevel value) {
  assert(::falcon_remoting_msg::StatusReport_LogLevel_IsValid(value));
  set_has_level();
  level_ = value;
}

// optional string message = 4;
inline bool StatusReport::has_message() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StatusReport::set_has_message() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StatusReport::clear_has_message() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StatusReport::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& StatusReport::message() const {
  return *message_;
}
inline void StatusReport::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void StatusReport::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void StatusReport::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatusReport::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* StatusReport::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StatusReport::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BlacklistStatus

// optional string msgName = 1 [default = "BLACKLIST_STATUS"];
inline bool BlacklistStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlacklistStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlacklistStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlacklistStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& BlacklistStatus::msgname() const {
  return *msgname_;
}
inline void BlacklistStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void BlacklistStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void BlacklistStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlacklistStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* BlacklistStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void BlacklistStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// repeated .falcon_common_msg.BlacklistEntry entries = 2;
inline int BlacklistStatus::entries_size() const {
  return entries_.size();
}
inline void BlacklistStatus::clear_entries() {
  entries_.Clear();
}
inline const ::falcon_common_msg::BlacklistEntry& BlacklistStatus::entries(int index) const {
  return entries_.Get(index);
}
inline ::falcon_common_msg::BlacklistEntry* BlacklistStatus::mutable_entries(int index) {
  return entries_.Mutable(index);
}
inline ::falcon_common_msg::BlacklistEntry* BlacklistStatus::add_entries() {
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::BlacklistEntry >&
BlacklistStatus::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::BlacklistEntry >*
BlacklistStatus::mutable_entries() {
  return &entries_;
}

// -------------------------------------------------------------------

// InterceptListStatus

// optional string msgName = 1 [default = "INTERCEPT_LIST_STATUS"];
inline bool InterceptListStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InterceptListStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InterceptListStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InterceptListStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& InterceptListStatus::msgname() const {
  return *msgname_;
}
inline void InterceptListStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void InterceptListStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void InterceptListStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InterceptListStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* InterceptListStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void InterceptListStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// repeated .falcon_trigger_msg.Intercept entries = 2;
inline int InterceptListStatus::entries_size() const {
  return entries_.size();
}
inline void InterceptListStatus::clear_entries() {
  entries_.Clear();
}
inline const ::falcon_trigger_msg::Intercept& InterceptListStatus::entries(int index) const {
  return entries_.Get(index);
}
inline ::falcon_trigger_msg::Intercept* InterceptListStatus::mutable_entries(int index) {
  return entries_.Mutable(index);
}
inline ::falcon_trigger_msg::Intercept* InterceptListStatus::add_entries() {
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::falcon_trigger_msg::Intercept >&
InterceptListStatus::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::falcon_trigger_msg::Intercept >*
InterceptListStatus::mutable_entries() {
  return &entries_;
}

// -------------------------------------------------------------------

// ExternalsHitListStatus

// optional string msgName = 1 [default = "EXTERNALS_HIT_LIST_STATUS"];
inline bool ExternalsHitListStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExternalsHitListStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExternalsHitListStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExternalsHitListStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ExternalsHitListStatus::msgname() const {
  return *msgname_;
}
inline void ExternalsHitListStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ExternalsHitListStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ExternalsHitListStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExternalsHitListStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ExternalsHitListStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ExternalsHitListStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// repeated .falcon_externals_msg.ExternalsHit entries = 2;
inline int ExternalsHitListStatus::entries_size() const {
  return entries_.size();
}
inline void ExternalsHitListStatus::clear_entries() {
  entries_.Clear();
}
inline const ::falcon_externals_msg::ExternalsHit& ExternalsHitListStatus::entries(int index) const {
  return entries_.Get(index);
}
inline ::falcon_externals_msg::ExternalsHit* ExternalsHitListStatus::mutable_entries(int index) {
  return entries_.Mutable(index);
}
inline ::falcon_externals_msg::ExternalsHit* ExternalsHitListStatus::add_entries() {
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::falcon_externals_msg::ExternalsHit >&
ExternalsHitListStatus::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::falcon_externals_msg::ExternalsHit >*
ExternalsHitListStatus::mutable_entries() {
  return &entries_;
}

// -------------------------------------------------------------------

// GlobalSignalListStatus

// optional string msgName = 1 [default = "GLOBAL_SIGNAL_LIST_STATUS"];
inline bool GlobalSignalListStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GlobalSignalListStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GlobalSignalListStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GlobalSignalListStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& GlobalSignalListStatus::msgname() const {
  return *msgname_;
}
inline void GlobalSignalListStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GlobalSignalListStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GlobalSignalListStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GlobalSignalListStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* GlobalSignalListStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void GlobalSignalListStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 feed_id = 2;
inline bool GlobalSignalListStatus::has_feed_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GlobalSignalListStatus::set_has_feed_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GlobalSignalListStatus::clear_has_feed_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GlobalSignalListStatus::clear_feed_id() {
  feed_id_ = 0;
  clear_has_feed_id();
}
inline ::google::protobuf::int32 GlobalSignalListStatus::feed_id() const {
  return feed_id_;
}
inline void GlobalSignalListStatus::set_feed_id(::google::protobuf::int32 value) {
  set_has_feed_id();
  feed_id_ = value;
}

// -------------------------------------------------------------------

// StatusChannel

// optional string msgName = 1 [default = "STATUS_CHANNEL"];
inline bool StatusChannel::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatusChannel::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StatusChannel::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StatusChannel::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& StatusChannel::msgname() const {
  return *msgname_;
}
inline void StatusChannel::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void StatusChannel::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void StatusChannel::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatusChannel::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* StatusChannel::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void StatusChannel::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 appID = 2;
inline bool StatusChannel::has_appid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StatusChannel::set_has_appid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StatusChannel::clear_has_appid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StatusChannel::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 StatusChannel::appid() const {
  return appid_;
}
inline void StatusChannel::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional .falcon_remoting_msg.StatusChannel.Status status = 3;
inline bool StatusChannel::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StatusChannel::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StatusChannel::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StatusChannel::clear_status() {
  status_ = -3;
  clear_has_status();
}
inline ::falcon_remoting_msg::StatusChannel_Status StatusChannel::status() const {
  return static_cast< ::falcon_remoting_msg::StatusChannel_Status >(status_);
}
inline void StatusChannel::set_status(::falcon_remoting_msg::StatusChannel_Status value) {
  assert(::falcon_remoting_msg::StatusChannel_Status_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional string scrypt = 4;
inline bool StatusChannel::has_scrypt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StatusChannel::set_has_scrypt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StatusChannel::clear_has_scrypt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StatusChannel::clear_scrypt() {
  if (scrypt_ != &::google::protobuf::internal::kEmptyString) {
    scrypt_->clear();
  }
  clear_has_scrypt();
}
inline const ::std::string& StatusChannel::scrypt() const {
  return *scrypt_;
}
inline void StatusChannel::set_scrypt(const ::std::string& value) {
  set_has_scrypt();
  if (scrypt_ == &::google::protobuf::internal::kEmptyString) {
    scrypt_ = new ::std::string;
  }
  scrypt_->assign(value);
}
inline void StatusChannel::set_scrypt(const char* value) {
  set_has_scrypt();
  if (scrypt_ == &::google::protobuf::internal::kEmptyString) {
    scrypt_ = new ::std::string;
  }
  scrypt_->assign(value);
}
inline void StatusChannel::set_scrypt(const char* value, size_t size) {
  set_has_scrypt();
  if (scrypt_ == &::google::protobuf::internal::kEmptyString) {
    scrypt_ = new ::std::string;
  }
  scrypt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatusChannel::mutable_scrypt() {
  set_has_scrypt();
  if (scrypt_ == &::google::protobuf::internal::kEmptyString) {
    scrypt_ = new ::std::string;
  }
  return scrypt_;
}
inline ::std::string* StatusChannel::release_scrypt() {
  clear_has_scrypt();
  if (scrypt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = scrypt_;
    scrypt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StatusChannel::set_allocated_scrypt(::std::string* scrypt) {
  if (scrypt_ != &::google::protobuf::internal::kEmptyString) {
    delete scrypt_;
  }
  if (scrypt) {
    set_has_scrypt();
    scrypt_ = scrypt;
  } else {
    clear_has_scrypt();
    scrypt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// HealthStatus

// optional string msgName = 1 [default = "HEALTH_STATUS"];
inline bool HealthStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HealthStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HealthStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HealthStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& HealthStatus::msgname() const {
  return *msgname_;
}
inline void HealthStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void HealthStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void HealthStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HealthStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* HealthStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void HealthStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 channel = 2;
inline bool HealthStatus::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HealthStatus::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HealthStatus::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HealthStatus::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 HealthStatus::channel() const {
  return channel_;
}
inline void HealthStatus::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// optional string pic = 3 [default = "NO_PIC"];
inline bool HealthStatus::has_pic() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HealthStatus::set_has_pic() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HealthStatus::clear_has_pic() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HealthStatus::clear_pic() {
  if (pic_ != _default_pic_) {
    pic_->assign(*_default_pic_);
  }
  clear_has_pic();
}
inline const ::std::string& HealthStatus::pic() const {
  return *pic_;
}
inline void HealthStatus::set_pic(const ::std::string& value) {
  set_has_pic();
  if (pic_ == _default_pic_) {
    pic_ = new ::std::string;
  }
  pic_->assign(value);
}
inline void HealthStatus::set_pic(const char* value) {
  set_has_pic();
  if (pic_ == _default_pic_) {
    pic_ = new ::std::string;
  }
  pic_->assign(value);
}
inline void HealthStatus::set_pic(const char* value, size_t size) {
  set_has_pic();
  if (pic_ == _default_pic_) {
    pic_ = new ::std::string;
  }
  pic_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HealthStatus::mutable_pic() {
  set_has_pic();
  if (pic_ == _default_pic_) {
    pic_ = new ::std::string(*_default_pic_);
  }
  return pic_;
}
inline ::std::string* HealthStatus::release_pic() {
  clear_has_pic();
  if (pic_ == _default_pic_) {
    return NULL;
  } else {
    ::std::string* temp = pic_;
    pic_ = const_cast< ::std::string*>(_default_pic_);
    return temp;
  }
}
inline void HealthStatus::set_allocated_pic(::std::string* pic) {
  if (pic_ != _default_pic_) {
    delete pic_;
  }
  if (pic) {
    set_has_pic();
    pic_ = pic;
  } else {
    clear_has_pic();
    pic_ = const_cast< ::std::string*>(_default_pic_);
  }
}

// optional string ntp = 4 [default = "F"];
inline bool HealthStatus::has_ntp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HealthStatus::set_has_ntp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HealthStatus::clear_has_ntp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HealthStatus::clear_ntp() {
  if (ntp_ != _default_ntp_) {
    ntp_->assign(*_default_ntp_);
  }
  clear_has_ntp();
}
inline const ::std::string& HealthStatus::ntp() const {
  return *ntp_;
}
inline void HealthStatus::set_ntp(const ::std::string& value) {
  set_has_ntp();
  if (ntp_ == _default_ntp_) {
    ntp_ = new ::std::string;
  }
  ntp_->assign(value);
}
inline void HealthStatus::set_ntp(const char* value) {
  set_has_ntp();
  if (ntp_ == _default_ntp_) {
    ntp_ = new ::std::string;
  }
  ntp_->assign(value);
}
inline void HealthStatus::set_ntp(const char* value, size_t size) {
  set_has_ntp();
  if (ntp_ == _default_ntp_) {
    ntp_ = new ::std::string;
  }
  ntp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HealthStatus::mutable_ntp() {
  set_has_ntp();
  if (ntp_ == _default_ntp_) {
    ntp_ = new ::std::string(*_default_ntp_);
  }
  return ntp_;
}
inline ::std::string* HealthStatus::release_ntp() {
  clear_has_ntp();
  if (ntp_ == _default_ntp_) {
    return NULL;
  } else {
    ::std::string* temp = ntp_;
    ntp_ = const_cast< ::std::string*>(_default_ntp_);
    return temp;
  }
}
inline void HealthStatus::set_allocated_ntp(::std::string* ntp) {
  if (ntp_ != _default_ntp_) {
    delete ntp_;
  }
  if (ntp) {
    set_has_ntp();
    ntp_ = ntp;
  } else {
    clear_has_ntp();
    ntp_ = const_cast< ::std::string*>(_default_ntp_);
  }
}

// optional string mhz = 5 [default = "F"];
inline bool HealthStatus::has_mhz() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HealthStatus::set_has_mhz() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HealthStatus::clear_has_mhz() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HealthStatus::clear_mhz() {
  if (mhz_ != _default_mhz_) {
    mhz_->assign(*_default_mhz_);
  }
  clear_has_mhz();
}
inline const ::std::string& HealthStatus::mhz() const {
  return *mhz_;
}
inline void HealthStatus::set_mhz(const ::std::string& value) {
  set_has_mhz();
  if (mhz_ == _default_mhz_) {
    mhz_ = new ::std::string;
  }
  mhz_->assign(value);
}
inline void HealthStatus::set_mhz(const char* value) {
  set_has_mhz();
  if (mhz_ == _default_mhz_) {
    mhz_ = new ::std::string;
  }
  mhz_->assign(value);
}
inline void HealthStatus::set_mhz(const char* value, size_t size) {
  set_has_mhz();
  if (mhz_ == _default_mhz_) {
    mhz_ = new ::std::string;
  }
  mhz_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HealthStatus::mutable_mhz() {
  set_has_mhz();
  if (mhz_ == _default_mhz_) {
    mhz_ = new ::std::string(*_default_mhz_);
  }
  return mhz_;
}
inline ::std::string* HealthStatus::release_mhz() {
  clear_has_mhz();
  if (mhz_ == _default_mhz_) {
    return NULL;
  } else {
    ::std::string* temp = mhz_;
    mhz_ = const_cast< ::std::string*>(_default_mhz_);
    return temp;
  }
}
inline void HealthStatus::set_allocated_mhz(::std::string* mhz) {
  if (mhz_ != _default_mhz_) {
    delete mhz_;
  }
  if (mhz) {
    set_has_mhz();
    mhz_ = mhz;
  } else {
    clear_has_mhz();
    mhz_ = const_cast< ::std::string*>(_default_mhz_);
  }
}

// optional string pps = 6 [default = "F"];
inline bool HealthStatus::has_pps() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HealthStatus::set_has_pps() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HealthStatus::clear_has_pps() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HealthStatus::clear_pps() {
  if (pps_ != _default_pps_) {
    pps_->assign(*_default_pps_);
  }
  clear_has_pps();
}
inline const ::std::string& HealthStatus::pps() const {
  return *pps_;
}
inline void HealthStatus::set_pps(const ::std::string& value) {
  set_has_pps();
  if (pps_ == _default_pps_) {
    pps_ = new ::std::string;
  }
  pps_->assign(value);
}
inline void HealthStatus::set_pps(const char* value) {
  set_has_pps();
  if (pps_ == _default_pps_) {
    pps_ = new ::std::string;
  }
  pps_->assign(value);
}
inline void HealthStatus::set_pps(const char* value, size_t size) {
  set_has_pps();
  if (pps_ == _default_pps_) {
    pps_ = new ::std::string;
  }
  pps_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HealthStatus::mutable_pps() {
  set_has_pps();
  if (pps_ == _default_pps_) {
    pps_ = new ::std::string(*_default_pps_);
  }
  return pps_;
}
inline ::std::string* HealthStatus::release_pps() {
  clear_has_pps();
  if (pps_ == _default_pps_) {
    return NULL;
  } else {
    ::std::string* temp = pps_;
    pps_ = const_cast< ::std::string*>(_default_pps_);
    return temp;
  }
}
inline void HealthStatus::set_allocated_pps(::std::string* pps) {
  if (pps_ != _default_pps_) {
    delete pps_;
  }
  if (pps) {
    set_has_pps();
    pps_ = pps;
  } else {
    clear_has_pps();
    pps_ = const_cast< ::std::string*>(_default_pps_);
  }
}

// optional string serial = 7 [default = "F"];
inline bool HealthStatus::has_serial() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HealthStatus::set_has_serial() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HealthStatus::clear_has_serial() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HealthStatus::clear_serial() {
  if (serial_ != _default_serial_) {
    serial_->assign(*_default_serial_);
  }
  clear_has_serial();
}
inline const ::std::string& HealthStatus::serial() const {
  return *serial_;
}
inline void HealthStatus::set_serial(const ::std::string& value) {
  set_has_serial();
  if (serial_ == _default_serial_) {
    serial_ = new ::std::string;
  }
  serial_->assign(value);
}
inline void HealthStatus::set_serial(const char* value) {
  set_has_serial();
  if (serial_ == _default_serial_) {
    serial_ = new ::std::string;
  }
  serial_->assign(value);
}
inline void HealthStatus::set_serial(const char* value, size_t size) {
  set_has_serial();
  if (serial_ == _default_serial_) {
    serial_ = new ::std::string;
  }
  serial_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HealthStatus::mutable_serial() {
  set_has_serial();
  if (serial_ == _default_serial_) {
    serial_ = new ::std::string(*_default_serial_);
  }
  return serial_;
}
inline ::std::string* HealthStatus::release_serial() {
  clear_has_serial();
  if (serial_ == _default_serial_) {
    return NULL;
  } else {
    ::std::string* temp = serial_;
    serial_ = const_cast< ::std::string*>(_default_serial_);
    return temp;
  }
}
inline void HealthStatus::set_allocated_serial(::std::string* serial) {
  if (serial_ != _default_serial_) {
    delete serial_;
  }
  if (serial) {
    set_has_serial();
    serial_ = serial;
  } else {
    clear_has_serial();
    serial_ = const_cast< ::std::string*>(_default_serial_);
  }
}

// optional string rx = 8 [default = "F"];
inline bool HealthStatus::has_rx() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HealthStatus::set_has_rx() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HealthStatus::clear_has_rx() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HealthStatus::clear_rx() {
  if (rx_ != _default_rx_) {
    rx_->assign(*_default_rx_);
  }
  clear_has_rx();
}
inline const ::std::string& HealthStatus::rx() const {
  return *rx_;
}
inline void HealthStatus::set_rx(const ::std::string& value) {
  set_has_rx();
  if (rx_ == _default_rx_) {
    rx_ = new ::std::string;
  }
  rx_->assign(value);
}
inline void HealthStatus::set_rx(const char* value) {
  set_has_rx();
  if (rx_ == _default_rx_) {
    rx_ = new ::std::string;
  }
  rx_->assign(value);
}
inline void HealthStatus::set_rx(const char* value, size_t size) {
  set_has_rx();
  if (rx_ == _default_rx_) {
    rx_ = new ::std::string;
  }
  rx_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HealthStatus::mutable_rx() {
  set_has_rx();
  if (rx_ == _default_rx_) {
    rx_ = new ::std::string(*_default_rx_);
  }
  return rx_;
}
inline ::std::string* HealthStatus::release_rx() {
  clear_has_rx();
  if (rx_ == _default_rx_) {
    return NULL;
  } else {
    ::std::string* temp = rx_;
    rx_ = const_cast< ::std::string*>(_default_rx_);
    return temp;
  }
}
inline void HealthStatus::set_allocated_rx(::std::string* rx) {
  if (rx_ != _default_rx_) {
    delete rx_;
  }
  if (rx) {
    set_has_rx();
    rx_ = rx;
  } else {
    clear_has_rx();
    rx_ = const_cast< ::std::string*>(_default_rx_);
  }
}

// optional string raid = 9 [default = "F"];
inline bool HealthStatus::has_raid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HealthStatus::set_has_raid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HealthStatus::clear_has_raid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HealthStatus::clear_raid() {
  if (raid_ != _default_raid_) {
    raid_->assign(*_default_raid_);
  }
  clear_has_raid();
}
inline const ::std::string& HealthStatus::raid() const {
  return *raid_;
}
inline void HealthStatus::set_raid(const ::std::string& value) {
  set_has_raid();
  if (raid_ == _default_raid_) {
    raid_ = new ::std::string;
  }
  raid_->assign(value);
}
inline void HealthStatus::set_raid(const char* value) {
  set_has_raid();
  if (raid_ == _default_raid_) {
    raid_ = new ::std::string;
  }
  raid_->assign(value);
}
inline void HealthStatus::set_raid(const char* value, size_t size) {
  set_has_raid();
  if (raid_ == _default_raid_) {
    raid_ = new ::std::string;
  }
  raid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HealthStatus::mutable_raid() {
  set_has_raid();
  if (raid_ == _default_raid_) {
    raid_ = new ::std::string(*_default_raid_);
  }
  return raid_;
}
inline ::std::string* HealthStatus::release_raid() {
  clear_has_raid();
  if (raid_ == _default_raid_) {
    return NULL;
  } else {
    ::std::string* temp = raid_;
    raid_ = const_cast< ::std::string*>(_default_raid_);
    return temp;
  }
}
inline void HealthStatus::set_allocated_raid(::std::string* raid) {
  if (raid_ != _default_raid_) {
    delete raid_;
  }
  if (raid) {
    set_has_raid();
    raid_ = raid;
  } else {
    clear_has_raid();
    raid_ = const_cast< ::std::string*>(_default_raid_);
  }
}

// optional string disabled = 10 [default = "UNKNOWN"];
inline bool HealthStatus::has_disabled() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void HealthStatus::set_has_disabled() {
  _has_bits_[0] |= 0x00000200u;
}
inline void HealthStatus::clear_has_disabled() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void HealthStatus::clear_disabled() {
  if (disabled_ != _default_disabled_) {
    disabled_->assign(*_default_disabled_);
  }
  clear_has_disabled();
}
inline const ::std::string& HealthStatus::disabled() const {
  return *disabled_;
}
inline void HealthStatus::set_disabled(const ::std::string& value) {
  set_has_disabled();
  if (disabled_ == _default_disabled_) {
    disabled_ = new ::std::string;
  }
  disabled_->assign(value);
}
inline void HealthStatus::set_disabled(const char* value) {
  set_has_disabled();
  if (disabled_ == _default_disabled_) {
    disabled_ = new ::std::string;
  }
  disabled_->assign(value);
}
inline void HealthStatus::set_disabled(const char* value, size_t size) {
  set_has_disabled();
  if (disabled_ == _default_disabled_) {
    disabled_ = new ::std::string;
  }
  disabled_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HealthStatus::mutable_disabled() {
  set_has_disabled();
  if (disabled_ == _default_disabled_) {
    disabled_ = new ::std::string(*_default_disabled_);
  }
  return disabled_;
}
inline ::std::string* HealthStatus::release_disabled() {
  clear_has_disabled();
  if (disabled_ == _default_disabled_) {
    return NULL;
  } else {
    ::std::string* temp = disabled_;
    disabled_ = const_cast< ::std::string*>(_default_disabled_);
    return temp;
  }
}
inline void HealthStatus::set_allocated_disabled(::std::string* disabled) {
  if (disabled_ != _default_disabled_) {
    delete disabled_;
  }
  if (disabled) {
    set_has_disabled();
    disabled_ = disabled;
  } else {
    clear_has_disabled();
    disabled_ = const_cast< ::std::string*>(_default_disabled_);
  }
}

// optional int32 ssid = 11;
inline bool HealthStatus::has_ssid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void HealthStatus::set_has_ssid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void HealthStatus::clear_has_ssid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void HealthStatus::clear_ssid() {
  ssid_ = 0;
  clear_has_ssid();
}
inline ::google::protobuf::int32 HealthStatus::ssid() const {
  return ssid_;
}
inline void HealthStatus::set_ssid(::google::protobuf::int32 value) {
  set_has_ssid();
  ssid_ = value;
}

// optional string uniqrxid = 12;
inline bool HealthStatus::has_uniqrxid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void HealthStatus::set_has_uniqrxid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void HealthStatus::clear_has_uniqrxid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void HealthStatus::clear_uniqrxid() {
  if (uniqrxid_ != &::google::protobuf::internal::kEmptyString) {
    uniqrxid_->clear();
  }
  clear_has_uniqrxid();
}
inline const ::std::string& HealthStatus::uniqrxid() const {
  return *uniqrxid_;
}
inline void HealthStatus::set_uniqrxid(const ::std::string& value) {
  set_has_uniqrxid();
  if (uniqrxid_ == &::google::protobuf::internal::kEmptyString) {
    uniqrxid_ = new ::std::string;
  }
  uniqrxid_->assign(value);
}
inline void HealthStatus::set_uniqrxid(const char* value) {
  set_has_uniqrxid();
  if (uniqrxid_ == &::google::protobuf::internal::kEmptyString) {
    uniqrxid_ = new ::std::string;
  }
  uniqrxid_->assign(value);
}
inline void HealthStatus::set_uniqrxid(const char* value, size_t size) {
  set_has_uniqrxid();
  if (uniqrxid_ == &::google::protobuf::internal::kEmptyString) {
    uniqrxid_ = new ::std::string;
  }
  uniqrxid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HealthStatus::mutable_uniqrxid() {
  set_has_uniqrxid();
  if (uniqrxid_ == &::google::protobuf::internal::kEmptyString) {
    uniqrxid_ = new ::std::string;
  }
  return uniqrxid_;
}
inline ::std::string* HealthStatus::release_uniqrxid() {
  clear_has_uniqrxid();
  if (uniqrxid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uniqrxid_;
    uniqrxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HealthStatus::set_allocated_uniqrxid(::std::string* uniqrxid) {
  if (uniqrxid_ != &::google::protobuf::internal::kEmptyString) {
    delete uniqrxid_;
  }
  if (uniqrxid) {
    set_has_uniqrxid();
    uniqrxid_ = uniqrxid;
  } else {
    clear_has_uniqrxid();
    uniqrxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// HealthMessage

// optional string msgName = 1 [default = "HEALTH_MESSAGE"];
inline bool HealthMessage::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HealthMessage::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HealthMessage::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HealthMessage::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& HealthMessage::msgname() const {
  return *msgname_;
}
inline void HealthMessage::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void HealthMessage::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void HealthMessage::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HealthMessage::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* HealthMessage::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void HealthMessage::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string description = 2;
inline bool HealthMessage::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HealthMessage::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HealthMessage::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HealthMessage::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& HealthMessage::description() const {
  return *description_;
}
inline void HealthMessage::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void HealthMessage::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void HealthMessage::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HealthMessage::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* HealthMessage::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HealthMessage::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .falcon_remoting_msg.HealthMessage.Code code = 3;
inline bool HealthMessage::has_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HealthMessage::set_has_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HealthMessage::clear_has_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HealthMessage::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::falcon_remoting_msg::HealthMessage_Code HealthMessage::code() const {
  return static_cast< ::falcon_remoting_msg::HealthMessage_Code >(code_);
}
inline void HealthMessage::set_code(::falcon_remoting_msg::HealthMessage_Code value) {
  assert(::falcon_remoting_msg::HealthMessage_Code_IsValid(value));
  set_has_code();
  code_ = value;
}

// optional string status = 4;
inline bool HealthMessage::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HealthMessage::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HealthMessage::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HealthMessage::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& HealthMessage::status() const {
  return *status_;
}
inline void HealthMessage::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void HealthMessage::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void HealthMessage::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HealthMessage::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* HealthMessage::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HealthMessage::set_allocated_status(::std::string* status) {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    delete status_;
  }
  if (status) {
    set_has_status();
    status_ = status;
  } else {
    clear_has_status();
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string type = 5 [default = "Functional"];
inline bool HealthMessage::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HealthMessage::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HealthMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HealthMessage::clear_type() {
  if (type_ != _default_type_) {
    type_->assign(*_default_type_);
  }
  clear_has_type();
}
inline const ::std::string& HealthMessage::type() const {
  return *type_;
}
inline void HealthMessage::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void HealthMessage::set_type(const char* value) {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void HealthMessage::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HealthMessage::mutable_type() {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string(*_default_type_);
  }
  return type_;
}
inline ::std::string* HealthMessage::release_type() {
  clear_has_type();
  if (type_ == _default_type_) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(_default_type_);
    return temp;
  }
}
inline void HealthMessage::set_allocated_type(::std::string* type) {
  if (type_ != _default_type_) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(_default_type_);
  }
}

// optional string timestamp = 6;
inline bool HealthMessage::has_timestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HealthMessage::set_has_timestamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HealthMessage::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HealthMessage::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& HealthMessage::timestamp() const {
  return *timestamp_;
}
inline void HealthMessage::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void HealthMessage::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void HealthMessage::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HealthMessage::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* HealthMessage::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HealthMessage::set_allocated_timestamp(::std::string* timestamp) {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    delete timestamp_;
  }
  if (timestamp) {
    set_has_timestamp();
    timestamp_ = timestamp;
  } else {
    clear_has_timestamp();
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// HealthTest

// optional string msgName = 1 [default = "HEALTH_TEST"];
inline bool HealthTest::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HealthTest::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HealthTest::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HealthTest::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& HealthTest::msgname() const {
  return *msgname_;
}
inline void HealthTest::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void HealthTest::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void HealthTest::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HealthTest::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* HealthTest::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void HealthTest::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional .falcon_remoting_msg.HealthTest.Status status = 2;
inline bool HealthTest::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HealthTest::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HealthTest::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HealthTest::clear_status() {
  status_ = -1;
  clear_has_status();
}
inline ::falcon_remoting_msg::HealthTest_Status HealthTest::status() const {
  return static_cast< ::falcon_remoting_msg::HealthTest_Status >(status_);
}
inline void HealthTest::set_status(::falcon_remoting_msg::HealthTest_Status value) {
  assert(::falcon_remoting_msg::HealthTest_Status_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// SignalEvent

// optional string msgName = 1 [default = "SIGNAL_EVENT"];
inline bool SignalEvent::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignalEvent::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignalEvent::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignalEvent::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SignalEvent::msgname() const {
  return *msgname_;
}
inline void SignalEvent::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SignalEvent::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SignalEvent::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalEvent::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SignalEvent::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SignalEvent::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 channel = 2;
inline bool SignalEvent::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignalEvent::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignalEvent::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignalEvent::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 SignalEvent::channel() const {
  return channel_;
}
inline void SignalEvent::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// optional .falcon_remoting_msg.SignalEvent.Type eventType = 3;
inline bool SignalEvent::has_eventtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignalEvent::set_has_eventtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignalEvent::clear_has_eventtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignalEvent::clear_eventtype() {
  eventtype_ = 0;
  clear_has_eventtype();
}
inline ::falcon_remoting_msg::SignalEvent_Type SignalEvent::eventtype() const {
  return static_cast< ::falcon_remoting_msg::SignalEvent_Type >(eventtype_);
}
inline void SignalEvent::set_eventtype(::falcon_remoting_msg::SignalEvent_Type value) {
  assert(::falcon_remoting_msg::SignalEvent_Type_IsValid(value));
  set_has_eventtype();
  eventtype_ = value;
}

// optional string eventID = 4;
inline bool SignalEvent::has_eventid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignalEvent::set_has_eventid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignalEvent::clear_has_eventid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignalEvent::clear_eventid() {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    eventid_->clear();
  }
  clear_has_eventid();
}
inline const ::std::string& SignalEvent::eventid() const {
  return *eventid_;
}
inline void SignalEvent::set_eventid(const ::std::string& value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void SignalEvent::set_eventid(const char* value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void SignalEvent::set_eventid(const char* value, size_t size) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalEvent::mutable_eventid() {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  return eventid_;
}
inline ::std::string* SignalEvent::release_eventid() {
  clear_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventid_;
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignalEvent::set_allocated_eventid(::std::string* eventid) {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    delete eventid_;
  }
  if (eventid) {
    set_has_eventid();
    eventid_ = eventid;
  } else {
    clear_has_eventid();
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string timestamp = 5;
inline bool SignalEvent::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SignalEvent::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SignalEvent::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SignalEvent::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& SignalEvent::timestamp() const {
  return *timestamp_;
}
inline void SignalEvent::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void SignalEvent::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void SignalEvent::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalEvent::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* SignalEvent::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignalEvent::set_allocated_timestamp(::std::string* timestamp) {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    delete timestamp_;
  }
  if (timestamp) {
    set_has_timestamp();
    timestamp_ = timestamp;
  } else {
    clear_has_timestamp();
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string soiNum = 6;
inline bool SignalEvent::has_soinum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SignalEvent::set_has_soinum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SignalEvent::clear_has_soinum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SignalEvent::clear_soinum() {
  if (soinum_ != &::google::protobuf::internal::kEmptyString) {
    soinum_->clear();
  }
  clear_has_soinum();
}
inline const ::std::string& SignalEvent::soinum() const {
  return *soinum_;
}
inline void SignalEvent::set_soinum(const ::std::string& value) {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  soinum_->assign(value);
}
inline void SignalEvent::set_soinum(const char* value) {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  soinum_->assign(value);
}
inline void SignalEvent::set_soinum(const char* value, size_t size) {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  soinum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalEvent::mutable_soinum() {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  return soinum_;
}
inline ::std::string* SignalEvent::release_soinum() {
  clear_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = soinum_;
    soinum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignalEvent::set_allocated_soinum(::std::string* soinum) {
  if (soinum_ != &::google::protobuf::internal::kEmptyString) {
    delete soinum_;
  }
  if (soinum) {
    set_has_soinum();
    soinum_ = soinum;
  } else {
    clear_has_soinum();
    soinum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float rfMHz = 7;
inline bool SignalEvent::has_rfmhz() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SignalEvent::set_has_rfmhz() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SignalEvent::clear_has_rfmhz() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SignalEvent::clear_rfmhz() {
  rfmhz_ = 0;
  clear_has_rfmhz();
}
inline float SignalEvent::rfmhz() const {
  return rfmhz_;
}
inline void SignalEvent::set_rfmhz(float value) {
  set_has_rfmhz();
  rfmhz_ = value;
}

// optional float subcarMHz = 8;
inline bool SignalEvent::has_subcarmhz() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SignalEvent::set_has_subcarmhz() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SignalEvent::clear_has_subcarmhz() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SignalEvent::clear_subcarmhz() {
  subcarmhz_ = 0;
  clear_has_subcarmhz();
}
inline float SignalEvent::subcarmhz() const {
  return subcarmhz_;
}
inline void SignalEvent::set_subcarmhz(float value) {
  set_has_subcarmhz();
  subcarmhz_ = value;
}

// optional float excurKHz = 9;
inline bool SignalEvent::has_excurkhz() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SignalEvent::set_has_excurkhz() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SignalEvent::clear_has_excurkhz() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SignalEvent::clear_excurkhz() {
  excurkhz_ = 0;
  clear_has_excurkhz();
}
inline float SignalEvent::excurkhz() const {
  return excurkhz_;
}
inline void SignalEvent::set_excurkhz(float value) {
  set_has_excurkhz();
  excurkhz_ = value;
}

// optional int32 appID = 10;
inline bool SignalEvent::has_appid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SignalEvent::set_has_appid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SignalEvent::clear_has_appid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SignalEvent::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 SignalEvent::appid() const {
  return appid_;
}
inline void SignalEvent::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional int32 antNum = 11;
inline bool SignalEvent::has_antnum() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SignalEvent::set_has_antnum() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SignalEvent::clear_has_antnum() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SignalEvent::clear_antnum() {
  antnum_ = 0;
  clear_has_antnum();
}
inline ::google::protobuf::int32 SignalEvent::antnum() const {
  return antnum_;
}
inline void SignalEvent::set_antnum(::google::protobuf::int32 value) {
  set_has_antnum();
  antnum_ = value;
}

// optional float antAz = 12 [default = 0];
inline bool SignalEvent::has_antaz() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SignalEvent::set_has_antaz() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SignalEvent::clear_has_antaz() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SignalEvent::clear_antaz() {
  antaz_ = 0;
  clear_has_antaz();
}
inline float SignalEvent::antaz() const {
  return antaz_;
}
inline void SignalEvent::set_antaz(float value) {
  set_has_antaz();
  antaz_ = value;
}

// optional float antEl = 13 [default = 0];
inline bool SignalEvent::has_antel() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SignalEvent::set_has_antel() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SignalEvent::clear_has_antel() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SignalEvent::clear_antel() {
  antel_ = 0;
  clear_has_antel();
}
inline float SignalEvent::antel() const {
  return antel_;
}
inline void SignalEvent::set_antel(float value) {
  set_has_antel();
  antel_ = value;
}

// optional string globalID = 14;
inline bool SignalEvent::has_globalid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SignalEvent::set_has_globalid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SignalEvent::clear_has_globalid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SignalEvent::clear_globalid() {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    globalid_->clear();
  }
  clear_has_globalid();
}
inline const ::std::string& SignalEvent::globalid() const {
  return *globalid_;
}
inline void SignalEvent::set_globalid(const ::std::string& value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void SignalEvent::set_globalid(const char* value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void SignalEvent::set_globalid(const char* value, size_t size) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalEvent::mutable_globalid() {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  return globalid_;
}
inline ::std::string* SignalEvent::release_globalid() {
  clear_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalid_;
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignalEvent::set_allocated_globalid(::std::string* globalid) {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    delete globalid_;
  }
  if (globalid) {
    set_has_globalid();
    globalid_ = globalid;
  } else {
    clear_has_globalid();
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string scrypt = 15;
inline bool SignalEvent::has_scrypt() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SignalEvent::set_has_scrypt() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SignalEvent::clear_has_scrypt() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SignalEvent::clear_scrypt() {
  if (scrypt_ != &::google::protobuf::internal::kEmptyString) {
    scrypt_->clear();
  }
  clear_has_scrypt();
}
inline const ::std::string& SignalEvent::scrypt() const {
  return *scrypt_;
}
inline void SignalEvent::set_scrypt(const ::std::string& value) {
  set_has_scrypt();
  if (scrypt_ == &::google::protobuf::internal::kEmptyString) {
    scrypt_ = new ::std::string;
  }
  scrypt_->assign(value);
}
inline void SignalEvent::set_scrypt(const char* value) {
  set_has_scrypt();
  if (scrypt_ == &::google::protobuf::internal::kEmptyString) {
    scrypt_ = new ::std::string;
  }
  scrypt_->assign(value);
}
inline void SignalEvent::set_scrypt(const char* value, size_t size) {
  set_has_scrypt();
  if (scrypt_ == &::google::protobuf::internal::kEmptyString) {
    scrypt_ = new ::std::string;
  }
  scrypt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalEvent::mutable_scrypt() {
  set_has_scrypt();
  if (scrypt_ == &::google::protobuf::internal::kEmptyString) {
    scrypt_ = new ::std::string;
  }
  return scrypt_;
}
inline ::std::string* SignalEvent::release_scrypt() {
  clear_has_scrypt();
  if (scrypt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = scrypt_;
    scrypt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignalEvent::set_allocated_scrypt(::std::string* scrypt) {
  if (scrypt_ != &::google::protobuf::internal::kEmptyString) {
    delete scrypt_;
  }
  if (scrypt) {
    set_has_scrypt();
    scrypt_ = scrypt;
  } else {
    clear_has_scrypt();
    scrypt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 exportPort = 16;
inline bool SignalEvent::has_exportport() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SignalEvent::set_has_exportport() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SignalEvent::clear_has_exportport() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SignalEvent::clear_exportport() {
  exportport_ = 0;
  clear_has_exportport();
}
inline ::google::protobuf::int32 SignalEvent::exportport() const {
  return exportport_;
}
inline void SignalEvent::set_exportport(::google::protobuf::int32 value) {
  set_has_exportport();
  exportport_ = value;
}

// optional string eltex = 17;
inline bool SignalEvent::has_eltex() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SignalEvent::set_has_eltex() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SignalEvent::clear_has_eltex() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SignalEvent::clear_eltex() {
  if (eltex_ != &::google::protobuf::internal::kEmptyString) {
    eltex_->clear();
  }
  clear_has_eltex();
}
inline const ::std::string& SignalEvent::eltex() const {
  return *eltex_;
}
inline void SignalEvent::set_eltex(const ::std::string& value) {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  eltex_->assign(value);
}
inline void SignalEvent::set_eltex(const char* value) {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  eltex_->assign(value);
}
inline void SignalEvent::set_eltex(const char* value, size_t size) {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  eltex_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalEvent::mutable_eltex() {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  return eltex_;
}
inline ::std::string* SignalEvent::release_eltex() {
  clear_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eltex_;
    eltex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignalEvent::set_allocated_eltex(::std::string* eltex) {
  if (eltex_ != &::google::protobuf::internal::kEmptyString) {
    delete eltex_;
  }
  if (eltex) {
    set_has_eltex();
    eltex_ = eltex;
  } else {
    clear_has_eltex();
    eltex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float bwMHz = 18;
inline bool SignalEvent::has_bwmhz() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SignalEvent::set_has_bwmhz() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SignalEvent::clear_has_bwmhz() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SignalEvent::clear_bwmhz() {
  bwmhz_ = 0;
  clear_has_bwmhz();
}
inline float SignalEvent::bwmhz() const {
  return bwmhz_;
}
inline void SignalEvent::set_bwmhz(float value) {
  set_has_bwmhz();
  bwmhz_ = value;
}

// optional string sensorName = 19 [default = ""];
inline bool SignalEvent::has_sensorname() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SignalEvent::set_has_sensorname() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SignalEvent::clear_has_sensorname() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SignalEvent::clear_sensorname() {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    sensorname_->clear();
  }
  clear_has_sensorname();
}
inline const ::std::string& SignalEvent::sensorname() const {
  return *sensorname_;
}
inline void SignalEvent::set_sensorname(const ::std::string& value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void SignalEvent::set_sensorname(const char* value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void SignalEvent::set_sensorname(const char* value, size_t size) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalEvent::mutable_sensorname() {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  return sensorname_;
}
inline ::std::string* SignalEvent::release_sensorname() {
  clear_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sensorname_;
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignalEvent::set_allocated_sensorname(::std::string* sensorname) {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    delete sensorname_;
  }
  if (sensorname) {
    set_has_sensorname();
    sensorname_ = sensorname;
  } else {
    clear_has_sensorname();
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .falcon_externals_msg.ExternalsHit externals = 20;
inline bool SignalEvent::has_externals() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SignalEvent::set_has_externals() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SignalEvent::clear_has_externals() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SignalEvent::clear_externals() {
  if (externals_ != NULL) externals_->::falcon_externals_msg::ExternalsHit::Clear();
  clear_has_externals();
}
inline const ::falcon_externals_msg::ExternalsHit& SignalEvent::externals() const {
  return externals_ != NULL ? *externals_ : *default_instance_->externals_;
}
inline ::falcon_externals_msg::ExternalsHit* SignalEvent::mutable_externals() {
  set_has_externals();
  if (externals_ == NULL) externals_ = new ::falcon_externals_msg::ExternalsHit;
  return externals_;
}
inline ::falcon_externals_msg::ExternalsHit* SignalEvent::release_externals() {
  clear_has_externals();
  ::falcon_externals_msg::ExternalsHit* temp = externals_;
  externals_ = NULL;
  return temp;
}
inline void SignalEvent::set_allocated_externals(::falcon_externals_msg::ExternalsHit* externals) {
  delete externals_;
  externals_ = externals;
  if (externals) {
    set_has_externals();
  } else {
    clear_has_externals();
  }
}

// optional .falcon_externals_msg.InternalsHit internals = 21;
inline bool SignalEvent::has_internals() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SignalEvent::set_has_internals() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SignalEvent::clear_has_internals() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SignalEvent::clear_internals() {
  if (internals_ != NULL) internals_->::falcon_externals_msg::InternalsHit::Clear();
  clear_has_internals();
}
inline const ::falcon_externals_msg::InternalsHit& SignalEvent::internals() const {
  return internals_ != NULL ? *internals_ : *default_instance_->internals_;
}
inline ::falcon_externals_msg::InternalsHit* SignalEvent::mutable_internals() {
  set_has_internals();
  if (internals_ == NULL) internals_ = new ::falcon_externals_msg::InternalsHit;
  return internals_;
}
inline ::falcon_externals_msg::InternalsHit* SignalEvent::release_internals() {
  clear_has_internals();
  ::falcon_externals_msg::InternalsHit* temp = internals_;
  internals_ = NULL;
  return temp;
}
inline void SignalEvent::set_allocated_internals(::falcon_externals_msg::InternalsHit* internals) {
  delete internals_;
  internals_ = internals;
  if (internals) {
    set_has_internals();
  } else {
    clear_has_internals();
  }
}

// -------------------------------------------------------------------

// GPSPosition

// optional string msgName = 1 [default = "GPS_POSITION"];
inline bool GPSPosition::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPSPosition::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPSPosition::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPSPosition::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& GPSPosition::msgname() const {
  return *msgname_;
}
inline void GPSPosition::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GPSPosition::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GPSPosition::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSPosition::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* GPSPosition::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void GPSPosition::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 channel = 2;
inline bool GPSPosition::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GPSPosition::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GPSPosition::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GPSPosition::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 GPSPosition::channel() const {
  return channel_;
}
inline void GPSPosition::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// optional string eventID = 3;
inline bool GPSPosition::has_eventid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GPSPosition::set_has_eventid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GPSPosition::clear_has_eventid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GPSPosition::clear_eventid() {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    eventid_->clear();
  }
  clear_has_eventid();
}
inline const ::std::string& GPSPosition::eventid() const {
  return *eventid_;
}
inline void GPSPosition::set_eventid(const ::std::string& value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void GPSPosition::set_eventid(const char* value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void GPSPosition::set_eventid(const char* value, size_t size) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSPosition::mutable_eventid() {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  return eventid_;
}
inline ::std::string* GPSPosition::release_eventid() {
  clear_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventid_;
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSPosition::set_allocated_eventid(::std::string* eventid) {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    delete eventid_;
  }
  if (eventid) {
    set_has_eventid();
    eventid_ = eventid;
  } else {
    clear_has_eventid();
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float latitude = 4;
inline bool GPSPosition::has_latitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GPSPosition::set_has_latitude() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GPSPosition::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GPSPosition::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline float GPSPosition::latitude() const {
  return latitude_;
}
inline void GPSPosition::set_latitude(float value) {
  set_has_latitude();
  latitude_ = value;
}

// optional float longitude = 5;
inline bool GPSPosition::has_longitude() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GPSPosition::set_has_longitude() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GPSPosition::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GPSPosition::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline float GPSPosition::longitude() const {
  return longitude_;
}
inline void GPSPosition::set_longitude(float value) {
  set_has_longitude();
  longitude_ = value;
}

// optional float altitude = 6;
inline bool GPSPosition::has_altitude() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GPSPosition::set_has_altitude() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GPSPosition::clear_has_altitude() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GPSPosition::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline float GPSPosition::altitude() const {
  return altitude_;
}
inline void GPSPosition::set_altitude(float value) {
  set_has_altitude();
  altitude_ = value;
}

// optional float wpLatitude = 7;
inline bool GPSPosition::has_wplatitude() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GPSPosition::set_has_wplatitude() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GPSPosition::clear_has_wplatitude() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GPSPosition::clear_wplatitude() {
  wplatitude_ = 0;
  clear_has_wplatitude();
}
inline float GPSPosition::wplatitude() const {
  return wplatitude_;
}
inline void GPSPosition::set_wplatitude(float value) {
  set_has_wplatitude();
  wplatitude_ = value;
}

// optional float wpLongitude = 8;
inline bool GPSPosition::has_wplongitude() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GPSPosition::set_has_wplongitude() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GPSPosition::clear_has_wplongitude() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GPSPosition::clear_wplongitude() {
  wplongitude_ = 0;
  clear_has_wplongitude();
}
inline float GPSPosition::wplongitude() const {
  return wplongitude_;
}
inline void GPSPosition::set_wplongitude(float value) {
  set_has_wplongitude();
  wplongitude_ = value;
}

// optional float velocity = 9;
inline bool GPSPosition::has_velocity() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GPSPosition::set_has_velocity() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GPSPosition::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GPSPosition::clear_velocity() {
  velocity_ = 0;
  clear_has_velocity();
}
inline float GPSPosition::velocity() const {
  return velocity_;
}
inline void GPSPosition::set_velocity(float value) {
  set_has_velocity();
  velocity_ = value;
}

// optional float bearing = 10;
inline bool GPSPosition::has_bearing() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GPSPosition::set_has_bearing() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GPSPosition::clear_has_bearing() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GPSPosition::clear_bearing() {
  bearing_ = 0;
  clear_has_bearing();
}
inline float GPSPosition::bearing() const {
  return bearing_;
}
inline void GPSPosition::set_bearing(float value) {
  set_has_bearing();
  bearing_ = value;
}

// optional string timestamp = 11;
inline bool GPSPosition::has_timestamp() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GPSPosition::set_has_timestamp() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GPSPosition::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GPSPosition::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& GPSPosition::timestamp() const {
  return *timestamp_;
}
inline void GPSPosition::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void GPSPosition::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void GPSPosition::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSPosition::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* GPSPosition::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSPosition::set_allocated_timestamp(::std::string* timestamp) {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    delete timestamp_;
  }
  if (timestamp) {
    set_has_timestamp();
    timestamp_ = timestamp;
  } else {
    clear_has_timestamp();
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float seqnum = 12;
inline bool GPSPosition::has_seqnum() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GPSPosition::set_has_seqnum() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GPSPosition::clear_has_seqnum() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GPSPosition::clear_seqnum() {
  seqnum_ = 0;
  clear_has_seqnum();
}
inline float GPSPosition::seqnum() const {
  return seqnum_;
}
inline void GPSPosition::set_seqnum(float value) {
  set_has_seqnum();
  seqnum_ = value;
}

// optional string soi = 13;
inline bool GPSPosition::has_soi() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GPSPosition::set_has_soi() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GPSPosition::clear_has_soi() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GPSPosition::clear_soi() {
  if (soi_ != &::google::protobuf::internal::kEmptyString) {
    soi_->clear();
  }
  clear_has_soi();
}
inline const ::std::string& GPSPosition::soi() const {
  return *soi_;
}
inline void GPSPosition::set_soi(const ::std::string& value) {
  set_has_soi();
  if (soi_ == &::google::protobuf::internal::kEmptyString) {
    soi_ = new ::std::string;
  }
  soi_->assign(value);
}
inline void GPSPosition::set_soi(const char* value) {
  set_has_soi();
  if (soi_ == &::google::protobuf::internal::kEmptyString) {
    soi_ = new ::std::string;
  }
  soi_->assign(value);
}
inline void GPSPosition::set_soi(const char* value, size_t size) {
  set_has_soi();
  if (soi_ == &::google::protobuf::internal::kEmptyString) {
    soi_ = new ::std::string;
  }
  soi_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSPosition::mutable_soi() {
  set_has_soi();
  if (soi_ == &::google::protobuf::internal::kEmptyString) {
    soi_ = new ::std::string;
  }
  return soi_;
}
inline ::std::string* GPSPosition::release_soi() {
  clear_has_soi();
  if (soi_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = soi_;
    soi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSPosition::set_allocated_soi(::std::string* soi) {
  if (soi_ != &::google::protobuf::internal::kEmptyString) {
    delete soi_;
  }
  if (soi) {
    set_has_soi();
    soi_ = soi;
  } else {
    clear_has_soi();
    soi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isPrediction = 14 [default = false];
inline bool GPSPosition::has_isprediction() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GPSPosition::set_has_isprediction() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GPSPosition::clear_has_isprediction() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GPSPosition::clear_isprediction() {
  isprediction_ = false;
  clear_has_isprediction();
}
inline bool GPSPosition::isprediction() const {
  return isprediction_;
}
inline void GPSPosition::set_isprediction(bool value) {
  set_has_isprediction();
  isprediction_ = value;
}

// optional float major = 15 [default = 0];
inline bool GPSPosition::has_major() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GPSPosition::set_has_major() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GPSPosition::clear_has_major() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GPSPosition::clear_major() {
  major_ = 0;
  clear_has_major();
}
inline float GPSPosition::major() const {
  return major_;
}
inline void GPSPosition::set_major(float value) {
  set_has_major();
  major_ = value;
}

// optional float minor = 16 [default = 0];
inline bool GPSPosition::has_minor() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GPSPosition::set_has_minor() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GPSPosition::clear_has_minor() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GPSPosition::clear_minor() {
  minor_ = 0;
  clear_has_minor();
}
inline float GPSPosition::minor() const {
  return minor_;
}
inline void GPSPosition::set_minor(float value) {
  set_has_minor();
  minor_ = value;
}

// optional float vector = 17 [default = 0];
inline bool GPSPosition::has_vector() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void GPSPosition::set_has_vector() {
  _has_bits_[0] |= 0x00010000u;
}
inline void GPSPosition::clear_has_vector() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void GPSPosition::clear_vector() {
  vector_ = 0;
  clear_has_vector();
}
inline float GPSPosition::vector() const {
  return vector_;
}
inline void GPSPosition::set_vector(float value) {
  set_has_vector();
  vector_ = value;
}

// optional int32 antNum = 18;
inline bool GPSPosition::has_antnum() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void GPSPosition::set_has_antnum() {
  _has_bits_[0] |= 0x00020000u;
}
inline void GPSPosition::clear_has_antnum() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void GPSPosition::clear_antnum() {
  antnum_ = 0;
  clear_has_antnum();
}
inline ::google::protobuf::int32 GPSPosition::antnum() const {
  return antnum_;
}
inline void GPSPosition::set_antnum(::google::protobuf::int32 value) {
  set_has_antnum();
  antnum_ = value;
}

// optional float antAz = 19 [default = 0];
inline bool GPSPosition::has_antaz() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void GPSPosition::set_has_antaz() {
  _has_bits_[0] |= 0x00040000u;
}
inline void GPSPosition::clear_has_antaz() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void GPSPosition::clear_antaz() {
  antaz_ = 0;
  clear_has_antaz();
}
inline float GPSPosition::antaz() const {
  return antaz_;
}
inline void GPSPosition::set_antaz(float value) {
  set_has_antaz();
  antaz_ = value;
}

// optional float antEl = 20 [default = 0];
inline bool GPSPosition::has_antel() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void GPSPosition::set_has_antel() {
  _has_bits_[0] |= 0x00080000u;
}
inline void GPSPosition::clear_has_antel() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void GPSPosition::clear_antel() {
  antel_ = 0;
  clear_has_antel();
}
inline float GPSPosition::antel() const {
  return antel_;
}
inline void GPSPosition::set_antel(float value) {
  set_has_antel();
  antel_ = value;
}

// optional string globalID = 21;
inline bool GPSPosition::has_globalid() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void GPSPosition::set_has_globalid() {
  _has_bits_[0] |= 0x00100000u;
}
inline void GPSPosition::clear_has_globalid() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void GPSPosition::clear_globalid() {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    globalid_->clear();
  }
  clear_has_globalid();
}
inline const ::std::string& GPSPosition::globalid() const {
  return *globalid_;
}
inline void GPSPosition::set_globalid(const ::std::string& value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void GPSPosition::set_globalid(const char* value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void GPSPosition::set_globalid(const char* value, size_t size) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSPosition::mutable_globalid() {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  return globalid_;
}
inline ::std::string* GPSPosition::release_globalid() {
  clear_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalid_;
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSPosition::set_allocated_globalid(::std::string* globalid) {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    delete globalid_;
  }
  if (globalid) {
    set_has_globalid();
    globalid_ = globalid;
  } else {
    clear_has_globalid();
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 appID = 22;
inline bool GPSPosition::has_appid() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void GPSPosition::set_has_appid() {
  _has_bits_[0] |= 0x00200000u;
}
inline void GPSPosition::clear_has_appid() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void GPSPosition::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 GPSPosition::appid() const {
  return appid_;
}
inline void GPSPosition::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional string sensorName = 23;
inline bool GPSPosition::has_sensorname() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void GPSPosition::set_has_sensorname() {
  _has_bits_[0] |= 0x00400000u;
}
inline void GPSPosition::clear_has_sensorname() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void GPSPosition::clear_sensorname() {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    sensorname_->clear();
  }
  clear_has_sensorname();
}
inline const ::std::string& GPSPosition::sensorname() const {
  return *sensorname_;
}
inline void GPSPosition::set_sensorname(const ::std::string& value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void GPSPosition::set_sensorname(const char* value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void GPSPosition::set_sensorname(const char* value, size_t size) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSPosition::mutable_sensorname() {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  return sensorname_;
}
inline ::std::string* GPSPosition::release_sensorname() {
  clear_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sensorname_;
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSPosition::set_allocated_sensorname(::std::string* sensorname) {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    delete sensorname_;
  }
  if (sensorname) {
    set_has_sensorname();
    sensorname_ = sensorname;
  } else {
    clear_has_sensorname();
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MetadataPOF

// optional string msgName = 1 [default = "METADATA_POF"];
inline bool MetadataPOF::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MetadataPOF::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MetadataPOF::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MetadataPOF::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& MetadataPOF::msgname() const {
  return *msgname_;
}
inline void MetadataPOF::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void MetadataPOF::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void MetadataPOF::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetadataPOF::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* MetadataPOF::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void MetadataPOF::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 channel = 2;
inline bool MetadataPOF::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MetadataPOF::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MetadataPOF::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MetadataPOF::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 MetadataPOF::channel() const {
  return channel_;
}
inline void MetadataPOF::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// optional string eventID = 3;
inline bool MetadataPOF::has_eventid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MetadataPOF::set_has_eventid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MetadataPOF::clear_has_eventid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MetadataPOF::clear_eventid() {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    eventid_->clear();
  }
  clear_has_eventid();
}
inline const ::std::string& MetadataPOF::eventid() const {
  return *eventid_;
}
inline void MetadataPOF::set_eventid(const ::std::string& value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void MetadataPOF::set_eventid(const char* value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void MetadataPOF::set_eventid(const char* value, size_t size) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetadataPOF::mutable_eventid() {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  return eventid_;
}
inline ::std::string* MetadataPOF::release_eventid() {
  clear_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventid_;
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MetadataPOF::set_allocated_eventid(::std::string* eventid) {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    delete eventid_;
  }
  if (eventid) {
    set_has_eventid();
    eventid_ = eventid;
  } else {
    clear_has_eventid();
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 pof = 4;
inline bool MetadataPOF::has_pof() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MetadataPOF::set_has_pof() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MetadataPOF::clear_has_pof() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MetadataPOF::clear_pof() {
  pof_ = 0;
  clear_has_pof();
}
inline ::google::protobuf::int32 MetadataPOF::pof() const {
  return pof_;
}
inline void MetadataPOF::set_pof(::google::protobuf::int32 value) {
  set_has_pof();
  pof_ = value;
}

// optional int32 mode = 5;
inline bool MetadataPOF::has_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MetadataPOF::set_has_mode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MetadataPOF::clear_has_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MetadataPOF::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::google::protobuf::int32 MetadataPOF::mode() const {
  return mode_;
}
inline void MetadataPOF::set_mode(::google::protobuf::int32 value) {
  set_has_mode();
  mode_ = value;
}

// optional int32 seqnum = 6;
inline bool MetadataPOF::has_seqnum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MetadataPOF::set_has_seqnum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MetadataPOF::clear_has_seqnum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MetadataPOF::clear_seqnum() {
  seqnum_ = 0;
  clear_has_seqnum();
}
inline ::google::protobuf::int32 MetadataPOF::seqnum() const {
  return seqnum_;
}
inline void MetadataPOF::set_seqnum(::google::protobuf::int32 value) {
  set_has_seqnum();
  seqnum_ = value;
}

// optional string soi = 7;
inline bool MetadataPOF::has_soi() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MetadataPOF::set_has_soi() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MetadataPOF::clear_has_soi() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MetadataPOF::clear_soi() {
  if (soi_ != &::google::protobuf::internal::kEmptyString) {
    soi_->clear();
  }
  clear_has_soi();
}
inline const ::std::string& MetadataPOF::soi() const {
  return *soi_;
}
inline void MetadataPOF::set_soi(const ::std::string& value) {
  set_has_soi();
  if (soi_ == &::google::protobuf::internal::kEmptyString) {
    soi_ = new ::std::string;
  }
  soi_->assign(value);
}
inline void MetadataPOF::set_soi(const char* value) {
  set_has_soi();
  if (soi_ == &::google::protobuf::internal::kEmptyString) {
    soi_ = new ::std::string;
  }
  soi_->assign(value);
}
inline void MetadataPOF::set_soi(const char* value, size_t size) {
  set_has_soi();
  if (soi_ == &::google::protobuf::internal::kEmptyString) {
    soi_ = new ::std::string;
  }
  soi_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetadataPOF::mutable_soi() {
  set_has_soi();
  if (soi_ == &::google::protobuf::internal::kEmptyString) {
    soi_ = new ::std::string;
  }
  return soi_;
}
inline ::std::string* MetadataPOF::release_soi() {
  clear_has_soi();
  if (soi_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = soi_;
    soi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MetadataPOF::set_allocated_soi(::std::string* soi) {
  if (soi_ != &::google::protobuf::internal::kEmptyString) {
    delete soi_;
  }
  if (soi) {
    set_has_soi();
    soi_ = soi;
  } else {
    clear_has_soi();
    soi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 antNum = 8;
inline bool MetadataPOF::has_antnum() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MetadataPOF::set_has_antnum() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MetadataPOF::clear_has_antnum() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MetadataPOF::clear_antnum() {
  antnum_ = 0;
  clear_has_antnum();
}
inline ::google::protobuf::int32 MetadataPOF::antnum() const {
  return antnum_;
}
inline void MetadataPOF::set_antnum(::google::protobuf::int32 value) {
  set_has_antnum();
  antnum_ = value;
}

// optional float antAz = 9 [default = 0];
inline bool MetadataPOF::has_antaz() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MetadataPOF::set_has_antaz() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MetadataPOF::clear_has_antaz() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MetadataPOF::clear_antaz() {
  antaz_ = 0;
  clear_has_antaz();
}
inline float MetadataPOF::antaz() const {
  return antaz_;
}
inline void MetadataPOF::set_antaz(float value) {
  set_has_antaz();
  antaz_ = value;
}

// optional float antEl = 10 [default = 0];
inline bool MetadataPOF::has_antel() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MetadataPOF::set_has_antel() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MetadataPOF::clear_has_antel() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MetadataPOF::clear_antel() {
  antel_ = 0;
  clear_has_antel();
}
inline float MetadataPOF::antel() const {
  return antel_;
}
inline void MetadataPOF::set_antel(float value) {
  set_has_antel();
  antel_ = value;
}

// optional string globalID = 11;
inline bool MetadataPOF::has_globalid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MetadataPOF::set_has_globalid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MetadataPOF::clear_has_globalid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MetadataPOF::clear_globalid() {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    globalid_->clear();
  }
  clear_has_globalid();
}
inline const ::std::string& MetadataPOF::globalid() const {
  return *globalid_;
}
inline void MetadataPOF::set_globalid(const ::std::string& value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void MetadataPOF::set_globalid(const char* value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void MetadataPOF::set_globalid(const char* value, size_t size) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetadataPOF::mutable_globalid() {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  return globalid_;
}
inline ::std::string* MetadataPOF::release_globalid() {
  clear_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalid_;
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MetadataPOF::set_allocated_globalid(::std::string* globalid) {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    delete globalid_;
  }
  if (globalid) {
    set_has_globalid();
    globalid_ = globalid;
  } else {
    clear_has_globalid();
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 appID = 12;
inline bool MetadataPOF::has_appid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MetadataPOF::set_has_appid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MetadataPOF::clear_has_appid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MetadataPOF::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 MetadataPOF::appid() const {
  return appid_;
}
inline void MetadataPOF::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// -------------------------------------------------------------------

// KVPMetaData

// optional string msgName = 1 [default = "KVP_METADATA"];
inline bool KVPMetaData::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KVPMetaData::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KVPMetaData::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KVPMetaData::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& KVPMetaData::msgname() const {
  return *msgname_;
}
inline void KVPMetaData::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void KVPMetaData::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void KVPMetaData::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KVPMetaData::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* KVPMetaData::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void KVPMetaData::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string eventID = 2;
inline bool KVPMetaData::has_eventid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KVPMetaData::set_has_eventid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KVPMetaData::clear_has_eventid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KVPMetaData::clear_eventid() {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    eventid_->clear();
  }
  clear_has_eventid();
}
inline const ::std::string& KVPMetaData::eventid() const {
  return *eventid_;
}
inline void KVPMetaData::set_eventid(const ::std::string& value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void KVPMetaData::set_eventid(const char* value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void KVPMetaData::set_eventid(const char* value, size_t size) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KVPMetaData::mutable_eventid() {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  return eventid_;
}
inline ::std::string* KVPMetaData::release_eventid() {
  clear_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventid_;
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KVPMetaData::set_allocated_eventid(::std::string* eventid) {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    delete eventid_;
  }
  if (eventid) {
    set_has_eventid();
    eventid_ = eventid;
  } else {
    clear_has_eventid();
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string key = 3;
inline int KVPMetaData::key_size() const {
  return key_.size();
}
inline void KVPMetaData::clear_key() {
  key_.Clear();
}
inline const ::std::string& KVPMetaData::key(int index) const {
  return key_.Get(index);
}
inline ::std::string* KVPMetaData::mutable_key(int index) {
  return key_.Mutable(index);
}
inline void KVPMetaData::set_key(int index, const ::std::string& value) {
  key_.Mutable(index)->assign(value);
}
inline void KVPMetaData::set_key(int index, const char* value) {
  key_.Mutable(index)->assign(value);
}
inline void KVPMetaData::set_key(int index, const char* value, size_t size) {
  key_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KVPMetaData::add_key() {
  return key_.Add();
}
inline void KVPMetaData::add_key(const ::std::string& value) {
  key_.Add()->assign(value);
}
inline void KVPMetaData::add_key(const char* value) {
  key_.Add()->assign(value);
}
inline void KVPMetaData::add_key(const char* value, size_t size) {
  key_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
KVPMetaData::key() const {
  return key_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
KVPMetaData::mutable_key() {
  return &key_;
}

// repeated string value = 4;
inline int KVPMetaData::value_size() const {
  return value_.size();
}
inline void KVPMetaData::clear_value() {
  value_.Clear();
}
inline const ::std::string& KVPMetaData::value(int index) const {
  return value_.Get(index);
}
inline ::std::string* KVPMetaData::mutable_value(int index) {
  return value_.Mutable(index);
}
inline void KVPMetaData::set_value(int index, const ::std::string& value) {
  value_.Mutable(index)->assign(value);
}
inline void KVPMetaData::set_value(int index, const char* value) {
  value_.Mutable(index)->assign(value);
}
inline void KVPMetaData::set_value(int index, const char* value, size_t size) {
  value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KVPMetaData::add_value() {
  return value_.Add();
}
inline void KVPMetaData::add_value(const ::std::string& value) {
  value_.Add()->assign(value);
}
inline void KVPMetaData::add_value(const char* value) {
  value_.Add()->assign(value);
}
inline void KVPMetaData::add_value(const char* value, size_t size) {
  value_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
KVPMetaData::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
KVPMetaData::mutable_value() {
  return &value_;
}

// optional float update = 5;
inline bool KVPMetaData::has_update() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void KVPMetaData::set_has_update() {
  _has_bits_[0] |= 0x00000010u;
}
inline void KVPMetaData::clear_has_update() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void KVPMetaData::clear_update() {
  update_ = 0;
  clear_has_update();
}
inline float KVPMetaData::update() const {
  return update_;
}
inline void KVPMetaData::set_update(float value) {
  set_has_update();
  update_ = value;
}

// optional int32 seqnum = 6;
inline bool KVPMetaData::has_seqnum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void KVPMetaData::set_has_seqnum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void KVPMetaData::clear_has_seqnum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void KVPMetaData::clear_seqnum() {
  seqnum_ = 0;
  clear_has_seqnum();
}
inline ::google::protobuf::int32 KVPMetaData::seqnum() const {
  return seqnum_;
}
inline void KVPMetaData::set_seqnum(::google::protobuf::int32 value) {
  set_has_seqnum();
  seqnum_ = value;
}

// optional string globalID = 7;
inline bool KVPMetaData::has_globalid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void KVPMetaData::set_has_globalid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void KVPMetaData::clear_has_globalid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void KVPMetaData::clear_globalid() {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    globalid_->clear();
  }
  clear_has_globalid();
}
inline const ::std::string& KVPMetaData::globalid() const {
  return *globalid_;
}
inline void KVPMetaData::set_globalid(const ::std::string& value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void KVPMetaData::set_globalid(const char* value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void KVPMetaData::set_globalid(const char* value, size_t size) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KVPMetaData::mutable_globalid() {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  return globalid_;
}
inline ::std::string* KVPMetaData::release_globalid() {
  clear_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalid_;
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KVPMetaData::set_allocated_globalid(::std::string* globalid) {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    delete globalid_;
  }
  if (globalid) {
    set_has_globalid();
    globalid_ = globalid;
  } else {
    clear_has_globalid();
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 appID = 8;
inline bool KVPMetaData::has_appid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void KVPMetaData::set_has_appid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void KVPMetaData::clear_has_appid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void KVPMetaData::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 KVPMetaData::appid() const {
  return appid_;
}
inline void KVPMetaData::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// -------------------------------------------------------------------

// WaypointMetaData

// optional string msgName = 1 [default = "WAYPOINT_METADATA"];
inline bool WaypointMetaData::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WaypointMetaData::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WaypointMetaData::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WaypointMetaData::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& WaypointMetaData::msgname() const {
  return *msgname_;
}
inline void WaypointMetaData::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void WaypointMetaData::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void WaypointMetaData::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WaypointMetaData::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* WaypointMetaData::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void WaypointMetaData::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string eventID = 2;
inline bool WaypointMetaData::has_eventid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WaypointMetaData::set_has_eventid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WaypointMetaData::clear_has_eventid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WaypointMetaData::clear_eventid() {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    eventid_->clear();
  }
  clear_has_eventid();
}
inline const ::std::string& WaypointMetaData::eventid() const {
  return *eventid_;
}
inline void WaypointMetaData::set_eventid(const ::std::string& value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void WaypointMetaData::set_eventid(const char* value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void WaypointMetaData::set_eventid(const char* value, size_t size) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WaypointMetaData::mutable_eventid() {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  return eventid_;
}
inline ::std::string* WaypointMetaData::release_eventid() {
  clear_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventid_;
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WaypointMetaData::set_allocated_eventid(::std::string* eventid) {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    delete eventid_;
  }
  if (eventid) {
    set_has_eventid();
    eventid_ = eventid;
  } else {
    clear_has_eventid();
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float waypointID = 3;
inline bool WaypointMetaData::has_waypointid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WaypointMetaData::set_has_waypointid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WaypointMetaData::clear_has_waypointid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WaypointMetaData::clear_waypointid() {
  waypointid_ = 0;
  clear_has_waypointid();
}
inline float WaypointMetaData::waypointid() const {
  return waypointid_;
}
inline void WaypointMetaData::set_waypointid(float value) {
  set_has_waypointid();
  waypointid_ = value;
}

// optional float lat = 4;
inline bool WaypointMetaData::has_lat() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WaypointMetaData::set_has_lat() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WaypointMetaData::clear_has_lat() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WaypointMetaData::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline float WaypointMetaData::lat() const {
  return lat_;
}
inline void WaypointMetaData::set_lat(float value) {
  set_has_lat();
  lat_ = value;
}

// optional float lon = 5;
inline bool WaypointMetaData::has_lon() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WaypointMetaData::set_has_lon() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WaypointMetaData::clear_has_lon() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WaypointMetaData::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline float WaypointMetaData::lon() const {
  return lon_;
}
inline void WaypointMetaData::set_lon(float value) {
  set_has_lon();
  lon_ = value;
}

// optional float alt = 6;
inline bool WaypointMetaData::has_alt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WaypointMetaData::set_has_alt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WaypointMetaData::clear_has_alt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WaypointMetaData::clear_alt() {
  alt_ = 0;
  clear_has_alt();
}
inline float WaypointMetaData::alt() const {
  return alt_;
}
inline void WaypointMetaData::set_alt(float value) {
  set_has_alt();
  alt_ = value;
}

// optional float update = 7;
inline bool WaypointMetaData::has_update() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void WaypointMetaData::set_has_update() {
  _has_bits_[0] |= 0x00000040u;
}
inline void WaypointMetaData::clear_has_update() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void WaypointMetaData::clear_update() {
  update_ = 0;
  clear_has_update();
}
inline float WaypointMetaData::update() const {
  return update_;
}
inline void WaypointMetaData::set_update(float value) {
  set_has_update();
  update_ = value;
}

// optional int32 seqnum = 8;
inline bool WaypointMetaData::has_seqnum() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void WaypointMetaData::set_has_seqnum() {
  _has_bits_[0] |= 0x00000080u;
}
inline void WaypointMetaData::clear_has_seqnum() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void WaypointMetaData::clear_seqnum() {
  seqnum_ = 0;
  clear_has_seqnum();
}
inline ::google::protobuf::int32 WaypointMetaData::seqnum() const {
  return seqnum_;
}
inline void WaypointMetaData::set_seqnum(::google::protobuf::int32 value) {
  set_has_seqnum();
  seqnum_ = value;
}

// optional string globalID = 9;
inline bool WaypointMetaData::has_globalid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void WaypointMetaData::set_has_globalid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void WaypointMetaData::clear_has_globalid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void WaypointMetaData::clear_globalid() {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    globalid_->clear();
  }
  clear_has_globalid();
}
inline const ::std::string& WaypointMetaData::globalid() const {
  return *globalid_;
}
inline void WaypointMetaData::set_globalid(const ::std::string& value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void WaypointMetaData::set_globalid(const char* value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void WaypointMetaData::set_globalid(const char* value, size_t size) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WaypointMetaData::mutable_globalid() {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  return globalid_;
}
inline ::std::string* WaypointMetaData::release_globalid() {
  clear_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalid_;
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WaypointMetaData::set_allocated_globalid(::std::string* globalid) {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    delete globalid_;
  }
  if (globalid) {
    set_has_globalid();
    globalid_ = globalid;
  } else {
    clear_has_globalid();
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 appID = 10;
inline bool WaypointMetaData::has_appid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void WaypointMetaData::set_has_appid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void WaypointMetaData::clear_has_appid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void WaypointMetaData::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 WaypointMetaData::appid() const {
  return appid_;
}
inline void WaypointMetaData::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// -------------------------------------------------------------------

// GndpointMetaData

// optional string msgName = 1 [default = "GNDPOINT_METADATA"];
inline bool GndpointMetaData::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GndpointMetaData::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GndpointMetaData::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GndpointMetaData::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& GndpointMetaData::msgname() const {
  return *msgname_;
}
inline void GndpointMetaData::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GndpointMetaData::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GndpointMetaData::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GndpointMetaData::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* GndpointMetaData::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void GndpointMetaData::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string eventID = 2;
inline bool GndpointMetaData::has_eventid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GndpointMetaData::set_has_eventid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GndpointMetaData::clear_has_eventid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GndpointMetaData::clear_eventid() {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    eventid_->clear();
  }
  clear_has_eventid();
}
inline const ::std::string& GndpointMetaData::eventid() const {
  return *eventid_;
}
inline void GndpointMetaData::set_eventid(const ::std::string& value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void GndpointMetaData::set_eventid(const char* value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void GndpointMetaData::set_eventid(const char* value, size_t size) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GndpointMetaData::mutable_eventid() {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  return eventid_;
}
inline ::std::string* GndpointMetaData::release_eventid() {
  clear_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventid_;
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GndpointMetaData::set_allocated_eventid(::std::string* eventid) {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    delete eventid_;
  }
  if (eventid) {
    set_has_eventid();
    eventid_ = eventid;
  } else {
    clear_has_eventid();
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pointID = 3;
inline bool GndpointMetaData::has_pointid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GndpointMetaData::set_has_pointid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GndpointMetaData::clear_has_pointid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GndpointMetaData::clear_pointid() {
  if (pointid_ != &::google::protobuf::internal::kEmptyString) {
    pointid_->clear();
  }
  clear_has_pointid();
}
inline const ::std::string& GndpointMetaData::pointid() const {
  return *pointid_;
}
inline void GndpointMetaData::set_pointid(const ::std::string& value) {
  set_has_pointid();
  if (pointid_ == &::google::protobuf::internal::kEmptyString) {
    pointid_ = new ::std::string;
  }
  pointid_->assign(value);
}
inline void GndpointMetaData::set_pointid(const char* value) {
  set_has_pointid();
  if (pointid_ == &::google::protobuf::internal::kEmptyString) {
    pointid_ = new ::std::string;
  }
  pointid_->assign(value);
}
inline void GndpointMetaData::set_pointid(const char* value, size_t size) {
  set_has_pointid();
  if (pointid_ == &::google::protobuf::internal::kEmptyString) {
    pointid_ = new ::std::string;
  }
  pointid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GndpointMetaData::mutable_pointid() {
  set_has_pointid();
  if (pointid_ == &::google::protobuf::internal::kEmptyString) {
    pointid_ = new ::std::string;
  }
  return pointid_;
}
inline ::std::string* GndpointMetaData::release_pointid() {
  clear_has_pointid();
  if (pointid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pointid_;
    pointid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GndpointMetaData::set_allocated_pointid(::std::string* pointid) {
  if (pointid_ != &::google::protobuf::internal::kEmptyString) {
    delete pointid_;
  }
  if (pointid) {
    set_has_pointid();
    pointid_ = pointid;
  } else {
    clear_has_pointid();
    pointid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float lat = 4;
inline bool GndpointMetaData::has_lat() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GndpointMetaData::set_has_lat() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GndpointMetaData::clear_has_lat() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GndpointMetaData::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline float GndpointMetaData::lat() const {
  return lat_;
}
inline void GndpointMetaData::set_lat(float value) {
  set_has_lat();
  lat_ = value;
}

// optional float lon = 5;
inline bool GndpointMetaData::has_lon() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GndpointMetaData::set_has_lon() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GndpointMetaData::clear_has_lon() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GndpointMetaData::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline float GndpointMetaData::lon() const {
  return lon_;
}
inline void GndpointMetaData::set_lon(float value) {
  set_has_lon();
  lon_ = value;
}

// optional float alt = 6;
inline bool GndpointMetaData::has_alt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GndpointMetaData::set_has_alt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GndpointMetaData::clear_has_alt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GndpointMetaData::clear_alt() {
  alt_ = 0;
  clear_has_alt();
}
inline float GndpointMetaData::alt() const {
  return alt_;
}
inline void GndpointMetaData::set_alt(float value) {
  set_has_alt();
  alt_ = value;
}

// optional float update = 7;
inline bool GndpointMetaData::has_update() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GndpointMetaData::set_has_update() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GndpointMetaData::clear_has_update() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GndpointMetaData::clear_update() {
  update_ = 0;
  clear_has_update();
}
inline float GndpointMetaData::update() const {
  return update_;
}
inline void GndpointMetaData::set_update(float value) {
  set_has_update();
  update_ = value;
}

// optional int32 seqnum = 8;
inline bool GndpointMetaData::has_seqnum() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GndpointMetaData::set_has_seqnum() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GndpointMetaData::clear_has_seqnum() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GndpointMetaData::clear_seqnum() {
  seqnum_ = 0;
  clear_has_seqnum();
}
inline ::google::protobuf::int32 GndpointMetaData::seqnum() const {
  return seqnum_;
}
inline void GndpointMetaData::set_seqnum(::google::protobuf::int32 value) {
  set_has_seqnum();
  seqnum_ = value;
}

// optional string globalID = 9;
inline bool GndpointMetaData::has_globalid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GndpointMetaData::set_has_globalid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GndpointMetaData::clear_has_globalid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GndpointMetaData::clear_globalid() {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    globalid_->clear();
  }
  clear_has_globalid();
}
inline const ::std::string& GndpointMetaData::globalid() const {
  return *globalid_;
}
inline void GndpointMetaData::set_globalid(const ::std::string& value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void GndpointMetaData::set_globalid(const char* value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void GndpointMetaData::set_globalid(const char* value, size_t size) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GndpointMetaData::mutable_globalid() {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  return globalid_;
}
inline ::std::string* GndpointMetaData::release_globalid() {
  clear_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalid_;
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GndpointMetaData::set_allocated_globalid(::std::string* globalid) {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    delete globalid_;
  }
  if (globalid) {
    set_has_globalid();
    globalid_ = globalid;
  } else {
    clear_has_globalid();
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 appID = 10;
inline bool GndpointMetaData::has_appid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GndpointMetaData::set_has_appid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GndpointMetaData::clear_has_appid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GndpointMetaData::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 GndpointMetaData::appid() const {
  return appid_;
}
inline void GndpointMetaData::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// -------------------------------------------------------------------

// RemoteMessage

// optional string msgName = 1 [default = "REMOTE_MESSAGE"];
inline bool RemoteMessage::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoteMessage::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoteMessage::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoteMessage::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& RemoteMessage::msgname() const {
  return *msgname_;
}
inline void RemoteMessage::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RemoteMessage::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RemoteMessage::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoteMessage::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* RemoteMessage::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void RemoteMessage::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional bool msgPass = 2 [default = true];
inline bool RemoteMessage::has_msgpass() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoteMessage::set_has_msgpass() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoteMessage::clear_has_msgpass() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoteMessage::clear_msgpass() {
  msgpass_ = true;
  clear_has_msgpass();
}
inline bool RemoteMessage::msgpass() const {
  return msgpass_;
}
inline void RemoteMessage::set_msgpass(bool value) {
  set_has_msgpass();
  msgpass_ = value;
}

// optional string format = 3;
inline bool RemoteMessage::has_format() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RemoteMessage::set_has_format() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RemoteMessage::clear_has_format() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RemoteMessage::clear_format() {
  if (format_ != &::google::protobuf::internal::kEmptyString) {
    format_->clear();
  }
  clear_has_format();
}
inline const ::std::string& RemoteMessage::format() const {
  return *format_;
}
inline void RemoteMessage::set_format(const ::std::string& value) {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  format_->assign(value);
}
inline void RemoteMessage::set_format(const char* value) {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  format_->assign(value);
}
inline void RemoteMessage::set_format(const char* value, size_t size) {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  format_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoteMessage::mutable_format() {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  return format_;
}
inline ::std::string* RemoteMessage::release_format() {
  clear_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = format_;
    format_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RemoteMessage::set_allocated_format(::std::string* format) {
  if (format_ != &::google::protobuf::internal::kEmptyString) {
    delete format_;
  }
  if (format) {
    set_has_format();
    format_ = format;
  } else {
    clear_has_format();
    format_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string content = 4;
inline int RemoteMessage::content_size() const {
  return content_.size();
}
inline void RemoteMessage::clear_content() {
  content_.Clear();
}
inline const ::std::string& RemoteMessage::content(int index) const {
  return content_.Get(index);
}
inline ::std::string* RemoteMessage::mutable_content(int index) {
  return content_.Mutable(index);
}
inline void RemoteMessage::set_content(int index, const ::std::string& value) {
  content_.Mutable(index)->assign(value);
}
inline void RemoteMessage::set_content(int index, const char* value) {
  content_.Mutable(index)->assign(value);
}
inline void RemoteMessage::set_content(int index, const char* value, size_t size) {
  content_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoteMessage::add_content() {
  return content_.Add();
}
inline void RemoteMessage::add_content(const ::std::string& value) {
  content_.Add()->assign(value);
}
inline void RemoteMessage::add_content(const char* value) {
  content_.Add()->assign(value);
}
inline void RemoteMessage::add_content(const char* value, size_t size) {
  content_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RemoteMessage::content() const {
  return content_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RemoteMessage::mutable_content() {
  return &content_;
}

// optional double msgID = 5;
inline bool RemoteMessage::has_msgid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RemoteMessage::set_has_msgid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RemoteMessage::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RemoteMessage::clear_msgid() {
  msgid_ = 0;
  clear_has_msgid();
}
inline double RemoteMessage::msgid() const {
  return msgid_;
}
inline void RemoteMessage::set_msgid(double value) {
  set_has_msgid();
  msgid_ = value;
}

// -------------------------------------------------------------------

// GPSPlatPos

// optional string msgName = 1 [default = "GPS_CURRENT_POSITION"];
inline bool GPSPlatPos::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPSPlatPos::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPSPlatPos::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPSPlatPos::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& GPSPlatPos::msgname() const {
  return *msgname_;
}
inline void GPSPlatPos::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GPSPlatPos::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GPSPlatPos::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSPlatPos::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* GPSPlatPos::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void GPSPlatPos::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional float latitude = 2;
inline bool GPSPlatPos::has_latitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GPSPlatPos::set_has_latitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GPSPlatPos::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GPSPlatPos::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline float GPSPlatPos::latitude() const {
  return latitude_;
}
inline void GPSPlatPos::set_latitude(float value) {
  set_has_latitude();
  latitude_ = value;
}

// optional float longitude = 3;
inline bool GPSPlatPos::has_longitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GPSPlatPos::set_has_longitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GPSPlatPos::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GPSPlatPos::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline float GPSPlatPos::longitude() const {
  return longitude_;
}
inline void GPSPlatPos::set_longitude(float value) {
  set_has_longitude();
  longitude_ = value;
}

// optional float heading = 4;
inline bool GPSPlatPos::has_heading() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GPSPlatPos::set_has_heading() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GPSPlatPos::clear_has_heading() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GPSPlatPos::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline float GPSPlatPos::heading() const {
  return heading_;
}
inline void GPSPlatPos::set_heading(float value) {
  set_has_heading();
  heading_ = value;
}

// -------------------------------------------------------------------

// RequestPsd

// optional string msgName = 1 [default = "REQUEST_PSD"];
inline bool RequestPsd::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestPsd::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestPsd::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestPsd::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& RequestPsd::msgname() const {
  return *msgname_;
}
inline void RequestPsd::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RequestPsd::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RequestPsd::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestPsd::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* RequestPsd::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void RequestPsd::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string resID = 2;
inline bool RequestPsd::has_resid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestPsd::set_has_resid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestPsd::clear_has_resid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestPsd::clear_resid() {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    resid_->clear();
  }
  clear_has_resid();
}
inline const ::std::string& RequestPsd::resid() const {
  return *resid_;
}
inline void RequestPsd::set_resid(const ::std::string& value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void RequestPsd::set_resid(const char* value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void RequestPsd::set_resid(const char* value, size_t size) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestPsd::mutable_resid() {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  return resid_;
}
inline ::std::string* RequestPsd::release_resid() {
  clear_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resid_;
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestPsd::set_allocated_resid(::std::string* resid) {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    delete resid_;
  }
  if (resid) {
    set_has_resid();
    resid_ = resid;
  } else {
    clear_has_resid();
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 archiveNum = 3;
inline bool RequestPsd::has_archivenum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestPsd::set_has_archivenum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestPsd::clear_has_archivenum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestPsd::clear_archivenum() {
  archivenum_ = 0;
  clear_has_archivenum();
}
inline ::google::protobuf::int32 RequestPsd::archivenum() const {
  return archivenum_;
}
inline void RequestPsd::set_archivenum(::google::protobuf::int32 value) {
  set_has_archivenum();
  archivenum_ = value;
}

// optional int32 returnChan = 4;
inline bool RequestPsd::has_returnchan() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestPsd::set_has_returnchan() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestPsd::clear_has_returnchan() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestPsd::clear_returnchan() {
  returnchan_ = 0;
  clear_has_returnchan();
}
inline ::google::protobuf::int32 RequestPsd::returnchan() const {
  return returnchan_;
}
inline void RequestPsd::set_returnchan(::google::protobuf::int32 value) {
  set_has_returnchan();
  returnchan_ = value;
}

// -------------------------------------------------------------------

// SetAtten

// optional string msgName = 1 [default = "SET_ATTEN"];
inline bool SetAtten::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetAtten::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetAtten::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetAtten::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SetAtten::msgname() const {
  return *msgname_;
}
inline void SetAtten::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SetAtten::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SetAtten::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SetAtten::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SetAtten::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SetAtten::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 appID = 2;
inline bool SetAtten::has_appid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetAtten::set_has_appid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetAtten::clear_has_appid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetAtten::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 SetAtten::appid() const {
  return appid_;
}
inline void SetAtten::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional .falcon_remoting_msg.SetAtten.AutoAtten autoAtten = 3;
inline bool SetAtten::has_autoatten() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetAtten::set_has_autoatten() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetAtten::clear_has_autoatten() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetAtten::clear_autoatten() {
  autoatten_ = 1;
  clear_has_autoatten();
}
inline ::falcon_remoting_msg::SetAtten_AutoAtten SetAtten::autoatten() const {
  return static_cast< ::falcon_remoting_msg::SetAtten_AutoAtten >(autoatten_);
}
inline void SetAtten::set_autoatten(::falcon_remoting_msg::SetAtten_AutoAtten value) {
  assert(::falcon_remoting_msg::SetAtten_AutoAtten_IsValid(value));
  set_has_autoatten();
  autoatten_ = value;
}

// optional int32 atten = 4;
inline bool SetAtten::has_atten() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SetAtten::set_has_atten() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SetAtten::clear_has_atten() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SetAtten::clear_atten() {
  atten_ = 0;
  clear_has_atten();
}
inline ::google::protobuf::int32 SetAtten::atten() const {
  return atten_;
}
inline void SetAtten::set_atten(::google::protobuf::int32 value) {
  set_has_atten();
  atten_ = value;
}

// -------------------------------------------------------------------

// SearchControl

// optional string msgName = 1 [default = "SEARCH_CONTROL"];
inline bool SearchControl::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchControl::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchControl::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchControl::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SearchControl::msgname() const {
  return *msgname_;
}
inline void SearchControl::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SearchControl::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SearchControl::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchControl::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SearchControl::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SearchControl::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 appID = 2;
inline bool SearchControl::has_appid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SearchControl::set_has_appid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SearchControl::clear_has_appid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SearchControl::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 SearchControl::appid() const {
  return appid_;
}
inline void SearchControl::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional .falcon_remoting_msg.SearchControl.Action action = 3;
inline bool SearchControl::has_action() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SearchControl::set_has_action() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SearchControl::clear_has_action() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SearchControl::clear_action() {
  action_ = 1;
  clear_has_action();
}
inline ::falcon_remoting_msg::SearchControl_Action SearchControl::action() const {
  return static_cast< ::falcon_remoting_msg::SearchControl_Action >(action_);
}
inline void SearchControl::set_action(::falcon_remoting_msg::SearchControl_Action value) {
  assert(::falcon_remoting_msg::SearchControl_Action_IsValid(value));
  set_has_action();
  action_ = value;
}

// -------------------------------------------------------------------

// FrequencyTune

// optional string msgName = 1 [default = "FREQUENCY_TUNE"];
inline bool FrequencyTune::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrequencyTune::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrequencyTune::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrequencyTune::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& FrequencyTune::msgname() const {
  return *msgname_;
}
inline void FrequencyTune::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void FrequencyTune::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void FrequencyTune::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FrequencyTune::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* FrequencyTune::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void FrequencyTune::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 appID = 2;
inline bool FrequencyTune::has_appid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FrequencyTune::set_has_appid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FrequencyTune::clear_has_appid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FrequencyTune::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 FrequencyTune::appid() const {
  return appid_;
}
inline void FrequencyTune::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional float freq = 3;
inline bool FrequencyTune::has_freq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FrequencyTune::set_has_freq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FrequencyTune::clear_has_freq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FrequencyTune::clear_freq() {
  freq_ = 0;
  clear_has_freq();
}
inline float FrequencyTune::freq() const {
  return freq_;
}
inline void FrequencyTune::set_freq(float value) {
  set_has_freq();
  freq_ = value;
}

// -------------------------------------------------------------------

// PredRecord

// optional string msgName = 1 [default = "PRED_RECORD"];
inline bool PredRecord::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PredRecord::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PredRecord::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PredRecord::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& PredRecord::msgname() const {
  return *msgname_;
}
inline void PredRecord::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void PredRecord::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void PredRecord::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PredRecord::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* PredRecord::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void PredRecord::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 appID = 2;
inline bool PredRecord::has_appid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PredRecord::set_has_appid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PredRecord::clear_has_appid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PredRecord::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 PredRecord::appid() const {
  return appid_;
}
inline void PredRecord::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional .falcon_remoting_msg.PredRecord.Action predRecord = 3;
inline bool PredRecord::has_predrecord() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PredRecord::set_has_predrecord() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PredRecord::clear_has_predrecord() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PredRecord::clear_predrecord() {
  predrecord_ = 1;
  clear_has_predrecord();
}
inline ::falcon_remoting_msg::PredRecord_Action PredRecord::predrecord() const {
  return static_cast< ::falcon_remoting_msg::PredRecord_Action >(predrecord_);
}
inline void PredRecord::set_predrecord(::falcon_remoting_msg::PredRecord_Action value) {
  assert(::falcon_remoting_msg::PredRecord_Action_IsValid(value));
  set_has_predrecord();
  predrecord_ = value;
}

// -------------------------------------------------------------------

// PredSnap

// optional string msgName = 1 [default = "PRED_SNAP"];
inline bool PredSnap::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PredSnap::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PredSnap::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PredSnap::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& PredSnap::msgname() const {
  return *msgname_;
}
inline void PredSnap::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void PredSnap::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void PredSnap::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PredSnap::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* PredSnap::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void PredSnap::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 appID = 2;
inline bool PredSnap::has_appid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PredSnap::set_has_appid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PredSnap::clear_has_appid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PredSnap::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 PredSnap::appid() const {
  return appid_;
}
inline void PredSnap::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional int32 snapLength = 3;
inline bool PredSnap::has_snaplength() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PredSnap::set_has_snaplength() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PredSnap::clear_has_snaplength() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PredSnap::clear_snaplength() {
  snaplength_ = 0;
  clear_has_snaplength();
}
inline ::google::protobuf::int32 PredSnap::snaplength() const {
  return snaplength_;
}
inline void PredSnap::set_snaplength(::google::protobuf::int32 value) {
  set_has_snaplength();
  snaplength_ = value;
}

// optional bool takeSnap = 4;
inline bool PredSnap::has_takesnap() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PredSnap::set_has_takesnap() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PredSnap::clear_has_takesnap() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PredSnap::clear_takesnap() {
  takesnap_ = false;
  clear_has_takesnap();
}
inline bool PredSnap::takesnap() const {
  return takesnap_;
}
inline void PredSnap::set_takesnap(bool value) {
  set_has_takesnap();
  takesnap_ = value;
}

// -------------------------------------------------------------------

// VideoControl

// optional string msgName = 1 [default = "VIDEO_CONTROL"];
inline bool VideoControl::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VideoControl::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VideoControl::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VideoControl::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& VideoControl::msgname() const {
  return *msgname_;
}
inline void VideoControl::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void VideoControl::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void VideoControl::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VideoControl::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* VideoControl::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void VideoControl::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 appID = 2;
inline bool VideoControl::has_appid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VideoControl::set_has_appid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VideoControl::clear_has_appid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VideoControl::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 VideoControl::appid() const {
  return appid_;
}
inline void VideoControl::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional .falcon_remoting_msg.VideoControl.Record videoRecord = 3;
inline bool VideoControl::has_videorecord() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VideoControl::set_has_videorecord() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VideoControl::clear_has_videorecord() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VideoControl::clear_videorecord() {
  videorecord_ = 1;
  clear_has_videorecord();
}
inline ::falcon_remoting_msg::VideoControl_Record VideoControl::videorecord() const {
  return static_cast< ::falcon_remoting_msg::VideoControl_Record >(videorecord_);
}
inline void VideoControl::set_videorecord(::falcon_remoting_msg::VideoControl_Record value) {
  assert(::falcon_remoting_msg::VideoControl_Record_IsValid(value));
  set_has_videorecord();
  videorecord_ = value;
}

// optional .falcon_remoting_msg.VideoControl.Sync videoSync = 4;
inline bool VideoControl::has_videosync() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VideoControl::set_has_videosync() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VideoControl::clear_has_videosync() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VideoControl::clear_videosync() {
  videosync_ = 1;
  clear_has_videosync();
}
inline ::falcon_remoting_msg::VideoControl_Sync VideoControl::videosync() const {
  return static_cast< ::falcon_remoting_msg::VideoControl_Sync >(videosync_);
}
inline void VideoControl::set_videosync(::falcon_remoting_msg::VideoControl_Sync value) {
  assert(::falcon_remoting_msg::VideoControl_Sync_IsValid(value));
  set_has_videosync();
  videosync_ = value;
}

// optional int32 videoIntegration = 5;
inline bool VideoControl::has_videointegration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VideoControl::set_has_videointegration() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VideoControl::clear_has_videointegration() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VideoControl::clear_videointegration() {
  videointegration_ = 0;
  clear_has_videointegration();
}
inline ::google::protobuf::int32 VideoControl::videointegration() const {
  return videointegration_;
}
inline void VideoControl::set_videointegration(::google::protobuf::int32 value) {
  set_has_videointegration();
  videointegration_ = value;
}

// optional .falcon_remoting_msg.VideoControl.Mode jpegCommand = 6;
inline bool VideoControl::has_jpegcommand() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VideoControl::set_has_jpegcommand() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VideoControl::clear_has_jpegcommand() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VideoControl::clear_jpegcommand() {
  jpegcommand_ = 1;
  clear_has_jpegcommand();
}
inline ::falcon_remoting_msg::VideoControl_Mode VideoControl::jpegcommand() const {
  return static_cast< ::falcon_remoting_msg::VideoControl_Mode >(jpegcommand_);
}
inline void VideoControl::set_jpegcommand(::falcon_remoting_msg::VideoControl_Mode value) {
  assert(::falcon_remoting_msg::VideoControl_Mode_IsValid(value));
  set_has_jpegcommand();
  jpegcommand_ = value;
}

// optional int32 jpegRate = 7;
inline bool VideoControl::has_jpegrate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VideoControl::set_has_jpegrate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VideoControl::clear_has_jpegrate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VideoControl::clear_jpegrate() {
  jpegrate_ = 0;
  clear_has_jpegrate();
}
inline ::google::protobuf::int32 VideoControl::jpegrate() const {
  return jpegrate_;
}
inline void VideoControl::set_jpegrate(::google::protobuf::int32 value) {
  set_has_jpegrate();
  jpegrate_ = value;
}

// -------------------------------------------------------------------

// FhopSettings

// optional string msgName = 1 [default = "FHOP_SETTINGS"];
inline bool FhopSettings::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FhopSettings::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FhopSettings::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FhopSettings::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& FhopSettings::msgname() const {
  return *msgname_;
}
inline void FhopSettings::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void FhopSettings::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void FhopSettings::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FhopSettings::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* FhopSettings::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void FhopSettings::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 appID = 2;
inline bool FhopSettings::has_appid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FhopSettings::set_has_appid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FhopSettings::clear_has_appid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FhopSettings::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 FhopSettings::appid() const {
  return appid_;
}
inline void FhopSettings::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional .falcon_remoting_msg.FhopSettings.FreqHopMode freqHopMode = 3;
inline bool FhopSettings::has_freqhopmode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FhopSettings::set_has_freqhopmode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FhopSettings::clear_has_freqhopmode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FhopSettings::clear_freqhopmode() {
  freqhopmode_ = 1;
  clear_has_freqhopmode();
}
inline ::falcon_remoting_msg::FhopSettings_FreqHopMode FhopSettings::freqhopmode() const {
  return static_cast< ::falcon_remoting_msg::FhopSettings_FreqHopMode >(freqhopmode_);
}
inline void FhopSettings::set_freqhopmode(::falcon_remoting_msg::FhopSettings_FreqHopMode value) {
  assert(::falcon_remoting_msg::FhopSettings_FreqHopMode_IsValid(value));
  set_has_freqhopmode();
  freqhopmode_ = value;
}

// repeated .falcon_remoting_msg.TunerLock tunerLock = 4;
inline int FhopSettings::tunerlock_size() const {
  return tunerlock_.size();
}
inline void FhopSettings::clear_tunerlock() {
  tunerlock_.Clear();
}
inline const ::falcon_remoting_msg::TunerLock& FhopSettings::tunerlock(int index) const {
  return tunerlock_.Get(index);
}
inline ::falcon_remoting_msg::TunerLock* FhopSettings::mutable_tunerlock(int index) {
  return tunerlock_.Mutable(index);
}
inline ::falcon_remoting_msg::TunerLock* FhopSettings::add_tunerlock() {
  return tunerlock_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::falcon_remoting_msg::TunerLock >&
FhopSettings::tunerlock() const {
  return tunerlock_;
}
inline ::google::protobuf::RepeatedPtrField< ::falcon_remoting_msg::TunerLock >*
FhopSettings::mutable_tunerlock() {
  return &tunerlock_;
}

// repeated float tunerFreq = 5;
inline int FhopSettings::tunerfreq_size() const {
  return tunerfreq_.size();
}
inline void FhopSettings::clear_tunerfreq() {
  tunerfreq_.Clear();
}
inline float FhopSettings::tunerfreq(int index) const {
  return tunerfreq_.Get(index);
}
inline void FhopSettings::set_tunerfreq(int index, float value) {
  tunerfreq_.Set(index, value);
}
inline void FhopSettings::add_tunerfreq(float value) {
  tunerfreq_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
FhopSettings::tunerfreq() const {
  return tunerfreq_;
}
inline ::google::protobuf::RepeatedField< float >*
FhopSettings::mutable_tunerfreq() {
  return &tunerfreq_;
}

// -------------------------------------------------------------------

// TunerLock

// optional int32 tuner = 1;
inline bool TunerLock::has_tuner() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TunerLock::set_has_tuner() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TunerLock::clear_has_tuner() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TunerLock::clear_tuner() {
  tuner_ = 0;
  clear_has_tuner();
}
inline ::google::protobuf::int32 TunerLock::tuner() const {
  return tuner_;
}
inline void TunerLock::set_tuner(::google::protobuf::int32 value) {
  set_has_tuner();
  tuner_ = value;
}

// optional bool lock = 2;
inline bool TunerLock::has_lock() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TunerLock::set_has_lock() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TunerLock::clear_has_lock() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TunerLock::clear_lock() {
  lock_ = false;
  clear_has_lock();
}
inline bool TunerLock::lock() const {
  return lock_;
}
inline void TunerLock::set_lock(bool value) {
  set_has_lock();
  lock_ = value;
}

// -------------------------------------------------------------------

// AntennaScanStatus

// optional string msgName = 1 [default = "ANTENNA_SCAN_STATUS"];
inline bool AntennaScanStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AntennaScanStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AntennaScanStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AntennaScanStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& AntennaScanStatus::msgname() const {
  return *msgname_;
}
inline void AntennaScanStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AntennaScanStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AntennaScanStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AntennaScanStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* AntennaScanStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void AntennaScanStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 appID = 2;
inline bool AntennaScanStatus::has_appid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AntennaScanStatus::set_has_appid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AntennaScanStatus::clear_has_appid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AntennaScanStatus::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 AntennaScanStatus::appid() const {
  return appid_;
}
inline void AntennaScanStatus::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional .falcon_remoting_msg.AntennaScanStatus.ScanStatus scanStatus = 3 [default = STANDBY];
inline bool AntennaScanStatus::has_scanstatus() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AntennaScanStatus::set_has_scanstatus() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AntennaScanStatus::clear_has_scanstatus() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AntennaScanStatus::clear_scanstatus() {
  scanstatus_ = 0;
  clear_has_scanstatus();
}
inline ::falcon_remoting_msg::AntennaScanStatus_ScanStatus AntennaScanStatus::scanstatus() const {
  return static_cast< ::falcon_remoting_msg::AntennaScanStatus_ScanStatus >(scanstatus_);
}
inline void AntennaScanStatus::set_scanstatus(::falcon_remoting_msg::AntennaScanStatus_ScanStatus value) {
  assert(::falcon_remoting_msg::AntennaScanStatus_ScanStatus_IsValid(value));
  set_has_scanstatus();
  scanstatus_ = value;
}

// optional .falcon_remoting_msg.AntennaScanStatus.TrackStatus trackStatus = 4 [default = OFF];
inline bool AntennaScanStatus::has_trackstatus() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AntennaScanStatus::set_has_trackstatus() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AntennaScanStatus::clear_has_trackstatus() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AntennaScanStatus::clear_trackstatus() {
  trackstatus_ = 0;
  clear_has_trackstatus();
}
inline ::falcon_remoting_msg::AntennaScanStatus_TrackStatus AntennaScanStatus::trackstatus() const {
  return static_cast< ::falcon_remoting_msg::AntennaScanStatus_TrackStatus >(trackstatus_);
}
inline void AntennaScanStatus::set_trackstatus(::falcon_remoting_msg::AntennaScanStatus_TrackStatus value) {
  assert(::falcon_remoting_msg::AntennaScanStatus_TrackStatus_IsValid(value));
  set_has_trackstatus();
  trackstatus_ = value;
}

// optional float minScanAngle = 5;
inline bool AntennaScanStatus::has_minscanangle() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AntennaScanStatus::set_has_minscanangle() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AntennaScanStatus::clear_has_minscanangle() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AntennaScanStatus::clear_minscanangle() {
  minscanangle_ = 0;
  clear_has_minscanangle();
}
inline float AntennaScanStatus::minscanangle() const {
  return minscanangle_;
}
inline void AntennaScanStatus::set_minscanangle(float value) {
  set_has_minscanangle();
  minscanangle_ = value;
}

// optional float maxScanAngle = 6;
inline bool AntennaScanStatus::has_maxscanangle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AntennaScanStatus::set_has_maxscanangle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AntennaScanStatus::clear_has_maxscanangle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AntennaScanStatus::clear_maxscanangle() {
  maxscanangle_ = 0;
  clear_has_maxscanangle();
}
inline float AntennaScanStatus::maxscanangle() const {
  return maxscanangle_;
}
inline void AntennaScanStatus::set_maxscanangle(float value) {
  set_has_maxscanangle();
  maxscanangle_ = value;
}

// -------------------------------------------------------------------

// QueryMidasAppStatus

// optional string msgName = 1 [default = "QUERY_MIDAS_APP_STATUS"];
inline bool QueryMidasAppStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryMidasAppStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryMidasAppStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryMidasAppStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& QueryMidasAppStatus::msgname() const {
  return *msgname_;
}
inline void QueryMidasAppStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void QueryMidasAppStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void QueryMidasAppStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryMidasAppStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* QueryMidasAppStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void QueryMidasAppStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 appID = 2;
inline bool QueryMidasAppStatus::has_appid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryMidasAppStatus::set_has_appid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryMidasAppStatus::clear_has_appid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryMidasAppStatus::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 QueryMidasAppStatus::appid() const {
  return appid_;
}
inline void QueryMidasAppStatus::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// -------------------------------------------------------------------

// MidasAppStatus

// optional string msgName = 1 [default = "MIDAS_APP_STATUS"];
inline bool MidasAppStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MidasAppStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MidasAppStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MidasAppStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& MidasAppStatus::msgname() const {
  return *msgname_;
}
inline void MidasAppStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void MidasAppStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void MidasAppStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MidasAppStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* MidasAppStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void MidasAppStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 appID = 2;
inline bool MidasAppStatus::has_appid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MidasAppStatus::set_has_appid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MidasAppStatus::clear_has_appid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MidasAppStatus::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 MidasAppStatus::appid() const {
  return appid_;
}
inline void MidasAppStatus::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional .falcon_remoting_msg.RxStatus rxStat = 3;
inline bool MidasAppStatus::has_rxstat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MidasAppStatus::set_has_rxstat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MidasAppStatus::clear_has_rxstat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MidasAppStatus::clear_rxstat() {
  if (rxstat_ != NULL) rxstat_->::falcon_remoting_msg::RxStatus::Clear();
  clear_has_rxstat();
}
inline const ::falcon_remoting_msg::RxStatus& MidasAppStatus::rxstat() const {
  return rxstat_ != NULL ? *rxstat_ : *default_instance_->rxstat_;
}
inline ::falcon_remoting_msg::RxStatus* MidasAppStatus::mutable_rxstat() {
  set_has_rxstat();
  if (rxstat_ == NULL) rxstat_ = new ::falcon_remoting_msg::RxStatus;
  return rxstat_;
}
inline ::falcon_remoting_msg::RxStatus* MidasAppStatus::release_rxstat() {
  clear_has_rxstat();
  ::falcon_remoting_msg::RxStatus* temp = rxstat_;
  rxstat_ = NULL;
  return temp;
}
inline void MidasAppStatus::set_allocated_rxstat(::falcon_remoting_msg::RxStatus* rxstat) {
  delete rxstat_;
  rxstat_ = rxstat;
  if (rxstat) {
    set_has_rxstat();
  } else {
    clear_has_rxstat();
  }
}

// optional .falcon_remoting_msg.RecordingStatus recStat = 4;
inline bool MidasAppStatus::has_recstat() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MidasAppStatus::set_has_recstat() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MidasAppStatus::clear_has_recstat() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MidasAppStatus::clear_recstat() {
  if (recstat_ != NULL) recstat_->::falcon_remoting_msg::RecordingStatus::Clear();
  clear_has_recstat();
}
inline const ::falcon_remoting_msg::RecordingStatus& MidasAppStatus::recstat() const {
  return recstat_ != NULL ? *recstat_ : *default_instance_->recstat_;
}
inline ::falcon_remoting_msg::RecordingStatus* MidasAppStatus::mutable_recstat() {
  set_has_recstat();
  if (recstat_ == NULL) recstat_ = new ::falcon_remoting_msg::RecordingStatus;
  return recstat_;
}
inline ::falcon_remoting_msg::RecordingStatus* MidasAppStatus::release_recstat() {
  clear_has_recstat();
  ::falcon_remoting_msg::RecordingStatus* temp = recstat_;
  recstat_ = NULL;
  return temp;
}
inline void MidasAppStatus::set_allocated_recstat(::falcon_remoting_msg::RecordingStatus* recstat) {
  delete recstat_;
  recstat_ = recstat;
  if (recstat) {
    set_has_recstat();
  } else {
    clear_has_recstat();
  }
}

// optional .falcon_remoting_msg.SignalStatus sigStat = 5;
inline bool MidasAppStatus::has_sigstat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MidasAppStatus::set_has_sigstat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MidasAppStatus::clear_has_sigstat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MidasAppStatus::clear_sigstat() {
  if (sigstat_ != NULL) sigstat_->::falcon_remoting_msg::SignalStatus::Clear();
  clear_has_sigstat();
}
inline const ::falcon_remoting_msg::SignalStatus& MidasAppStatus::sigstat() const {
  return sigstat_ != NULL ? *sigstat_ : *default_instance_->sigstat_;
}
inline ::falcon_remoting_msg::SignalStatus* MidasAppStatus::mutable_sigstat() {
  set_has_sigstat();
  if (sigstat_ == NULL) sigstat_ = new ::falcon_remoting_msg::SignalStatus;
  return sigstat_;
}
inline ::falcon_remoting_msg::SignalStatus* MidasAppStatus::release_sigstat() {
  clear_has_sigstat();
  ::falcon_remoting_msg::SignalStatus* temp = sigstat_;
  sigstat_ = NULL;
  return temp;
}
inline void MidasAppStatus::set_allocated_sigstat(::falcon_remoting_msg::SignalStatus* sigstat) {
  delete sigstat_;
  sigstat_ = sigstat;
  if (sigstat) {
    set_has_sigstat();
  } else {
    clear_has_sigstat();
  }
}

// optional .falcon_remoting_msg.VideoStatus vidStat = 6;
inline bool MidasAppStatus::has_vidstat() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MidasAppStatus::set_has_vidstat() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MidasAppStatus::clear_has_vidstat() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MidasAppStatus::clear_vidstat() {
  if (vidstat_ != NULL) vidstat_->::falcon_remoting_msg::VideoStatus::Clear();
  clear_has_vidstat();
}
inline const ::falcon_remoting_msg::VideoStatus& MidasAppStatus::vidstat() const {
  return vidstat_ != NULL ? *vidstat_ : *default_instance_->vidstat_;
}
inline ::falcon_remoting_msg::VideoStatus* MidasAppStatus::mutable_vidstat() {
  set_has_vidstat();
  if (vidstat_ == NULL) vidstat_ = new ::falcon_remoting_msg::VideoStatus;
  return vidstat_;
}
inline ::falcon_remoting_msg::VideoStatus* MidasAppStatus::release_vidstat() {
  clear_has_vidstat();
  ::falcon_remoting_msg::VideoStatus* temp = vidstat_;
  vidstat_ = NULL;
  return temp;
}
inline void MidasAppStatus::set_allocated_vidstat(::falcon_remoting_msg::VideoStatus* vidstat) {
  delete vidstat_;
  vidstat_ = vidstat;
  if (vidstat) {
    set_has_vidstat();
  } else {
    clear_has_vidstat();
  }
}

// optional .falcon_remoting_msg.FreqHopStatus fhStat = 7;
inline bool MidasAppStatus::has_fhstat() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MidasAppStatus::set_has_fhstat() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MidasAppStatus::clear_has_fhstat() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MidasAppStatus::clear_fhstat() {
  if (fhstat_ != NULL) fhstat_->::falcon_remoting_msg::FreqHopStatus::Clear();
  clear_has_fhstat();
}
inline const ::falcon_remoting_msg::FreqHopStatus& MidasAppStatus::fhstat() const {
  return fhstat_ != NULL ? *fhstat_ : *default_instance_->fhstat_;
}
inline ::falcon_remoting_msg::FreqHopStatus* MidasAppStatus::mutable_fhstat() {
  set_has_fhstat();
  if (fhstat_ == NULL) fhstat_ = new ::falcon_remoting_msg::FreqHopStatus;
  return fhstat_;
}
inline ::falcon_remoting_msg::FreqHopStatus* MidasAppStatus::release_fhstat() {
  clear_has_fhstat();
  ::falcon_remoting_msg::FreqHopStatus* temp = fhstat_;
  fhstat_ = NULL;
  return temp;
}
inline void MidasAppStatus::set_allocated_fhstat(::falcon_remoting_msg::FreqHopStatus* fhstat) {
  delete fhstat_;
  fhstat_ = fhstat;
  if (fhstat) {
    set_has_fhstat();
  } else {
    clear_has_fhstat();
  }
}

// optional .falcon_remoting_msg.MidasAppStatus.SearchSetting searchStat = 8;
inline bool MidasAppStatus::has_searchstat() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MidasAppStatus::set_has_searchstat() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MidasAppStatus::clear_has_searchstat() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MidasAppStatus::clear_searchstat() {
  searchstat_ = 1;
  clear_has_searchstat();
}
inline ::falcon_remoting_msg::MidasAppStatus_SearchSetting MidasAppStatus::searchstat() const {
  return static_cast< ::falcon_remoting_msg::MidasAppStatus_SearchSetting >(searchstat_);
}
inline void MidasAppStatus::set_searchstat(::falcon_remoting_msg::MidasAppStatus_SearchSetting value) {
  assert(::falcon_remoting_msg::MidasAppStatus_SearchSetting_IsValid(value));
  set_has_searchstat();
  searchstat_ = value;
}

// optional .falcon_remoting_msg.SpecialG specialG = 9;
inline bool MidasAppStatus::has_specialg() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MidasAppStatus::set_has_specialg() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MidasAppStatus::clear_has_specialg() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MidasAppStatus::clear_specialg() {
  if (specialg_ != NULL) specialg_->::falcon_remoting_msg::SpecialG::Clear();
  clear_has_specialg();
}
inline const ::falcon_remoting_msg::SpecialG& MidasAppStatus::specialg() const {
  return specialg_ != NULL ? *specialg_ : *default_instance_->specialg_;
}
inline ::falcon_remoting_msg::SpecialG* MidasAppStatus::mutable_specialg() {
  set_has_specialg();
  if (specialg_ == NULL) specialg_ = new ::falcon_remoting_msg::SpecialG;
  return specialg_;
}
inline ::falcon_remoting_msg::SpecialG* MidasAppStatus::release_specialg() {
  clear_has_specialg();
  ::falcon_remoting_msg::SpecialG* temp = specialg_;
  specialg_ = NULL;
  return temp;
}
inline void MidasAppStatus::set_allocated_specialg(::falcon_remoting_msg::SpecialG* specialg) {
  delete specialg_;
  specialg_ = specialg;
  if (specialg) {
    set_has_specialg();
  } else {
    clear_has_specialg();
  }
}

// optional float threshold = 10;
inline bool MidasAppStatus::has_threshold() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MidasAppStatus::set_has_threshold() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MidasAppStatus::clear_has_threshold() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MidasAppStatus::clear_threshold() {
  threshold_ = 0;
  clear_has_threshold();
}
inline float MidasAppStatus::threshold() const {
  return threshold_;
}
inline void MidasAppStatus::set_threshold(float value) {
  set_has_threshold();
  threshold_ = value;
}

// optional bool skyScraperProduct = 11;
inline bool MidasAppStatus::has_skyscraperproduct() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MidasAppStatus::set_has_skyscraperproduct() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MidasAppStatus::clear_has_skyscraperproduct() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MidasAppStatus::clear_skyscraperproduct() {
  skyscraperproduct_ = false;
  clear_has_skyscraperproduct();
}
inline bool MidasAppStatus::skyscraperproduct() const {
  return skyscraperproduct_;
}
inline void MidasAppStatus::set_skyscraperproduct(bool value) {
  set_has_skyscraperproduct();
  skyscraperproduct_ = value;
}

// -------------------------------------------------------------------

// RxStatus

// optional float freq = 1;
inline bool RxStatus::has_freq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RxStatus::set_has_freq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RxStatus::clear_has_freq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RxStatus::clear_freq() {
  freq_ = 0;
  clear_has_freq();
}
inline float RxStatus::freq() const {
  return freq_;
}
inline void RxStatus::set_freq(float value) {
  set_has_freq();
  freq_ = value;
}

// optional int32 atten = 2;
inline bool RxStatus::has_atten() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RxStatus::set_has_atten() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RxStatus::clear_has_atten() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RxStatus::clear_atten() {
  atten_ = 0;
  clear_has_atten();
}
inline ::google::protobuf::int32 RxStatus::atten() const {
  return atten_;
}
inline void RxStatus::set_atten(::google::protobuf::int32 value) {
  set_has_atten();
  atten_ = value;
}

// optional .falcon_remoting_msg.RxStatus.Status autoAtten = 3;
inline bool RxStatus::has_autoatten() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RxStatus::set_has_autoatten() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RxStatus::clear_has_autoatten() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RxStatus::clear_autoatten() {
  autoatten_ = 2;
  clear_has_autoatten();
}
inline ::falcon_remoting_msg::RxStatus_Status RxStatus::autoatten() const {
  return static_cast< ::falcon_remoting_msg::RxStatus_Status >(autoatten_);
}
inline void RxStatus::set_autoatten(::falcon_remoting_msg::RxStatus_Status value) {
  assert(::falcon_remoting_msg::RxStatus_Status_IsValid(value));
  set_has_autoatten();
  autoatten_ = value;
}

// -------------------------------------------------------------------

// RecordingStatus

// optional .falcon_remoting_msg.RecordingStatus.Status predRecStat = 1;
inline bool RecordingStatus::has_predrecstat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecordingStatus::set_has_predrecstat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecordingStatus::clear_has_predrecstat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecordingStatus::clear_predrecstat() {
  predrecstat_ = 0;
  clear_has_predrecstat();
}
inline ::falcon_remoting_msg::RecordingStatus_Status RecordingStatus::predrecstat() const {
  return static_cast< ::falcon_remoting_msg::RecordingStatus_Status >(predrecstat_);
}
inline void RecordingStatus::set_predrecstat(::falcon_remoting_msg::RecordingStatus_Status value) {
  assert(::falcon_remoting_msg::RecordingStatus_Status_IsValid(value));
  set_has_predrecstat();
  predrecstat_ = value;
}

// optional float diskUse = 2;
inline bool RecordingStatus::has_diskuse() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RecordingStatus::set_has_diskuse() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RecordingStatus::clear_has_diskuse() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RecordingStatus::clear_diskuse() {
  diskuse_ = 0;
  clear_has_diskuse();
}
inline float RecordingStatus::diskuse() const {
  return diskuse_;
}
inline void RecordingStatus::set_diskuse(float value) {
  set_has_diskuse();
  diskuse_ = value;
}

// -------------------------------------------------------------------

// SignalStatus

// repeated .falcon_remoting_msg.DetectionStatus detStat = 1;
inline int SignalStatus::detstat_size() const {
  return detstat_.size();
}
inline void SignalStatus::clear_detstat() {
  detstat_.Clear();
}
inline const ::falcon_remoting_msg::DetectionStatus& SignalStatus::detstat(int index) const {
  return detstat_.Get(index);
}
inline ::falcon_remoting_msg::DetectionStatus* SignalStatus::mutable_detstat(int index) {
  return detstat_.Mutable(index);
}
inline ::falcon_remoting_msg::DetectionStatus* SignalStatus::add_detstat() {
  return detstat_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::falcon_remoting_msg::DetectionStatus >&
SignalStatus::detstat() const {
  return detstat_;
}
inline ::google::protobuf::RepeatedPtrField< ::falcon_remoting_msg::DetectionStatus >*
SignalStatus::mutable_detstat() {
  return &detstat_;
}

// optional float ber = 2;
inline bool SignalStatus::has_ber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignalStatus::set_has_ber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignalStatus::clear_has_ber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignalStatus::clear_ber() {
  ber_ = 0;
  clear_has_ber();
}
inline float SignalStatus::ber() const {
  return ber_;
}
inline void SignalStatus::set_ber(float value) {
  set_has_ber();
  ber_ = value;
}

// optional float centerFreqEst = 3;
inline bool SignalStatus::has_centerfreqest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignalStatus::set_has_centerfreqest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignalStatus::clear_has_centerfreqest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignalStatus::clear_centerfreqest() {
  centerfreqest_ = 0;
  clear_has_centerfreqest();
}
inline float SignalStatus::centerfreqest() const {
  return centerfreqest_;
}
inline void SignalStatus::set_centerfreqest(float value) {
  set_has_centerfreqest();
  centerfreqest_ = value;
}

// optional float excurEst = 4;
inline bool SignalStatus::has_excurest() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignalStatus::set_has_excurest() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignalStatus::clear_has_excurest() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignalStatus::clear_excurest() {
  excurest_ = 0;
  clear_has_excurest();
}
inline float SignalStatus::excurest() const {
  return excurest_;
}
inline void SignalStatus::set_excurest(float value) {
  set_has_excurest();
  excurest_ = value;
}

// optional int32 packetCount = 5;
inline bool SignalStatus::has_packetcount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SignalStatus::set_has_packetcount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SignalStatus::clear_has_packetcount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SignalStatus::clear_packetcount() {
  packetcount_ = 0;
  clear_has_packetcount();
}
inline ::google::protobuf::int32 SignalStatus::packetcount() const {
  return packetcount_;
}
inline void SignalStatus::set_packetcount(::google::protobuf::int32 value) {
  set_has_packetcount();
  packetcount_ = value;
}

// optional int32 timeWindow = 6;
inline bool SignalStatus::has_timewindow() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SignalStatus::set_has_timewindow() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SignalStatus::clear_has_timewindow() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SignalStatus::clear_timewindow() {
  timewindow_ = 0;
  clear_has_timewindow();
}
inline ::google::protobuf::int32 SignalStatus::timewindow() const {
  return timewindow_;
}
inline void SignalStatus::set_timewindow(::google::protobuf::int32 value) {
  set_has_timewindow();
  timewindow_ = value;
}

// optional int64 timeStamp = 7;
inline bool SignalStatus::has_timestamp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SignalStatus::set_has_timestamp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SignalStatus::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SignalStatus::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 SignalStatus::timestamp() const {
  return timestamp_;
}
inline void SignalStatus::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// DetectionStatus

// optional string sigName = 1;
inline bool DetectionStatus::has_signame() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DetectionStatus::set_has_signame() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DetectionStatus::clear_has_signame() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DetectionStatus::clear_signame() {
  if (signame_ != &::google::protobuf::internal::kEmptyString) {
    signame_->clear();
  }
  clear_has_signame();
}
inline const ::std::string& DetectionStatus::signame() const {
  return *signame_;
}
inline void DetectionStatus::set_signame(const ::std::string& value) {
  set_has_signame();
  if (signame_ == &::google::protobuf::internal::kEmptyString) {
    signame_ = new ::std::string;
  }
  signame_->assign(value);
}
inline void DetectionStatus::set_signame(const char* value) {
  set_has_signame();
  if (signame_ == &::google::protobuf::internal::kEmptyString) {
    signame_ = new ::std::string;
  }
  signame_->assign(value);
}
inline void DetectionStatus::set_signame(const char* value, size_t size) {
  set_has_signame();
  if (signame_ == &::google::protobuf::internal::kEmptyString) {
    signame_ = new ::std::string;
  }
  signame_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DetectionStatus::mutable_signame() {
  set_has_signame();
  if (signame_ == &::google::protobuf::internal::kEmptyString) {
    signame_ = new ::std::string;
  }
  return signame_;
}
inline ::std::string* DetectionStatus::release_signame() {
  clear_has_signame();
  if (signame_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signame_;
    signame_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DetectionStatus::set_allocated_signame(::std::string* signame) {
  if (signame_ != &::google::protobuf::internal::kEmptyString) {
    delete signame_;
  }
  if (signame) {
    set_has_signame();
    signame_ = signame;
  } else {
    clear_has_signame();
    signame_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string detState = 2;
inline bool DetectionStatus::has_detstate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DetectionStatus::set_has_detstate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DetectionStatus::clear_has_detstate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DetectionStatus::clear_detstate() {
  if (detstate_ != &::google::protobuf::internal::kEmptyString) {
    detstate_->clear();
  }
  clear_has_detstate();
}
inline const ::std::string& DetectionStatus::detstate() const {
  return *detstate_;
}
inline void DetectionStatus::set_detstate(const ::std::string& value) {
  set_has_detstate();
  if (detstate_ == &::google::protobuf::internal::kEmptyString) {
    detstate_ = new ::std::string;
  }
  detstate_->assign(value);
}
inline void DetectionStatus::set_detstate(const char* value) {
  set_has_detstate();
  if (detstate_ == &::google::protobuf::internal::kEmptyString) {
    detstate_ = new ::std::string;
  }
  detstate_->assign(value);
}
inline void DetectionStatus::set_detstate(const char* value, size_t size) {
  set_has_detstate();
  if (detstate_ == &::google::protobuf::internal::kEmptyString) {
    detstate_ = new ::std::string;
  }
  detstate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DetectionStatus::mutable_detstate() {
  set_has_detstate();
  if (detstate_ == &::google::protobuf::internal::kEmptyString) {
    detstate_ = new ::std::string;
  }
  return detstate_;
}
inline ::std::string* DetectionStatus::release_detstate() {
  clear_has_detstate();
  if (detstate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = detstate_;
    detstate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DetectionStatus::set_allocated_detstate(::std::string* detstate) {
  if (detstate_ != &::google::protobuf::internal::kEmptyString) {
    delete detstate_;
  }
  if (detstate) {
    set_has_detstate();
    detstate_ = detstate;
  } else {
    clear_has_detstate();
    detstate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .falcon_remoting_msg.DetectionStatus.Color color = 3;
inline bool DetectionStatus::has_color() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DetectionStatus::set_has_color() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DetectionStatus::clear_has_color() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DetectionStatus::clear_color() {
  color_ = 1;
  clear_has_color();
}
inline ::falcon_remoting_msg::DetectionStatus_Color DetectionStatus::color() const {
  return static_cast< ::falcon_remoting_msg::DetectionStatus_Color >(color_);
}
inline void DetectionStatus::set_color(::falcon_remoting_msg::DetectionStatus_Color value) {
  assert(::falcon_remoting_msg::DetectionStatus_Color_IsValid(value));
  set_has_color();
  color_ = value;
}

// -------------------------------------------------------------------

// SearchStatus

// optional string msgName = 1 [default = "SEARCH_STATUS"];
inline bool SearchStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SearchStatus::msgname() const {
  return *msgname_;
}
inline void SearchStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SearchStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SearchStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SearchStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SearchStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 appID = 2;
inline bool SearchStatus::has_appid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SearchStatus::set_has_appid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SearchStatus::clear_has_appid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SearchStatus::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 SearchStatus::appid() const {
  return appid_;
}
inline void SearchStatus::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional string status = 3;
inline bool SearchStatus::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SearchStatus::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SearchStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SearchStatus::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& SearchStatus::status() const {
  return *status_;
}
inline void SearchStatus::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void SearchStatus::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void SearchStatus::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchStatus::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* SearchStatus::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SearchStatus::set_allocated_status(::std::string* status) {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    delete status_;
  }
  if (status) {
    set_has_status();
    status_ = status;
  } else {
    clear_has_status();
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .falcon_remoting_msg.SearchStatus.Color color = 4;
inline bool SearchStatus::has_color() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SearchStatus::set_has_color() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SearchStatus::clear_has_color() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SearchStatus::clear_color() {
  color_ = 1;
  clear_has_color();
}
inline ::falcon_remoting_msg::SearchStatus_Color SearchStatus::color() const {
  return static_cast< ::falcon_remoting_msg::SearchStatus_Color >(color_);
}
inline void SearchStatus::set_color(::falcon_remoting_msg::SearchStatus_Color value) {
  assert(::falcon_remoting_msg::SearchStatus_Color_IsValid(value));
  set_has_color();
  color_ = value;
}

// -------------------------------------------------------------------

// VideoStatus

// optional .falcon_remoting_msg.VideoStatus.RecStatus vidRecStat = 1;
inline bool VideoStatus::has_vidrecstat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VideoStatus::set_has_vidrecstat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VideoStatus::clear_has_vidrecstat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VideoStatus::clear_vidrecstat() {
  vidrecstat_ = 0;
  clear_has_vidrecstat();
}
inline ::falcon_remoting_msg::VideoStatus_RecStatus VideoStatus::vidrecstat() const {
  return static_cast< ::falcon_remoting_msg::VideoStatus_RecStatus >(vidrecstat_);
}
inline void VideoStatus::set_vidrecstat(::falcon_remoting_msg::VideoStatus_RecStatus value) {
  assert(::falcon_remoting_msg::VideoStatus_RecStatus_IsValid(value));
  set_has_vidrecstat();
  vidrecstat_ = value;
}

// optional .falcon_remoting_msg.VideoStatus.SyncStatus vidSync = 2;
inline bool VideoStatus::has_vidsync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VideoStatus::set_has_vidsync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VideoStatus::clear_has_vidsync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VideoStatus::clear_vidsync() {
  vidsync_ = 1;
  clear_has_vidsync();
}
inline ::falcon_remoting_msg::VideoStatus_SyncStatus VideoStatus::vidsync() const {
  return static_cast< ::falcon_remoting_msg::VideoStatus_SyncStatus >(vidsync_);
}
inline void VideoStatus::set_vidsync(::falcon_remoting_msg::VideoStatus_SyncStatus value) {
  assert(::falcon_remoting_msg::VideoStatus_SyncStatus_IsValid(value));
  set_has_vidsync();
  vidsync_ = value;
}

// optional int32 vidInt = 3;
inline bool VideoStatus::has_vidint() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VideoStatus::set_has_vidint() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VideoStatus::clear_has_vidint() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VideoStatus::clear_vidint() {
  vidint_ = 0;
  clear_has_vidint();
}
inline ::google::protobuf::int32 VideoStatus::vidint() const {
  return vidint_;
}
inline void VideoStatus::set_vidint(::google::protobuf::int32 value) {
  set_has_vidint();
  vidint_ = value;
}

// optional .falcon_remoting_msg.VideoStatus.JpegMode jpegMode = 4;
inline bool VideoStatus::has_jpegmode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VideoStatus::set_has_jpegmode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VideoStatus::clear_has_jpegmode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VideoStatus::clear_jpegmode() {
  jpegmode_ = 1;
  clear_has_jpegmode();
}
inline ::falcon_remoting_msg::VideoStatus_JpegMode VideoStatus::jpegmode() const {
  return static_cast< ::falcon_remoting_msg::VideoStatus_JpegMode >(jpegmode_);
}
inline void VideoStatus::set_jpegmode(::falcon_remoting_msg::VideoStatus_JpegMode value) {
  assert(::falcon_remoting_msg::VideoStatus_JpegMode_IsValid(value));
  set_has_jpegmode();
  jpegmode_ = value;
}

// optional int32 jpegRate = 5;
inline bool VideoStatus::has_jpegrate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VideoStatus::set_has_jpegrate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VideoStatus::clear_has_jpegrate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VideoStatus::clear_jpegrate() {
  jpegrate_ = 0;
  clear_has_jpegrate();
}
inline ::google::protobuf::int32 VideoStatus::jpegrate() const {
  return jpegrate_;
}
inline void VideoStatus::set_jpegrate(::google::protobuf::int32 value) {
  set_has_jpegrate();
  jpegrate_ = value;
}

// -------------------------------------------------------------------

// FreqHopStatus

// optional .falcon_remoting_msg.FreqHopStatus.Mode mode = 1;
inline bool FreqHopStatus::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FreqHopStatus::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FreqHopStatus::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FreqHopStatus::clear_mode() {
  mode_ = 1;
  clear_has_mode();
}
inline ::falcon_remoting_msg::FreqHopStatus_Mode FreqHopStatus::mode() const {
  return static_cast< ::falcon_remoting_msg::FreqHopStatus_Mode >(mode_);
}
inline void FreqHopStatus::set_mode(::falcon_remoting_msg::FreqHopStatus_Mode value) {
  assert(::falcon_remoting_msg::FreqHopStatus_Mode_IsValid(value));
  set_has_mode();
  mode_ = value;
}

// repeated .falcon_remoting_msg.FreqHopTunerStatus fhopTuner = 2;
inline int FreqHopStatus::fhoptuner_size() const {
  return fhoptuner_.size();
}
inline void FreqHopStatus::clear_fhoptuner() {
  fhoptuner_.Clear();
}
inline const ::falcon_remoting_msg::FreqHopTunerStatus& FreqHopStatus::fhoptuner(int index) const {
  return fhoptuner_.Get(index);
}
inline ::falcon_remoting_msg::FreqHopTunerStatus* FreqHopStatus::mutable_fhoptuner(int index) {
  return fhoptuner_.Mutable(index);
}
inline ::falcon_remoting_msg::FreqHopTunerStatus* FreqHopStatus::add_fhoptuner() {
  return fhoptuner_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::falcon_remoting_msg::FreqHopTunerStatus >&
FreqHopStatus::fhoptuner() const {
  return fhoptuner_;
}
inline ::google::protobuf::RepeatedPtrField< ::falcon_remoting_msg::FreqHopTunerStatus >*
FreqHopStatus::mutable_fhoptuner() {
  return &fhoptuner_;
}

// -------------------------------------------------------------------

// FreqHopTunerStatus

// optional int32 tuner = 1;
inline bool FreqHopTunerStatus::has_tuner() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FreqHopTunerStatus::set_has_tuner() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FreqHopTunerStatus::clear_has_tuner() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FreqHopTunerStatus::clear_tuner() {
  tuner_ = 0;
  clear_has_tuner();
}
inline ::google::protobuf::int32 FreqHopTunerStatus::tuner() const {
  return tuner_;
}
inline void FreqHopTunerStatus::set_tuner(::google::protobuf::int32 value) {
  set_has_tuner();
  tuner_ = value;
}

// optional double freq = 2;
inline bool FreqHopTunerStatus::has_freq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FreqHopTunerStatus::set_has_freq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FreqHopTunerStatus::clear_has_freq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FreqHopTunerStatus::clear_freq() {
  freq_ = 0;
  clear_has_freq();
}
inline double FreqHopTunerStatus::freq() const {
  return freq_;
}
inline void FreqHopTunerStatus::set_freq(double value) {
  set_has_freq();
  freq_ = value;
}

// optional int32 numHits = 3;
inline bool FreqHopTunerStatus::has_numhits() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FreqHopTunerStatus::set_has_numhits() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FreqHopTunerStatus::clear_has_numhits() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FreqHopTunerStatus::clear_numhits() {
  numhits_ = 0;
  clear_has_numhits();
}
inline ::google::protobuf::int32 FreqHopTunerStatus::numhits() const {
  return numhits_;
}
inline void FreqHopTunerStatus::set_numhits(::google::protobuf::int32 value) {
  set_has_numhits();
  numhits_ = value;
}

// optional bool locked = 4;
inline bool FreqHopTunerStatus::has_locked() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FreqHopTunerStatus::set_has_locked() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FreqHopTunerStatus::clear_has_locked() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FreqHopTunerStatus::clear_locked() {
  locked_ = false;
  clear_has_locked();
}
inline bool FreqHopTunerStatus::locked() const {
  return locked_;
}
inline void FreqHopTunerStatus::set_locked(bool value) {
  set_has_locked();
  locked_ = value;
}

// -------------------------------------------------------------------

// SpecialG

// optional string msgName = 1 [default = "PROCESS_SPECIAL_G"];
inline bool SpecialG::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpecialG::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpecialG::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpecialG::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SpecialG::msgname() const {
  return *msgname_;
}
inline void SpecialG::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SpecialG::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SpecialG::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpecialG::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SpecialG::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SpecialG::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional double lat = 2;
inline bool SpecialG::has_lat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpecialG::set_has_lat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpecialG::clear_has_lat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpecialG::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline double SpecialG::lat() const {
  return lat_;
}
inline void SpecialG::set_lat(double value) {
  set_has_lat();
  lat_ = value;
}

// optional double lon = 3;
inline bool SpecialG::has_lon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SpecialG::set_has_lon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SpecialG::clear_has_lon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SpecialG::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline double SpecialG::lon() const {
  return lon_;
}
inline void SpecialG::set_lon(double value) {
  set_has_lon();
  lon_ = value;
}

// optional double alt = 4;
inline bool SpecialG::has_alt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SpecialG::set_has_alt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SpecialG::clear_has_alt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SpecialG::clear_alt() {
  alt_ = 0;
  clear_has_alt();
}
inline double SpecialG::alt() const {
  return alt_;
}
inline void SpecialG::set_alt(double value) {
  set_has_alt();
  alt_ = value;
}

// optional double estAlt = 5;
inline bool SpecialG::has_estalt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SpecialG::set_has_estalt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SpecialG::clear_has_estalt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SpecialG::clear_estalt() {
  estalt_ = 0;
  clear_has_estalt();
}
inline double SpecialG::estalt() const {
  return estalt_;
}
inline void SpecialG::set_estalt(double value) {
  set_has_estalt();
  estalt_ = value;
}

// optional bool enable = 6;
inline bool SpecialG::has_enable() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SpecialG::set_has_enable() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SpecialG::clear_has_enable() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SpecialG::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool SpecialG::enable() const {
  return enable_;
}
inline void SpecialG::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// -------------------------------------------------------------------

// SensorPosition

// optional string msgName = 1 [default = "SENSOR_POSITION"];
inline bool SensorPosition::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorPosition::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SensorPosition::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SensorPosition::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SensorPosition::msgname() const {
  return *msgname_;
}
inline void SensorPosition::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SensorPosition::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SensorPosition::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SensorPosition::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SensorPosition::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SensorPosition::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional float lat = 2;
inline bool SensorPosition::has_lat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorPosition::set_has_lat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SensorPosition::clear_has_lat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SensorPosition::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline float SensorPosition::lat() const {
  return lat_;
}
inline void SensorPosition::set_lat(float value) {
  set_has_lat();
  lat_ = value;
}

// optional float lon = 3;
inline bool SensorPosition::has_lon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SensorPosition::set_has_lon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SensorPosition::clear_has_lon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SensorPosition::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline float SensorPosition::lon() const {
  return lon_;
}
inline void SensorPosition::set_lon(float value) {
  set_has_lon();
  lon_ = value;
}

// optional float alt = 4;
inline bool SensorPosition::has_alt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SensorPosition::set_has_alt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SensorPosition::clear_has_alt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SensorPosition::clear_alt() {
  alt_ = 0;
  clear_has_alt();
}
inline float SensorPosition::alt() const {
  return alt_;
}
inline void SensorPosition::set_alt(float value) {
  set_has_alt();
  alt_ = value;
}

// optional .falcon_remoting_msg.OrientationStatus orientation = 5;
inline bool SensorPosition::has_orientation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SensorPosition::set_has_orientation() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SensorPosition::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SensorPosition::clear_orientation() {
  if (orientation_ != NULL) orientation_->::falcon_remoting_msg::OrientationStatus::Clear();
  clear_has_orientation();
}
inline const ::falcon_remoting_msg::OrientationStatus& SensorPosition::orientation() const {
  return orientation_ != NULL ? *orientation_ : *default_instance_->orientation_;
}
inline ::falcon_remoting_msg::OrientationStatus* SensorPosition::mutable_orientation() {
  set_has_orientation();
  if (orientation_ == NULL) orientation_ = new ::falcon_remoting_msg::OrientationStatus;
  return orientation_;
}
inline ::falcon_remoting_msg::OrientationStatus* SensorPosition::release_orientation() {
  clear_has_orientation();
  ::falcon_remoting_msg::OrientationStatus* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline void SensorPosition::set_allocated_orientation(::falcon_remoting_msg::OrientationStatus* orientation) {
  delete orientation_;
  orientation_ = orientation;
  if (orientation) {
    set_has_orientation();
  } else {
    clear_has_orientation();
  }
}

// optional int64 timestamp = 6;
inline bool SensorPosition::has_timestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SensorPosition::set_has_timestamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SensorPosition::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SensorPosition::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 SensorPosition::timestamp() const {
  return timestamp_;
}
inline void SensorPosition::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional string sensorName = 7;
inline bool SensorPosition::has_sensorname() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SensorPosition::set_has_sensorname() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SensorPosition::clear_has_sensorname() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SensorPosition::clear_sensorname() {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    sensorname_->clear();
  }
  clear_has_sensorname();
}
inline const ::std::string& SensorPosition::sensorname() const {
  return *sensorname_;
}
inline void SensorPosition::set_sensorname(const ::std::string& value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void SensorPosition::set_sensorname(const char* value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void SensorPosition::set_sensorname(const char* value, size_t size) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SensorPosition::mutable_sensorname() {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  return sensorname_;
}
inline ::std::string* SensorPosition::release_sensorname() {
  clear_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sensorname_;
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SensorPosition::set_allocated_sensorname(::std::string* sensorname) {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    delete sensorname_;
  }
  if (sensorname) {
    set_has_sensorname();
    sensorname_ = sensorname;
  } else {
    clear_has_sensorname();
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string siteId = 8;
inline bool SensorPosition::has_siteid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SensorPosition::set_has_siteid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SensorPosition::clear_has_siteid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SensorPosition::clear_siteid() {
  if (siteid_ != &::google::protobuf::internal::kEmptyString) {
    siteid_->clear();
  }
  clear_has_siteid();
}
inline const ::std::string& SensorPosition::siteid() const {
  return *siteid_;
}
inline void SensorPosition::set_siteid(const ::std::string& value) {
  set_has_siteid();
  if (siteid_ == &::google::protobuf::internal::kEmptyString) {
    siteid_ = new ::std::string;
  }
  siteid_->assign(value);
}
inline void SensorPosition::set_siteid(const char* value) {
  set_has_siteid();
  if (siteid_ == &::google::protobuf::internal::kEmptyString) {
    siteid_ = new ::std::string;
  }
  siteid_->assign(value);
}
inline void SensorPosition::set_siteid(const char* value, size_t size) {
  set_has_siteid();
  if (siteid_ == &::google::protobuf::internal::kEmptyString) {
    siteid_ = new ::std::string;
  }
  siteid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SensorPosition::mutable_siteid() {
  set_has_siteid();
  if (siteid_ == &::google::protobuf::internal::kEmptyString) {
    siteid_ = new ::std::string;
  }
  return siteid_;
}
inline ::std::string* SensorPosition::release_siteid() {
  clear_has_siteid();
  if (siteid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = siteid_;
    siteid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SensorPosition::set_allocated_siteid(::std::string* siteid) {
  if (siteid_ != &::google::protobuf::internal::kEmptyString) {
    delete siteid_;
  }
  if (siteid) {
    set_has_siteid();
    siteid_ = siteid;
  } else {
    clear_has_siteid();
    siteid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sigAd = 9;
inline bool SensorPosition::has_sigad() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SensorPosition::set_has_sigad() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SensorPosition::clear_has_sigad() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SensorPosition::clear_sigad() {
  if (sigad_ != &::google::protobuf::internal::kEmptyString) {
    sigad_->clear();
  }
  clear_has_sigad();
}
inline const ::std::string& SensorPosition::sigad() const {
  return *sigad_;
}
inline void SensorPosition::set_sigad(const ::std::string& value) {
  set_has_sigad();
  if (sigad_ == &::google::protobuf::internal::kEmptyString) {
    sigad_ = new ::std::string;
  }
  sigad_->assign(value);
}
inline void SensorPosition::set_sigad(const char* value) {
  set_has_sigad();
  if (sigad_ == &::google::protobuf::internal::kEmptyString) {
    sigad_ = new ::std::string;
  }
  sigad_->assign(value);
}
inline void SensorPosition::set_sigad(const char* value, size_t size) {
  set_has_sigad();
  if (sigad_ == &::google::protobuf::internal::kEmptyString) {
    sigad_ = new ::std::string;
  }
  sigad_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SensorPosition::mutable_sigad() {
  set_has_sigad();
  if (sigad_ == &::google::protobuf::internal::kEmptyString) {
    sigad_ = new ::std::string;
  }
  return sigad_;
}
inline ::std::string* SensorPosition::release_sigad() {
  clear_has_sigad();
  if (sigad_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sigad_;
    sigad_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SensorPosition::set_allocated_sigad(::std::string* sigad) {
  if (sigad_ != &::google::protobuf::internal::kEmptyString) {
    delete sigad_;
  }
  if (sigad) {
    set_has_sigad();
    sigad_ = sigad;
  } else {
    clear_has_sigad();
    sigad_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .falcon_remoting_msg.FieldofView fov = 10;
inline int SensorPosition::fov_size() const {
  return fov_.size();
}
inline void SensorPosition::clear_fov() {
  fov_.Clear();
}
inline const ::falcon_remoting_msg::FieldofView& SensorPosition::fov(int index) const {
  return fov_.Get(index);
}
inline ::falcon_remoting_msg::FieldofView* SensorPosition::mutable_fov(int index) {
  return fov_.Mutable(index);
}
inline ::falcon_remoting_msg::FieldofView* SensorPosition::add_fov() {
  return fov_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::falcon_remoting_msg::FieldofView >&
SensorPosition::fov() const {
  return fov_;
}
inline ::google::protobuf::RepeatedPtrField< ::falcon_remoting_msg::FieldofView >*
SensorPosition::mutable_fov() {
  return &fov_;
}

// -------------------------------------------------------------------

// SensorHealth

// optional string msgName = 1 [default = "SENSOR_HEALTH"];
inline bool SensorHealth::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorHealth::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SensorHealth::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SensorHealth::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SensorHealth::msgname() const {
  return *msgname_;
}
inline void SensorHealth::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SensorHealth::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SensorHealth::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SensorHealth::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SensorHealth::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SensorHealth::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string sensorName = 2;
inline bool SensorHealth::has_sensorname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorHealth::set_has_sensorname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SensorHealth::clear_has_sensorname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SensorHealth::clear_sensorname() {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    sensorname_->clear();
  }
  clear_has_sensorname();
}
inline const ::std::string& SensorHealth::sensorname() const {
  return *sensorname_;
}
inline void SensorHealth::set_sensorname(const ::std::string& value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void SensorHealth::set_sensorname(const char* value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void SensorHealth::set_sensorname(const char* value, size_t size) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SensorHealth::mutable_sensorname() {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  return sensorname_;
}
inline ::std::string* SensorHealth::release_sensorname() {
  clear_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sensorname_;
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SensorHealth::set_allocated_sensorname(::std::string* sensorname) {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    delete sensorname_;
  }
  if (sensorname) {
    set_has_sensorname();
    sensorname_ = sensorname;
  } else {
    clear_has_sensorname();
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 pollTime = 3;
inline bool SensorHealth::has_polltime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SensorHealth::set_has_polltime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SensorHealth::clear_has_polltime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SensorHealth::clear_polltime() {
  polltime_ = 0;
  clear_has_polltime();
}
inline ::google::protobuf::int32 SensorHealth::polltime() const {
  return polltime_;
}
inline void SensorHealth::set_polltime(::google::protobuf::int32 value) {
  set_has_polltime();
  polltime_ = value;
}

// optional int32 averageCount = 4;
inline bool SensorHealth::has_averagecount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SensorHealth::set_has_averagecount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SensorHealth::clear_has_averagecount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SensorHealth::clear_averagecount() {
  averagecount_ = 0;
  clear_has_averagecount();
}
inline ::google::protobuf::int32 SensorHealth::averagecount() const {
  return averagecount_;
}
inline void SensorHealth::set_averagecount(::google::protobuf::int32 value) {
  set_has_averagecount();
  averagecount_ = value;
}

// optional float cpuUsage = 5;
inline bool SensorHealth::has_cpuusage() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SensorHealth::set_has_cpuusage() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SensorHealth::clear_has_cpuusage() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SensorHealth::clear_cpuusage() {
  cpuusage_ = 0;
  clear_has_cpuusage();
}
inline float SensorHealth::cpuusage() const {
  return cpuusage_;
}
inline void SensorHealth::set_cpuusage(float value) {
  set_has_cpuusage();
  cpuusage_ = value;
}

// optional float cpuAverage = 6;
inline bool SensorHealth::has_cpuaverage() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SensorHealth::set_has_cpuaverage() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SensorHealth::clear_has_cpuaverage() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SensorHealth::clear_cpuaverage() {
  cpuaverage_ = 0;
  clear_has_cpuaverage();
}
inline float SensorHealth::cpuaverage() const {
  return cpuaverage_;
}
inline void SensorHealth::set_cpuaverage(float value) {
  set_has_cpuaverage();
  cpuaverage_ = value;
}

// optional float ramUsage = 7;
inline bool SensorHealth::has_ramusage() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SensorHealth::set_has_ramusage() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SensorHealth::clear_has_ramusage() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SensorHealth::clear_ramusage() {
  ramusage_ = 0;
  clear_has_ramusage();
}
inline float SensorHealth::ramusage() const {
  return ramusage_;
}
inline void SensorHealth::set_ramusage(float value) {
  set_has_ramusage();
  ramusage_ = value;
}

// optional float ramAverage = 8;
inline bool SensorHealth::has_ramaverage() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SensorHealth::set_has_ramaverage() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SensorHealth::clear_has_ramaverage() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SensorHealth::clear_ramaverage() {
  ramaverage_ = 0;
  clear_has_ramaverage();
}
inline float SensorHealth::ramaverage() const {
  return ramaverage_;
}
inline void SensorHealth::set_ramaverage(float value) {
  set_has_ramaverage();
  ramaverage_ = value;
}

// optional float diskUsage = 9;
inline bool SensorHealth::has_diskusage() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SensorHealth::set_has_diskusage() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SensorHealth::clear_has_diskusage() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SensorHealth::clear_diskusage() {
  diskusage_ = 0;
  clear_has_diskusage();
}
inline float SensorHealth::diskusage() const {
  return diskusage_;
}
inline void SensorHealth::set_diskusage(float value) {
  set_has_diskusage();
  diskusage_ = value;
}

// optional float diskAverage = 10;
inline bool SensorHealth::has_diskaverage() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SensorHealth::set_has_diskaverage() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SensorHealth::clear_has_diskaverage() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SensorHealth::clear_diskaverage() {
  diskaverage_ = 0;
  clear_has_diskaverage();
}
inline float SensorHealth::diskaverage() const {
  return diskaverage_;
}
inline void SensorHealth::set_diskaverage(float value) {
  set_has_diskaverage();
  diskaverage_ = value;
}

// optional float cpuTempAvg = 11;
inline bool SensorHealth::has_cputempavg() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SensorHealth::set_has_cputempavg() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SensorHealth::clear_has_cputempavg() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SensorHealth::clear_cputempavg() {
  cputempavg_ = 0;
  clear_has_cputempavg();
}
inline float SensorHealth::cputempavg() const {
  return cputempavg_;
}
inline void SensorHealth::set_cputempavg(float value) {
  set_has_cputempavg();
  cputempavg_ = value;
}

// optional float cpuTempMin = 12;
inline bool SensorHealth::has_cputempmin() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SensorHealth::set_has_cputempmin() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SensorHealth::clear_has_cputempmin() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SensorHealth::clear_cputempmin() {
  cputempmin_ = 0;
  clear_has_cputempmin();
}
inline float SensorHealth::cputempmin() const {
  return cputempmin_;
}
inline void SensorHealth::set_cputempmin(float value) {
  set_has_cputempmin();
  cputempmin_ = value;
}

// optional float cpuTempMax = 13;
inline bool SensorHealth::has_cputempmax() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SensorHealth::set_has_cputempmax() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SensorHealth::clear_has_cputempmax() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SensorHealth::clear_cputempmax() {
  cputempmax_ = 0;
  clear_has_cputempmax();
}
inline float SensorHealth::cputempmax() const {
  return cputempmax_;
}
inline void SensorHealth::set_cputempmax(float value) {
  set_has_cputempmax();
  cputempmax_ = value;
}

// -------------------------------------------------------------------

// HardwareStatus

// optional string msgName = 1 [default = "HARDWARE_STATUS"];
inline bool HardwareStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HardwareStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HardwareStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HardwareStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& HardwareStatus::msgname() const {
  return *msgname_;
}
inline void HardwareStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void HardwareStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void HardwareStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HardwareStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* HardwareStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void HardwareStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string IPAddress = 2;
inline bool HardwareStatus::has_ipaddress() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HardwareStatus::set_has_ipaddress() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HardwareStatus::clear_has_ipaddress() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HardwareStatus::clear_ipaddress() {
  if (ipaddress_ != &::google::protobuf::internal::kEmptyString) {
    ipaddress_->clear();
  }
  clear_has_ipaddress();
}
inline const ::std::string& HardwareStatus::ipaddress() const {
  return *ipaddress_;
}
inline void HardwareStatus::set_ipaddress(const ::std::string& value) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(value);
}
inline void HardwareStatus::set_ipaddress(const char* value) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(value);
}
inline void HardwareStatus::set_ipaddress(const char* value, size_t size) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HardwareStatus::mutable_ipaddress() {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  return ipaddress_;
}
inline ::std::string* HardwareStatus::release_ipaddress() {
  clear_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ipaddress_;
    ipaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HardwareStatus::set_allocated_ipaddress(::std::string* ipaddress) {
  if (ipaddress_ != &::google::protobuf::internal::kEmptyString) {
    delete ipaddress_;
  }
  if (ipaddress) {
    set_has_ipaddress();
    ipaddress_ = ipaddress;
  } else {
    clear_has_ipaddress();
    ipaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sensorName = 3;
inline bool HardwareStatus::has_sensorname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HardwareStatus::set_has_sensorname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HardwareStatus::clear_has_sensorname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HardwareStatus::clear_sensorname() {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    sensorname_->clear();
  }
  clear_has_sensorname();
}
inline const ::std::string& HardwareStatus::sensorname() const {
  return *sensorname_;
}
inline void HardwareStatus::set_sensorname(const ::std::string& value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void HardwareStatus::set_sensorname(const char* value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void HardwareStatus::set_sensorname(const char* value, size_t size) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HardwareStatus::mutable_sensorname() {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  return sensorname_;
}
inline ::std::string* HardwareStatus::release_sensorname() {
  clear_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sensorname_;
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HardwareStatus::set_allocated_sensorname(::std::string* sensorname) {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    delete sensorname_;
  }
  if (sensorname) {
    set_has_sensorname();
    sensorname_ = sensorname;
  } else {
    clear_has_sensorname();
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float cpuAvgTemp = 4;
inline bool HardwareStatus::has_cpuavgtemp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HardwareStatus::set_has_cpuavgtemp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HardwareStatus::clear_has_cpuavgtemp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HardwareStatus::clear_cpuavgtemp() {
  cpuavgtemp_ = 0;
  clear_has_cpuavgtemp();
}
inline float HardwareStatus::cpuavgtemp() const {
  return cpuavgtemp_;
}
inline void HardwareStatus::set_cpuavgtemp(float value) {
  set_has_cpuavgtemp();
  cpuavgtemp_ = value;
}

// repeated float cpuHighTemp = 5;
inline int HardwareStatus::cpuhightemp_size() const {
  return cpuhightemp_.size();
}
inline void HardwareStatus::clear_cpuhightemp() {
  cpuhightemp_.Clear();
}
inline float HardwareStatus::cpuhightemp(int index) const {
  return cpuhightemp_.Get(index);
}
inline void HardwareStatus::set_cpuhightemp(int index, float value) {
  cpuhightemp_.Set(index, value);
}
inline void HardwareStatus::add_cpuhightemp(float value) {
  cpuhightemp_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
HardwareStatus::cpuhightemp() const {
  return cpuhightemp_;
}
inline ::google::protobuf::RepeatedField< float >*
HardwareStatus::mutable_cpuhightemp() {
  return &cpuhightemp_;
}

// optional float cpuIdlePercent = 6;
inline bool HardwareStatus::has_cpuidlepercent() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HardwareStatus::set_has_cpuidlepercent() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HardwareStatus::clear_has_cpuidlepercent() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HardwareStatus::clear_cpuidlepercent() {
  cpuidlepercent_ = 0;
  clear_has_cpuidlepercent();
}
inline float HardwareStatus::cpuidlepercent() const {
  return cpuidlepercent_;
}
inline void HardwareStatus::set_cpuidlepercent(float value) {
  set_has_cpuidlepercent();
  cpuidlepercent_ = value;
}

// optional float ramUsagePercent = 7;
inline bool HardwareStatus::has_ramusagepercent() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HardwareStatus::set_has_ramusagepercent() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HardwareStatus::clear_has_ramusagepercent() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HardwareStatus::clear_ramusagepercent() {
  ramusagepercent_ = 0;
  clear_has_ramusagepercent();
}
inline float HardwareStatus::ramusagepercent() const {
  return ramusagepercent_;
}
inline void HardwareStatus::set_ramusagepercent(float value) {
  set_has_ramusagepercent();
  ramusagepercent_ = value;
}

// optional bool online = 8;
inline bool HardwareStatus::has_online() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HardwareStatus::set_has_online() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HardwareStatus::clear_has_online() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HardwareStatus::clear_online() {
  online_ = false;
  clear_has_online();
}
inline bool HardwareStatus::online() const {
  return online_;
}
inline void HardwareStatus::set_online(bool value) {
  set_has_online();
  online_ = value;
}

// optional string deviceType = 9;
inline bool HardwareStatus::has_devicetype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HardwareStatus::set_has_devicetype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HardwareStatus::clear_has_devicetype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HardwareStatus::clear_devicetype() {
  if (devicetype_ != &::google::protobuf::internal::kEmptyString) {
    devicetype_->clear();
  }
  clear_has_devicetype();
}
inline const ::std::string& HardwareStatus::devicetype() const {
  return *devicetype_;
}
inline void HardwareStatus::set_devicetype(const ::std::string& value) {
  set_has_devicetype();
  if (devicetype_ == &::google::protobuf::internal::kEmptyString) {
    devicetype_ = new ::std::string;
  }
  devicetype_->assign(value);
}
inline void HardwareStatus::set_devicetype(const char* value) {
  set_has_devicetype();
  if (devicetype_ == &::google::protobuf::internal::kEmptyString) {
    devicetype_ = new ::std::string;
  }
  devicetype_->assign(value);
}
inline void HardwareStatus::set_devicetype(const char* value, size_t size) {
  set_has_devicetype();
  if (devicetype_ == &::google::protobuf::internal::kEmptyString) {
    devicetype_ = new ::std::string;
  }
  devicetype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HardwareStatus::mutable_devicetype() {
  set_has_devicetype();
  if (devicetype_ == &::google::protobuf::internal::kEmptyString) {
    devicetype_ = new ::std::string;
  }
  return devicetype_;
}
inline ::std::string* HardwareStatus::release_devicetype() {
  clear_has_devicetype();
  if (devicetype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicetype_;
    devicetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HardwareStatus::set_allocated_devicetype(::std::string* devicetype) {
  if (devicetype_ != &::google::protobuf::internal::kEmptyString) {
    delete devicetype_;
  }
  if (devicetype) {
    set_has_devicetype();
    devicetype_ = devicetype;
  } else {
    clear_has_devicetype();
    devicetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SensorStatus

// optional string msgName = 1 [default = "SENSOR_STATUS"];
inline bool SensorStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SensorStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SensorStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SensorStatus::msgname() const {
  return *msgname_;
}
inline void SensorStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SensorStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SensorStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SensorStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SensorStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SensorStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional .falcon_remoting_msg.SensorHealth sensor_health = 2;
inline bool SensorStatus::has_sensor_health() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorStatus::set_has_sensor_health() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SensorStatus::clear_has_sensor_health() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SensorStatus::clear_sensor_health() {
  if (sensor_health_ != NULL) sensor_health_->::falcon_remoting_msg::SensorHealth::Clear();
  clear_has_sensor_health();
}
inline const ::falcon_remoting_msg::SensorHealth& SensorStatus::sensor_health() const {
  return sensor_health_ != NULL ? *sensor_health_ : *default_instance_->sensor_health_;
}
inline ::falcon_remoting_msg::SensorHealth* SensorStatus::mutable_sensor_health() {
  set_has_sensor_health();
  if (sensor_health_ == NULL) sensor_health_ = new ::falcon_remoting_msg::SensorHealth;
  return sensor_health_;
}
inline ::falcon_remoting_msg::SensorHealth* SensorStatus::release_sensor_health() {
  clear_has_sensor_health();
  ::falcon_remoting_msg::SensorHealth* temp = sensor_health_;
  sensor_health_ = NULL;
  return temp;
}
inline void SensorStatus::set_allocated_sensor_health(::falcon_remoting_msg::SensorHealth* sensor_health) {
  delete sensor_health_;
  sensor_health_ = sensor_health;
  if (sensor_health) {
    set_has_sensor_health();
  } else {
    clear_has_sensor_health();
  }
}

// repeated .falcon_remoting_msg.ReceiverStatus rx_status = 3;
inline int SensorStatus::rx_status_size() const {
  return rx_status_.size();
}
inline void SensorStatus::clear_rx_status() {
  rx_status_.Clear();
}
inline const ::falcon_remoting_msg::ReceiverStatus& SensorStatus::rx_status(int index) const {
  return rx_status_.Get(index);
}
inline ::falcon_remoting_msg::ReceiverStatus* SensorStatus::mutable_rx_status(int index) {
  return rx_status_.Mutable(index);
}
inline ::falcon_remoting_msg::ReceiverStatus* SensorStatus::add_rx_status() {
  return rx_status_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::falcon_remoting_msg::ReceiverStatus >&
SensorStatus::rx_status() const {
  return rx_status_;
}
inline ::google::protobuf::RepeatedPtrField< ::falcon_remoting_msg::ReceiverStatus >*
SensorStatus::mutable_rx_status() {
  return &rx_status_;
}

// optional .falcon_remoting_msg.SensorPosition sensor_position = 4;
inline bool SensorStatus::has_sensor_position() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SensorStatus::set_has_sensor_position() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SensorStatus::clear_has_sensor_position() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SensorStatus::clear_sensor_position() {
  if (sensor_position_ != NULL) sensor_position_->::falcon_remoting_msg::SensorPosition::Clear();
  clear_has_sensor_position();
}
inline const ::falcon_remoting_msg::SensorPosition& SensorStatus::sensor_position() const {
  return sensor_position_ != NULL ? *sensor_position_ : *default_instance_->sensor_position_;
}
inline ::falcon_remoting_msg::SensorPosition* SensorStatus::mutable_sensor_position() {
  set_has_sensor_position();
  if (sensor_position_ == NULL) sensor_position_ = new ::falcon_remoting_msg::SensorPosition;
  return sensor_position_;
}
inline ::falcon_remoting_msg::SensorPosition* SensorStatus::release_sensor_position() {
  clear_has_sensor_position();
  ::falcon_remoting_msg::SensorPosition* temp = sensor_position_;
  sensor_position_ = NULL;
  return temp;
}
inline void SensorStatus::set_allocated_sensor_position(::falcon_remoting_msg::SensorPosition* sensor_position) {
  delete sensor_position_;
  sensor_position_ = sensor_position;
  if (sensor_position) {
    set_has_sensor_position();
  } else {
    clear_has_sensor_position();
  }
}

// -------------------------------------------------------------------

// OrientationStatus

// optional string msgName = 1 [default = "ORIENTATION_STATUS"];
inline bool OrientationStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrientationStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrientationStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrientationStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& OrientationStatus::msgname() const {
  return *msgname_;
}
inline void OrientationStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void OrientationStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void OrientationStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrientationStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* OrientationStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void OrientationStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional float yaw = 2;
inline bool OrientationStatus::has_yaw() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrientationStatus::set_has_yaw() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrientationStatus::clear_has_yaw() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrientationStatus::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
inline float OrientationStatus::yaw() const {
  return yaw_;
}
inline void OrientationStatus::set_yaw(float value) {
  set_has_yaw();
  yaw_ = value;
}

// optional float roll = 3;
inline bool OrientationStatus::has_roll() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrientationStatus::set_has_roll() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrientationStatus::clear_has_roll() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrientationStatus::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline float OrientationStatus::roll() const {
  return roll_;
}
inline void OrientationStatus::set_roll(float value) {
  set_has_roll();
  roll_ = value;
}

// optional float pitch = 4;
inline bool OrientationStatus::has_pitch() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OrientationStatus::set_has_pitch() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OrientationStatus::clear_has_pitch() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OrientationStatus::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
inline float OrientationStatus::pitch() const {
  return pitch_;
}
inline void OrientationStatus::set_pitch(float value) {
  set_has_pitch();
  pitch_ = value;
}

// optional float heading = 5;
inline bool OrientationStatus::has_heading() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OrientationStatus::set_has_heading() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OrientationStatus::clear_has_heading() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OrientationStatus::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline float OrientationStatus::heading() const {
  return heading_;
}
inline void OrientationStatus::set_heading(float value) {
  set_has_heading();
  heading_ = value;
}

// optional float speed = 6;
inline bool OrientationStatus::has_speed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OrientationStatus::set_has_speed() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OrientationStatus::clear_has_speed() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OrientationStatus::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline float OrientationStatus::speed() const {
  return speed_;
}
inline void OrientationStatus::set_speed(float value) {
  set_has_speed();
  speed_ = value;
}

// -------------------------------------------------------------------

// ReceiverStatus

// optional string msgName = 1 [default = "RECEIVER_STATUS"];
inline bool ReceiverStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReceiverStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReceiverStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReceiverStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ReceiverStatus::msgname() const {
  return *msgname_;
}
inline void ReceiverStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ReceiverStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ReceiverStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiverStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ReceiverStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ReceiverStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 idNum = 2;
inline bool ReceiverStatus::has_idnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReceiverStatus::set_has_idnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReceiverStatus::clear_has_idnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReceiverStatus::clear_idnum() {
  idnum_ = 0;
  clear_has_idnum();
}
inline ::google::protobuf::int32 ReceiverStatus::idnum() const {
  return idnum_;
}
inline void ReceiverStatus::set_idnum(::google::protobuf::int32 value) {
  set_has_idnum();
  idnum_ = value;
}

// optional string name = 3;
inline bool ReceiverStatus::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReceiverStatus::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReceiverStatus::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReceiverStatus::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ReceiverStatus::name() const {
  return *name_;
}
inline void ReceiverStatus::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ReceiverStatus::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ReceiverStatus::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiverStatus::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ReceiverStatus::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReceiverStatus::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string type = 4;
inline bool ReceiverStatus::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReceiverStatus::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReceiverStatus::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReceiverStatus::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& ReceiverStatus::type() const {
  return *type_;
}
inline void ReceiverStatus::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void ReceiverStatus::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void ReceiverStatus::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiverStatus::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* ReceiverStatus::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReceiverStatus::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float rxFreq = 5;
inline bool ReceiverStatus::has_rxfreq() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReceiverStatus::set_has_rxfreq() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReceiverStatus::clear_has_rxfreq() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReceiverStatus::clear_rxfreq() {
  rxfreq_ = 0;
  clear_has_rxfreq();
}
inline float ReceiverStatus::rxfreq() const {
  return rxfreq_;
}
inline void ReceiverStatus::set_rxfreq(float value) {
  set_has_rxfreq();
  rxfreq_ = value;
}

// optional float rxBandwidth = 6;
inline bool ReceiverStatus::has_rxbandwidth() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReceiverStatus::set_has_rxbandwidth() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReceiverStatus::clear_has_rxbandwidth() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReceiverStatus::clear_rxbandwidth() {
  rxbandwidth_ = 0;
  clear_has_rxbandwidth();
}
inline float ReceiverStatus::rxbandwidth() const {
  return rxbandwidth_;
}
inline void ReceiverStatus::set_rxbandwidth(float value) {
  set_has_rxbandwidth();
  rxbandwidth_ = value;
}

// optional int32 gain = 7;
inline bool ReceiverStatus::has_gain() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReceiverStatus::set_has_gain() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReceiverStatus::clear_has_gain() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReceiverStatus::clear_gain() {
  gain_ = 0;
  clear_has_gain();
}
inline ::google::protobuf::int32 ReceiverStatus::gain() const {
  return gain_;
}
inline void ReceiverStatus::set_gain(::google::protobuf::int32 value) {
  set_has_gain();
  gain_ = value;
}

// optional .falcon_remoting_msg.ReceiverStatus.GainMode gainMode = 8;
inline bool ReceiverStatus::has_gainmode() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ReceiverStatus::set_has_gainmode() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ReceiverStatus::clear_has_gainmode() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ReceiverStatus::clear_gainmode() {
  gainmode_ = 0;
  clear_has_gainmode();
}
inline ::falcon_remoting_msg::ReceiverStatus_GainMode ReceiverStatus::gainmode() const {
  return static_cast< ::falcon_remoting_msg::ReceiverStatus_GainMode >(gainmode_);
}
inline void ReceiverStatus::set_gainmode(::falcon_remoting_msg::ReceiverStatus_GainMode value) {
  assert(::falcon_remoting_msg::ReceiverStatus_GainMode_IsValid(value));
  set_has_gainmode();
  gainmode_ = value;
}

// -------------------------------------------------------------------

// FieldofView

// optional float boreSite = 1;
inline bool FieldofView::has_boresite() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FieldofView::set_has_boresite() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FieldofView::clear_has_boresite() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FieldofView::clear_boresite() {
  boresite_ = 0;
  clear_has_boresite();
}
inline float FieldofView::boresite() const {
  return boresite_;
}
inline void FieldofView::set_boresite(float value) {
  set_has_boresite();
  boresite_ = value;
}

// optional float azimuth = 2;
inline bool FieldofView::has_azimuth() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FieldofView::set_has_azimuth() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FieldofView::clear_has_azimuth() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FieldofView::clear_azimuth() {
  azimuth_ = 0;
  clear_has_azimuth();
}
inline float FieldofView::azimuth() const {
  return azimuth_;
}
inline void FieldofView::set_azimuth(float value) {
  set_has_azimuth();
  azimuth_ = value;
}

// optional float elevation = 3;
inline bool FieldofView::has_elevation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FieldofView::set_has_elevation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FieldofView::clear_has_elevation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FieldofView::clear_elevation() {
  elevation_ = 0;
  clear_has_elevation();
}
inline float FieldofView::elevation() const {
  return elevation_;
}
inline void FieldofView::set_elevation(float value) {
  set_has_elevation();
  elevation_ = value;
}

// optional float beamWidth = 4;
inline bool FieldofView::has_beamwidth() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FieldofView::set_has_beamwidth() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FieldofView::clear_has_beamwidth() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FieldofView::clear_beamwidth() {
  beamwidth_ = 0;
  clear_has_beamwidth();
}
inline float FieldofView::beamwidth() const {
  return beamwidth_;
}
inline void FieldofView::set_beamwidth(float value) {
  set_has_beamwidth();
  beamwidth_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace falcon_remoting_msg

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_remoting_msg::StatusReport_LogLevel>() {
  return ::falcon_remoting_msg::StatusReport_LogLevel_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_remoting_msg::StatusChannel_Status>() {
  return ::falcon_remoting_msg::StatusChannel_Status_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_remoting_msg::HealthMessage_Code>() {
  return ::falcon_remoting_msg::HealthMessage_Code_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_remoting_msg::HealthTest_Status>() {
  return ::falcon_remoting_msg::HealthTest_Status_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_remoting_msg::SignalEvent_Type>() {
  return ::falcon_remoting_msg::SignalEvent_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_remoting_msg::SetAtten_AutoAtten>() {
  return ::falcon_remoting_msg::SetAtten_AutoAtten_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_remoting_msg::SearchControl_Action>() {
  return ::falcon_remoting_msg::SearchControl_Action_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_remoting_msg::PredRecord_Action>() {
  return ::falcon_remoting_msg::PredRecord_Action_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_remoting_msg::VideoControl_Record>() {
  return ::falcon_remoting_msg::VideoControl_Record_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_remoting_msg::VideoControl_Sync>() {
  return ::falcon_remoting_msg::VideoControl_Sync_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_remoting_msg::VideoControl_Mode>() {
  return ::falcon_remoting_msg::VideoControl_Mode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_remoting_msg::FhopSettings_FreqHopMode>() {
  return ::falcon_remoting_msg::FhopSettings_FreqHopMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_remoting_msg::AntennaScanStatus_ScanStatus>() {
  return ::falcon_remoting_msg::AntennaScanStatus_ScanStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_remoting_msg::AntennaScanStatus_TrackStatus>() {
  return ::falcon_remoting_msg::AntennaScanStatus_TrackStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_remoting_msg::MidasAppStatus_SearchSetting>() {
  return ::falcon_remoting_msg::MidasAppStatus_SearchSetting_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_remoting_msg::RxStatus_Status>() {
  return ::falcon_remoting_msg::RxStatus_Status_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_remoting_msg::RecordingStatus_Status>() {
  return ::falcon_remoting_msg::RecordingStatus_Status_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_remoting_msg::DetectionStatus_Color>() {
  return ::falcon_remoting_msg::DetectionStatus_Color_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_remoting_msg::SearchStatus_Color>() {
  return ::falcon_remoting_msg::SearchStatus_Color_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_remoting_msg::VideoStatus_RecStatus>() {
  return ::falcon_remoting_msg::VideoStatus_RecStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_remoting_msg::VideoStatus_SyncStatus>() {
  return ::falcon_remoting_msg::VideoStatus_SyncStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_remoting_msg::VideoStatus_JpegMode>() {
  return ::falcon_remoting_msg::VideoStatus_JpegMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_remoting_msg::FreqHopStatus_Mode>() {
  return ::falcon_remoting_msg::FreqHopStatus_Mode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_remoting_msg::ReceiverStatus_GainMode>() {
  return ::falcon_remoting_msg::ReceiverStatus_GainMode_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_FalconRemotingMessages_2eproto__INCLUDED
