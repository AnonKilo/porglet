// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FalconReceiverMessages.proto

#ifndef PROTOBUF_FalconReceiverMessages_2eproto__INCLUDED
#define PROTOBUF_FalconReceiverMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace falcon_receiver_msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_FalconReceiverMessages_2eproto();
void protobuf_AssignDesc_FalconReceiverMessages_2eproto();
void protobuf_ShutdownFile_FalconReceiverMessages_2eproto();

class ReceiverRequest;
class ReceiverResponse;
class UniqueRXIDRequest;
class UniqueRXIDResponse;
class ReceiverInfoRequest;
class ReceiverInfoResponse;
class ReceiverHealthTest;
class ReceiverHealthResponse;
class MMSStat;

enum ReceiverRequest_Action {
  ReceiverRequest_Action_SET = 0,
  ReceiverRequest_Action_GET = 1
};
bool ReceiverRequest_Action_IsValid(int value);
const ReceiverRequest_Action ReceiverRequest_Action_Action_MIN = ReceiverRequest_Action_SET;
const ReceiverRequest_Action ReceiverRequest_Action_Action_MAX = ReceiverRequest_Action_GET;
const int ReceiverRequest_Action_Action_ARRAYSIZE = ReceiverRequest_Action_Action_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReceiverRequest_Action_descriptor();
inline const ::std::string& ReceiverRequest_Action_Name(ReceiverRequest_Action value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReceiverRequest_Action_descriptor(), value);
}
inline bool ReceiverRequest_Action_Parse(
    const ::std::string& name, ReceiverRequest_Action* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReceiverRequest_Action>(
    ReceiverRequest_Action_descriptor(), name, value);
}
enum ReceiverRequest_Property {
  ReceiverRequest_Property_FREQUENCY = 0,
  ReceiverRequest_Property_BANDWIDTH = 1,
  ReceiverRequest_Property_GAIN = 2,
  ReceiverRequest_Property_REF = 3
};
bool ReceiverRequest_Property_IsValid(int value);
const ReceiverRequest_Property ReceiverRequest_Property_Property_MIN = ReceiverRequest_Property_FREQUENCY;
const ReceiverRequest_Property ReceiverRequest_Property_Property_MAX = ReceiverRequest_Property_REF;
const int ReceiverRequest_Property_Property_ARRAYSIZE = ReceiverRequest_Property_Property_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReceiverRequest_Property_descriptor();
inline const ::std::string& ReceiverRequest_Property_Name(ReceiverRequest_Property value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReceiverRequest_Property_descriptor(), value);
}
inline bool ReceiverRequest_Property_Parse(
    const ::std::string& name, ReceiverRequest_Property* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReceiverRequest_Property>(
    ReceiverRequest_Property_descriptor(), name, value);
}
enum ReceiverResponse_Status {
  ReceiverResponse_Status_SUCCESS = 0,
  ReceiverResponse_Status_FAIL = 1,
  ReceiverResponse_Status_DISCONNECTED = 2,
  ReceiverResponse_Status_PERMISSIONS = 3
};
bool ReceiverResponse_Status_IsValid(int value);
const ReceiverResponse_Status ReceiverResponse_Status_Status_MIN = ReceiverResponse_Status_SUCCESS;
const ReceiverResponse_Status ReceiverResponse_Status_Status_MAX = ReceiverResponse_Status_PERMISSIONS;
const int ReceiverResponse_Status_Status_ARRAYSIZE = ReceiverResponse_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReceiverResponse_Status_descriptor();
inline const ::std::string& ReceiverResponse_Status_Name(ReceiverResponse_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReceiverResponse_Status_descriptor(), value);
}
inline bool ReceiverResponse_Status_Parse(
    const ::std::string& name, ReceiverResponse_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReceiverResponse_Status>(
    ReceiverResponse_Status_descriptor(), name, value);
}
enum UniqueRXIDRequest_Action {
  UniqueRXIDRequest_Action_SET = 0,
  UniqueRXIDRequest_Action_GET = 1
};
bool UniqueRXIDRequest_Action_IsValid(int value);
const UniqueRXIDRequest_Action UniqueRXIDRequest_Action_Action_MIN = UniqueRXIDRequest_Action_SET;
const UniqueRXIDRequest_Action UniqueRXIDRequest_Action_Action_MAX = UniqueRXIDRequest_Action_GET;
const int UniqueRXIDRequest_Action_Action_ARRAYSIZE = UniqueRXIDRequest_Action_Action_MAX + 1;

const ::google::protobuf::EnumDescriptor* UniqueRXIDRequest_Action_descriptor();
inline const ::std::string& UniqueRXIDRequest_Action_Name(UniqueRXIDRequest_Action value) {
  return ::google::protobuf::internal::NameOfEnum(
    UniqueRXIDRequest_Action_descriptor(), value);
}
inline bool UniqueRXIDRequest_Action_Parse(
    const ::std::string& name, UniqueRXIDRequest_Action* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UniqueRXIDRequest_Action>(
    UniqueRXIDRequest_Action_descriptor(), name, value);
}
// ===================================================================

class ReceiverRequest : public ::google::protobuf::Message {
 public:
  ReceiverRequest();
  virtual ~ReceiverRequest();

  ReceiverRequest(const ReceiverRequest& from);

  inline ReceiverRequest& operator=(const ReceiverRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiverRequest& default_instance();

  void Swap(ReceiverRequest* other);

  // implements Message ----------------------------------------------

  ReceiverRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReceiverRequest& from);
  void MergeFrom(const ReceiverRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ReceiverRequest_Action Action;
  static const Action SET = ReceiverRequest_Action_SET;
  static const Action GET = ReceiverRequest_Action_GET;
  static inline bool Action_IsValid(int value) {
    return ReceiverRequest_Action_IsValid(value);
  }
  static const Action Action_MIN =
    ReceiverRequest_Action_Action_MIN;
  static const Action Action_MAX =
    ReceiverRequest_Action_Action_MAX;
  static const int Action_ARRAYSIZE =
    ReceiverRequest_Action_Action_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Action_descriptor() {
    return ReceiverRequest_Action_descriptor();
  }
  static inline const ::std::string& Action_Name(Action value) {
    return ReceiverRequest_Action_Name(value);
  }
  static inline bool Action_Parse(const ::std::string& name,
      Action* value) {
    return ReceiverRequest_Action_Parse(name, value);
  }

  typedef ReceiverRequest_Property Property;
  static const Property FREQUENCY = ReceiverRequest_Property_FREQUENCY;
  static const Property BANDWIDTH = ReceiverRequest_Property_BANDWIDTH;
  static const Property GAIN = ReceiverRequest_Property_GAIN;
  static const Property REF = ReceiverRequest_Property_REF;
  static inline bool Property_IsValid(int value) {
    return ReceiverRequest_Property_IsValid(value);
  }
  static const Property Property_MIN =
    ReceiverRequest_Property_Property_MIN;
  static const Property Property_MAX =
    ReceiverRequest_Property_Property_MAX;
  static const int Property_ARRAYSIZE =
    ReceiverRequest_Property_Property_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Property_descriptor() {
    return ReceiverRequest_Property_descriptor();
  }
  static inline const ::std::string& Property_Name(Property value) {
    return ReceiverRequest_Property_Name(value);
  }
  static inline bool Property_Parse(const ::std::string& name,
      Property* value) {
    return ReceiverRequest_Property_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "RECEIVER_REQUEST"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string resID = 2;
  inline bool has_resid() const;
  inline void clear_resid();
  static const int kResIDFieldNumber = 2;
  inline const ::std::string& resid() const;
  inline void set_resid(const ::std::string& value);
  inline void set_resid(const char* value);
  inline void set_resid(const char* value, size_t size);
  inline ::std::string* mutable_resid();
  inline ::std::string* release_resid();
  inline void set_allocated_resid(::std::string* resid);

  // optional int32 appID = 3;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 3;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional .falcon_receiver_msg.ReceiverRequest.Action action = 4;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 4;
  inline ::falcon_receiver_msg::ReceiverRequest_Action action() const;
  inline void set_action(::falcon_receiver_msg::ReceiverRequest_Action value);

  // optional .falcon_receiver_msg.ReceiverRequest.Property property = 5;
  inline bool has_property() const;
  inline void clear_property();
  static const int kPropertyFieldNumber = 5;
  inline ::falcon_receiver_msg::ReceiverRequest_Property property() const;
  inline void set_property(::falcon_receiver_msg::ReceiverRequest_Property value);

  // optional float value = 6;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 6;
  inline float value() const;
  inline void set_value(float value);

  // @@protoc_insertion_point(class_scope:falcon_receiver_msg.ReceiverRequest)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_resid();
  inline void clear_has_resid();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_property();
  inline void clear_has_property();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* resid_;
  ::google::protobuf::int32 appid_;
  int action_;
  int property_;
  float value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_FalconReceiverMessages_2eproto();
  friend void protobuf_AssignDesc_FalconReceiverMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconReceiverMessages_2eproto();

  void InitAsDefaultInstance();
  static ReceiverRequest* default_instance_;
};
// -------------------------------------------------------------------

class ReceiverResponse : public ::google::protobuf::Message {
 public:
  ReceiverResponse();
  virtual ~ReceiverResponse();

  ReceiverResponse(const ReceiverResponse& from);

  inline ReceiverResponse& operator=(const ReceiverResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiverResponse& default_instance();

  void Swap(ReceiverResponse* other);

  // implements Message ----------------------------------------------

  ReceiverResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReceiverResponse& from);
  void MergeFrom(const ReceiverResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ReceiverResponse_Status Status;
  static const Status SUCCESS = ReceiverResponse_Status_SUCCESS;
  static const Status FAIL = ReceiverResponse_Status_FAIL;
  static const Status DISCONNECTED = ReceiverResponse_Status_DISCONNECTED;
  static const Status PERMISSIONS = ReceiverResponse_Status_PERMISSIONS;
  static inline bool Status_IsValid(int value) {
    return ReceiverResponse_Status_IsValid(value);
  }
  static const Status Status_MIN =
    ReceiverResponse_Status_Status_MIN;
  static const Status Status_MAX =
    ReceiverResponse_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    ReceiverResponse_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return ReceiverResponse_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return ReceiverResponse_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return ReceiverResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "RECEIVER_RESPONSE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string resID = 2;
  inline bool has_resid() const;
  inline void clear_resid();
  static const int kResIDFieldNumber = 2;
  inline const ::std::string& resid() const;
  inline void set_resid(const ::std::string& value);
  inline void set_resid(const char* value);
  inline void set_resid(const char* value, size_t size);
  inline ::std::string* mutable_resid();
  inline ::std::string* release_resid();
  inline void set_allocated_resid(::std::string* resid);

  // optional int32 appID = 3;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 3;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional .falcon_receiver_msg.ReceiverResponse.Status status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline ::falcon_receiver_msg::ReceiverResponse_Status status() const;
  inline void set_status(::falcon_receiver_msg::ReceiverResponse_Status value);

  // optional .falcon_receiver_msg.ReceiverRequest.Property property = 5;
  inline bool has_property() const;
  inline void clear_property();
  static const int kPropertyFieldNumber = 5;
  inline ::falcon_receiver_msg::ReceiverRequest_Property property() const;
  inline void set_property(::falcon_receiver_msg::ReceiverRequest_Property value);

  // optional float value = 6;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 6;
  inline float value() const;
  inline void set_value(float value);

  // @@protoc_insertion_point(class_scope:falcon_receiver_msg.ReceiverResponse)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_resid();
  inline void clear_has_resid();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_property();
  inline void clear_has_property();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* resid_;
  ::google::protobuf::int32 appid_;
  int status_;
  int property_;
  float value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_FalconReceiverMessages_2eproto();
  friend void protobuf_AssignDesc_FalconReceiverMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconReceiverMessages_2eproto();

  void InitAsDefaultInstance();
  static ReceiverResponse* default_instance_;
};
// -------------------------------------------------------------------

class UniqueRXIDRequest : public ::google::protobuf::Message {
 public:
  UniqueRXIDRequest();
  virtual ~UniqueRXIDRequest();

  UniqueRXIDRequest(const UniqueRXIDRequest& from);

  inline UniqueRXIDRequest& operator=(const UniqueRXIDRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UniqueRXIDRequest& default_instance();

  void Swap(UniqueRXIDRequest* other);

  // implements Message ----------------------------------------------

  UniqueRXIDRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UniqueRXIDRequest& from);
  void MergeFrom(const UniqueRXIDRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef UniqueRXIDRequest_Action Action;
  static const Action SET = UniqueRXIDRequest_Action_SET;
  static const Action GET = UniqueRXIDRequest_Action_GET;
  static inline bool Action_IsValid(int value) {
    return UniqueRXIDRequest_Action_IsValid(value);
  }
  static const Action Action_MIN =
    UniqueRXIDRequest_Action_Action_MIN;
  static const Action Action_MAX =
    UniqueRXIDRequest_Action_Action_MAX;
  static const int Action_ARRAYSIZE =
    UniqueRXIDRequest_Action_Action_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Action_descriptor() {
    return UniqueRXIDRequest_Action_descriptor();
  }
  static inline const ::std::string& Action_Name(Action value) {
    return UniqueRXIDRequest_Action_Name(value);
  }
  static inline bool Action_Parse(const ::std::string& name,
      Action* value) {
    return UniqueRXIDRequest_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "UNIQUE_RXID_REQUEST"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string resID = 2;
  inline bool has_resid() const;
  inline void clear_resid();
  static const int kResIDFieldNumber = 2;
  inline const ::std::string& resid() const;
  inline void set_resid(const ::std::string& value);
  inline void set_resid(const char* value);
  inline void set_resid(const char* value, size_t size);
  inline ::std::string* mutable_resid();
  inline ::std::string* release_resid();
  inline void set_allocated_resid(::std::string* resid);

  // optional .falcon_receiver_msg.UniqueRXIDRequest.Action action = 3 [default = GET];
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 3;
  inline ::falcon_receiver_msg::UniqueRXIDRequest_Action action() const;
  inline void set_action(::falcon_receiver_msg::UniqueRXIDRequest_Action value);

  // optional string value = 4;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 4;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:falcon_receiver_msg.UniqueRXIDRequest)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_resid();
  inline void clear_has_resid();
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* resid_;
  ::std::string* value_;
  int action_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_FalconReceiverMessages_2eproto();
  friend void protobuf_AssignDesc_FalconReceiverMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconReceiverMessages_2eproto();

  void InitAsDefaultInstance();
  static UniqueRXIDRequest* default_instance_;
};
// -------------------------------------------------------------------

class UniqueRXIDResponse : public ::google::protobuf::Message {
 public:
  UniqueRXIDResponse();
  virtual ~UniqueRXIDResponse();

  UniqueRXIDResponse(const UniqueRXIDResponse& from);

  inline UniqueRXIDResponse& operator=(const UniqueRXIDResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UniqueRXIDResponse& default_instance();

  void Swap(UniqueRXIDResponse* other);

  // implements Message ----------------------------------------------

  UniqueRXIDResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UniqueRXIDResponse& from);
  void MergeFrom(const UniqueRXIDResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "UNIQUE_RXID_RESPONSE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string resID = 2;
  inline bool has_resid() const;
  inline void clear_resid();
  static const int kResIDFieldNumber = 2;
  inline const ::std::string& resid() const;
  inline void set_resid(const ::std::string& value);
  inline void set_resid(const char* value);
  inline void set_resid(const char* value, size_t size);
  inline ::std::string* mutable_resid();
  inline ::std::string* release_resid();
  inline void set_allocated_resid(::std::string* resid);

  // optional string value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:falcon_receiver_msg.UniqueRXIDResponse)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_resid();
  inline void clear_has_resid();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* resid_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconReceiverMessages_2eproto();
  friend void protobuf_AssignDesc_FalconReceiverMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconReceiverMessages_2eproto();

  void InitAsDefaultInstance();
  static UniqueRXIDResponse* default_instance_;
};
// -------------------------------------------------------------------

class ReceiverInfoRequest : public ::google::protobuf::Message {
 public:
  ReceiverInfoRequest();
  virtual ~ReceiverInfoRequest();

  ReceiverInfoRequest(const ReceiverInfoRequest& from);

  inline ReceiverInfoRequest& operator=(const ReceiverInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiverInfoRequest& default_instance();

  void Swap(ReceiverInfoRequest* other);

  // implements Message ----------------------------------------------

  ReceiverInfoRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReceiverInfoRequest& from);
  void MergeFrom(const ReceiverInfoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "RECEIVER_INFO_REQUEST"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // @@protoc_insertion_point(class_scope:falcon_receiver_msg.ReceiverInfoRequest)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_FalconReceiverMessages_2eproto();
  friend void protobuf_AssignDesc_FalconReceiverMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconReceiverMessages_2eproto();

  void InitAsDefaultInstance();
  static ReceiverInfoRequest* default_instance_;
};
// -------------------------------------------------------------------

class ReceiverInfoResponse : public ::google::protobuf::Message {
 public:
  ReceiverInfoResponse();
  virtual ~ReceiverInfoResponse();

  ReceiverInfoResponse(const ReceiverInfoResponse& from);

  inline ReceiverInfoResponse& operator=(const ReceiverInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiverInfoResponse& default_instance();

  void Swap(ReceiverInfoResponse* other);

  // implements Message ----------------------------------------------

  ReceiverInfoResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReceiverInfoResponse& from);
  void MergeFrom(const ReceiverInfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "RECEIVER_INFO_RESPONSE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string resID = 2;
  inline bool has_resid() const;
  inline void clear_resid();
  static const int kResIDFieldNumber = 2;
  inline const ::std::string& resid() const;
  inline void set_resid(const ::std::string& value);
  inline void set_resid(const char* value);
  inline void set_resid(const char* value, size_t size);
  inline ::std::string* mutable_resid();
  inline ::std::string* release_resid();
  inline void set_allocated_resid(::std::string* resid);

  // optional string ntp = 3;
  inline bool has_ntp() const;
  inline void clear_ntp();
  static const int kNtpFieldNumber = 3;
  inline const ::std::string& ntp() const;
  inline void set_ntp(const ::std::string& value);
  inline void set_ntp(const char* value);
  inline void set_ntp(const char* value, size_t size);
  inline ::std::string* mutable_ntp();
  inline ::std::string* release_ntp();
  inline void set_allocated_ntp(::std::string* ntp);

  // optional string ref = 4;
  inline bool has_ref() const;
  inline void clear_ref();
  static const int kRefFieldNumber = 4;
  inline const ::std::string& ref() const;
  inline void set_ref(const ::std::string& value);
  inline void set_ref(const char* value);
  inline void set_ref(const char* value, size_t size);
  inline ::std::string* mutable_ref();
  inline ::std::string* release_ref();
  inline void set_allocated_ref(::std::string* ref);

  // optional string pps = 5;
  inline bool has_pps() const;
  inline void clear_pps();
  static const int kPpsFieldNumber = 5;
  inline const ::std::string& pps() const;
  inline void set_pps(const ::std::string& value);
  inline void set_pps(const char* value);
  inline void set_pps(const char* value, size_t size);
  inline ::std::string* mutable_pps();
  inline ::std::string* release_pps();
  inline void set_allocated_pps(::std::string* pps);

  // optional string comms = 6;
  inline bool has_comms() const;
  inline void clear_comms();
  static const int kCommsFieldNumber = 6;
  inline const ::std::string& comms() const;
  inline void set_comms(const ::std::string& value);
  inline void set_comms(const char* value);
  inline void set_comms(const char* value, size_t size);
  inline ::std::string* mutable_comms();
  inline ::std::string* release_comms();
  inline void set_allocated_comms(::std::string* comms);

  // optional string ping = 7;
  inline bool has_ping() const;
  inline void clear_ping();
  static const int kPingFieldNumber = 7;
  inline const ::std::string& ping() const;
  inline void set_ping(const ::std::string& value);
  inline void set_ping(const char* value);
  inline void set_ping(const char* value, size_t size);
  inline ::std::string* mutable_ping();
  inline ::std::string* release_ping();
  inline void set_allocated_ping(::std::string* ping);

  // optional string raid = 8;
  inline bool has_raid() const;
  inline void clear_raid();
  static const int kRaidFieldNumber = 8;
  inline const ::std::string& raid() const;
  inline void set_raid(const ::std::string& value);
  inline void set_raid(const char* value);
  inline void set_raid(const char* value, size_t size);
  inline ::std::string* mutable_raid();
  inline ::std::string* release_raid();
  inline void set_allocated_raid(::std::string* raid);

  // @@protoc_insertion_point(class_scope:falcon_receiver_msg.ReceiverInfoResponse)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_resid();
  inline void clear_has_resid();
  inline void set_has_ntp();
  inline void clear_has_ntp();
  inline void set_has_ref();
  inline void clear_has_ref();
  inline void set_has_pps();
  inline void clear_has_pps();
  inline void set_has_comms();
  inline void clear_has_comms();
  inline void set_has_ping();
  inline void clear_has_ping();
  inline void set_has_raid();
  inline void clear_has_raid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* resid_;
  ::std::string* ntp_;
  ::std::string* ref_;
  ::std::string* pps_;
  ::std::string* comms_;
  ::std::string* ping_;
  ::std::string* raid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_FalconReceiverMessages_2eproto();
  friend void protobuf_AssignDesc_FalconReceiverMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconReceiverMessages_2eproto();

  void InitAsDefaultInstance();
  static ReceiverInfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class ReceiverHealthTest : public ::google::protobuf::Message {
 public:
  ReceiverHealthTest();
  virtual ~ReceiverHealthTest();

  ReceiverHealthTest(const ReceiverHealthTest& from);

  inline ReceiverHealthTest& operator=(const ReceiverHealthTest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiverHealthTest& default_instance();

  void Swap(ReceiverHealthTest* other);

  // implements Message ----------------------------------------------

  ReceiverHealthTest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReceiverHealthTest& from);
  void MergeFrom(const ReceiverHealthTest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "RECEIVER_HEALTH_TEST"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 ntp = 2;
  inline bool has_ntp() const;
  inline void clear_ntp();
  static const int kNtpFieldNumber = 2;
  inline ::google::protobuf::int32 ntp() const;
  inline void set_ntp(::google::protobuf::int32 value);

  // optional int32 raid = 3;
  inline bool has_raid() const;
  inline void clear_raid();
  static const int kRaidFieldNumber = 3;
  inline ::google::protobuf::int32 raid() const;
  inline void set_raid(::google::protobuf::int32 value);

  // optional int32 singleraid = 4;
  inline bool has_singleraid() const;
  inline void clear_singleraid();
  static const int kSingleraidFieldNumber = 4;
  inline ::google::protobuf::int32 singleraid() const;
  inline void set_singleraid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_receiver_msg.ReceiverHealthTest)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_ntp();
  inline void clear_has_ntp();
  inline void set_has_raid();
  inline void clear_has_raid();
  inline void set_has_singleraid();
  inline void clear_has_singleraid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 ntp_;
  ::google::protobuf::int32 raid_;
  ::google::protobuf::int32 singleraid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_FalconReceiverMessages_2eproto();
  friend void protobuf_AssignDesc_FalconReceiverMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconReceiverMessages_2eproto();

  void InitAsDefaultInstance();
  static ReceiverHealthTest* default_instance_;
};
// -------------------------------------------------------------------

class ReceiverHealthResponse : public ::google::protobuf::Message {
 public:
  ReceiverHealthResponse();
  virtual ~ReceiverHealthResponse();

  ReceiverHealthResponse(const ReceiverHealthResponse& from);

  inline ReceiverHealthResponse& operator=(const ReceiverHealthResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiverHealthResponse& default_instance();

  void Swap(ReceiverHealthResponse* other);

  // implements Message ----------------------------------------------

  ReceiverHealthResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReceiverHealthResponse& from);
  void MergeFrom(const ReceiverHealthResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "RECEIVER_HEALTH_RESPONSE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string resID = 2;
  inline bool has_resid() const;
  inline void clear_resid();
  static const int kResIDFieldNumber = 2;
  inline const ::std::string& resid() const;
  inline void set_resid(const ::std::string& value);
  inline void set_resid(const char* value);
  inline void set_resid(const char* value, size_t size);
  inline ::std::string* mutable_resid();
  inline ::std::string* release_resid();
  inline void set_allocated_resid(::std::string* resid);

  // optional string ntp = 3 [default = "-"];
  inline bool has_ntp() const;
  inline void clear_ntp();
  static const int kNtpFieldNumber = 3;
  inline const ::std::string& ntp() const;
  inline void set_ntp(const ::std::string& value);
  inline void set_ntp(const char* value);
  inline void set_ntp(const char* value, size_t size);
  inline ::std::string* mutable_ntp();
  inline ::std::string* release_ntp();
  inline void set_allocated_ntp(::std::string* ntp);

  // optional string ref = 4 [default = "-"];
  inline bool has_ref() const;
  inline void clear_ref();
  static const int kRefFieldNumber = 4;
  inline const ::std::string& ref() const;
  inline void set_ref(const ::std::string& value);
  inline void set_ref(const char* value);
  inline void set_ref(const char* value, size_t size);
  inline ::std::string* mutable_ref();
  inline ::std::string* release_ref();
  inline void set_allocated_ref(::std::string* ref);

  // optional string pps = 5 [default = "-"];
  inline bool has_pps() const;
  inline void clear_pps();
  static const int kPpsFieldNumber = 5;
  inline const ::std::string& pps() const;
  inline void set_pps(const ::std::string& value);
  inline void set_pps(const char* value);
  inline void set_pps(const char* value, size_t size);
  inline ::std::string* mutable_pps();
  inline ::std::string* release_pps();
  inline void set_allocated_pps(::std::string* pps);

  // optional string rx = 6 [default = "-"];
  inline bool has_rx() const;
  inline void clear_rx();
  static const int kRxFieldNumber = 6;
  inline const ::std::string& rx() const;
  inline void set_rx(const ::std::string& value);
  inline void set_rx(const char* value);
  inline void set_rx(const char* value, size_t size);
  inline ::std::string* mutable_rx();
  inline ::std::string* release_rx();
  inline void set_allocated_rx(::std::string* rx);

  // optional string ping = 7 [default = "-"];
  inline bool has_ping() const;
  inline void clear_ping();
  static const int kPingFieldNumber = 7;
  inline const ::std::string& ping() const;
  inline void set_ping(const ::std::string& value);
  inline void set_ping(const char* value);
  inline void set_ping(const char* value, size_t size);
  inline ::std::string* mutable_ping();
  inline ::std::string* release_ping();
  inline void set_allocated_ping(::std::string* ping);

  // optional string raid = 8 [default = "-"];
  inline bool has_raid() const;
  inline void clear_raid();
  static const int kRaidFieldNumber = 8;
  inline const ::std::string& raid() const;
  inline void set_raid(const ::std::string& value);
  inline void set_raid(const char* value);
  inline void set_raid(const char* value, size_t size);
  inline ::std::string* mutable_raid();
  inline ::std::string* release_raid();
  inline void set_allocated_raid(::std::string* raid);

  // @@protoc_insertion_point(class_scope:falcon_receiver_msg.ReceiverHealthResponse)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_resid();
  inline void clear_has_resid();
  inline void set_has_ntp();
  inline void clear_has_ntp();
  inline void set_has_ref();
  inline void clear_has_ref();
  inline void set_has_pps();
  inline void clear_has_pps();
  inline void set_has_rx();
  inline void clear_has_rx();
  inline void set_has_ping();
  inline void clear_has_ping();
  inline void set_has_raid();
  inline void clear_has_raid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* resid_;
  ::std::string* ntp_;
  static ::std::string* _default_ntp_;
  ::std::string* ref_;
  static ::std::string* _default_ref_;
  ::std::string* pps_;
  static ::std::string* _default_pps_;
  ::std::string* rx_;
  static ::std::string* _default_rx_;
  ::std::string* ping_;
  static ::std::string* _default_ping_;
  ::std::string* raid_;
  static ::std::string* _default_raid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_FalconReceiverMessages_2eproto();
  friend void protobuf_AssignDesc_FalconReceiverMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconReceiverMessages_2eproto();

  void InitAsDefaultInstance();
  static ReceiverHealthResponse* default_instance_;
};
// -------------------------------------------------------------------

class MMSStat : public ::google::protobuf::Message {
 public:
  MMSStat();
  virtual ~MMSStat();

  MMSStat(const MMSStat& from);

  inline MMSStat& operator=(const MMSStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MMSStat& default_instance();

  void Swap(MMSStat* other);

  // implements Message ----------------------------------------------

  MMSStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MMSStat& from);
  void MergeFrom(const MMSStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "MMS_STAT"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string resID = 2;
  inline bool has_resid() const;
  inline void clear_resid();
  static const int kResIDFieldNumber = 2;
  inline const ::std::string& resid() const;
  inline void set_resid(const ::std::string& value);
  inline void set_resid(const char* value);
  inline void set_resid(const char* value, size_t size);
  inline ::std::string* mutable_resid();
  inline ::std::string* release_resid();
  inline void set_allocated_resid(::std::string* resid);

  // optional int32 id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string sn = 4;
  inline bool has_sn() const;
  inline void clear_sn();
  static const int kSnFieldNumber = 4;
  inline const ::std::string& sn() const;
  inline void set_sn(const ::std::string& value);
  inline void set_sn(const char* value);
  inline void set_sn(const char* value, size_t size);
  inline ::std::string* mutable_sn();
  inline ::std::string* release_sn();
  inline void set_allocated_sn(::std::string* sn);

  // optional int32 chans = 5;
  inline bool has_chans() const;
  inline void clear_chans();
  static const int kChansFieldNumber = 5;
  inline ::google::protobuf::int32 chans() const;
  inline void set_chans(::google::protobuf::int32 value);

  // optional string conn = 6;
  inline bool has_conn() const;
  inline void clear_conn();
  static const int kConnFieldNumber = 6;
  inline const ::std::string& conn() const;
  inline void set_conn(const ::std::string& value);
  inline void set_conn(const char* value);
  inline void set_conn(const char* value, size_t size);
  inline ::std::string* mutable_conn();
  inline ::std::string* release_conn();
  inline void set_allocated_conn(::std::string* conn);

  // optional string tod = 7;
  inline bool has_tod() const;
  inline void clear_tod();
  static const int kTodFieldNumber = 7;
  inline const ::std::string& tod() const;
  inline void set_tod(const ::std::string& value);
  inline void set_tod(const char* value);
  inline void set_tod(const char* value, size_t size);
  inline ::std::string* mutable_tod();
  inline ::std::string* release_tod();
  inline void set_allocated_tod(::std::string* tod);

  // optional string rcv = 8;
  inline bool has_rcv() const;
  inline void clear_rcv();
  static const int kRcvFieldNumber = 8;
  inline const ::std::string& rcv() const;
  inline void set_rcv(const ::std::string& value);
  inline void set_rcv(const char* value);
  inline void set_rcv(const char* value, size_t size);
  inline ::std::string* mutable_rcv();
  inline ::std::string* release_rcv();
  inline void set_allocated_rcv(::std::string* rcv);

  // optional string brd = 9;
  inline bool has_brd() const;
  inline void clear_brd();
  static const int kBrdFieldNumber = 9;
  inline const ::std::string& brd() const;
  inline void set_brd(const ::std::string& value);
  inline void set_brd(const char* value);
  inline void set_brd(const char* value, size_t size);
  inline ::std::string* mutable_brd();
  inline ::std::string* release_brd();
  inline void set_allocated_brd(::std::string* brd);

  // optional string wbddc = 10;
  inline bool has_wbddc() const;
  inline void clear_wbddc();
  static const int kWbddcFieldNumber = 10;
  inline const ::std::string& wbddc() const;
  inline void set_wbddc(const ::std::string& value);
  inline void set_wbddc(const char* value);
  inline void set_wbddc(const char* value, size_t size);
  inline ::std::string* mutable_wbddc();
  inline ::std::string* release_wbddc();
  inline void set_allocated_wbddc(::std::string* wbddc);

  // optional string out = 11;
  inline bool has_out() const;
  inline void clear_out();
  static const int kOutFieldNumber = 11;
  inline const ::std::string& out() const;
  inline void set_out(const ::std::string& value);
  inline void set_out(const char* value);
  inline void set_out(const char* value, size_t size);
  inline ::std::string* mutable_out();
  inline ::std::string* release_out();
  inline void set_allocated_out(::std::string* out);

  // optional string temp = 12;
  inline bool has_temp() const;
  inline void clear_temp();
  static const int kTempFieldNumber = 12;
  inline const ::std::string& temp() const;
  inline void set_temp(const ::std::string& value);
  inline void set_temp(const char* value);
  inline void set_temp(const char* value, size_t size);
  inline ::std::string* mutable_temp();
  inline ::std::string* release_temp();
  inline void set_allocated_temp(::std::string* temp);

  // optional int32 id2 = 13;
  inline bool has_id2() const;
  inline void clear_id2();
  static const int kId2FieldNumber = 13;
  inline ::google::protobuf::int32 id2() const;
  inline void set_id2(::google::protobuf::int32 value);

  // optional string conn2 = 14;
  inline bool has_conn2() const;
  inline void clear_conn2();
  static const int kConn2FieldNumber = 14;
  inline const ::std::string& conn2() const;
  inline void set_conn2(const ::std::string& value);
  inline void set_conn2(const char* value);
  inline void set_conn2(const char* value, size_t size);
  inline ::std::string* mutable_conn2();
  inline ::std::string* release_conn2();
  inline void set_allocated_conn2(::std::string* conn2);

  // optional string rcv2 = 15;
  inline bool has_rcv2() const;
  inline void clear_rcv2();
  static const int kRcv2FieldNumber = 15;
  inline const ::std::string& rcv2() const;
  inline void set_rcv2(const ::std::string& value);
  inline void set_rcv2(const char* value);
  inline void set_rcv2(const char* value, size_t size);
  inline ::std::string* mutable_rcv2();
  inline ::std::string* release_rcv2();
  inline void set_allocated_rcv2(::std::string* rcv2);

  // optional string wbddc2 = 16;
  inline bool has_wbddc2() const;
  inline void clear_wbddc2();
  static const int kWbddc2FieldNumber = 16;
  inline const ::std::string& wbddc2() const;
  inline void set_wbddc2(const ::std::string& value);
  inline void set_wbddc2(const char* value);
  inline void set_wbddc2(const char* value, size_t size);
  inline ::std::string* mutable_wbddc2();
  inline ::std::string* release_wbddc2();
  inline void set_allocated_wbddc2(::std::string* wbddc2);

  // optional string out2 = 17;
  inline bool has_out2() const;
  inline void clear_out2();
  static const int kOut2FieldNumber = 17;
  inline const ::std::string& out2() const;
  inline void set_out2(const ::std::string& value);
  inline void set_out2(const char* value);
  inline void set_out2(const char* value, size_t size);
  inline ::std::string* mutable_out2();
  inline ::std::string* release_out2();
  inline void set_allocated_out2(::std::string* out2);

  // optional string wdt = 18;
  inline bool has_wdt() const;
  inline void clear_wdt();
  static const int kWdtFieldNumber = 18;
  inline const ::std::string& wdt() const;
  inline void set_wdt(const ::std::string& value);
  inline void set_wdt(const char* value);
  inline void set_wdt(const char* value, size_t size);
  inline ::std::string* mutable_wdt();
  inline ::std::string* release_wdt();
  inline void set_allocated_wdt(::std::string* wdt);

  // optional int32 line = 19;
  inline bool has_line() const;
  inline void clear_line();
  static const int kLineFieldNumber = 19;
  inline ::google::protobuf::int32 line() const;
  inline void set_line(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_receiver_msg.MMSStat)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_resid();
  inline void clear_has_resid();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_sn();
  inline void clear_has_sn();
  inline void set_has_chans();
  inline void clear_has_chans();
  inline void set_has_conn();
  inline void clear_has_conn();
  inline void set_has_tod();
  inline void clear_has_tod();
  inline void set_has_rcv();
  inline void clear_has_rcv();
  inline void set_has_brd();
  inline void clear_has_brd();
  inline void set_has_wbddc();
  inline void clear_has_wbddc();
  inline void set_has_out();
  inline void clear_has_out();
  inline void set_has_temp();
  inline void clear_has_temp();
  inline void set_has_id2();
  inline void clear_has_id2();
  inline void set_has_conn2();
  inline void clear_has_conn2();
  inline void set_has_rcv2();
  inline void clear_has_rcv2();
  inline void set_has_wbddc2();
  inline void clear_has_wbddc2();
  inline void set_has_out2();
  inline void clear_has_out2();
  inline void set_has_wdt();
  inline void clear_has_wdt();
  inline void set_has_line();
  inline void clear_has_line();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* resid_;
  ::std::string* sn_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 chans_;
  ::std::string* conn_;
  ::std::string* tod_;
  ::std::string* rcv_;
  ::std::string* brd_;
  ::std::string* wbddc_;
  ::std::string* out_;
  ::std::string* temp_;
  ::std::string* conn2_;
  ::std::string* rcv2_;
  ::std::string* wbddc2_;
  ::google::protobuf::int32 id2_;
  ::google::protobuf::int32 line_;
  ::std::string* out2_;
  ::std::string* wdt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  friend void  protobuf_AddDesc_FalconReceiverMessages_2eproto();
  friend void protobuf_AssignDesc_FalconReceiverMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconReceiverMessages_2eproto();

  void InitAsDefaultInstance();
  static MMSStat* default_instance_;
};
// ===================================================================


// ===================================================================

// ReceiverRequest

// optional string msgName = 1 [default = "RECEIVER_REQUEST"];
inline bool ReceiverRequest::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReceiverRequest::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReceiverRequest::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReceiverRequest::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ReceiverRequest::msgname() const {
  return *msgname_;
}
inline void ReceiverRequest::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ReceiverRequest::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ReceiverRequest::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiverRequest::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ReceiverRequest::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ReceiverRequest::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string resID = 2;
inline bool ReceiverRequest::has_resid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReceiverRequest::set_has_resid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReceiverRequest::clear_has_resid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReceiverRequest::clear_resid() {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    resid_->clear();
  }
  clear_has_resid();
}
inline const ::std::string& ReceiverRequest::resid() const {
  return *resid_;
}
inline void ReceiverRequest::set_resid(const ::std::string& value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void ReceiverRequest::set_resid(const char* value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void ReceiverRequest::set_resid(const char* value, size_t size) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiverRequest::mutable_resid() {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  return resid_;
}
inline ::std::string* ReceiverRequest::release_resid() {
  clear_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resid_;
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReceiverRequest::set_allocated_resid(::std::string* resid) {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    delete resid_;
  }
  if (resid) {
    set_has_resid();
    resid_ = resid;
  } else {
    clear_has_resid();
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 appID = 3;
inline bool ReceiverRequest::has_appid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReceiverRequest::set_has_appid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReceiverRequest::clear_has_appid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReceiverRequest::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 ReceiverRequest::appid() const {
  return appid_;
}
inline void ReceiverRequest::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional .falcon_receiver_msg.ReceiverRequest.Action action = 4;
inline bool ReceiverRequest::has_action() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReceiverRequest::set_has_action() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReceiverRequest::clear_has_action() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReceiverRequest::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::falcon_receiver_msg::ReceiverRequest_Action ReceiverRequest::action() const {
  return static_cast< ::falcon_receiver_msg::ReceiverRequest_Action >(action_);
}
inline void ReceiverRequest::set_action(::falcon_receiver_msg::ReceiverRequest_Action value) {
  assert(::falcon_receiver_msg::ReceiverRequest_Action_IsValid(value));
  set_has_action();
  action_ = value;
}

// optional .falcon_receiver_msg.ReceiverRequest.Property property = 5;
inline bool ReceiverRequest::has_property() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReceiverRequest::set_has_property() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReceiverRequest::clear_has_property() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReceiverRequest::clear_property() {
  property_ = 0;
  clear_has_property();
}
inline ::falcon_receiver_msg::ReceiverRequest_Property ReceiverRequest::property() const {
  return static_cast< ::falcon_receiver_msg::ReceiverRequest_Property >(property_);
}
inline void ReceiverRequest::set_property(::falcon_receiver_msg::ReceiverRequest_Property value) {
  assert(::falcon_receiver_msg::ReceiverRequest_Property_IsValid(value));
  set_has_property();
  property_ = value;
}

// optional float value = 6;
inline bool ReceiverRequest::has_value() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReceiverRequest::set_has_value() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReceiverRequest::clear_has_value() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReceiverRequest::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float ReceiverRequest::value() const {
  return value_;
}
inline void ReceiverRequest::set_value(float value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// ReceiverResponse

// optional string msgName = 1 [default = "RECEIVER_RESPONSE"];
inline bool ReceiverResponse::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReceiverResponse::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReceiverResponse::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReceiverResponse::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ReceiverResponse::msgname() const {
  return *msgname_;
}
inline void ReceiverResponse::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ReceiverResponse::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ReceiverResponse::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiverResponse::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ReceiverResponse::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ReceiverResponse::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string resID = 2;
inline bool ReceiverResponse::has_resid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReceiverResponse::set_has_resid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReceiverResponse::clear_has_resid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReceiverResponse::clear_resid() {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    resid_->clear();
  }
  clear_has_resid();
}
inline const ::std::string& ReceiverResponse::resid() const {
  return *resid_;
}
inline void ReceiverResponse::set_resid(const ::std::string& value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void ReceiverResponse::set_resid(const char* value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void ReceiverResponse::set_resid(const char* value, size_t size) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiverResponse::mutable_resid() {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  return resid_;
}
inline ::std::string* ReceiverResponse::release_resid() {
  clear_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resid_;
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReceiverResponse::set_allocated_resid(::std::string* resid) {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    delete resid_;
  }
  if (resid) {
    set_has_resid();
    resid_ = resid;
  } else {
    clear_has_resid();
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 appID = 3;
inline bool ReceiverResponse::has_appid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReceiverResponse::set_has_appid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReceiverResponse::clear_has_appid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReceiverResponse::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 ReceiverResponse::appid() const {
  return appid_;
}
inline void ReceiverResponse::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional .falcon_receiver_msg.ReceiverResponse.Status status = 4;
inline bool ReceiverResponse::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReceiverResponse::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReceiverResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReceiverResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::falcon_receiver_msg::ReceiverResponse_Status ReceiverResponse::status() const {
  return static_cast< ::falcon_receiver_msg::ReceiverResponse_Status >(status_);
}
inline void ReceiverResponse::set_status(::falcon_receiver_msg::ReceiverResponse_Status value) {
  assert(::falcon_receiver_msg::ReceiverResponse_Status_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional .falcon_receiver_msg.ReceiverRequest.Property property = 5;
inline bool ReceiverResponse::has_property() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReceiverResponse::set_has_property() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReceiverResponse::clear_has_property() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReceiverResponse::clear_property() {
  property_ = 0;
  clear_has_property();
}
inline ::falcon_receiver_msg::ReceiverRequest_Property ReceiverResponse::property() const {
  return static_cast< ::falcon_receiver_msg::ReceiverRequest_Property >(property_);
}
inline void ReceiverResponse::set_property(::falcon_receiver_msg::ReceiverRequest_Property value) {
  assert(::falcon_receiver_msg::ReceiverRequest_Property_IsValid(value));
  set_has_property();
  property_ = value;
}

// optional float value = 6;
inline bool ReceiverResponse::has_value() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReceiverResponse::set_has_value() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReceiverResponse::clear_has_value() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReceiverResponse::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float ReceiverResponse::value() const {
  return value_;
}
inline void ReceiverResponse::set_value(float value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// UniqueRXIDRequest

// optional string msgName = 1 [default = "UNIQUE_RXID_REQUEST"];
inline bool UniqueRXIDRequest::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UniqueRXIDRequest::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UniqueRXIDRequest::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UniqueRXIDRequest::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& UniqueRXIDRequest::msgname() const {
  return *msgname_;
}
inline void UniqueRXIDRequest::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UniqueRXIDRequest::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UniqueRXIDRequest::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UniqueRXIDRequest::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* UniqueRXIDRequest::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void UniqueRXIDRequest::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string resID = 2;
inline bool UniqueRXIDRequest::has_resid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UniqueRXIDRequest::set_has_resid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UniqueRXIDRequest::clear_has_resid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UniqueRXIDRequest::clear_resid() {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    resid_->clear();
  }
  clear_has_resid();
}
inline const ::std::string& UniqueRXIDRequest::resid() const {
  return *resid_;
}
inline void UniqueRXIDRequest::set_resid(const ::std::string& value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void UniqueRXIDRequest::set_resid(const char* value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void UniqueRXIDRequest::set_resid(const char* value, size_t size) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UniqueRXIDRequest::mutable_resid() {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  return resid_;
}
inline ::std::string* UniqueRXIDRequest::release_resid() {
  clear_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resid_;
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UniqueRXIDRequest::set_allocated_resid(::std::string* resid) {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    delete resid_;
  }
  if (resid) {
    set_has_resid();
    resid_ = resid;
  } else {
    clear_has_resid();
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .falcon_receiver_msg.UniqueRXIDRequest.Action action = 3 [default = GET];
inline bool UniqueRXIDRequest::has_action() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UniqueRXIDRequest::set_has_action() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UniqueRXIDRequest::clear_has_action() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UniqueRXIDRequest::clear_action() {
  action_ = 1;
  clear_has_action();
}
inline ::falcon_receiver_msg::UniqueRXIDRequest_Action UniqueRXIDRequest::action() const {
  return static_cast< ::falcon_receiver_msg::UniqueRXIDRequest_Action >(action_);
}
inline void UniqueRXIDRequest::set_action(::falcon_receiver_msg::UniqueRXIDRequest_Action value) {
  assert(::falcon_receiver_msg::UniqueRXIDRequest_Action_IsValid(value));
  set_has_action();
  action_ = value;
}

// optional string value = 4;
inline bool UniqueRXIDRequest::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UniqueRXIDRequest::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UniqueRXIDRequest::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UniqueRXIDRequest::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& UniqueRXIDRequest::value() const {
  return *value_;
}
inline void UniqueRXIDRequest::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void UniqueRXIDRequest::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void UniqueRXIDRequest::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UniqueRXIDRequest::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* UniqueRXIDRequest::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UniqueRXIDRequest::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UniqueRXIDResponse

// optional string msgName = 1 [default = "UNIQUE_RXID_RESPONSE"];
inline bool UniqueRXIDResponse::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UniqueRXIDResponse::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UniqueRXIDResponse::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UniqueRXIDResponse::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& UniqueRXIDResponse::msgname() const {
  return *msgname_;
}
inline void UniqueRXIDResponse::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UniqueRXIDResponse::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UniqueRXIDResponse::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UniqueRXIDResponse::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* UniqueRXIDResponse::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void UniqueRXIDResponse::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string resID = 2;
inline bool UniqueRXIDResponse::has_resid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UniqueRXIDResponse::set_has_resid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UniqueRXIDResponse::clear_has_resid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UniqueRXIDResponse::clear_resid() {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    resid_->clear();
  }
  clear_has_resid();
}
inline const ::std::string& UniqueRXIDResponse::resid() const {
  return *resid_;
}
inline void UniqueRXIDResponse::set_resid(const ::std::string& value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void UniqueRXIDResponse::set_resid(const char* value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void UniqueRXIDResponse::set_resid(const char* value, size_t size) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UniqueRXIDResponse::mutable_resid() {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  return resid_;
}
inline ::std::string* UniqueRXIDResponse::release_resid() {
  clear_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resid_;
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UniqueRXIDResponse::set_allocated_resid(::std::string* resid) {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    delete resid_;
  }
  if (resid) {
    set_has_resid();
    resid_ = resid;
  } else {
    clear_has_resid();
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string value = 3;
inline bool UniqueRXIDResponse::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UniqueRXIDResponse::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UniqueRXIDResponse::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UniqueRXIDResponse::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& UniqueRXIDResponse::value() const {
  return *value_;
}
inline void UniqueRXIDResponse::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void UniqueRXIDResponse::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void UniqueRXIDResponse::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UniqueRXIDResponse::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* UniqueRXIDResponse::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UniqueRXIDResponse::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReceiverInfoRequest

// optional string msgName = 1 [default = "RECEIVER_INFO_REQUEST"];
inline bool ReceiverInfoRequest::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReceiverInfoRequest::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReceiverInfoRequest::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReceiverInfoRequest::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ReceiverInfoRequest::msgname() const {
  return *msgname_;
}
inline void ReceiverInfoRequest::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ReceiverInfoRequest::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ReceiverInfoRequest::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiverInfoRequest::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ReceiverInfoRequest::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ReceiverInfoRequest::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// -------------------------------------------------------------------

// ReceiverInfoResponse

// optional string msgName = 1 [default = "RECEIVER_INFO_RESPONSE"];
inline bool ReceiverInfoResponse::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReceiverInfoResponse::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReceiverInfoResponse::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReceiverInfoResponse::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ReceiverInfoResponse::msgname() const {
  return *msgname_;
}
inline void ReceiverInfoResponse::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ReceiverInfoResponse::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ReceiverInfoResponse::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiverInfoResponse::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ReceiverInfoResponse::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ReceiverInfoResponse::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string resID = 2;
inline bool ReceiverInfoResponse::has_resid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReceiverInfoResponse::set_has_resid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReceiverInfoResponse::clear_has_resid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReceiverInfoResponse::clear_resid() {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    resid_->clear();
  }
  clear_has_resid();
}
inline const ::std::string& ReceiverInfoResponse::resid() const {
  return *resid_;
}
inline void ReceiverInfoResponse::set_resid(const ::std::string& value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void ReceiverInfoResponse::set_resid(const char* value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void ReceiverInfoResponse::set_resid(const char* value, size_t size) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiverInfoResponse::mutable_resid() {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  return resid_;
}
inline ::std::string* ReceiverInfoResponse::release_resid() {
  clear_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resid_;
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReceiverInfoResponse::set_allocated_resid(::std::string* resid) {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    delete resid_;
  }
  if (resid) {
    set_has_resid();
    resid_ = resid;
  } else {
    clear_has_resid();
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ntp = 3;
inline bool ReceiverInfoResponse::has_ntp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReceiverInfoResponse::set_has_ntp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReceiverInfoResponse::clear_has_ntp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReceiverInfoResponse::clear_ntp() {
  if (ntp_ != &::google::protobuf::internal::kEmptyString) {
    ntp_->clear();
  }
  clear_has_ntp();
}
inline const ::std::string& ReceiverInfoResponse::ntp() const {
  return *ntp_;
}
inline void ReceiverInfoResponse::set_ntp(const ::std::string& value) {
  set_has_ntp();
  if (ntp_ == &::google::protobuf::internal::kEmptyString) {
    ntp_ = new ::std::string;
  }
  ntp_->assign(value);
}
inline void ReceiverInfoResponse::set_ntp(const char* value) {
  set_has_ntp();
  if (ntp_ == &::google::protobuf::internal::kEmptyString) {
    ntp_ = new ::std::string;
  }
  ntp_->assign(value);
}
inline void ReceiverInfoResponse::set_ntp(const char* value, size_t size) {
  set_has_ntp();
  if (ntp_ == &::google::protobuf::internal::kEmptyString) {
    ntp_ = new ::std::string;
  }
  ntp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiverInfoResponse::mutable_ntp() {
  set_has_ntp();
  if (ntp_ == &::google::protobuf::internal::kEmptyString) {
    ntp_ = new ::std::string;
  }
  return ntp_;
}
inline ::std::string* ReceiverInfoResponse::release_ntp() {
  clear_has_ntp();
  if (ntp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ntp_;
    ntp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReceiverInfoResponse::set_allocated_ntp(::std::string* ntp) {
  if (ntp_ != &::google::protobuf::internal::kEmptyString) {
    delete ntp_;
  }
  if (ntp) {
    set_has_ntp();
    ntp_ = ntp;
  } else {
    clear_has_ntp();
    ntp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ref = 4;
inline bool ReceiverInfoResponse::has_ref() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReceiverInfoResponse::set_has_ref() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReceiverInfoResponse::clear_has_ref() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReceiverInfoResponse::clear_ref() {
  if (ref_ != &::google::protobuf::internal::kEmptyString) {
    ref_->clear();
  }
  clear_has_ref();
}
inline const ::std::string& ReceiverInfoResponse::ref() const {
  return *ref_;
}
inline void ReceiverInfoResponse::set_ref(const ::std::string& value) {
  set_has_ref();
  if (ref_ == &::google::protobuf::internal::kEmptyString) {
    ref_ = new ::std::string;
  }
  ref_->assign(value);
}
inline void ReceiverInfoResponse::set_ref(const char* value) {
  set_has_ref();
  if (ref_ == &::google::protobuf::internal::kEmptyString) {
    ref_ = new ::std::string;
  }
  ref_->assign(value);
}
inline void ReceiverInfoResponse::set_ref(const char* value, size_t size) {
  set_has_ref();
  if (ref_ == &::google::protobuf::internal::kEmptyString) {
    ref_ = new ::std::string;
  }
  ref_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiverInfoResponse::mutable_ref() {
  set_has_ref();
  if (ref_ == &::google::protobuf::internal::kEmptyString) {
    ref_ = new ::std::string;
  }
  return ref_;
}
inline ::std::string* ReceiverInfoResponse::release_ref() {
  clear_has_ref();
  if (ref_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ref_;
    ref_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReceiverInfoResponse::set_allocated_ref(::std::string* ref) {
  if (ref_ != &::google::protobuf::internal::kEmptyString) {
    delete ref_;
  }
  if (ref) {
    set_has_ref();
    ref_ = ref;
  } else {
    clear_has_ref();
    ref_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pps = 5;
inline bool ReceiverInfoResponse::has_pps() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReceiverInfoResponse::set_has_pps() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReceiverInfoResponse::clear_has_pps() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReceiverInfoResponse::clear_pps() {
  if (pps_ != &::google::protobuf::internal::kEmptyString) {
    pps_->clear();
  }
  clear_has_pps();
}
inline const ::std::string& ReceiverInfoResponse::pps() const {
  return *pps_;
}
inline void ReceiverInfoResponse::set_pps(const ::std::string& value) {
  set_has_pps();
  if (pps_ == &::google::protobuf::internal::kEmptyString) {
    pps_ = new ::std::string;
  }
  pps_->assign(value);
}
inline void ReceiverInfoResponse::set_pps(const char* value) {
  set_has_pps();
  if (pps_ == &::google::protobuf::internal::kEmptyString) {
    pps_ = new ::std::string;
  }
  pps_->assign(value);
}
inline void ReceiverInfoResponse::set_pps(const char* value, size_t size) {
  set_has_pps();
  if (pps_ == &::google::protobuf::internal::kEmptyString) {
    pps_ = new ::std::string;
  }
  pps_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiverInfoResponse::mutable_pps() {
  set_has_pps();
  if (pps_ == &::google::protobuf::internal::kEmptyString) {
    pps_ = new ::std::string;
  }
  return pps_;
}
inline ::std::string* ReceiverInfoResponse::release_pps() {
  clear_has_pps();
  if (pps_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pps_;
    pps_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReceiverInfoResponse::set_allocated_pps(::std::string* pps) {
  if (pps_ != &::google::protobuf::internal::kEmptyString) {
    delete pps_;
  }
  if (pps) {
    set_has_pps();
    pps_ = pps;
  } else {
    clear_has_pps();
    pps_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string comms = 6;
inline bool ReceiverInfoResponse::has_comms() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReceiverInfoResponse::set_has_comms() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReceiverInfoResponse::clear_has_comms() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReceiverInfoResponse::clear_comms() {
  if (comms_ != &::google::protobuf::internal::kEmptyString) {
    comms_->clear();
  }
  clear_has_comms();
}
inline const ::std::string& ReceiverInfoResponse::comms() const {
  return *comms_;
}
inline void ReceiverInfoResponse::set_comms(const ::std::string& value) {
  set_has_comms();
  if (comms_ == &::google::protobuf::internal::kEmptyString) {
    comms_ = new ::std::string;
  }
  comms_->assign(value);
}
inline void ReceiverInfoResponse::set_comms(const char* value) {
  set_has_comms();
  if (comms_ == &::google::protobuf::internal::kEmptyString) {
    comms_ = new ::std::string;
  }
  comms_->assign(value);
}
inline void ReceiverInfoResponse::set_comms(const char* value, size_t size) {
  set_has_comms();
  if (comms_ == &::google::protobuf::internal::kEmptyString) {
    comms_ = new ::std::string;
  }
  comms_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiverInfoResponse::mutable_comms() {
  set_has_comms();
  if (comms_ == &::google::protobuf::internal::kEmptyString) {
    comms_ = new ::std::string;
  }
  return comms_;
}
inline ::std::string* ReceiverInfoResponse::release_comms() {
  clear_has_comms();
  if (comms_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comms_;
    comms_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReceiverInfoResponse::set_allocated_comms(::std::string* comms) {
  if (comms_ != &::google::protobuf::internal::kEmptyString) {
    delete comms_;
  }
  if (comms) {
    set_has_comms();
    comms_ = comms;
  } else {
    clear_has_comms();
    comms_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ping = 7;
inline bool ReceiverInfoResponse::has_ping() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReceiverInfoResponse::set_has_ping() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReceiverInfoResponse::clear_has_ping() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReceiverInfoResponse::clear_ping() {
  if (ping_ != &::google::protobuf::internal::kEmptyString) {
    ping_->clear();
  }
  clear_has_ping();
}
inline const ::std::string& ReceiverInfoResponse::ping() const {
  return *ping_;
}
inline void ReceiverInfoResponse::set_ping(const ::std::string& value) {
  set_has_ping();
  if (ping_ == &::google::protobuf::internal::kEmptyString) {
    ping_ = new ::std::string;
  }
  ping_->assign(value);
}
inline void ReceiverInfoResponse::set_ping(const char* value) {
  set_has_ping();
  if (ping_ == &::google::protobuf::internal::kEmptyString) {
    ping_ = new ::std::string;
  }
  ping_->assign(value);
}
inline void ReceiverInfoResponse::set_ping(const char* value, size_t size) {
  set_has_ping();
  if (ping_ == &::google::protobuf::internal::kEmptyString) {
    ping_ = new ::std::string;
  }
  ping_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiverInfoResponse::mutable_ping() {
  set_has_ping();
  if (ping_ == &::google::protobuf::internal::kEmptyString) {
    ping_ = new ::std::string;
  }
  return ping_;
}
inline ::std::string* ReceiverInfoResponse::release_ping() {
  clear_has_ping();
  if (ping_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ping_;
    ping_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReceiverInfoResponse::set_allocated_ping(::std::string* ping) {
  if (ping_ != &::google::protobuf::internal::kEmptyString) {
    delete ping_;
  }
  if (ping) {
    set_has_ping();
    ping_ = ping;
  } else {
    clear_has_ping();
    ping_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string raid = 8;
inline bool ReceiverInfoResponse::has_raid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ReceiverInfoResponse::set_has_raid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ReceiverInfoResponse::clear_has_raid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ReceiverInfoResponse::clear_raid() {
  if (raid_ != &::google::protobuf::internal::kEmptyString) {
    raid_->clear();
  }
  clear_has_raid();
}
inline const ::std::string& ReceiverInfoResponse::raid() const {
  return *raid_;
}
inline void ReceiverInfoResponse::set_raid(const ::std::string& value) {
  set_has_raid();
  if (raid_ == &::google::protobuf::internal::kEmptyString) {
    raid_ = new ::std::string;
  }
  raid_->assign(value);
}
inline void ReceiverInfoResponse::set_raid(const char* value) {
  set_has_raid();
  if (raid_ == &::google::protobuf::internal::kEmptyString) {
    raid_ = new ::std::string;
  }
  raid_->assign(value);
}
inline void ReceiverInfoResponse::set_raid(const char* value, size_t size) {
  set_has_raid();
  if (raid_ == &::google::protobuf::internal::kEmptyString) {
    raid_ = new ::std::string;
  }
  raid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiverInfoResponse::mutable_raid() {
  set_has_raid();
  if (raid_ == &::google::protobuf::internal::kEmptyString) {
    raid_ = new ::std::string;
  }
  return raid_;
}
inline ::std::string* ReceiverInfoResponse::release_raid() {
  clear_has_raid();
  if (raid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = raid_;
    raid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReceiverInfoResponse::set_allocated_raid(::std::string* raid) {
  if (raid_ != &::google::protobuf::internal::kEmptyString) {
    delete raid_;
  }
  if (raid) {
    set_has_raid();
    raid_ = raid;
  } else {
    clear_has_raid();
    raid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReceiverHealthTest

// optional string msgName = 1 [default = "RECEIVER_HEALTH_TEST"];
inline bool ReceiverHealthTest::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReceiverHealthTest::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReceiverHealthTest::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReceiverHealthTest::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ReceiverHealthTest::msgname() const {
  return *msgname_;
}
inline void ReceiverHealthTest::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ReceiverHealthTest::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ReceiverHealthTest::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiverHealthTest::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ReceiverHealthTest::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ReceiverHealthTest::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 ntp = 2;
inline bool ReceiverHealthTest::has_ntp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReceiverHealthTest::set_has_ntp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReceiverHealthTest::clear_has_ntp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReceiverHealthTest::clear_ntp() {
  ntp_ = 0;
  clear_has_ntp();
}
inline ::google::protobuf::int32 ReceiverHealthTest::ntp() const {
  return ntp_;
}
inline void ReceiverHealthTest::set_ntp(::google::protobuf::int32 value) {
  set_has_ntp();
  ntp_ = value;
}

// optional int32 raid = 3;
inline bool ReceiverHealthTest::has_raid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReceiverHealthTest::set_has_raid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReceiverHealthTest::clear_has_raid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReceiverHealthTest::clear_raid() {
  raid_ = 0;
  clear_has_raid();
}
inline ::google::protobuf::int32 ReceiverHealthTest::raid() const {
  return raid_;
}
inline void ReceiverHealthTest::set_raid(::google::protobuf::int32 value) {
  set_has_raid();
  raid_ = value;
}

// optional int32 singleraid = 4;
inline bool ReceiverHealthTest::has_singleraid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReceiverHealthTest::set_has_singleraid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReceiverHealthTest::clear_has_singleraid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReceiverHealthTest::clear_singleraid() {
  singleraid_ = 0;
  clear_has_singleraid();
}
inline ::google::protobuf::int32 ReceiverHealthTest::singleraid() const {
  return singleraid_;
}
inline void ReceiverHealthTest::set_singleraid(::google::protobuf::int32 value) {
  set_has_singleraid();
  singleraid_ = value;
}

// -------------------------------------------------------------------

// ReceiverHealthResponse

// optional string msgName = 1 [default = "RECEIVER_HEALTH_RESPONSE"];
inline bool ReceiverHealthResponse::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReceiverHealthResponse::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReceiverHealthResponse::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReceiverHealthResponse::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ReceiverHealthResponse::msgname() const {
  return *msgname_;
}
inline void ReceiverHealthResponse::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ReceiverHealthResponse::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ReceiverHealthResponse::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiverHealthResponse::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ReceiverHealthResponse::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ReceiverHealthResponse::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string resID = 2;
inline bool ReceiverHealthResponse::has_resid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReceiverHealthResponse::set_has_resid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReceiverHealthResponse::clear_has_resid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReceiverHealthResponse::clear_resid() {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    resid_->clear();
  }
  clear_has_resid();
}
inline const ::std::string& ReceiverHealthResponse::resid() const {
  return *resid_;
}
inline void ReceiverHealthResponse::set_resid(const ::std::string& value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void ReceiverHealthResponse::set_resid(const char* value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void ReceiverHealthResponse::set_resid(const char* value, size_t size) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiverHealthResponse::mutable_resid() {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  return resid_;
}
inline ::std::string* ReceiverHealthResponse::release_resid() {
  clear_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resid_;
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReceiverHealthResponse::set_allocated_resid(::std::string* resid) {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    delete resid_;
  }
  if (resid) {
    set_has_resid();
    resid_ = resid;
  } else {
    clear_has_resid();
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ntp = 3 [default = "-"];
inline bool ReceiverHealthResponse::has_ntp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReceiverHealthResponse::set_has_ntp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReceiverHealthResponse::clear_has_ntp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReceiverHealthResponse::clear_ntp() {
  if (ntp_ != _default_ntp_) {
    ntp_->assign(*_default_ntp_);
  }
  clear_has_ntp();
}
inline const ::std::string& ReceiverHealthResponse::ntp() const {
  return *ntp_;
}
inline void ReceiverHealthResponse::set_ntp(const ::std::string& value) {
  set_has_ntp();
  if (ntp_ == _default_ntp_) {
    ntp_ = new ::std::string;
  }
  ntp_->assign(value);
}
inline void ReceiverHealthResponse::set_ntp(const char* value) {
  set_has_ntp();
  if (ntp_ == _default_ntp_) {
    ntp_ = new ::std::string;
  }
  ntp_->assign(value);
}
inline void ReceiverHealthResponse::set_ntp(const char* value, size_t size) {
  set_has_ntp();
  if (ntp_ == _default_ntp_) {
    ntp_ = new ::std::string;
  }
  ntp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiverHealthResponse::mutable_ntp() {
  set_has_ntp();
  if (ntp_ == _default_ntp_) {
    ntp_ = new ::std::string(*_default_ntp_);
  }
  return ntp_;
}
inline ::std::string* ReceiverHealthResponse::release_ntp() {
  clear_has_ntp();
  if (ntp_ == _default_ntp_) {
    return NULL;
  } else {
    ::std::string* temp = ntp_;
    ntp_ = const_cast< ::std::string*>(_default_ntp_);
    return temp;
  }
}
inline void ReceiverHealthResponse::set_allocated_ntp(::std::string* ntp) {
  if (ntp_ != _default_ntp_) {
    delete ntp_;
  }
  if (ntp) {
    set_has_ntp();
    ntp_ = ntp;
  } else {
    clear_has_ntp();
    ntp_ = const_cast< ::std::string*>(_default_ntp_);
  }
}

// optional string ref = 4 [default = "-"];
inline bool ReceiverHealthResponse::has_ref() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReceiverHealthResponse::set_has_ref() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReceiverHealthResponse::clear_has_ref() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReceiverHealthResponse::clear_ref() {
  if (ref_ != _default_ref_) {
    ref_->assign(*_default_ref_);
  }
  clear_has_ref();
}
inline const ::std::string& ReceiverHealthResponse::ref() const {
  return *ref_;
}
inline void ReceiverHealthResponse::set_ref(const ::std::string& value) {
  set_has_ref();
  if (ref_ == _default_ref_) {
    ref_ = new ::std::string;
  }
  ref_->assign(value);
}
inline void ReceiverHealthResponse::set_ref(const char* value) {
  set_has_ref();
  if (ref_ == _default_ref_) {
    ref_ = new ::std::string;
  }
  ref_->assign(value);
}
inline void ReceiverHealthResponse::set_ref(const char* value, size_t size) {
  set_has_ref();
  if (ref_ == _default_ref_) {
    ref_ = new ::std::string;
  }
  ref_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiverHealthResponse::mutable_ref() {
  set_has_ref();
  if (ref_ == _default_ref_) {
    ref_ = new ::std::string(*_default_ref_);
  }
  return ref_;
}
inline ::std::string* ReceiverHealthResponse::release_ref() {
  clear_has_ref();
  if (ref_ == _default_ref_) {
    return NULL;
  } else {
    ::std::string* temp = ref_;
    ref_ = const_cast< ::std::string*>(_default_ref_);
    return temp;
  }
}
inline void ReceiverHealthResponse::set_allocated_ref(::std::string* ref) {
  if (ref_ != _default_ref_) {
    delete ref_;
  }
  if (ref) {
    set_has_ref();
    ref_ = ref;
  } else {
    clear_has_ref();
    ref_ = const_cast< ::std::string*>(_default_ref_);
  }
}

// optional string pps = 5 [default = "-"];
inline bool ReceiverHealthResponse::has_pps() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReceiverHealthResponse::set_has_pps() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReceiverHealthResponse::clear_has_pps() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReceiverHealthResponse::clear_pps() {
  if (pps_ != _default_pps_) {
    pps_->assign(*_default_pps_);
  }
  clear_has_pps();
}
inline const ::std::string& ReceiverHealthResponse::pps() const {
  return *pps_;
}
inline void ReceiverHealthResponse::set_pps(const ::std::string& value) {
  set_has_pps();
  if (pps_ == _default_pps_) {
    pps_ = new ::std::string;
  }
  pps_->assign(value);
}
inline void ReceiverHealthResponse::set_pps(const char* value) {
  set_has_pps();
  if (pps_ == _default_pps_) {
    pps_ = new ::std::string;
  }
  pps_->assign(value);
}
inline void ReceiverHealthResponse::set_pps(const char* value, size_t size) {
  set_has_pps();
  if (pps_ == _default_pps_) {
    pps_ = new ::std::string;
  }
  pps_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiverHealthResponse::mutable_pps() {
  set_has_pps();
  if (pps_ == _default_pps_) {
    pps_ = new ::std::string(*_default_pps_);
  }
  return pps_;
}
inline ::std::string* ReceiverHealthResponse::release_pps() {
  clear_has_pps();
  if (pps_ == _default_pps_) {
    return NULL;
  } else {
    ::std::string* temp = pps_;
    pps_ = const_cast< ::std::string*>(_default_pps_);
    return temp;
  }
}
inline void ReceiverHealthResponse::set_allocated_pps(::std::string* pps) {
  if (pps_ != _default_pps_) {
    delete pps_;
  }
  if (pps) {
    set_has_pps();
    pps_ = pps;
  } else {
    clear_has_pps();
    pps_ = const_cast< ::std::string*>(_default_pps_);
  }
}

// optional string rx = 6 [default = "-"];
inline bool ReceiverHealthResponse::has_rx() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReceiverHealthResponse::set_has_rx() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReceiverHealthResponse::clear_has_rx() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReceiverHealthResponse::clear_rx() {
  if (rx_ != _default_rx_) {
    rx_->assign(*_default_rx_);
  }
  clear_has_rx();
}
inline const ::std::string& ReceiverHealthResponse::rx() const {
  return *rx_;
}
inline void ReceiverHealthResponse::set_rx(const ::std::string& value) {
  set_has_rx();
  if (rx_ == _default_rx_) {
    rx_ = new ::std::string;
  }
  rx_->assign(value);
}
inline void ReceiverHealthResponse::set_rx(const char* value) {
  set_has_rx();
  if (rx_ == _default_rx_) {
    rx_ = new ::std::string;
  }
  rx_->assign(value);
}
inline void ReceiverHealthResponse::set_rx(const char* value, size_t size) {
  set_has_rx();
  if (rx_ == _default_rx_) {
    rx_ = new ::std::string;
  }
  rx_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiverHealthResponse::mutable_rx() {
  set_has_rx();
  if (rx_ == _default_rx_) {
    rx_ = new ::std::string(*_default_rx_);
  }
  return rx_;
}
inline ::std::string* ReceiverHealthResponse::release_rx() {
  clear_has_rx();
  if (rx_ == _default_rx_) {
    return NULL;
  } else {
    ::std::string* temp = rx_;
    rx_ = const_cast< ::std::string*>(_default_rx_);
    return temp;
  }
}
inline void ReceiverHealthResponse::set_allocated_rx(::std::string* rx) {
  if (rx_ != _default_rx_) {
    delete rx_;
  }
  if (rx) {
    set_has_rx();
    rx_ = rx;
  } else {
    clear_has_rx();
    rx_ = const_cast< ::std::string*>(_default_rx_);
  }
}

// optional string ping = 7 [default = "-"];
inline bool ReceiverHealthResponse::has_ping() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReceiverHealthResponse::set_has_ping() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReceiverHealthResponse::clear_has_ping() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReceiverHealthResponse::clear_ping() {
  if (ping_ != _default_ping_) {
    ping_->assign(*_default_ping_);
  }
  clear_has_ping();
}
inline const ::std::string& ReceiverHealthResponse::ping() const {
  return *ping_;
}
inline void ReceiverHealthResponse::set_ping(const ::std::string& value) {
  set_has_ping();
  if (ping_ == _default_ping_) {
    ping_ = new ::std::string;
  }
  ping_->assign(value);
}
inline void ReceiverHealthResponse::set_ping(const char* value) {
  set_has_ping();
  if (ping_ == _default_ping_) {
    ping_ = new ::std::string;
  }
  ping_->assign(value);
}
inline void ReceiverHealthResponse::set_ping(const char* value, size_t size) {
  set_has_ping();
  if (ping_ == _default_ping_) {
    ping_ = new ::std::string;
  }
  ping_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiverHealthResponse::mutable_ping() {
  set_has_ping();
  if (ping_ == _default_ping_) {
    ping_ = new ::std::string(*_default_ping_);
  }
  return ping_;
}
inline ::std::string* ReceiverHealthResponse::release_ping() {
  clear_has_ping();
  if (ping_ == _default_ping_) {
    return NULL;
  } else {
    ::std::string* temp = ping_;
    ping_ = const_cast< ::std::string*>(_default_ping_);
    return temp;
  }
}
inline void ReceiverHealthResponse::set_allocated_ping(::std::string* ping) {
  if (ping_ != _default_ping_) {
    delete ping_;
  }
  if (ping) {
    set_has_ping();
    ping_ = ping;
  } else {
    clear_has_ping();
    ping_ = const_cast< ::std::string*>(_default_ping_);
  }
}

// optional string raid = 8 [default = "-"];
inline bool ReceiverHealthResponse::has_raid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ReceiverHealthResponse::set_has_raid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ReceiverHealthResponse::clear_has_raid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ReceiverHealthResponse::clear_raid() {
  if (raid_ != _default_raid_) {
    raid_->assign(*_default_raid_);
  }
  clear_has_raid();
}
inline const ::std::string& ReceiverHealthResponse::raid() const {
  return *raid_;
}
inline void ReceiverHealthResponse::set_raid(const ::std::string& value) {
  set_has_raid();
  if (raid_ == _default_raid_) {
    raid_ = new ::std::string;
  }
  raid_->assign(value);
}
inline void ReceiverHealthResponse::set_raid(const char* value) {
  set_has_raid();
  if (raid_ == _default_raid_) {
    raid_ = new ::std::string;
  }
  raid_->assign(value);
}
inline void ReceiverHealthResponse::set_raid(const char* value, size_t size) {
  set_has_raid();
  if (raid_ == _default_raid_) {
    raid_ = new ::std::string;
  }
  raid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiverHealthResponse::mutable_raid() {
  set_has_raid();
  if (raid_ == _default_raid_) {
    raid_ = new ::std::string(*_default_raid_);
  }
  return raid_;
}
inline ::std::string* ReceiverHealthResponse::release_raid() {
  clear_has_raid();
  if (raid_ == _default_raid_) {
    return NULL;
  } else {
    ::std::string* temp = raid_;
    raid_ = const_cast< ::std::string*>(_default_raid_);
    return temp;
  }
}
inline void ReceiverHealthResponse::set_allocated_raid(::std::string* raid) {
  if (raid_ != _default_raid_) {
    delete raid_;
  }
  if (raid) {
    set_has_raid();
    raid_ = raid;
  } else {
    clear_has_raid();
    raid_ = const_cast< ::std::string*>(_default_raid_);
  }
}

// -------------------------------------------------------------------

// MMSStat

// optional string msgName = 1 [default = "MMS_STAT"];
inline bool MMSStat::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MMSStat::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MMSStat::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MMSStat::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& MMSStat::msgname() const {
  return *msgname_;
}
inline void MMSStat::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void MMSStat::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void MMSStat::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSStat::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* MMSStat::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void MMSStat::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string resID = 2;
inline bool MMSStat::has_resid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MMSStat::set_has_resid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MMSStat::clear_has_resid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MMSStat::clear_resid() {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    resid_->clear();
  }
  clear_has_resid();
}
inline const ::std::string& MMSStat::resid() const {
  return *resid_;
}
inline void MMSStat::set_resid(const ::std::string& value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void MMSStat::set_resid(const char* value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void MMSStat::set_resid(const char* value, size_t size) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSStat::mutable_resid() {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  return resid_;
}
inline ::std::string* MMSStat::release_resid() {
  clear_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resid_;
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MMSStat::set_allocated_resid(::std::string* resid) {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    delete resid_;
  }
  if (resid) {
    set_has_resid();
    resid_ = resid;
  } else {
    clear_has_resid();
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 id = 3;
inline bool MMSStat::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MMSStat::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MMSStat::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MMSStat::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 MMSStat::id() const {
  return id_;
}
inline void MMSStat::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string sn = 4;
inline bool MMSStat::has_sn() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MMSStat::set_has_sn() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MMSStat::clear_has_sn() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MMSStat::clear_sn() {
  if (sn_ != &::google::protobuf::internal::kEmptyString) {
    sn_->clear();
  }
  clear_has_sn();
}
inline const ::std::string& MMSStat::sn() const {
  return *sn_;
}
inline void MMSStat::set_sn(const ::std::string& value) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(value);
}
inline void MMSStat::set_sn(const char* value) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(value);
}
inline void MMSStat::set_sn(const char* value, size_t size) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSStat::mutable_sn() {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  return sn_;
}
inline ::std::string* MMSStat::release_sn() {
  clear_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sn_;
    sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MMSStat::set_allocated_sn(::std::string* sn) {
  if (sn_ != &::google::protobuf::internal::kEmptyString) {
    delete sn_;
  }
  if (sn) {
    set_has_sn();
    sn_ = sn;
  } else {
    clear_has_sn();
    sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 chans = 5;
inline bool MMSStat::has_chans() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MMSStat::set_has_chans() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MMSStat::clear_has_chans() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MMSStat::clear_chans() {
  chans_ = 0;
  clear_has_chans();
}
inline ::google::protobuf::int32 MMSStat::chans() const {
  return chans_;
}
inline void MMSStat::set_chans(::google::protobuf::int32 value) {
  set_has_chans();
  chans_ = value;
}

// optional string conn = 6;
inline bool MMSStat::has_conn() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MMSStat::set_has_conn() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MMSStat::clear_has_conn() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MMSStat::clear_conn() {
  if (conn_ != &::google::protobuf::internal::kEmptyString) {
    conn_->clear();
  }
  clear_has_conn();
}
inline const ::std::string& MMSStat::conn() const {
  return *conn_;
}
inline void MMSStat::set_conn(const ::std::string& value) {
  set_has_conn();
  if (conn_ == &::google::protobuf::internal::kEmptyString) {
    conn_ = new ::std::string;
  }
  conn_->assign(value);
}
inline void MMSStat::set_conn(const char* value) {
  set_has_conn();
  if (conn_ == &::google::protobuf::internal::kEmptyString) {
    conn_ = new ::std::string;
  }
  conn_->assign(value);
}
inline void MMSStat::set_conn(const char* value, size_t size) {
  set_has_conn();
  if (conn_ == &::google::protobuf::internal::kEmptyString) {
    conn_ = new ::std::string;
  }
  conn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSStat::mutable_conn() {
  set_has_conn();
  if (conn_ == &::google::protobuf::internal::kEmptyString) {
    conn_ = new ::std::string;
  }
  return conn_;
}
inline ::std::string* MMSStat::release_conn() {
  clear_has_conn();
  if (conn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = conn_;
    conn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MMSStat::set_allocated_conn(::std::string* conn) {
  if (conn_ != &::google::protobuf::internal::kEmptyString) {
    delete conn_;
  }
  if (conn) {
    set_has_conn();
    conn_ = conn;
  } else {
    clear_has_conn();
    conn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string tod = 7;
inline bool MMSStat::has_tod() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MMSStat::set_has_tod() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MMSStat::clear_has_tod() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MMSStat::clear_tod() {
  if (tod_ != &::google::protobuf::internal::kEmptyString) {
    tod_->clear();
  }
  clear_has_tod();
}
inline const ::std::string& MMSStat::tod() const {
  return *tod_;
}
inline void MMSStat::set_tod(const ::std::string& value) {
  set_has_tod();
  if (tod_ == &::google::protobuf::internal::kEmptyString) {
    tod_ = new ::std::string;
  }
  tod_->assign(value);
}
inline void MMSStat::set_tod(const char* value) {
  set_has_tod();
  if (tod_ == &::google::protobuf::internal::kEmptyString) {
    tod_ = new ::std::string;
  }
  tod_->assign(value);
}
inline void MMSStat::set_tod(const char* value, size_t size) {
  set_has_tod();
  if (tod_ == &::google::protobuf::internal::kEmptyString) {
    tod_ = new ::std::string;
  }
  tod_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSStat::mutable_tod() {
  set_has_tod();
  if (tod_ == &::google::protobuf::internal::kEmptyString) {
    tod_ = new ::std::string;
  }
  return tod_;
}
inline ::std::string* MMSStat::release_tod() {
  clear_has_tod();
  if (tod_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tod_;
    tod_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MMSStat::set_allocated_tod(::std::string* tod) {
  if (tod_ != &::google::protobuf::internal::kEmptyString) {
    delete tod_;
  }
  if (tod) {
    set_has_tod();
    tod_ = tod;
  } else {
    clear_has_tod();
    tod_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string rcv = 8;
inline bool MMSStat::has_rcv() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MMSStat::set_has_rcv() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MMSStat::clear_has_rcv() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MMSStat::clear_rcv() {
  if (rcv_ != &::google::protobuf::internal::kEmptyString) {
    rcv_->clear();
  }
  clear_has_rcv();
}
inline const ::std::string& MMSStat::rcv() const {
  return *rcv_;
}
inline void MMSStat::set_rcv(const ::std::string& value) {
  set_has_rcv();
  if (rcv_ == &::google::protobuf::internal::kEmptyString) {
    rcv_ = new ::std::string;
  }
  rcv_->assign(value);
}
inline void MMSStat::set_rcv(const char* value) {
  set_has_rcv();
  if (rcv_ == &::google::protobuf::internal::kEmptyString) {
    rcv_ = new ::std::string;
  }
  rcv_->assign(value);
}
inline void MMSStat::set_rcv(const char* value, size_t size) {
  set_has_rcv();
  if (rcv_ == &::google::protobuf::internal::kEmptyString) {
    rcv_ = new ::std::string;
  }
  rcv_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSStat::mutable_rcv() {
  set_has_rcv();
  if (rcv_ == &::google::protobuf::internal::kEmptyString) {
    rcv_ = new ::std::string;
  }
  return rcv_;
}
inline ::std::string* MMSStat::release_rcv() {
  clear_has_rcv();
  if (rcv_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rcv_;
    rcv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MMSStat::set_allocated_rcv(::std::string* rcv) {
  if (rcv_ != &::google::protobuf::internal::kEmptyString) {
    delete rcv_;
  }
  if (rcv) {
    set_has_rcv();
    rcv_ = rcv;
  } else {
    clear_has_rcv();
    rcv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string brd = 9;
inline bool MMSStat::has_brd() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MMSStat::set_has_brd() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MMSStat::clear_has_brd() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MMSStat::clear_brd() {
  if (brd_ != &::google::protobuf::internal::kEmptyString) {
    brd_->clear();
  }
  clear_has_brd();
}
inline const ::std::string& MMSStat::brd() const {
  return *brd_;
}
inline void MMSStat::set_brd(const ::std::string& value) {
  set_has_brd();
  if (brd_ == &::google::protobuf::internal::kEmptyString) {
    brd_ = new ::std::string;
  }
  brd_->assign(value);
}
inline void MMSStat::set_brd(const char* value) {
  set_has_brd();
  if (brd_ == &::google::protobuf::internal::kEmptyString) {
    brd_ = new ::std::string;
  }
  brd_->assign(value);
}
inline void MMSStat::set_brd(const char* value, size_t size) {
  set_has_brd();
  if (brd_ == &::google::protobuf::internal::kEmptyString) {
    brd_ = new ::std::string;
  }
  brd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSStat::mutable_brd() {
  set_has_brd();
  if (brd_ == &::google::protobuf::internal::kEmptyString) {
    brd_ = new ::std::string;
  }
  return brd_;
}
inline ::std::string* MMSStat::release_brd() {
  clear_has_brd();
  if (brd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brd_;
    brd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MMSStat::set_allocated_brd(::std::string* brd) {
  if (brd_ != &::google::protobuf::internal::kEmptyString) {
    delete brd_;
  }
  if (brd) {
    set_has_brd();
    brd_ = brd;
  } else {
    clear_has_brd();
    brd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string wbddc = 10;
inline bool MMSStat::has_wbddc() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MMSStat::set_has_wbddc() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MMSStat::clear_has_wbddc() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MMSStat::clear_wbddc() {
  if (wbddc_ != &::google::protobuf::internal::kEmptyString) {
    wbddc_->clear();
  }
  clear_has_wbddc();
}
inline const ::std::string& MMSStat::wbddc() const {
  return *wbddc_;
}
inline void MMSStat::set_wbddc(const ::std::string& value) {
  set_has_wbddc();
  if (wbddc_ == &::google::protobuf::internal::kEmptyString) {
    wbddc_ = new ::std::string;
  }
  wbddc_->assign(value);
}
inline void MMSStat::set_wbddc(const char* value) {
  set_has_wbddc();
  if (wbddc_ == &::google::protobuf::internal::kEmptyString) {
    wbddc_ = new ::std::string;
  }
  wbddc_->assign(value);
}
inline void MMSStat::set_wbddc(const char* value, size_t size) {
  set_has_wbddc();
  if (wbddc_ == &::google::protobuf::internal::kEmptyString) {
    wbddc_ = new ::std::string;
  }
  wbddc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSStat::mutable_wbddc() {
  set_has_wbddc();
  if (wbddc_ == &::google::protobuf::internal::kEmptyString) {
    wbddc_ = new ::std::string;
  }
  return wbddc_;
}
inline ::std::string* MMSStat::release_wbddc() {
  clear_has_wbddc();
  if (wbddc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = wbddc_;
    wbddc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MMSStat::set_allocated_wbddc(::std::string* wbddc) {
  if (wbddc_ != &::google::protobuf::internal::kEmptyString) {
    delete wbddc_;
  }
  if (wbddc) {
    set_has_wbddc();
    wbddc_ = wbddc;
  } else {
    clear_has_wbddc();
    wbddc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string out = 11;
inline bool MMSStat::has_out() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MMSStat::set_has_out() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MMSStat::clear_has_out() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MMSStat::clear_out() {
  if (out_ != &::google::protobuf::internal::kEmptyString) {
    out_->clear();
  }
  clear_has_out();
}
inline const ::std::string& MMSStat::out() const {
  return *out_;
}
inline void MMSStat::set_out(const ::std::string& value) {
  set_has_out();
  if (out_ == &::google::protobuf::internal::kEmptyString) {
    out_ = new ::std::string;
  }
  out_->assign(value);
}
inline void MMSStat::set_out(const char* value) {
  set_has_out();
  if (out_ == &::google::protobuf::internal::kEmptyString) {
    out_ = new ::std::string;
  }
  out_->assign(value);
}
inline void MMSStat::set_out(const char* value, size_t size) {
  set_has_out();
  if (out_ == &::google::protobuf::internal::kEmptyString) {
    out_ = new ::std::string;
  }
  out_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSStat::mutable_out() {
  set_has_out();
  if (out_ == &::google::protobuf::internal::kEmptyString) {
    out_ = new ::std::string;
  }
  return out_;
}
inline ::std::string* MMSStat::release_out() {
  clear_has_out();
  if (out_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = out_;
    out_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MMSStat::set_allocated_out(::std::string* out) {
  if (out_ != &::google::protobuf::internal::kEmptyString) {
    delete out_;
  }
  if (out) {
    set_has_out();
    out_ = out;
  } else {
    clear_has_out();
    out_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string temp = 12;
inline bool MMSStat::has_temp() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MMSStat::set_has_temp() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MMSStat::clear_has_temp() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MMSStat::clear_temp() {
  if (temp_ != &::google::protobuf::internal::kEmptyString) {
    temp_->clear();
  }
  clear_has_temp();
}
inline const ::std::string& MMSStat::temp() const {
  return *temp_;
}
inline void MMSStat::set_temp(const ::std::string& value) {
  set_has_temp();
  if (temp_ == &::google::protobuf::internal::kEmptyString) {
    temp_ = new ::std::string;
  }
  temp_->assign(value);
}
inline void MMSStat::set_temp(const char* value) {
  set_has_temp();
  if (temp_ == &::google::protobuf::internal::kEmptyString) {
    temp_ = new ::std::string;
  }
  temp_->assign(value);
}
inline void MMSStat::set_temp(const char* value, size_t size) {
  set_has_temp();
  if (temp_ == &::google::protobuf::internal::kEmptyString) {
    temp_ = new ::std::string;
  }
  temp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSStat::mutable_temp() {
  set_has_temp();
  if (temp_ == &::google::protobuf::internal::kEmptyString) {
    temp_ = new ::std::string;
  }
  return temp_;
}
inline ::std::string* MMSStat::release_temp() {
  clear_has_temp();
  if (temp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = temp_;
    temp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MMSStat::set_allocated_temp(::std::string* temp) {
  if (temp_ != &::google::protobuf::internal::kEmptyString) {
    delete temp_;
  }
  if (temp) {
    set_has_temp();
    temp_ = temp;
  } else {
    clear_has_temp();
    temp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 id2 = 13;
inline bool MMSStat::has_id2() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MMSStat::set_has_id2() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MMSStat::clear_has_id2() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MMSStat::clear_id2() {
  id2_ = 0;
  clear_has_id2();
}
inline ::google::protobuf::int32 MMSStat::id2() const {
  return id2_;
}
inline void MMSStat::set_id2(::google::protobuf::int32 value) {
  set_has_id2();
  id2_ = value;
}

// optional string conn2 = 14;
inline bool MMSStat::has_conn2() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MMSStat::set_has_conn2() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MMSStat::clear_has_conn2() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MMSStat::clear_conn2() {
  if (conn2_ != &::google::protobuf::internal::kEmptyString) {
    conn2_->clear();
  }
  clear_has_conn2();
}
inline const ::std::string& MMSStat::conn2() const {
  return *conn2_;
}
inline void MMSStat::set_conn2(const ::std::string& value) {
  set_has_conn2();
  if (conn2_ == &::google::protobuf::internal::kEmptyString) {
    conn2_ = new ::std::string;
  }
  conn2_->assign(value);
}
inline void MMSStat::set_conn2(const char* value) {
  set_has_conn2();
  if (conn2_ == &::google::protobuf::internal::kEmptyString) {
    conn2_ = new ::std::string;
  }
  conn2_->assign(value);
}
inline void MMSStat::set_conn2(const char* value, size_t size) {
  set_has_conn2();
  if (conn2_ == &::google::protobuf::internal::kEmptyString) {
    conn2_ = new ::std::string;
  }
  conn2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSStat::mutable_conn2() {
  set_has_conn2();
  if (conn2_ == &::google::protobuf::internal::kEmptyString) {
    conn2_ = new ::std::string;
  }
  return conn2_;
}
inline ::std::string* MMSStat::release_conn2() {
  clear_has_conn2();
  if (conn2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = conn2_;
    conn2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MMSStat::set_allocated_conn2(::std::string* conn2) {
  if (conn2_ != &::google::protobuf::internal::kEmptyString) {
    delete conn2_;
  }
  if (conn2) {
    set_has_conn2();
    conn2_ = conn2;
  } else {
    clear_has_conn2();
    conn2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string rcv2 = 15;
inline bool MMSStat::has_rcv2() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MMSStat::set_has_rcv2() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MMSStat::clear_has_rcv2() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MMSStat::clear_rcv2() {
  if (rcv2_ != &::google::protobuf::internal::kEmptyString) {
    rcv2_->clear();
  }
  clear_has_rcv2();
}
inline const ::std::string& MMSStat::rcv2() const {
  return *rcv2_;
}
inline void MMSStat::set_rcv2(const ::std::string& value) {
  set_has_rcv2();
  if (rcv2_ == &::google::protobuf::internal::kEmptyString) {
    rcv2_ = new ::std::string;
  }
  rcv2_->assign(value);
}
inline void MMSStat::set_rcv2(const char* value) {
  set_has_rcv2();
  if (rcv2_ == &::google::protobuf::internal::kEmptyString) {
    rcv2_ = new ::std::string;
  }
  rcv2_->assign(value);
}
inline void MMSStat::set_rcv2(const char* value, size_t size) {
  set_has_rcv2();
  if (rcv2_ == &::google::protobuf::internal::kEmptyString) {
    rcv2_ = new ::std::string;
  }
  rcv2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSStat::mutable_rcv2() {
  set_has_rcv2();
  if (rcv2_ == &::google::protobuf::internal::kEmptyString) {
    rcv2_ = new ::std::string;
  }
  return rcv2_;
}
inline ::std::string* MMSStat::release_rcv2() {
  clear_has_rcv2();
  if (rcv2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rcv2_;
    rcv2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MMSStat::set_allocated_rcv2(::std::string* rcv2) {
  if (rcv2_ != &::google::protobuf::internal::kEmptyString) {
    delete rcv2_;
  }
  if (rcv2) {
    set_has_rcv2();
    rcv2_ = rcv2;
  } else {
    clear_has_rcv2();
    rcv2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string wbddc2 = 16;
inline bool MMSStat::has_wbddc2() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MMSStat::set_has_wbddc2() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MMSStat::clear_has_wbddc2() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MMSStat::clear_wbddc2() {
  if (wbddc2_ != &::google::protobuf::internal::kEmptyString) {
    wbddc2_->clear();
  }
  clear_has_wbddc2();
}
inline const ::std::string& MMSStat::wbddc2() const {
  return *wbddc2_;
}
inline void MMSStat::set_wbddc2(const ::std::string& value) {
  set_has_wbddc2();
  if (wbddc2_ == &::google::protobuf::internal::kEmptyString) {
    wbddc2_ = new ::std::string;
  }
  wbddc2_->assign(value);
}
inline void MMSStat::set_wbddc2(const char* value) {
  set_has_wbddc2();
  if (wbddc2_ == &::google::protobuf::internal::kEmptyString) {
    wbddc2_ = new ::std::string;
  }
  wbddc2_->assign(value);
}
inline void MMSStat::set_wbddc2(const char* value, size_t size) {
  set_has_wbddc2();
  if (wbddc2_ == &::google::protobuf::internal::kEmptyString) {
    wbddc2_ = new ::std::string;
  }
  wbddc2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSStat::mutable_wbddc2() {
  set_has_wbddc2();
  if (wbddc2_ == &::google::protobuf::internal::kEmptyString) {
    wbddc2_ = new ::std::string;
  }
  return wbddc2_;
}
inline ::std::string* MMSStat::release_wbddc2() {
  clear_has_wbddc2();
  if (wbddc2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = wbddc2_;
    wbddc2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MMSStat::set_allocated_wbddc2(::std::string* wbddc2) {
  if (wbddc2_ != &::google::protobuf::internal::kEmptyString) {
    delete wbddc2_;
  }
  if (wbddc2) {
    set_has_wbddc2();
    wbddc2_ = wbddc2;
  } else {
    clear_has_wbddc2();
    wbddc2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string out2 = 17;
inline bool MMSStat::has_out2() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MMSStat::set_has_out2() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MMSStat::clear_has_out2() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MMSStat::clear_out2() {
  if (out2_ != &::google::protobuf::internal::kEmptyString) {
    out2_->clear();
  }
  clear_has_out2();
}
inline const ::std::string& MMSStat::out2() const {
  return *out2_;
}
inline void MMSStat::set_out2(const ::std::string& value) {
  set_has_out2();
  if (out2_ == &::google::protobuf::internal::kEmptyString) {
    out2_ = new ::std::string;
  }
  out2_->assign(value);
}
inline void MMSStat::set_out2(const char* value) {
  set_has_out2();
  if (out2_ == &::google::protobuf::internal::kEmptyString) {
    out2_ = new ::std::string;
  }
  out2_->assign(value);
}
inline void MMSStat::set_out2(const char* value, size_t size) {
  set_has_out2();
  if (out2_ == &::google::protobuf::internal::kEmptyString) {
    out2_ = new ::std::string;
  }
  out2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSStat::mutable_out2() {
  set_has_out2();
  if (out2_ == &::google::protobuf::internal::kEmptyString) {
    out2_ = new ::std::string;
  }
  return out2_;
}
inline ::std::string* MMSStat::release_out2() {
  clear_has_out2();
  if (out2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = out2_;
    out2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MMSStat::set_allocated_out2(::std::string* out2) {
  if (out2_ != &::google::protobuf::internal::kEmptyString) {
    delete out2_;
  }
  if (out2) {
    set_has_out2();
    out2_ = out2;
  } else {
    clear_has_out2();
    out2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string wdt = 18;
inline bool MMSStat::has_wdt() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MMSStat::set_has_wdt() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MMSStat::clear_has_wdt() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MMSStat::clear_wdt() {
  if (wdt_ != &::google::protobuf::internal::kEmptyString) {
    wdt_->clear();
  }
  clear_has_wdt();
}
inline const ::std::string& MMSStat::wdt() const {
  return *wdt_;
}
inline void MMSStat::set_wdt(const ::std::string& value) {
  set_has_wdt();
  if (wdt_ == &::google::protobuf::internal::kEmptyString) {
    wdt_ = new ::std::string;
  }
  wdt_->assign(value);
}
inline void MMSStat::set_wdt(const char* value) {
  set_has_wdt();
  if (wdt_ == &::google::protobuf::internal::kEmptyString) {
    wdt_ = new ::std::string;
  }
  wdt_->assign(value);
}
inline void MMSStat::set_wdt(const char* value, size_t size) {
  set_has_wdt();
  if (wdt_ == &::google::protobuf::internal::kEmptyString) {
    wdt_ = new ::std::string;
  }
  wdt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSStat::mutable_wdt() {
  set_has_wdt();
  if (wdt_ == &::google::protobuf::internal::kEmptyString) {
    wdt_ = new ::std::string;
  }
  return wdt_;
}
inline ::std::string* MMSStat::release_wdt() {
  clear_has_wdt();
  if (wdt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = wdt_;
    wdt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MMSStat::set_allocated_wdt(::std::string* wdt) {
  if (wdt_ != &::google::protobuf::internal::kEmptyString) {
    delete wdt_;
  }
  if (wdt) {
    set_has_wdt();
    wdt_ = wdt;
  } else {
    clear_has_wdt();
    wdt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 line = 19;
inline bool MMSStat::has_line() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MMSStat::set_has_line() {
  _has_bits_[0] |= 0x00040000u;
}
inline void MMSStat::clear_has_line() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void MMSStat::clear_line() {
  line_ = 0;
  clear_has_line();
}
inline ::google::protobuf::int32 MMSStat::line() const {
  return line_;
}
inline void MMSStat::set_line(::google::protobuf::int32 value) {
  set_has_line();
  line_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace falcon_receiver_msg

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_receiver_msg::ReceiverRequest_Action>() {
  return ::falcon_receiver_msg::ReceiverRequest_Action_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_receiver_msg::ReceiverRequest_Property>() {
  return ::falcon_receiver_msg::ReceiverRequest_Property_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_receiver_msg::ReceiverResponse_Status>() {
  return ::falcon_receiver_msg::ReceiverResponse_Status_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_receiver_msg::UniqueRXIDRequest_Action>() {
  return ::falcon_receiver_msg::UniqueRXIDRequest_Action_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_FalconReceiverMessages_2eproto__INCLUDED
