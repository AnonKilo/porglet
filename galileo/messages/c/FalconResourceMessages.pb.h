// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FalconResourceMessages.proto

#ifndef PROTOBUF_FalconResourceMessages_2eproto__INCLUDED
#define PROTOBUF_FalconResourceMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace falcon_res_msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_FalconResourceMessages_2eproto();
void protobuf_AssignDesc_FalconResourceMessages_2eproto();
void protobuf_ShutdownFile_FalconResourceMessages_2eproto();

class DummyRcvConfig;
class PICConfig;
class MMSConfig;
class ZACQConfig;
class USRPRxTxConfig;
class EPIQRxTxConfig;
class RTLSDRConfig;
class USRPRxConfig;
class PentekConfig;
class USRPTxConfig;
class RFSwitchConfig;
class RFSwitchSerialConfig;
class CPSwitchConfig;
class AntennaConfig;
class RotorRPMConfig;
class RotorProtatorConfig;
class RotorProsistelConfig;
class RotorEzrotorConfig;
class RotorHGIOConfig;
class RotorESAConfig;
class DSSwitchConfig;
class DummyConfig;
class MMSXTConfig;
class AmpConfig;

enum PentekConfig_SiggenType {
  PentekConfig_SiggenType_ROHDE_SCHWARZ = 0,
  PentekConfig_SiggenType_MMS_MUP = 1
};
bool PentekConfig_SiggenType_IsValid(int value);
const PentekConfig_SiggenType PentekConfig_SiggenType_SiggenType_MIN = PentekConfig_SiggenType_ROHDE_SCHWARZ;
const PentekConfig_SiggenType PentekConfig_SiggenType_SiggenType_MAX = PentekConfig_SiggenType_MMS_MUP;
const int PentekConfig_SiggenType_SiggenType_ARRAYSIZE = PentekConfig_SiggenType_SiggenType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PentekConfig_SiggenType_descriptor();
inline const ::std::string& PentekConfig_SiggenType_Name(PentekConfig_SiggenType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PentekConfig_SiggenType_descriptor(), value);
}
inline bool PentekConfig_SiggenType_Parse(
    const ::std::string& name, PentekConfig_SiggenType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PentekConfig_SiggenType>(
    PentekConfig_SiggenType_descriptor(), name, value);
}
// ===================================================================

class DummyRcvConfig : public ::google::protobuf::Message {
 public:
  DummyRcvConfig();
  virtual ~DummyRcvConfig();

  DummyRcvConfig(const DummyRcvConfig& from);

  inline DummyRcvConfig& operator=(const DummyRcvConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DummyRcvConfig& default_instance();

  void Swap(DummyRcvConfig* other);

  // implements Message ----------------------------------------------

  DummyRcvConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DummyRcvConfig& from);
  void MergeFrom(const DummyRcvConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "DUMMYRCV_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional int32 baseAux = 3;
  inline bool has_baseaux() const;
  inline void clear_baseaux();
  static const int kBaseAuxFieldNumber = 3;
  inline ::google::protobuf::int32 baseaux() const;
  inline void set_baseaux(::google::protobuf::int32 value);

  // optional string rx = 4;
  inline bool has_rx() const;
  inline void clear_rx();
  static const int kRxFieldNumber = 4;
  inline const ::std::string& rx() const;
  inline void set_rx(const ::std::string& value);
  inline void set_rx(const char* value);
  inline void set_rx(const char* value, size_t size);
  inline ::std::string* mutable_rx();
  inline ::std::string* release_rx();
  inline void set_allocated_rx(::std::string* rx);

  // optional string host = 5 [default = "local"];
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 5;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  inline void set_allocated_host(::std::string* host);

  // optional float fs = 6 [default = 1e+08];
  inline bool has_fs() const;
  inline void clear_fs();
  static const int kFsFieldNumber = 6;
  inline float fs() const;
  inline void set_fs(float value);

  // optional float minRF = 7 [default = 2e+07];
  inline bool has_minrf() const;
  inline void clear_minrf();
  static const int kMinRFFieldNumber = 7;
  inline float minrf() const;
  inline void set_minrf(float value);

  // optional float maxRF = 8 [default = 3e+09];
  inline bool has_maxrf() const;
  inline void clear_maxrf();
  static const int kMaxRFFieldNumber = 8;
  inline float maxrf() const;
  inline void set_maxrf(float value);

  // optional string uniqRXID = 9 [default = "999"];
  inline bool has_uniqrxid() const;
  inline void clear_uniqrxid();
  static const int kUniqRXIDFieldNumber = 9;
  inline const ::std::string& uniqrxid() const;
  inline void set_uniqrxid(const ::std::string& value);
  inline void set_uniqrxid(const char* value);
  inline void set_uniqrxid(const char* value, size_t size);
  inline ::std::string* mutable_uniqrxid();
  inline ::std::string* release_uniqrxid();
  inline void set_allocated_uniqrxid(::std::string* uniqrxid);

  // optional int32 pair = 10;
  inline bool has_pair() const;
  inline void clear_pair();
  static const int kPairFieldNumber = 10;
  inline ::google::protobuf::int32 pair() const;
  inline void set_pair(::google::protobuf::int32 value);

  // optional int32 testDur = 11;
  inline bool has_testdur() const;
  inline void clear_testdur();
  static const int kTestDurFieldNumber = 11;
  inline ::google::protobuf::int32 testdur() const;
  inline void set_testdur(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_res_msg.DummyRcvConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_baseaux();
  inline void clear_has_baseaux();
  inline void set_has_rx();
  inline void clear_has_rx();
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_fs();
  inline void clear_has_fs();
  inline void set_has_minrf();
  inline void clear_has_minrf();
  inline void set_has_maxrf();
  inline void clear_has_maxrf();
  inline void set_has_uniqrxid();
  inline void clear_has_uniqrxid();
  inline void set_has_pair();
  inline void clear_has_pair();
  inline void set_has_testdur();
  inline void clear_has_testdur();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 channel_;
  ::google::protobuf::int32 baseaux_;
  ::std::string* rx_;
  ::std::string* host_;
  static ::std::string* _default_host_;
  float fs_;
  float minrf_;
  ::std::string* uniqrxid_;
  static ::std::string* _default_uniqrxid_;
  float maxrf_;
  ::google::protobuf::int32 pair_;
  ::google::protobuf::int32 testdur_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_FalconResourceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconResourceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconResourceMessages_2eproto();

  void InitAsDefaultInstance();
  static DummyRcvConfig* default_instance_;
};
// -------------------------------------------------------------------

class PICConfig : public ::google::protobuf::Message {
 public:
  PICConfig();
  virtual ~PICConfig();

  PICConfig(const PICConfig& from);

  inline PICConfig& operator=(const PICConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PICConfig& default_instance();

  void Swap(PICConfig* other);

  // implements Message ----------------------------------------------

  PICConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PICConfig& from);
  void MergeFrom(const PICConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "PIC_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional int32 baseAux = 3;
  inline bool has_baseaux() const;
  inline void clear_baseaux();
  static const int kBaseAuxFieldNumber = 3;
  inline ::google::protobuf::int32 baseaux() const;
  inline void set_baseaux(::google::protobuf::int32 value);

  // optional string rx = 4;
  inline bool has_rx() const;
  inline void clear_rx();
  static const int kRxFieldNumber = 4;
  inline const ::std::string& rx() const;
  inline void set_rx(const ::std::string& value);
  inline void set_rx(const char* value);
  inline void set_rx(const char* value, size_t size);
  inline ::std::string* mutable_rx();
  inline ::std::string* release_rx();
  inline void set_allocated_rx(::std::string* rx);

  // optional string pic = 5;
  inline bool has_pic() const;
  inline void clear_pic();
  static const int kPicFieldNumber = 5;
  inline const ::std::string& pic() const;
  inline void set_pic(const ::std::string& value);
  inline void set_pic(const char* value);
  inline void set_pic(const char* value, size_t size);
  inline ::std::string* mutable_pic();
  inline ::std::string* release_pic();
  inline void set_allocated_pic(::std::string* pic);

  // optional string picflags = 6;
  inline bool has_picflags() const;
  inline void clear_picflags();
  static const int kPicflagsFieldNumber = 6;
  inline const ::std::string& picflags() const;
  inline void set_picflags(const ::std::string& value);
  inline void set_picflags(const char* value);
  inline void set_picflags(const char* value, size_t size);
  inline ::std::string* mutable_picflags();
  inline ::std::string* release_picflags();
  inline void set_allocated_picflags(::std::string* picflags);

  // optional string picside = 7;
  inline bool has_picside() const;
  inline void clear_picside();
  static const int kPicsideFieldNumber = 7;
  inline const ::std::string& picside() const;
  inline void set_picside(const ::std::string& value);
  inline void set_picside(const char* value);
  inline void set_picside(const char* value, size_t size);
  inline ::std::string* mutable_picside();
  inline ::std::string* release_picside();
  inline void set_allocated_picside(::std::string* picside);

  // optional string host = 8 [default = "local"];
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 8;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  inline void set_allocated_host(::std::string* host);

  // optional float fs = 9 [default = 1e+08];
  inline bool has_fs() const;
  inline void clear_fs();
  static const int kFsFieldNumber = 9;
  inline float fs() const;
  inline void set_fs(float value);

  // optional float minRF = 10 [default = 2e+07];
  inline bool has_minrf() const;
  inline void clear_minrf();
  static const int kMinRFFieldNumber = 10;
  inline float minrf() const;
  inline void set_minrf(float value);

  // optional float maxRF = 11 [default = 3e+09];
  inline bool has_maxrf() const;
  inline void clear_maxrf();
  static const int kMaxRFFieldNumber = 11;
  inline float maxrf() const;
  inline void set_maxrf(float value);

  // optional string uniqRXID = 12 [default = "999"];
  inline bool has_uniqrxid() const;
  inline void clear_uniqrxid();
  static const int kUniqRXIDFieldNumber = 12;
  inline const ::std::string& uniqrxid() const;
  inline void set_uniqrxid(const ::std::string& value);
  inline void set_uniqrxid(const char* value);
  inline void set_uniqrxid(const char* value, size_t size);
  inline ::std::string* mutable_uniqrxid();
  inline ::std::string* release_uniqrxid();
  inline void set_allocated_uniqrxid(::std::string* uniqrxid);

  // optional int32 pair = 13;
  inline bool has_pair() const;
  inline void clear_pair();
  static const int kPairFieldNumber = 13;
  inline ::google::protobuf::int32 pair() const;
  inline void set_pair(::google::protobuf::int32 value);

  // optional int32 testDur = 14;
  inline bool has_testdur() const;
  inline void clear_testdur();
  static const int kTestDurFieldNumber = 14;
  inline ::google::protobuf::int32 testdur() const;
  inline void set_testdur(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_res_msg.PICConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_baseaux();
  inline void clear_has_baseaux();
  inline void set_has_rx();
  inline void clear_has_rx();
  inline void set_has_pic();
  inline void clear_has_pic();
  inline void set_has_picflags();
  inline void clear_has_picflags();
  inline void set_has_picside();
  inline void clear_has_picside();
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_fs();
  inline void clear_has_fs();
  inline void set_has_minrf();
  inline void clear_has_minrf();
  inline void set_has_maxrf();
  inline void clear_has_maxrf();
  inline void set_has_uniqrxid();
  inline void clear_has_uniqrxid();
  inline void set_has_pair();
  inline void clear_has_pair();
  inline void set_has_testdur();
  inline void clear_has_testdur();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 channel_;
  ::google::protobuf::int32 baseaux_;
  ::std::string* rx_;
  ::std::string* pic_;
  ::std::string* picflags_;
  ::std::string* picside_;
  ::std::string* host_;
  static ::std::string* _default_host_;
  float fs_;
  float minrf_;
  ::std::string* uniqrxid_;
  static ::std::string* _default_uniqrxid_;
  float maxrf_;
  ::google::protobuf::int32 pair_;
  ::google::protobuf::int32 testdur_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_FalconResourceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconResourceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconResourceMessages_2eproto();

  void InitAsDefaultInstance();
  static PICConfig* default_instance_;
};
// -------------------------------------------------------------------

class MMSConfig : public ::google::protobuf::Message {
 public:
  MMSConfig();
  virtual ~MMSConfig();

  MMSConfig(const MMSConfig& from);

  inline MMSConfig& operator=(const MMSConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MMSConfig& default_instance();

  void Swap(MMSConfig* other);

  // implements Message ----------------------------------------------

  MMSConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MMSConfig& from);
  void MergeFrom(const MMSConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "MMS_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional int32 baseAux = 3;
  inline bool has_baseaux() const;
  inline void clear_baseaux();
  static const int kBaseAuxFieldNumber = 3;
  inline ::google::protobuf::int32 baseaux() const;
  inline void set_baseaux(::google::protobuf::int32 value);

  // optional string IP = 4;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIPFieldNumber = 4;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional int32 controlPort = 5;
  inline bool has_controlport() const;
  inline void clear_controlport();
  static const int kControlPortFieldNumber = 5;
  inline ::google::protobuf::int32 controlport() const;
  inline void set_controlport(::google::protobuf::int32 value);

  // optional int32 dataPort = 6;
  inline bool has_dataport() const;
  inline void clear_dataport();
  static const int kDataPortFieldNumber = 6;
  inline ::google::protobuf::int32 dataport() const;
  inline void set_dataport(::google::protobuf::int32 value);

  // optional string interfaceIP = 7;
  inline bool has_interfaceip() const;
  inline void clear_interfaceip();
  static const int kInterfaceIPFieldNumber = 7;
  inline const ::std::string& interfaceip() const;
  inline void set_interfaceip(const ::std::string& value);
  inline void set_interfaceip(const char* value);
  inline void set_interfaceip(const char* value, size_t size);
  inline ::std::string* mutable_interfaceip();
  inline ::std::string* release_interfaceip();
  inline void set_allocated_interfaceip(::std::string* interfaceip);

  // optional int32 receiver = 8;
  inline bool has_receiver() const;
  inline void clear_receiver();
  static const int kReceiverFieldNumber = 8;
  inline ::google::protobuf::int32 receiver() const;
  inline void set_receiver(::google::protobuf::int32 value);

  // optional string host = 9 [default = "local"];
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 9;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  inline void set_allocated_host(::std::string* host);

  // optional float fs = 10 [default = 1e+08];
  inline bool has_fs() const;
  inline void clear_fs();
  static const int kFsFieldNumber = 10;
  inline float fs() const;
  inline void set_fs(float value);

  // optional float minRF = 11 [default = 2e+07];
  inline bool has_minrf() const;
  inline void clear_minrf();
  static const int kMinRFFieldNumber = 11;
  inline float minrf() const;
  inline void set_minrf(float value);

  // optional float maxRF = 12 [default = 3e+09];
  inline bool has_maxrf() const;
  inline void clear_maxrf();
  static const int kMaxRFFieldNumber = 12;
  inline float maxrf() const;
  inline void set_maxrf(float value);

  // optional string cal30abw = 13 [default = "mms_30abw.csv"];
  inline bool has_cal30abw() const;
  inline void clear_cal30abw();
  static const int kCal30AbwFieldNumber = 13;
  inline const ::std::string& cal30abw() const;
  inline void set_cal30abw(const ::std::string& value);
  inline void set_cal30abw(const char* value);
  inline void set_cal30abw(const char* value, size_t size);
  inline ::std::string* mutable_cal30abw();
  inline ::std::string* release_cal30abw();
  inline void set_allocated_cal30abw(::std::string* cal30abw);

  // optional string cal5abw = 14 [default = "mms_5abw.csv"];
  inline bool has_cal5abw() const;
  inline void clear_cal5abw();
  static const int kCal5AbwFieldNumber = 14;
  inline const ::std::string& cal5abw() const;
  inline void set_cal5abw(const ::std::string& value);
  inline void set_cal5abw(const char* value);
  inline void set_cal5abw(const char* value, size_t size);
  inline ::std::string* mutable_cal5abw();
  inline ::std::string* release_cal5abw();
  inline void set_allocated_cal5abw(::std::string* cal5abw);

  // optional string uniqRXID = 15 [default = "999"];
  inline bool has_uniqrxid() const;
  inline void clear_uniqrxid();
  static const int kUniqRXIDFieldNumber = 15;
  inline const ::std::string& uniqrxid() const;
  inline void set_uniqrxid(const ::std::string& value);
  inline void set_uniqrxid(const char* value);
  inline void set_uniqrxid(const char* value, size_t size);
  inline ::std::string* mutable_uniqrxid();
  inline ::std::string* release_uniqrxid();
  inline void set_allocated_uniqrxid(::std::string* uniqrxid);

  // optional int32 pair = 16;
  inline bool has_pair() const;
  inline void clear_pair();
  static const int kPairFieldNumber = 16;
  inline ::google::protobuf::int32 pair() const;
  inline void set_pair(::google::protobuf::int32 value);

  // optional int32 testDur = 17;
  inline bool has_testdur() const;
  inline void clear_testdur();
  static const int kTestDurFieldNumber = 17;
  inline ::google::protobuf::int32 testdur() const;
  inline void set_testdur(::google::protobuf::int32 value);

  // optional int32 rfcuPort = 18 [default = -1];
  inline bool has_rfcuport() const;
  inline void clear_rfcuport();
  static const int kRfcuPortFieldNumber = 18;
  inline ::google::protobuf::int32 rfcuport() const;
  inline void set_rfcuport(::google::protobuf::int32 value);

  // optional string rfcuIP = 19 [default = ""];
  inline bool has_rfcuip() const;
  inline void clear_rfcuip();
  static const int kRfcuIPFieldNumber = 19;
  inline const ::std::string& rfcuip() const;
  inline void set_rfcuip(const ::std::string& value);
  inline void set_rfcuip(const char* value);
  inline void set_rfcuip(const char* value, size_t size);
  inline ::std::string* mutable_rfcuip();
  inline ::std::string* release_rfcuip();
  inline void set_allocated_rfcuip(::std::string* rfcuip);

  // @@protoc_insertion_point(class_scope:falcon_res_msg.MMSConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_baseaux();
  inline void clear_has_baseaux();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_controlport();
  inline void clear_has_controlport();
  inline void set_has_dataport();
  inline void clear_has_dataport();
  inline void set_has_interfaceip();
  inline void clear_has_interfaceip();
  inline void set_has_receiver();
  inline void clear_has_receiver();
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_fs();
  inline void clear_has_fs();
  inline void set_has_minrf();
  inline void clear_has_minrf();
  inline void set_has_maxrf();
  inline void clear_has_maxrf();
  inline void set_has_cal30abw();
  inline void clear_has_cal30abw();
  inline void set_has_cal5abw();
  inline void clear_has_cal5abw();
  inline void set_has_uniqrxid();
  inline void clear_has_uniqrxid();
  inline void set_has_pair();
  inline void clear_has_pair();
  inline void set_has_testdur();
  inline void clear_has_testdur();
  inline void set_has_rfcuport();
  inline void clear_has_rfcuport();
  inline void set_has_rfcuip();
  inline void clear_has_rfcuip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 channel_;
  ::google::protobuf::int32 baseaux_;
  ::std::string* ip_;
  ::google::protobuf::int32 controlport_;
  ::google::protobuf::int32 dataport_;
  ::std::string* interfaceip_;
  ::std::string* host_;
  static ::std::string* _default_host_;
  ::google::protobuf::int32 receiver_;
  float fs_;
  float minrf_;
  float maxrf_;
  ::std::string* cal30abw_;
  static ::std::string* _default_cal30abw_;
  ::std::string* cal5abw_;
  static ::std::string* _default_cal5abw_;
  ::std::string* uniqrxid_;
  static ::std::string* _default_uniqrxid_;
  ::google::protobuf::int32 pair_;
  ::google::protobuf::int32 testdur_;
  ::std::string* rfcuip_;
  ::google::protobuf::int32 rfcuport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  friend void  protobuf_AddDesc_FalconResourceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconResourceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconResourceMessages_2eproto();

  void InitAsDefaultInstance();
  static MMSConfig* default_instance_;
};
// -------------------------------------------------------------------

class ZACQConfig : public ::google::protobuf::Message {
 public:
  ZACQConfig();
  virtual ~ZACQConfig();

  ZACQConfig(const ZACQConfig& from);

  inline ZACQConfig& operator=(const ZACQConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ZACQConfig& default_instance();

  void Swap(ZACQConfig* other);

  // implements Message ----------------------------------------------

  ZACQConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ZACQConfig& from);
  void MergeFrom(const ZACQConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ZACQ_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional int32 baseAux = 3;
  inline bool has_baseaux() const;
  inline void clear_baseaux();
  static const int kBaseAuxFieldNumber = 3;
  inline ::google::protobuf::int32 baseaux() const;
  inline void set_baseaux(::google::protobuf::int32 value);

  // optional string rx = 4;
  inline bool has_rx() const;
  inline void clear_rx();
  static const int kRxFieldNumber = 4;
  inline const ::std::string& rx() const;
  inline void set_rx(const ::std::string& value);
  inline void set_rx(const char* value);
  inline void set_rx(const char* value, size_t size);
  inline ::std::string* mutable_rx();
  inline ::std::string* release_rx();
  inline void set_allocated_rx(::std::string* rx);

  // optional string host = 5 [default = "local"];
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 5;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  inline void set_allocated_host(::std::string* host);

  // optional float fs = 6 [default = 1e+08];
  inline bool has_fs() const;
  inline void clear_fs();
  static const int kFsFieldNumber = 6;
  inline float fs() const;
  inline void set_fs(float value);

  // optional float minRF = 7 [default = 2e+07];
  inline bool has_minrf() const;
  inline void clear_minrf();
  static const int kMinRFFieldNumber = 7;
  inline float minrf() const;
  inline void set_minrf(float value);

  // optional float maxRF = 8 [default = 3e+09];
  inline bool has_maxrf() const;
  inline void clear_maxrf();
  static const int kMaxRFFieldNumber = 8;
  inline float maxrf() const;
  inline void set_maxrf(float value);

  // optional string uniqRXID = 9 [default = "999"];
  inline bool has_uniqrxid() const;
  inline void clear_uniqrxid();
  static const int kUniqRXIDFieldNumber = 9;
  inline const ::std::string& uniqrxid() const;
  inline void set_uniqrxid(const ::std::string& value);
  inline void set_uniqrxid(const char* value);
  inline void set_uniqrxid(const char* value, size_t size);
  inline ::std::string* mutable_uniqrxid();
  inline ::std::string* release_uniqrxid();
  inline void set_allocated_uniqrxid(::std::string* uniqrxid);

  // optional int32 pair = 10;
  inline bool has_pair() const;
  inline void clear_pair();
  static const int kPairFieldNumber = 10;
  inline ::google::protobuf::int32 pair() const;
  inline void set_pair(::google::protobuf::int32 value);

  // optional int32 testDur = 11;
  inline bool has_testdur() const;
  inline void clear_testdur();
  static const int kTestDurFieldNumber = 11;
  inline ::google::protobuf::int32 testdur() const;
  inline void set_testdur(::google::protobuf::int32 value);

  // optional string initScript = 12;
  inline bool has_initscript() const;
  inline void clear_initscript();
  static const int kInitScriptFieldNumber = 12;
  inline const ::std::string& initscript() const;
  inline void set_initscript(const ::std::string& value);
  inline void set_initscript(const char* value);
  inline void set_initscript(const char* value, size_t size);
  inline ::std::string* mutable_initscript();
  inline ::std::string* release_initscript();
  inline void set_allocated_initscript(::std::string* initscript);

  // @@protoc_insertion_point(class_scope:falcon_res_msg.ZACQConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_baseaux();
  inline void clear_has_baseaux();
  inline void set_has_rx();
  inline void clear_has_rx();
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_fs();
  inline void clear_has_fs();
  inline void set_has_minrf();
  inline void clear_has_minrf();
  inline void set_has_maxrf();
  inline void clear_has_maxrf();
  inline void set_has_uniqrxid();
  inline void clear_has_uniqrxid();
  inline void set_has_pair();
  inline void clear_has_pair();
  inline void set_has_testdur();
  inline void clear_has_testdur();
  inline void set_has_initscript();
  inline void clear_has_initscript();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 channel_;
  ::google::protobuf::int32 baseaux_;
  ::std::string* rx_;
  ::std::string* host_;
  static ::std::string* _default_host_;
  float fs_;
  float minrf_;
  ::std::string* uniqrxid_;
  static ::std::string* _default_uniqrxid_;
  float maxrf_;
  ::google::protobuf::int32 pair_;
  ::std::string* initscript_;
  ::google::protobuf::int32 testdur_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_FalconResourceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconResourceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconResourceMessages_2eproto();

  void InitAsDefaultInstance();
  static ZACQConfig* default_instance_;
};
// -------------------------------------------------------------------

class USRPRxTxConfig : public ::google::protobuf::Message {
 public:
  USRPRxTxConfig();
  virtual ~USRPRxTxConfig();

  USRPRxTxConfig(const USRPRxTxConfig& from);

  inline USRPRxTxConfig& operator=(const USRPRxTxConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const USRPRxTxConfig& default_instance();

  void Swap(USRPRxTxConfig* other);

  // implements Message ----------------------------------------------

  USRPRxTxConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const USRPRxTxConfig& from);
  void MergeFrom(const USRPRxTxConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "USRP_RXTX_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional int32 baseAux = 3;
  inline bool has_baseaux() const;
  inline void clear_baseaux();
  static const int kBaseAuxFieldNumber = 3;
  inline ::google::protobuf::int32 baseaux() const;
  inline void set_baseaux(::google::protobuf::int32 value);

  // optional string args = 4 [default = "addr=192.168.10.2"];
  inline bool has_args() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 4;
  inline const ::std::string& args() const;
  inline void set_args(const ::std::string& value);
  inline void set_args(const char* value);
  inline void set_args(const char* value, size_t size);
  inline ::std::string* mutable_args();
  inline ::std::string* release_args();
  inline void set_allocated_args(::std::string* args);

  // optional float minRF = 5;
  inline bool has_minrf() const;
  inline void clear_minrf();
  static const int kMinRFFieldNumber = 5;
  inline float minrf() const;
  inline void set_minrf(float value);

  // optional float maxRF = 6;
  inline bool has_maxrf() const;
  inline void clear_maxrf();
  static const int kMaxRFFieldNumber = 6;
  inline float maxrf() const;
  inline void set_maxrf(float value);

  // optional float fs = 7 [default = 1e+08];
  inline bool has_fs() const;
  inline void clear_fs();
  static const int kFsFieldNumber = 7;
  inline float fs() const;
  inline void set_fs(float value);

  // optional string uniqRXID = 8 [default = "999"];
  inline bool has_uniqrxid() const;
  inline void clear_uniqrxid();
  static const int kUniqRXIDFieldNumber = 8;
  inline const ::std::string& uniqrxid() const;
  inline void set_uniqrxid(const ::std::string& value);
  inline void set_uniqrxid(const char* value);
  inline void set_uniqrxid(const char* value, size_t size);
  inline ::std::string* mutable_uniqrxid();
  inline ::std::string* release_uniqrxid();
  inline void set_allocated_uniqrxid(::std::string* uniqrxid);

  // @@protoc_insertion_point(class_scope:falcon_res_msg.USRPRxTxConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_baseaux();
  inline void clear_has_baseaux();
  inline void set_has_args();
  inline void clear_has_args();
  inline void set_has_minrf();
  inline void clear_has_minrf();
  inline void set_has_maxrf();
  inline void clear_has_maxrf();
  inline void set_has_fs();
  inline void clear_has_fs();
  inline void set_has_uniqrxid();
  inline void clear_has_uniqrxid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 channel_;
  ::google::protobuf::int32 baseaux_;
  ::std::string* args_;
  static ::std::string* _default_args_;
  float minrf_;
  float maxrf_;
  ::std::string* uniqrxid_;
  static ::std::string* _default_uniqrxid_;
  float fs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_FalconResourceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconResourceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconResourceMessages_2eproto();

  void InitAsDefaultInstance();
  static USRPRxTxConfig* default_instance_;
};
// -------------------------------------------------------------------

class EPIQRxTxConfig : public ::google::protobuf::Message {
 public:
  EPIQRxTxConfig();
  virtual ~EPIQRxTxConfig();

  EPIQRxTxConfig(const EPIQRxTxConfig& from);

  inline EPIQRxTxConfig& operator=(const EPIQRxTxConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EPIQRxTxConfig& default_instance();

  void Swap(EPIQRxTxConfig* other);

  // implements Message ----------------------------------------------

  EPIQRxTxConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EPIQRxTxConfig& from);
  void MergeFrom(const EPIQRxTxConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EPIQ_RXTX_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional int32 baseAux = 3;
  inline bool has_baseaux() const;
  inline void clear_baseaux();
  static const int kBaseAuxFieldNumber = 3;
  inline ::google::protobuf::int32 baseaux() const;
  inline void set_baseaux(::google::protobuf::int32 value);

  // optional int32 controlPort = 4;
  inline bool has_controlport() const;
  inline void clear_controlport();
  static const int kControlPortFieldNumber = 4;
  inline ::google::protobuf::int32 controlport() const;
  inline void set_controlport(::google::protobuf::int32 value);

  // optional int32 rfPort = 5;
  inline bool has_rfport() const;
  inline void clear_rfport();
  static const int kRfPortFieldNumber = 5;
  inline ::google::protobuf::int32 rfport() const;
  inline void set_rfport(::google::protobuf::int32 value);

  // optional string host = 6 [default = "local"];
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 6;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  inline void set_allocated_host(::std::string* host);

  // optional float minRF = 7;
  inline bool has_minrf() const;
  inline void clear_minrf();
  static const int kMinRFFieldNumber = 7;
  inline float minrf() const;
  inline void set_minrf(float value);

  // optional float maxRF = 8;
  inline bool has_maxrf() const;
  inline void clear_maxrf();
  static const int kMaxRFFieldNumber = 8;
  inline float maxrf() const;
  inline void set_maxrf(float value);

  // optional float fs = 9 [default = 2.5e+07];
  inline bool has_fs() const;
  inline void clear_fs();
  static const int kFsFieldNumber = 9;
  inline float fs() const;
  inline void set_fs(float value);

  // optional string uniqRXID = 10 [default = "999"];
  inline bool has_uniqrxid() const;
  inline void clear_uniqrxid();
  static const int kUniqRXIDFieldNumber = 10;
  inline const ::std::string& uniqrxid() const;
  inline void set_uniqrxid(const ::std::string& value);
  inline void set_uniqrxid(const char* value);
  inline void set_uniqrxid(const char* value, size_t size);
  inline ::std::string* mutable_uniqrxid();
  inline ::std::string* release_uniqrxid();
  inline void set_allocated_uniqrxid(::std::string* uniqrxid);

  // optional string uniqTXID = 11 [default = "999"];
  inline bool has_uniqtxid() const;
  inline void clear_uniqtxid();
  static const int kUniqTXIDFieldNumber = 11;
  inline const ::std::string& uniqtxid() const;
  inline void set_uniqtxid(const ::std::string& value);
  inline void set_uniqtxid(const char* value);
  inline void set_uniqtxid(const char* value, size_t size);
  inline ::std::string* mutable_uniqtxid();
  inline ::std::string* release_uniqtxid();
  inline void set_allocated_uniqtxid(::std::string* uniqtxid);

  // optional float delayReset = 12 [default = -1];
  inline bool has_delayreset() const;
  inline void clear_delayreset();
  static const int kDelayResetFieldNumber = 12;
  inline float delayreset() const;
  inline void set_delayreset(float value);

  // @@protoc_insertion_point(class_scope:falcon_res_msg.EPIQRxTxConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_baseaux();
  inline void clear_has_baseaux();
  inline void set_has_controlport();
  inline void clear_has_controlport();
  inline void set_has_rfport();
  inline void clear_has_rfport();
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_minrf();
  inline void clear_has_minrf();
  inline void set_has_maxrf();
  inline void clear_has_maxrf();
  inline void set_has_fs();
  inline void clear_has_fs();
  inline void set_has_uniqrxid();
  inline void clear_has_uniqrxid();
  inline void set_has_uniqtxid();
  inline void clear_has_uniqtxid();
  inline void set_has_delayreset();
  inline void clear_has_delayreset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 channel_;
  ::google::protobuf::int32 baseaux_;
  ::google::protobuf::int32 controlport_;
  ::google::protobuf::int32 rfport_;
  ::std::string* host_;
  static ::std::string* _default_host_;
  float minrf_;
  float maxrf_;
  ::std::string* uniqrxid_;
  static ::std::string* _default_uniqrxid_;
  float fs_;
  float delayreset_;
  ::std::string* uniqtxid_;
  static ::std::string* _default_uniqtxid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_FalconResourceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconResourceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconResourceMessages_2eproto();

  void InitAsDefaultInstance();
  static EPIQRxTxConfig* default_instance_;
};
// -------------------------------------------------------------------

class RTLSDRConfig : public ::google::protobuf::Message {
 public:
  RTLSDRConfig();
  virtual ~RTLSDRConfig();

  RTLSDRConfig(const RTLSDRConfig& from);

  inline RTLSDRConfig& operator=(const RTLSDRConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RTLSDRConfig& default_instance();

  void Swap(RTLSDRConfig* other);

  // implements Message ----------------------------------------------

  RTLSDRConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RTLSDRConfig& from);
  void MergeFrom(const RTLSDRConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "RTLSDR_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional int32 baseAux = 3;
  inline bool has_baseaux() const;
  inline void clear_baseaux();
  static const int kBaseAuxFieldNumber = 3;
  inline ::google::protobuf::int32 baseaux() const;
  inline void set_baseaux(::google::protobuf::int32 value);

  // optional int32 controlPort = 4;
  inline bool has_controlport() const;
  inline void clear_controlport();
  static const int kControlPortFieldNumber = 4;
  inline ::google::protobuf::int32 controlport() const;
  inline void set_controlport(::google::protobuf::int32 value);

  // optional string host = 5 [default = "local"];
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 5;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  inline void set_allocated_host(::std::string* host);

  // optional float minRF = 6;
  inline bool has_minrf() const;
  inline void clear_minrf();
  static const int kMinRFFieldNumber = 6;
  inline float minrf() const;
  inline void set_minrf(float value);

  // optional float maxRF = 7;
  inline bool has_maxrf() const;
  inline void clear_maxrf();
  static const int kMaxRFFieldNumber = 7;
  inline float maxrf() const;
  inline void set_maxrf(float value);

  // optional float fs = 8 [default = 2.048e+06];
  inline bool has_fs() const;
  inline void clear_fs();
  static const int kFsFieldNumber = 8;
  inline float fs() const;
  inline void set_fs(float value);

  // optional string uniqRXID = 9 [default = "999"];
  inline bool has_uniqrxid() const;
  inline void clear_uniqrxid();
  static const int kUniqRXIDFieldNumber = 9;
  inline const ::std::string& uniqrxid() const;
  inline void set_uniqrxid(const ::std::string& value);
  inline void set_uniqrxid(const char* value);
  inline void set_uniqrxid(const char* value, size_t size);
  inline ::std::string* mutable_uniqrxid();
  inline ::std::string* release_uniqrxid();
  inline void set_allocated_uniqrxid(::std::string* uniqrxid);

  // @@protoc_insertion_point(class_scope:falcon_res_msg.RTLSDRConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_baseaux();
  inline void clear_has_baseaux();
  inline void set_has_controlport();
  inline void clear_has_controlport();
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_minrf();
  inline void clear_has_minrf();
  inline void set_has_maxrf();
  inline void clear_has_maxrf();
  inline void set_has_fs();
  inline void clear_has_fs();
  inline void set_has_uniqrxid();
  inline void clear_has_uniqrxid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 channel_;
  ::google::protobuf::int32 baseaux_;
  ::std::string* host_;
  static ::std::string* _default_host_;
  ::google::protobuf::int32 controlport_;
  float minrf_;
  float maxrf_;
  float fs_;
  ::std::string* uniqrxid_;
  static ::std::string* _default_uniqrxid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_FalconResourceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconResourceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconResourceMessages_2eproto();

  void InitAsDefaultInstance();
  static RTLSDRConfig* default_instance_;
};
// -------------------------------------------------------------------

class USRPRxConfig : public ::google::protobuf::Message {
 public:
  USRPRxConfig();
  virtual ~USRPRxConfig();

  USRPRxConfig(const USRPRxConfig& from);

  inline USRPRxConfig& operator=(const USRPRxConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const USRPRxConfig& default_instance();

  void Swap(USRPRxConfig* other);

  // implements Message ----------------------------------------------

  USRPRxConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const USRPRxConfig& from);
  void MergeFrom(const USRPRxConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "USRP_RX_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional int32 baseAux = 3;
  inline bool has_baseaux() const;
  inline void clear_baseaux();
  static const int kBaseAuxFieldNumber = 3;
  inline ::google::protobuf::int32 baseaux() const;
  inline void set_baseaux(::google::protobuf::int32 value);

  // optional string args = 4 [default = "addr=192.168.10.2"];
  inline bool has_args() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 4;
  inline const ::std::string& args() const;
  inline void set_args(const ::std::string& value);
  inline void set_args(const char* value);
  inline void set_args(const char* value, size_t size);
  inline ::std::string* mutable_args();
  inline ::std::string* release_args();
  inline void set_allocated_args(::std::string* args);

  // optional int32 usrpchan = 5;
  inline bool has_usrpchan() const;
  inline void clear_usrpchan();
  static const int kUsrpchanFieldNumber = 5;
  inline ::google::protobuf::int32 usrpchan() const;
  inline void set_usrpchan(::google::protobuf::int32 value);

  // optional float minRF = 6;
  inline bool has_minrf() const;
  inline void clear_minrf();
  static const int kMinRFFieldNumber = 6;
  inline float minrf() const;
  inline void set_minrf(float value);

  // optional float maxRF = 7;
  inline bool has_maxrf() const;
  inline void clear_maxrf();
  static const int kMaxRFFieldNumber = 7;
  inline float maxrf() const;
  inline void set_maxrf(float value);

  // optional float fs = 8 [default = 1e+08];
  inline bool has_fs() const;
  inline void clear_fs();
  static const int kFsFieldNumber = 8;
  inline float fs() const;
  inline void set_fs(float value);

  // @@protoc_insertion_point(class_scope:falcon_res_msg.USRPRxConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_baseaux();
  inline void clear_has_baseaux();
  inline void set_has_args();
  inline void clear_has_args();
  inline void set_has_usrpchan();
  inline void clear_has_usrpchan();
  inline void set_has_minrf();
  inline void clear_has_minrf();
  inline void set_has_maxrf();
  inline void clear_has_maxrf();
  inline void set_has_fs();
  inline void clear_has_fs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 channel_;
  ::google::protobuf::int32 baseaux_;
  ::std::string* args_;
  static ::std::string* _default_args_;
  ::google::protobuf::int32 usrpchan_;
  float minrf_;
  float maxrf_;
  float fs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_FalconResourceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconResourceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconResourceMessages_2eproto();

  void InitAsDefaultInstance();
  static USRPRxConfig* default_instance_;
};
// -------------------------------------------------------------------

class PentekConfig : public ::google::protobuf::Message {
 public:
  PentekConfig();
  virtual ~PentekConfig();

  PentekConfig(const PentekConfig& from);

  inline PentekConfig& operator=(const PentekConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PentekConfig& default_instance();

  void Swap(PentekConfig* other);

  // implements Message ----------------------------------------------

  PentekConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PentekConfig& from);
  void MergeFrom(const PentekConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PentekConfig_SiggenType SiggenType;
  static const SiggenType ROHDE_SCHWARZ = PentekConfig_SiggenType_ROHDE_SCHWARZ;
  static const SiggenType MMS_MUP = PentekConfig_SiggenType_MMS_MUP;
  static inline bool SiggenType_IsValid(int value) {
    return PentekConfig_SiggenType_IsValid(value);
  }
  static const SiggenType SiggenType_MIN =
    PentekConfig_SiggenType_SiggenType_MIN;
  static const SiggenType SiggenType_MAX =
    PentekConfig_SiggenType_SiggenType_MAX;
  static const int SiggenType_ARRAYSIZE =
    PentekConfig_SiggenType_SiggenType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SiggenType_descriptor() {
    return PentekConfig_SiggenType_descriptor();
  }
  static inline const ::std::string& SiggenType_Name(SiggenType value) {
    return PentekConfig_SiggenType_Name(value);
  }
  static inline bool SiggenType_Parse(const ::std::string& name,
      SiggenType* value) {
    return PentekConfig_SiggenType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "PENTEK_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional float clkFreq = 2 [default = 4e+08];
  inline bool has_clkfreq() const;
  inline void clear_clkfreq();
  static const int kClkFreqFieldNumber = 2;
  inline float clkfreq() const;
  inline void set_clkfreq(float value);

  // optional int32 dacInterp = 3 [default = 16];
  inline bool has_dacinterp() const;
  inline void clear_dacinterp();
  static const int kDacInterpFieldNumber = 3;
  inline ::google::protobuf::int32 dacinterp() const;
  inline void set_dacinterp(::google::protobuf::int32 value);

  // optional int32 coreInterp = 4 [default = 1];
  inline bool has_coreinterp() const;
  inline void clear_coreinterp();
  static const int kCoreInterpFieldNumber = 4;
  inline ::google::protobuf::int32 coreinterp() const;
  inline void set_coreinterp(::google::protobuf::int32 value);

  // optional int32 baseChan = 5 [default = 1];
  inline bool has_basechan() const;
  inline void clear_basechan();
  static const int kBaseChanFieldNumber = 5;
  inline ::google::protobuf::int32 basechan() const;
  inline void set_basechan(::google::protobuf::int32 value);

  // optional int32 numBuffers = 6 [default = 2];
  inline bool has_numbuffers() const;
  inline void clear_numbuffers();
  static const int kNumBuffersFieldNumber = 6;
  inline ::google::protobuf::int32 numbuffers() const;
  inline void set_numbuffers(::google::protobuf::int32 value);

  // optional float freqShift = 7 [default = 0];
  inline bool has_freqshift() const;
  inline void clear_freqshift();
  static const int kFreqShiftFieldNumber = 7;
  inline float freqshift() const;
  inline void set_freqshift(float value);

  // optional string siggenIP = 8;
  inline bool has_siggenip() const;
  inline void clear_siggenip();
  static const int kSiggenIPFieldNumber = 8;
  inline const ::std::string& siggenip() const;
  inline void set_siggenip(const ::std::string& value);
  inline void set_siggenip(const char* value);
  inline void set_siggenip(const char* value, size_t size);
  inline ::std::string* mutable_siggenip();
  inline ::std::string* release_siggenip();
  inline void set_allocated_siggenip(::std::string* siggenip);

  // optional .falcon_res_msg.PentekConfig.SiggenType siggenType = 9 [default = ROHDE_SCHWARZ];
  inline bool has_siggentype() const;
  inline void clear_siggentype();
  static const int kSiggenTypeFieldNumber = 9;
  inline ::falcon_res_msg::PentekConfig_SiggenType siggentype() const;
  inline void set_siggentype(::falcon_res_msg::PentekConfig_SiggenType value);

  // @@protoc_insertion_point(class_scope:falcon_res_msg.PentekConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_clkfreq();
  inline void clear_has_clkfreq();
  inline void set_has_dacinterp();
  inline void clear_has_dacinterp();
  inline void set_has_coreinterp();
  inline void clear_has_coreinterp();
  inline void set_has_basechan();
  inline void clear_has_basechan();
  inline void set_has_numbuffers();
  inline void clear_has_numbuffers();
  inline void set_has_freqshift();
  inline void clear_has_freqshift();
  inline void set_has_siggenip();
  inline void clear_has_siggenip();
  inline void set_has_siggentype();
  inline void clear_has_siggentype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  float clkfreq_;
  ::google::protobuf::int32 dacinterp_;
  ::google::protobuf::int32 coreinterp_;
  ::google::protobuf::int32 basechan_;
  ::google::protobuf::int32 numbuffers_;
  float freqshift_;
  ::std::string* siggenip_;
  int siggentype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_FalconResourceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconResourceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconResourceMessages_2eproto();

  void InitAsDefaultInstance();
  static PentekConfig* default_instance_;
};
// -------------------------------------------------------------------

class USRPTxConfig : public ::google::protobuf::Message {
 public:
  USRPTxConfig();
  virtual ~USRPTxConfig();

  USRPTxConfig(const USRPTxConfig& from);

  inline USRPTxConfig& operator=(const USRPTxConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const USRPTxConfig& default_instance();

  void Swap(USRPTxConfig* other);

  // implements Message ----------------------------------------------

  USRPTxConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const USRPTxConfig& from);
  void MergeFrom(const USRPTxConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "USRP_TX_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string args = 2 [default = "addr=192.168.10.2"];
  inline bool has_args() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 2;
  inline const ::std::string& args() const;
  inline void set_args(const ::std::string& value);
  inline void set_args(const char* value);
  inline void set_args(const char* value, size_t size);
  inline ::std::string* mutable_args();
  inline ::std::string* release_args();
  inline void set_allocated_args(::std::string* args);

  // optional int32 usrpchan = 3;
  inline bool has_usrpchan() const;
  inline void clear_usrpchan();
  static const int kUsrpchanFieldNumber = 3;
  inline ::google::protobuf::int32 usrpchan() const;
  inline void set_usrpchan(::google::protobuf::int32 value);

  // optional float minRF = 4;
  inline bool has_minrf() const;
  inline void clear_minrf();
  static const int kMinRFFieldNumber = 4;
  inline float minrf() const;
  inline void set_minrf(float value);

  // optional float maxRF = 5;
  inline bool has_maxrf() const;
  inline void clear_maxrf();
  static const int kMaxRFFieldNumber = 5;
  inline float maxrf() const;
  inline void set_maxrf(float value);

  // @@protoc_insertion_point(class_scope:falcon_res_msg.USRPTxConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_args();
  inline void clear_has_args();
  inline void set_has_usrpchan();
  inline void clear_has_usrpchan();
  inline void set_has_minrf();
  inline void clear_has_minrf();
  inline void set_has_maxrf();
  inline void clear_has_maxrf();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* args_;
  static ::std::string* _default_args_;
  ::google::protobuf::int32 usrpchan_;
  float minrf_;
  float maxrf_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_FalconResourceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconResourceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconResourceMessages_2eproto();

  void InitAsDefaultInstance();
  static USRPTxConfig* default_instance_;
};
// -------------------------------------------------------------------

class RFSwitchConfig : public ::google::protobuf::Message {
 public:
  RFSwitchConfig();
  virtual ~RFSwitchConfig();

  RFSwitchConfig(const RFSwitchConfig& from);

  inline RFSwitchConfig& operator=(const RFSwitchConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RFSwitchConfig& default_instance();

  void Swap(RFSwitchConfig* other);

  // implements Message ----------------------------------------------

  RFSwitchConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RFSwitchConfig& from);
  void MergeFrom(const RFSwitchConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "RFSWITCH_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string IP = 2 [default = "nportserver"];
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIPFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional int32 slaveTimeout = 3 [default = 180];
  inline bool has_slavetimeout() const;
  inline void clear_slavetimeout();
  static const int kSlaveTimeoutFieldNumber = 3;
  inline ::google::protobuf::int32 slavetimeout() const;
  inline void set_slavetimeout(::google::protobuf::int32 value);

  // optional float energyScanSec = 4 [default = 10];
  inline bool has_energyscansec() const;
  inline void clear_energyscansec();
  static const int kEnergyScanSecFieldNumber = 4;
  inline float energyscansec() const;
  inline void set_energyscansec(float value);

  // optional float energyTrackTime = 5 [default = 300];
  inline bool has_energytracktime() const;
  inline void clear_energytracktime();
  static const int kEnergyTrackTimeFieldNumber = 5;
  inline float energytracktime() const;
  inline void set_energytracktime(float value);

  // optional int32 port = 6 [default = 4003];
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 6;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // optional bool setOnLaunch = 7 [default = false];
  inline bool has_setonlaunch() const;
  inline void clear_setonlaunch();
  static const int kSetOnLaunchFieldNumber = 7;
  inline bool setonlaunch() const;
  inline void set_setonlaunch(bool value);

  // @@protoc_insertion_point(class_scope:falcon_res_msg.RFSwitchConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_slavetimeout();
  inline void clear_has_slavetimeout();
  inline void set_has_energyscansec();
  inline void clear_has_energyscansec();
  inline void set_has_energytracktime();
  inline void clear_has_energytracktime();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_setonlaunch();
  inline void clear_has_setonlaunch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* ip_;
  static ::std::string* _default_ip_;
  ::google::protobuf::int32 slavetimeout_;
  float energyscansec_;
  float energytracktime_;
  ::google::protobuf::int32 port_;
  bool setonlaunch_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_FalconResourceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconResourceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconResourceMessages_2eproto();

  void InitAsDefaultInstance();
  static RFSwitchConfig* default_instance_;
};
// -------------------------------------------------------------------

class RFSwitchSerialConfig : public ::google::protobuf::Message {
 public:
  RFSwitchSerialConfig();
  virtual ~RFSwitchSerialConfig();

  RFSwitchSerialConfig(const RFSwitchSerialConfig& from);

  inline RFSwitchSerialConfig& operator=(const RFSwitchSerialConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RFSwitchSerialConfig& default_instance();

  void Swap(RFSwitchSerialConfig* other);

  // implements Message ----------------------------------------------

  RFSwitchSerialConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RFSwitchSerialConfig& from);
  void MergeFrom(const RFSwitchSerialConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "RFSWITCH_SERIAL_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string device = 2 [default = "/dev/ttyS0"];
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 2;
  inline const ::std::string& device() const;
  inline void set_device(const ::std::string& value);
  inline void set_device(const char* value);
  inline void set_device(const char* value, size_t size);
  inline ::std::string* mutable_device();
  inline ::std::string* release_device();
  inline void set_allocated_device(::std::string* device);

  // optional int32 baud = 3 [default = 9600];
  inline bool has_baud() const;
  inline void clear_baud();
  static const int kBaudFieldNumber = 3;
  inline ::google::protobuf::int32 baud() const;
  inline void set_baud(::google::protobuf::int32 value);

  // optional int32 slaveTimeout = 4 [default = 180];
  inline bool has_slavetimeout() const;
  inline void clear_slavetimeout();
  static const int kSlaveTimeoutFieldNumber = 4;
  inline ::google::protobuf::int32 slavetimeout() const;
  inline void set_slavetimeout(::google::protobuf::int32 value);

  // optional float energyScanSec = 5 [default = 10];
  inline bool has_energyscansec() const;
  inline void clear_energyscansec();
  static const int kEnergyScanSecFieldNumber = 5;
  inline float energyscansec() const;
  inline void set_energyscansec(float value);

  // optional float energyTrackTime = 6 [default = 300];
  inline bool has_energytracktime() const;
  inline void clear_energytracktime();
  static const int kEnergyTrackTimeFieldNumber = 6;
  inline float energytracktime() const;
  inline void set_energytracktime(float value);

  // @@protoc_insertion_point(class_scope:falcon_res_msg.RFSwitchSerialConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_device();
  inline void clear_has_device();
  inline void set_has_baud();
  inline void clear_has_baud();
  inline void set_has_slavetimeout();
  inline void clear_has_slavetimeout();
  inline void set_has_energyscansec();
  inline void clear_has_energyscansec();
  inline void set_has_energytracktime();
  inline void clear_has_energytracktime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* device_;
  static ::std::string* _default_device_;
  ::google::protobuf::int32 baud_;
  ::google::protobuf::int32 slavetimeout_;
  float energyscansec_;
  float energytracktime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_FalconResourceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconResourceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconResourceMessages_2eproto();

  void InitAsDefaultInstance();
  static RFSwitchSerialConfig* default_instance_;
};
// -------------------------------------------------------------------

class CPSwitchConfig : public ::google::protobuf::Message {
 public:
  CPSwitchConfig();
  virtual ~CPSwitchConfig();

  CPSwitchConfig(const CPSwitchConfig& from);

  inline CPSwitchConfig& operator=(const CPSwitchConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CPSwitchConfig& default_instance();

  void Swap(CPSwitchConfig* other);

  // implements Message ----------------------------------------------

  CPSwitchConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CPSwitchConfig& from);
  void MergeFrom(const CPSwitchConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "CPSWITCH_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string IP = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIPFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional int32 port = 3 [default = 23];
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // optional int32 slaveTimeout = 4 [default = 180];
  inline bool has_slavetimeout() const;
  inline void clear_slavetimeout();
  static const int kSlaveTimeoutFieldNumber = 4;
  inline ::google::protobuf::int32 slavetimeout() const;
  inline void set_slavetimeout(::google::protobuf::int32 value);

  // optional float energyScanSec = 5 [default = 10];
  inline bool has_energyscansec() const;
  inline void clear_energyscansec();
  static const int kEnergyScanSecFieldNumber = 5;
  inline float energyscansec() const;
  inline void set_energyscansec(float value);

  // optional float energyTrackTime = 6 [default = 300];
  inline bool has_energytracktime() const;
  inline void clear_energytracktime();
  static const int kEnergyTrackTimeFieldNumber = 6;
  inline float energytracktime() const;
  inline void set_energytracktime(float value);

  // @@protoc_insertion_point(class_scope:falcon_res_msg.CPSwitchConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_slavetimeout();
  inline void clear_has_slavetimeout();
  inline void set_has_energyscansec();
  inline void clear_has_energyscansec();
  inline void set_has_energytracktime();
  inline void clear_has_energytracktime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* ip_;
  ::google::protobuf::int32 port_;
  ::google::protobuf::int32 slavetimeout_;
  float energyscansec_;
  float energytracktime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_FalconResourceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconResourceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconResourceMessages_2eproto();

  void InitAsDefaultInstance();
  static CPSwitchConfig* default_instance_;
};
// -------------------------------------------------------------------

class AntennaConfig : public ::google::protobuf::Message {
 public:
  AntennaConfig();
  virtual ~AntennaConfig();

  AntennaConfig(const AntennaConfig& from);

  inline AntennaConfig& operator=(const AntennaConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AntennaConfig& default_instance();

  void Swap(AntennaConfig* other);

  // implements Message ----------------------------------------------

  AntennaConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AntennaConfig& from);
  void MergeFrom(const AntennaConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ANTENNA_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional float minRF = 2;
  inline bool has_minrf() const;
  inline void clear_minrf();
  static const int kMinRFFieldNumber = 2;
  inline float minrf() const;
  inline void set_minrf(float value);

  // optional float maxRF = 3;
  inline bool has_maxrf() const;
  inline void clear_maxrf();
  static const int kMaxRFFieldNumber = 3;
  inline float maxrf() const;
  inline void set_maxrf(float value);

  // optional float fixedAngle = 4 [default = -999];
  inline bool has_fixedangle() const;
  inline void clear_fixedangle();
  static const int kFixedAngleFieldNumber = 4;
  inline float fixedangle() const;
  inline void set_fixedangle(float value);

  // optional float latitude = 5 [default = 0];
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 5;
  inline float latitude() const;
  inline void set_latitude(float value);

  // optional float longitude = 6 [default = 0];
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 6;
  inline float longitude() const;
  inline void set_longitude(float value);

  // optional float altitude = 7 [default = 0];
  inline bool has_altitude() const;
  inline void clear_altitude();
  static const int kAltitudeFieldNumber = 7;
  inline float altitude() const;
  inline void set_altitude(float value);

  // optional float beamwidth = 8 [default = 0];
  inline bool has_beamwidth() const;
  inline void clear_beamwidth();
  static const int kBeamwidthFieldNumber = 8;
  inline float beamwidth() const;
  inline void set_beamwidth(float value);

  // optional float dwncnvtLO = 9 [default = 0];
  inline bool has_dwncnvtlo() const;
  inline void clear_dwncnvtlo();
  static const int kDwncnvtLOFieldNumber = 9;
  inline float dwncnvtlo() const;
  inline void set_dwncnvtlo(float value);

  // optional int32 ssc = 10 [default = -1];
  inline bool has_ssc() const;
  inline void clear_ssc();
  static const int kSscFieldNumber = 10;
  inline ::google::protobuf::int32 ssc() const;
  inline void set_ssc(::google::protobuf::int32 value);

  // optional string band = 11;
  inline bool has_band() const;
  inline void clear_band();
  static const int kBandFieldNumber = 11;
  inline const ::std::string& band() const;
  inline void set_band(const ::std::string& value);
  inline void set_band(const char* value);
  inline void set_band(const char* value, size_t size);
  inline ::std::string* mutable_band();
  inline ::std::string* release_band();
  inline void set_allocated_band(::std::string* band);

  // optional string polarization = 12;
  inline bool has_polarization() const;
  inline void clear_polarization();
  static const int kPolarizationFieldNumber = 12;
  inline const ::std::string& polarization() const;
  inline void set_polarization(const ::std::string& value);
  inline void set_polarization(const char* value);
  inline void set_polarization(const char* value, size_t size);
  inline ::std::string* mutable_polarization();
  inline ::std::string* release_polarization();
  inline void set_allocated_polarization(::std::string* polarization);

  // optional int32 group = 13;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 13;
  inline ::google::protobuf::int32 group() const;
  inline void set_group(::google::protobuf::int32 value);

  // optional float sightDistance = 14 [default = 500];
  inline bool has_sightdistance() const;
  inline void clear_sightdistance();
  static const int kSightDistanceFieldNumber = 14;
  inline float sightdistance() const;
  inline void set_sightdistance(float value);

  // optional string noiseTest = 15 [default = "NO_TEST"];
  inline bool has_noisetest() const;
  inline void clear_noisetest();
  static const int kNoiseTestFieldNumber = 15;
  inline const ::std::string& noisetest() const;
  inline void set_noisetest(const ::std::string& value);
  inline void set_noisetest(const char* value);
  inline void set_noisetest(const char* value, size_t size);
  inline ::std::string* mutable_noisetest();
  inline ::std::string* release_noisetest();
  inline void set_allocated_noisetest(::std::string* noisetest);

  // @@protoc_insertion_point(class_scope:falcon_res_msg.AntennaConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_minrf();
  inline void clear_has_minrf();
  inline void set_has_maxrf();
  inline void clear_has_maxrf();
  inline void set_has_fixedangle();
  inline void clear_has_fixedangle();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_altitude();
  inline void clear_has_altitude();
  inline void set_has_beamwidth();
  inline void clear_has_beamwidth();
  inline void set_has_dwncnvtlo();
  inline void clear_has_dwncnvtlo();
  inline void set_has_ssc();
  inline void clear_has_ssc();
  inline void set_has_band();
  inline void clear_has_band();
  inline void set_has_polarization();
  inline void clear_has_polarization();
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_sightdistance();
  inline void clear_has_sightdistance();
  inline void set_has_noisetest();
  inline void clear_has_noisetest();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  float minrf_;
  float maxrf_;
  float fixedangle_;
  float latitude_;
  float longitude_;
  float altitude_;
  float beamwidth_;
  float dwncnvtlo_;
  ::std::string* band_;
  ::google::protobuf::int32 ssc_;
  ::google::protobuf::int32 group_;
  ::std::string* polarization_;
  ::std::string* noisetest_;
  static ::std::string* _default_noisetest_;
  float sightdistance_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_FalconResourceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconResourceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconResourceMessages_2eproto();

  void InitAsDefaultInstance();
  static AntennaConfig* default_instance_;
};
// -------------------------------------------------------------------

class RotorRPMConfig : public ::google::protobuf::Message {
 public:
  RotorRPMConfig();
  virtual ~RotorRPMConfig();

  RotorRPMConfig(const RotorRPMConfig& from);

  inline RotorRPMConfig& operator=(const RotorRPMConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RotorRPMConfig& default_instance();

  void Swap(RotorRPMConfig* other);

  // implements Message ----------------------------------------------

  RotorRPMConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RotorRPMConfig& from);
  void MergeFrom(const RotorRPMConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ROTOR_RPM_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string IP = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIPFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional int32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // optional float AzOffset = 4;
  inline bool has_azoffset() const;
  inline void clear_azoffset();
  static const int kAzOffsetFieldNumber = 4;
  inline float azoffset() const;
  inline void set_azoffset(float value);

  // optional float ElOffset = 5;
  inline bool has_eloffset() const;
  inline void clear_eloffset();
  static const int kElOffsetFieldNumber = 5;
  inline float eloffset() const;
  inline void set_eloffset(float value);

  // optional bool hardLimit = 6;
  inline bool has_hardlimit() const;
  inline void clear_hardlimit();
  static const int kHardLimitFieldNumber = 6;
  inline bool hardlimit() const;
  inline void set_hardlimit(bool value);

  // optional float minScanAngle = 7;
  inline bool has_minscanangle() const;
  inline void clear_minscanangle();
  static const int kMinScanAngleFieldNumber = 7;
  inline float minscanangle() const;
  inline void set_minscanangle(float value);

  // optional float maxScanAngle = 8;
  inline bool has_maxscanangle() const;
  inline void clear_maxscanangle();
  static const int kMaxScanAngleFieldNumber = 8;
  inline float maxscanangle() const;
  inline void set_maxscanangle(float value);

  // optional float minElevation = 9;
  inline bool has_minelevation() const;
  inline void clear_minelevation();
  static const int kMinElevationFieldNumber = 9;
  inline float minelevation() const;
  inline void set_minelevation(float value);

  // optional float maxElevation = 10;
  inline bool has_maxelevation() const;
  inline void clear_maxelevation();
  static const int kMaxElevationFieldNumber = 10;
  inline float maxelevation() const;
  inline void set_maxelevation(float value);

  // optional float scanElevation = 11;
  inline bool has_scanelevation() const;
  inline void clear_scanelevation();
  static const int kScanElevationFieldNumber = 11;
  inline float scanelevation() const;
  inline void set_scanelevation(float value);

  // optional float multicastRate = 12;
  inline bool has_multicastrate() const;
  inline void clear_multicastrate();
  static const int kMulticastRateFieldNumber = 12;
  inline float multicastrate() const;
  inline void set_multicastrate(float value);

  // optional float pointHoldIncrement = 13;
  inline bool has_pointholdincrement() const;
  inline void clear_pointholdincrement();
  static const int kPointHoldIncrementFieldNumber = 13;
  inline float pointholdincrement() const;
  inline void set_pointholdincrement(float value);

  // optional float energyScanSpeed = 14 [default = 4];
  inline bool has_energyscanspeed() const;
  inline void clear_energyscanspeed();
  static const int kEnergyScanSpeedFieldNumber = 14;
  inline float energyscanspeed() const;
  inline void set_energyscanspeed(float value);

  // optional float startDeviation = 15 [default = 180];
  inline bool has_startdeviation() const;
  inline void clear_startdeviation();
  static const int kStartDeviationFieldNumber = 15;
  inline float startdeviation() const;
  inline void set_startdeviation(float value);

  // optional float energyTrackTime = 16 [default = 30];
  inline bool has_energytracktime() const;
  inline void clear_energytracktime();
  static const int kEnergyTrackTimeFieldNumber = 16;
  inline float energytracktime() const;
  inline void set_energytracktime(float value);

  // optional string scanScrypt = 17 [default = "NONE"];
  inline bool has_scanscrypt() const;
  inline void clear_scanscrypt();
  static const int kScanScryptFieldNumber = 17;
  inline const ::std::string& scanscrypt() const;
  inline void set_scanscrypt(const ::std::string& value);
  inline void set_scanscrypt(const char* value);
  inline void set_scanscrypt(const char* value, size_t size);
  inline ::std::string* mutable_scanscrypt();
  inline ::std::string* release_scanscrypt();
  inline void set_allocated_scanscrypt(::std::string* scanscrypt);

  // optional string gpsServer = 18 [default = "OFF"];
  inline bool has_gpsserver() const;
  inline void clear_gpsserver();
  static const int kGpsServerFieldNumber = 18;
  inline const ::std::string& gpsserver() const;
  inline void set_gpsserver(const ::std::string& value);
  inline void set_gpsserver(const char* value);
  inline void set_gpsserver(const char* value, size_t size);
  inline ::std::string* mutable_gpsserver();
  inline ::std::string* release_gpsserver();
  inline void set_allocated_gpsserver(::std::string* gpsserver);

  // optional string gpsUpdate = 19 [default = "ON"];
  inline bool has_gpsupdate() const;
  inline void clear_gpsupdate();
  static const int kGpsUpdateFieldNumber = 19;
  inline const ::std::string& gpsupdate() const;
  inline void set_gpsupdate(const ::std::string& value);
  inline void set_gpsupdate(const char* value);
  inline void set_gpsupdate(const char* value, size_t size);
  inline ::std::string* mutable_gpsupdate();
  inline ::std::string* release_gpsupdate();
  inline void set_allocated_gpsupdate(::std::string* gpsupdate);

  // optional bool elDisabled = 20 [default = false];
  inline bool has_eldisabled() const;
  inline void clear_eldisabled();
  static const int kElDisabledFieldNumber = 20;
  inline bool eldisabled() const;
  inline void set_eldisabled(bool value);

  // optional bool invertAz = 21 [default = false];
  inline bool has_invertaz() const;
  inline void clear_invertaz();
  static const int kInvertAzFieldNumber = 21;
  inline bool invertaz() const;
  inline void set_invertaz(bool value);

  // optional float maxVelocity = 22 [default = 10];
  inline bool has_maxvelocity() const;
  inline void clear_maxvelocity();
  static const int kMaxVelocityFieldNumber = 22;
  inline float maxvelocity() const;
  inline void set_maxvelocity(float value);

  // optional bool dynamicVel = 23 [default = false];
  inline bool has_dynamicvel() const;
  inline void clear_dynamicvel();
  static const int kDynamicVelFieldNumber = 23;
  inline bool dynamicvel() const;
  inline void set_dynamicvel(bool value);

  // optional bool slewEnabled = 24 [default = false];
  inline bool has_slewenabled() const;
  inline void clear_slewenabled();
  static const int kSlewEnabledFieldNumber = 24;
  inline bool slewenabled() const;
  inline void set_slewenabled(bool value);

  // optional float azCloseEnough = 25 [default = 0.5];
  inline bool has_azcloseenough() const;
  inline void clear_azcloseenough();
  static const int kAzCloseEnoughFieldNumber = 25;
  inline float azcloseenough() const;
  inline void set_azcloseenough(float value);

  // @@protoc_insertion_point(class_scope:falcon_res_msg.RotorRPMConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_azoffset();
  inline void clear_has_azoffset();
  inline void set_has_eloffset();
  inline void clear_has_eloffset();
  inline void set_has_hardlimit();
  inline void clear_has_hardlimit();
  inline void set_has_minscanangle();
  inline void clear_has_minscanangle();
  inline void set_has_maxscanangle();
  inline void clear_has_maxscanangle();
  inline void set_has_minelevation();
  inline void clear_has_minelevation();
  inline void set_has_maxelevation();
  inline void clear_has_maxelevation();
  inline void set_has_scanelevation();
  inline void clear_has_scanelevation();
  inline void set_has_multicastrate();
  inline void clear_has_multicastrate();
  inline void set_has_pointholdincrement();
  inline void clear_has_pointholdincrement();
  inline void set_has_energyscanspeed();
  inline void clear_has_energyscanspeed();
  inline void set_has_startdeviation();
  inline void clear_has_startdeviation();
  inline void set_has_energytracktime();
  inline void clear_has_energytracktime();
  inline void set_has_scanscrypt();
  inline void clear_has_scanscrypt();
  inline void set_has_gpsserver();
  inline void clear_has_gpsserver();
  inline void set_has_gpsupdate();
  inline void clear_has_gpsupdate();
  inline void set_has_eldisabled();
  inline void clear_has_eldisabled();
  inline void set_has_invertaz();
  inline void clear_has_invertaz();
  inline void set_has_maxvelocity();
  inline void clear_has_maxvelocity();
  inline void set_has_dynamicvel();
  inline void clear_has_dynamicvel();
  inline void set_has_slewenabled();
  inline void clear_has_slewenabled();
  inline void set_has_azcloseenough();
  inline void clear_has_azcloseenough();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* ip_;
  ::google::protobuf::int32 port_;
  float azoffset_;
  float eloffset_;
  float minscanangle_;
  float maxscanangle_;
  float minelevation_;
  float maxelevation_;
  float scanelevation_;
  float multicastrate_;
  float pointholdincrement_;
  float energyscanspeed_;
  float startdeviation_;
  ::std::string* scanscrypt_;
  static ::std::string* _default_scanscrypt_;
  float energytracktime_;
  bool hardlimit_;
  bool eldisabled_;
  bool invertaz_;
  bool dynamicvel_;
  ::std::string* gpsserver_;
  static ::std::string* _default_gpsserver_;
  ::std::string* gpsupdate_;
  static ::std::string* _default_gpsupdate_;
  float maxvelocity_;
  bool slewenabled_;
  float azcloseenough_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(25 + 31) / 32];

  friend void  protobuf_AddDesc_FalconResourceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconResourceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconResourceMessages_2eproto();

  void InitAsDefaultInstance();
  static RotorRPMConfig* default_instance_;
};
// -------------------------------------------------------------------

class RotorProtatorConfig : public ::google::protobuf::Message {
 public:
  RotorProtatorConfig();
  virtual ~RotorProtatorConfig();

  RotorProtatorConfig(const RotorProtatorConfig& from);

  inline RotorProtatorConfig& operator=(const RotorProtatorConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RotorProtatorConfig& default_instance();

  void Swap(RotorProtatorConfig* other);

  // implements Message ----------------------------------------------

  RotorProtatorConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RotorProtatorConfig& from);
  void MergeFrom(const RotorProtatorConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ROTOR_PROTATOR_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string IP = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIPFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional int32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // optional float AzOffset = 4;
  inline bool has_azoffset() const;
  inline void clear_azoffset();
  static const int kAzOffsetFieldNumber = 4;
  inline float azoffset() const;
  inline void set_azoffset(float value);

  // optional bool hardLimit = 5;
  inline bool has_hardlimit() const;
  inline void clear_hardlimit();
  static const int kHardLimitFieldNumber = 5;
  inline bool hardlimit() const;
  inline void set_hardlimit(bool value);

  // optional float minScanAngle = 6;
  inline bool has_minscanangle() const;
  inline void clear_minscanangle();
  static const int kMinScanAngleFieldNumber = 6;
  inline float minscanangle() const;
  inline void set_minscanangle(float value);

  // optional float maxScanAngle = 7;
  inline bool has_maxscanangle() const;
  inline void clear_maxscanangle();
  static const int kMaxScanAngleFieldNumber = 7;
  inline float maxscanangle() const;
  inline void set_maxscanangle(float value);

  // optional float multicastRate = 8;
  inline bool has_multicastrate() const;
  inline void clear_multicastrate();
  static const int kMulticastRateFieldNumber = 8;
  inline float multicastrate() const;
  inline void set_multicastrate(float value);

  // optional float pointHoldIncrement = 9;
  inline bool has_pointholdincrement() const;
  inline void clear_pointholdincrement();
  static const int kPointHoldIncrementFieldNumber = 9;
  inline float pointholdincrement() const;
  inline void set_pointholdincrement(float value);

  // optional float energyScanSpeed = 10 [default = 20];
  inline bool has_energyscanspeed() const;
  inline void clear_energyscanspeed();
  static const int kEnergyScanSpeedFieldNumber = 10;
  inline float energyscanspeed() const;
  inline void set_energyscanspeed(float value);

  // optional float startDeviation = 11 [default = 180];
  inline bool has_startdeviation() const;
  inline void clear_startdeviation();
  static const int kStartDeviationFieldNumber = 11;
  inline float startdeviation() const;
  inline void set_startdeviation(float value);

  // optional float energyTrackTime = 12 [default = 500];
  inline bool has_energytracktime() const;
  inline void clear_energytracktime();
  static const int kEnergyTrackTimeFieldNumber = 12;
  inline float energytracktime() const;
  inline void set_energytracktime(float value);

  // optional string scanScrypt = 13 [default = "NONE"];
  inline bool has_scanscrypt() const;
  inline void clear_scanscrypt();
  static const int kScanScryptFieldNumber = 13;
  inline const ::std::string& scanscrypt() const;
  inline void set_scanscrypt(const ::std::string& value);
  inline void set_scanscrypt(const char* value);
  inline void set_scanscrypt(const char* value, size_t size);
  inline ::std::string* mutable_scanscrypt();
  inline ::std::string* release_scanscrypt();
  inline void set_allocated_scanscrypt(::std::string* scanscrypt);

  // optional string gpsServer = 14 [default = "OFF"];
  inline bool has_gpsserver() const;
  inline void clear_gpsserver();
  static const int kGpsServerFieldNumber = 14;
  inline const ::std::string& gpsserver() const;
  inline void set_gpsserver(const ::std::string& value);
  inline void set_gpsserver(const char* value);
  inline void set_gpsserver(const char* value, size_t size);
  inline ::std::string* mutable_gpsserver();
  inline ::std::string* release_gpsserver();
  inline void set_allocated_gpsserver(::std::string* gpsserver);

  // optional string gpsUpdate = 15 [default = "ON"];
  inline bool has_gpsupdate() const;
  inline void clear_gpsupdate();
  static const int kGpsUpdateFieldNumber = 15;
  inline const ::std::string& gpsupdate() const;
  inline void set_gpsupdate(const ::std::string& value);
  inline void set_gpsupdate(const char* value);
  inline void set_gpsupdate(const char* value, size_t size);
  inline ::std::string* mutable_gpsupdate();
  inline ::std::string* release_gpsupdate();
  inline void set_allocated_gpsupdate(::std::string* gpsupdate);

  // optional float azCloseEnough = 16 [default = 5];
  inline bool has_azcloseenough() const;
  inline void clear_azcloseenough();
  static const int kAzCloseEnoughFieldNumber = 16;
  inline float azcloseenough() const;
  inline void set_azcloseenough(float value);

  // optional bool elDisabled = 17 [default = true];
  inline bool has_eldisabled() const;
  inline void clear_eldisabled();
  static const int kElDisabledFieldNumber = 17;
  inline bool eldisabled() const;
  inline void set_eldisabled(bool value);

  // @@protoc_insertion_point(class_scope:falcon_res_msg.RotorProtatorConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_azoffset();
  inline void clear_has_azoffset();
  inline void set_has_hardlimit();
  inline void clear_has_hardlimit();
  inline void set_has_minscanangle();
  inline void clear_has_minscanangle();
  inline void set_has_maxscanangle();
  inline void clear_has_maxscanangle();
  inline void set_has_multicastrate();
  inline void clear_has_multicastrate();
  inline void set_has_pointholdincrement();
  inline void clear_has_pointholdincrement();
  inline void set_has_energyscanspeed();
  inline void clear_has_energyscanspeed();
  inline void set_has_startdeviation();
  inline void clear_has_startdeviation();
  inline void set_has_energytracktime();
  inline void clear_has_energytracktime();
  inline void set_has_scanscrypt();
  inline void clear_has_scanscrypt();
  inline void set_has_gpsserver();
  inline void clear_has_gpsserver();
  inline void set_has_gpsupdate();
  inline void clear_has_gpsupdate();
  inline void set_has_azcloseenough();
  inline void clear_has_azcloseenough();
  inline void set_has_eldisabled();
  inline void clear_has_eldisabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* ip_;
  ::google::protobuf::int32 port_;
  float azoffset_;
  float minscanangle_;
  float maxscanangle_;
  float multicastrate_;
  float pointholdincrement_;
  float energyscanspeed_;
  float startdeviation_;
  bool hardlimit_;
  bool eldisabled_;
  float energytracktime_;
  ::std::string* scanscrypt_;
  static ::std::string* _default_scanscrypt_;
  ::std::string* gpsserver_;
  static ::std::string* _default_gpsserver_;
  ::std::string* gpsupdate_;
  static ::std::string* _default_gpsupdate_;
  float azcloseenough_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  friend void  protobuf_AddDesc_FalconResourceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconResourceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconResourceMessages_2eproto();

  void InitAsDefaultInstance();
  static RotorProtatorConfig* default_instance_;
};
// -------------------------------------------------------------------

class RotorProsistelConfig : public ::google::protobuf::Message {
 public:
  RotorProsistelConfig();
  virtual ~RotorProsistelConfig();

  RotorProsistelConfig(const RotorProsistelConfig& from);

  inline RotorProsistelConfig& operator=(const RotorProsistelConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RotorProsistelConfig& default_instance();

  void Swap(RotorProsistelConfig* other);

  // implements Message ----------------------------------------------

  RotorProsistelConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RotorProsistelConfig& from);
  void MergeFrom(const RotorProsistelConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ROTOR_PROSISTEL_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string IP = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIPFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional int32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // optional float AzOffset = 4;
  inline bool has_azoffset() const;
  inline void clear_azoffset();
  static const int kAzOffsetFieldNumber = 4;
  inline float azoffset() const;
  inline void set_azoffset(float value);

  // optional bool hardLimit = 5;
  inline bool has_hardlimit() const;
  inline void clear_hardlimit();
  static const int kHardLimitFieldNumber = 5;
  inline bool hardlimit() const;
  inline void set_hardlimit(bool value);

  // optional float minScanAngle = 6;
  inline bool has_minscanangle() const;
  inline void clear_minscanangle();
  static const int kMinScanAngleFieldNumber = 6;
  inline float minscanangle() const;
  inline void set_minscanangle(float value);

  // optional float maxScanAngle = 7;
  inline bool has_maxscanangle() const;
  inline void clear_maxscanangle();
  static const int kMaxScanAngleFieldNumber = 7;
  inline float maxscanangle() const;
  inline void set_maxscanangle(float value);

  // optional float multicastRate = 8;
  inline bool has_multicastrate() const;
  inline void clear_multicastrate();
  static const int kMulticastRateFieldNumber = 8;
  inline float multicastrate() const;
  inline void set_multicastrate(float value);

  // optional float pointHoldIncrement = 9;
  inline bool has_pointholdincrement() const;
  inline void clear_pointholdincrement();
  static const int kPointHoldIncrementFieldNumber = 9;
  inline float pointholdincrement() const;
  inline void set_pointholdincrement(float value);

  // optional float energyScanSpeed = 10 [default = 20];
  inline bool has_energyscanspeed() const;
  inline void clear_energyscanspeed();
  static const int kEnergyScanSpeedFieldNumber = 10;
  inline float energyscanspeed() const;
  inline void set_energyscanspeed(float value);

  // optional float startDeviation = 11 [default = 180];
  inline bool has_startdeviation() const;
  inline void clear_startdeviation();
  static const int kStartDeviationFieldNumber = 11;
  inline float startdeviation() const;
  inline void set_startdeviation(float value);

  // optional float energyTrackTime = 12 [default = 500];
  inline bool has_energytracktime() const;
  inline void clear_energytracktime();
  static const int kEnergyTrackTimeFieldNumber = 12;
  inline float energytracktime() const;
  inline void set_energytracktime(float value);

  // optional string scanScrypt = 13 [default = "NONE"];
  inline bool has_scanscrypt() const;
  inline void clear_scanscrypt();
  static const int kScanScryptFieldNumber = 13;
  inline const ::std::string& scanscrypt() const;
  inline void set_scanscrypt(const ::std::string& value);
  inline void set_scanscrypt(const char* value);
  inline void set_scanscrypt(const char* value, size_t size);
  inline ::std::string* mutable_scanscrypt();
  inline ::std::string* release_scanscrypt();
  inline void set_allocated_scanscrypt(::std::string* scanscrypt);

  // optional string gpsServer = 14 [default = "OFF"];
  inline bool has_gpsserver() const;
  inline void clear_gpsserver();
  static const int kGpsServerFieldNumber = 14;
  inline const ::std::string& gpsserver() const;
  inline void set_gpsserver(const ::std::string& value);
  inline void set_gpsserver(const char* value);
  inline void set_gpsserver(const char* value, size_t size);
  inline ::std::string* mutable_gpsserver();
  inline ::std::string* release_gpsserver();
  inline void set_allocated_gpsserver(::std::string* gpsserver);

  // optional string gpsUpdate = 15 [default = "ON"];
  inline bool has_gpsupdate() const;
  inline void clear_gpsupdate();
  static const int kGpsUpdateFieldNumber = 15;
  inline const ::std::string& gpsupdate() const;
  inline void set_gpsupdate(const ::std::string& value);
  inline void set_gpsupdate(const char* value);
  inline void set_gpsupdate(const char* value, size_t size);
  inline ::std::string* mutable_gpsupdate();
  inline ::std::string* release_gpsupdate();
  inline void set_allocated_gpsupdate(::std::string* gpsupdate);

  // optional float azCloseEnough = 16 [default = 5];
  inline bool has_azcloseenough() const;
  inline void clear_azcloseenough();
  static const int kAzCloseEnoughFieldNumber = 16;
  inline float azcloseenough() const;
  inline void set_azcloseenough(float value);

  // optional bool elDisabled = 17 [default = false];
  inline bool has_eldisabled() const;
  inline void clear_eldisabled();
  static const int kElDisabledFieldNumber = 17;
  inline bool eldisabled() const;
  inline void set_eldisabled(bool value);

  // @@protoc_insertion_point(class_scope:falcon_res_msg.RotorProsistelConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_azoffset();
  inline void clear_has_azoffset();
  inline void set_has_hardlimit();
  inline void clear_has_hardlimit();
  inline void set_has_minscanangle();
  inline void clear_has_minscanangle();
  inline void set_has_maxscanangle();
  inline void clear_has_maxscanangle();
  inline void set_has_multicastrate();
  inline void clear_has_multicastrate();
  inline void set_has_pointholdincrement();
  inline void clear_has_pointholdincrement();
  inline void set_has_energyscanspeed();
  inline void clear_has_energyscanspeed();
  inline void set_has_startdeviation();
  inline void clear_has_startdeviation();
  inline void set_has_energytracktime();
  inline void clear_has_energytracktime();
  inline void set_has_scanscrypt();
  inline void clear_has_scanscrypt();
  inline void set_has_gpsserver();
  inline void clear_has_gpsserver();
  inline void set_has_gpsupdate();
  inline void clear_has_gpsupdate();
  inline void set_has_azcloseenough();
  inline void clear_has_azcloseenough();
  inline void set_has_eldisabled();
  inline void clear_has_eldisabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* ip_;
  ::google::protobuf::int32 port_;
  float azoffset_;
  float minscanangle_;
  float maxscanangle_;
  float multicastrate_;
  float pointholdincrement_;
  float energyscanspeed_;
  float startdeviation_;
  bool hardlimit_;
  bool eldisabled_;
  float energytracktime_;
  ::std::string* scanscrypt_;
  static ::std::string* _default_scanscrypt_;
  ::std::string* gpsserver_;
  static ::std::string* _default_gpsserver_;
  ::std::string* gpsupdate_;
  static ::std::string* _default_gpsupdate_;
  float azcloseenough_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  friend void  protobuf_AddDesc_FalconResourceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconResourceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconResourceMessages_2eproto();

  void InitAsDefaultInstance();
  static RotorProsistelConfig* default_instance_;
};
// -------------------------------------------------------------------

class RotorEzrotorConfig : public ::google::protobuf::Message {
 public:
  RotorEzrotorConfig();
  virtual ~RotorEzrotorConfig();

  RotorEzrotorConfig(const RotorEzrotorConfig& from);

  inline RotorEzrotorConfig& operator=(const RotorEzrotorConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RotorEzrotorConfig& default_instance();

  void Swap(RotorEzrotorConfig* other);

  // implements Message ----------------------------------------------

  RotorEzrotorConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RotorEzrotorConfig& from);
  void MergeFrom(const RotorEzrotorConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EZROTOR_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string IP = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIPFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional int32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // optional float AzOffset = 4;
  inline bool has_azoffset() const;
  inline void clear_azoffset();
  static const int kAzOffsetFieldNumber = 4;
  inline float azoffset() const;
  inline void set_azoffset(float value);

  // optional bool hardLimit = 5;
  inline bool has_hardlimit() const;
  inline void clear_hardlimit();
  static const int kHardLimitFieldNumber = 5;
  inline bool hardlimit() const;
  inline void set_hardlimit(bool value);

  // optional float minScanAngle = 6;
  inline bool has_minscanangle() const;
  inline void clear_minscanangle();
  static const int kMinScanAngleFieldNumber = 6;
  inline float minscanangle() const;
  inline void set_minscanangle(float value);

  // optional float maxScanAngle = 7;
  inline bool has_maxscanangle() const;
  inline void clear_maxscanangle();
  static const int kMaxScanAngleFieldNumber = 7;
  inline float maxscanangle() const;
  inline void set_maxscanangle(float value);

  // optional float multicastRate = 8;
  inline bool has_multicastrate() const;
  inline void clear_multicastrate();
  static const int kMulticastRateFieldNumber = 8;
  inline float multicastrate() const;
  inline void set_multicastrate(float value);

  // optional float pointHoldIncrement = 9;
  inline bool has_pointholdincrement() const;
  inline void clear_pointholdincrement();
  static const int kPointHoldIncrementFieldNumber = 9;
  inline float pointholdincrement() const;
  inline void set_pointholdincrement(float value);

  // optional float energyScanSpeed = 10 [default = 20];
  inline bool has_energyscanspeed() const;
  inline void clear_energyscanspeed();
  static const int kEnergyScanSpeedFieldNumber = 10;
  inline float energyscanspeed() const;
  inline void set_energyscanspeed(float value);

  // optional float startDeviation = 11 [default = 180];
  inline bool has_startdeviation() const;
  inline void clear_startdeviation();
  static const int kStartDeviationFieldNumber = 11;
  inline float startdeviation() const;
  inline void set_startdeviation(float value);

  // optional float energyTrackTime = 12 [default = 500];
  inline bool has_energytracktime() const;
  inline void clear_energytracktime();
  static const int kEnergyTrackTimeFieldNumber = 12;
  inline float energytracktime() const;
  inline void set_energytracktime(float value);

  // optional string scanScrypt = 13 [default = "NONE"];
  inline bool has_scanscrypt() const;
  inline void clear_scanscrypt();
  static const int kScanScryptFieldNumber = 13;
  inline const ::std::string& scanscrypt() const;
  inline void set_scanscrypt(const ::std::string& value);
  inline void set_scanscrypt(const char* value);
  inline void set_scanscrypt(const char* value, size_t size);
  inline ::std::string* mutable_scanscrypt();
  inline ::std::string* release_scanscrypt();
  inline void set_allocated_scanscrypt(::std::string* scanscrypt);

  // optional string gpsServer = 14 [default = "OFF"];
  inline bool has_gpsserver() const;
  inline void clear_gpsserver();
  static const int kGpsServerFieldNumber = 14;
  inline const ::std::string& gpsserver() const;
  inline void set_gpsserver(const ::std::string& value);
  inline void set_gpsserver(const char* value);
  inline void set_gpsserver(const char* value, size_t size);
  inline ::std::string* mutable_gpsserver();
  inline ::std::string* release_gpsserver();
  inline void set_allocated_gpsserver(::std::string* gpsserver);

  // optional string gpsUpdate = 15 [default = "ON"];
  inline bool has_gpsupdate() const;
  inline void clear_gpsupdate();
  static const int kGpsUpdateFieldNumber = 15;
  inline const ::std::string& gpsupdate() const;
  inline void set_gpsupdate(const ::std::string& value);
  inline void set_gpsupdate(const char* value);
  inline void set_gpsupdate(const char* value, size_t size);
  inline ::std::string* mutable_gpsupdate();
  inline ::std::string* release_gpsupdate();
  inline void set_allocated_gpsupdate(::std::string* gpsupdate);

  // optional float azCloseEnough = 16 [default = 5];
  inline bool has_azcloseenough() const;
  inline void clear_azcloseenough();
  static const int kAzCloseEnoughFieldNumber = 16;
  inline float azcloseenough() const;
  inline void set_azcloseenough(float value);

  // optional bool elDisabled = 17 [default = false];
  inline bool has_eldisabled() const;
  inline void clear_eldisabled();
  static const int kElDisabledFieldNumber = 17;
  inline bool eldisabled() const;
  inline void set_eldisabled(bool value);

  // @@protoc_insertion_point(class_scope:falcon_res_msg.RotorEzrotorConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_azoffset();
  inline void clear_has_azoffset();
  inline void set_has_hardlimit();
  inline void clear_has_hardlimit();
  inline void set_has_minscanangle();
  inline void clear_has_minscanangle();
  inline void set_has_maxscanangle();
  inline void clear_has_maxscanangle();
  inline void set_has_multicastrate();
  inline void clear_has_multicastrate();
  inline void set_has_pointholdincrement();
  inline void clear_has_pointholdincrement();
  inline void set_has_energyscanspeed();
  inline void clear_has_energyscanspeed();
  inline void set_has_startdeviation();
  inline void clear_has_startdeviation();
  inline void set_has_energytracktime();
  inline void clear_has_energytracktime();
  inline void set_has_scanscrypt();
  inline void clear_has_scanscrypt();
  inline void set_has_gpsserver();
  inline void clear_has_gpsserver();
  inline void set_has_gpsupdate();
  inline void clear_has_gpsupdate();
  inline void set_has_azcloseenough();
  inline void clear_has_azcloseenough();
  inline void set_has_eldisabled();
  inline void clear_has_eldisabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* ip_;
  ::google::protobuf::int32 port_;
  float azoffset_;
  float minscanangle_;
  float maxscanangle_;
  float multicastrate_;
  float pointholdincrement_;
  float energyscanspeed_;
  float startdeviation_;
  bool hardlimit_;
  bool eldisabled_;
  float energytracktime_;
  ::std::string* scanscrypt_;
  static ::std::string* _default_scanscrypt_;
  ::std::string* gpsserver_;
  static ::std::string* _default_gpsserver_;
  ::std::string* gpsupdate_;
  static ::std::string* _default_gpsupdate_;
  float azcloseenough_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  friend void  protobuf_AddDesc_FalconResourceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconResourceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconResourceMessages_2eproto();

  void InitAsDefaultInstance();
  static RotorEzrotorConfig* default_instance_;
};
// -------------------------------------------------------------------

class RotorHGIOConfig : public ::google::protobuf::Message {
 public:
  RotorHGIOConfig();
  virtual ~RotorHGIOConfig();

  RotorHGIOConfig(const RotorHGIOConfig& from);

  inline RotorHGIOConfig& operator=(const RotorHGIOConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RotorHGIOConfig& default_instance();

  void Swap(RotorHGIOConfig* other);

  // implements Message ----------------------------------------------

  RotorHGIOConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RotorHGIOConfig& from);
  void MergeFrom(const RotorHGIOConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "HGIO_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string IP = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIPFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional int32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // optional float AzOffset = 4;
  inline bool has_azoffset() const;
  inline void clear_azoffset();
  static const int kAzOffsetFieldNumber = 4;
  inline float azoffset() const;
  inline void set_azoffset(float value);

  // optional bool hardLimit = 5 [default = false];
  inline bool has_hardlimit() const;
  inline void clear_hardlimit();
  static const int kHardLimitFieldNumber = 5;
  inline bool hardlimit() const;
  inline void set_hardlimit(bool value);

  // optional float minScanAngle = 6;
  inline bool has_minscanangle() const;
  inline void clear_minscanangle();
  static const int kMinScanAngleFieldNumber = 6;
  inline float minscanangle() const;
  inline void set_minscanangle(float value);

  // optional float maxScanAngle = 7;
  inline bool has_maxscanangle() const;
  inline void clear_maxscanangle();
  static const int kMaxScanAngleFieldNumber = 7;
  inline float maxscanangle() const;
  inline void set_maxscanangle(float value);

  // optional float minElevation = 8;
  inline bool has_minelevation() const;
  inline void clear_minelevation();
  static const int kMinElevationFieldNumber = 8;
  inline float minelevation() const;
  inline void set_minelevation(float value);

  // optional float maxElevation = 9;
  inline bool has_maxelevation() const;
  inline void clear_maxelevation();
  static const int kMaxElevationFieldNumber = 9;
  inline float maxelevation() const;
  inline void set_maxelevation(float value);

  // optional float scanElevation = 10;
  inline bool has_scanelevation() const;
  inline void clear_scanelevation();
  static const int kScanElevationFieldNumber = 10;
  inline float scanelevation() const;
  inline void set_scanelevation(float value);

  // optional float multicastRate = 11;
  inline bool has_multicastrate() const;
  inline void clear_multicastrate();
  static const int kMulticastRateFieldNumber = 11;
  inline float multicastrate() const;
  inline void set_multicastrate(float value);

  // optional float pointHoldIncrement = 12;
  inline bool has_pointholdincrement() const;
  inline void clear_pointholdincrement();
  static const int kPointHoldIncrementFieldNumber = 12;
  inline float pointholdincrement() const;
  inline void set_pointholdincrement(float value);

  // optional float energyScanSpeed = 13 [default = 5];
  inline bool has_energyscanspeed() const;
  inline void clear_energyscanspeed();
  static const int kEnergyScanSpeedFieldNumber = 13;
  inline float energyscanspeed() const;
  inline void set_energyscanspeed(float value);

  // optional float startDeviation = 14 [default = 180];
  inline bool has_startdeviation() const;
  inline void clear_startdeviation();
  static const int kStartDeviationFieldNumber = 14;
  inline float startdeviation() const;
  inline void set_startdeviation(float value);

  // optional float energyTrackTime = 15 [default = 500];
  inline bool has_energytracktime() const;
  inline void clear_energytracktime();
  static const int kEnergyTrackTimeFieldNumber = 15;
  inline float energytracktime() const;
  inline void set_energytracktime(float value);

  // optional bool useGps = 16 [default = false];
  inline bool has_usegps() const;
  inline void clear_usegps();
  static const int kUseGpsFieldNumber = 16;
  inline bool usegps() const;
  inline void set_usegps(bool value);

  // optional string scanScrypt = 17 [default = "NONE"];
  inline bool has_scanscrypt() const;
  inline void clear_scanscrypt();
  static const int kScanScryptFieldNumber = 17;
  inline const ::std::string& scanscrypt() const;
  inline void set_scanscrypt(const ::std::string& value);
  inline void set_scanscrypt(const char* value);
  inline void set_scanscrypt(const char* value, size_t size);
  inline ::std::string* mutable_scanscrypt();
  inline ::std::string* release_scanscrypt();
  inline void set_allocated_scanscrypt(::std::string* scanscrypt);

  // optional string gpsServer = 18 [default = "OFF"];
  inline bool has_gpsserver() const;
  inline void clear_gpsserver();
  static const int kGpsServerFieldNumber = 18;
  inline const ::std::string& gpsserver() const;
  inline void set_gpsserver(const ::std::string& value);
  inline void set_gpsserver(const char* value);
  inline void set_gpsserver(const char* value, size_t size);
  inline ::std::string* mutable_gpsserver();
  inline ::std::string* release_gpsserver();
  inline void set_allocated_gpsserver(::std::string* gpsserver);

  // optional string gpsUpdate = 19 [default = "ON"];
  inline bool has_gpsupdate() const;
  inline void clear_gpsupdate();
  static const int kGpsUpdateFieldNumber = 19;
  inline const ::std::string& gpsupdate() const;
  inline void set_gpsupdate(const ::std::string& value);
  inline void set_gpsupdate(const char* value);
  inline void set_gpsupdate(const char* value, size_t size);
  inline ::std::string* mutable_gpsupdate();
  inline ::std::string* release_gpsupdate();
  inline void set_allocated_gpsupdate(::std::string* gpsupdate);

  // optional float azCloseEnough = 20 [default = 0.5];
  inline bool has_azcloseenough() const;
  inline void clear_azcloseenough();
  static const int kAzCloseEnoughFieldNumber = 20;
  inline float azcloseenough() const;
  inline void set_azcloseenough(float value);

  // optional bool elDisabled = 21 [default = false];
  inline bool has_eldisabled() const;
  inline void clear_eldisabled();
  static const int kElDisabledFieldNumber = 21;
  inline bool eldisabled() const;
  inline void set_eldisabled(bool value);

  // optional bool slewEnabled = 22 [default = false];
  inline bool has_slewenabled() const;
  inline void clear_slewenabled();
  static const int kSlewEnabledFieldNumber = 22;
  inline bool slewenabled() const;
  inline void set_slewenabled(bool value);

  // @@protoc_insertion_point(class_scope:falcon_res_msg.RotorHGIOConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_azoffset();
  inline void clear_has_azoffset();
  inline void set_has_hardlimit();
  inline void clear_has_hardlimit();
  inline void set_has_minscanangle();
  inline void clear_has_minscanangle();
  inline void set_has_maxscanangle();
  inline void clear_has_maxscanangle();
  inline void set_has_minelevation();
  inline void clear_has_minelevation();
  inline void set_has_maxelevation();
  inline void clear_has_maxelevation();
  inline void set_has_scanelevation();
  inline void clear_has_scanelevation();
  inline void set_has_multicastrate();
  inline void clear_has_multicastrate();
  inline void set_has_pointholdincrement();
  inline void clear_has_pointholdincrement();
  inline void set_has_energyscanspeed();
  inline void clear_has_energyscanspeed();
  inline void set_has_startdeviation();
  inline void clear_has_startdeviation();
  inline void set_has_energytracktime();
  inline void clear_has_energytracktime();
  inline void set_has_usegps();
  inline void clear_has_usegps();
  inline void set_has_scanscrypt();
  inline void clear_has_scanscrypt();
  inline void set_has_gpsserver();
  inline void clear_has_gpsserver();
  inline void set_has_gpsupdate();
  inline void clear_has_gpsupdate();
  inline void set_has_azcloseenough();
  inline void clear_has_azcloseenough();
  inline void set_has_eldisabled();
  inline void clear_has_eldisabled();
  inline void set_has_slewenabled();
  inline void clear_has_slewenabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* ip_;
  ::google::protobuf::int32 port_;
  float azoffset_;
  float minscanangle_;
  float maxscanangle_;
  float minelevation_;
  float maxelevation_;
  float scanelevation_;
  float multicastrate_;
  float pointholdincrement_;
  float energyscanspeed_;
  float startdeviation_;
  float energytracktime_;
  bool hardlimit_;
  bool usegps_;
  bool eldisabled_;
  bool slewenabled_;
  float azcloseenough_;
  ::std::string* scanscrypt_;
  static ::std::string* _default_scanscrypt_;
  ::std::string* gpsserver_;
  static ::std::string* _default_gpsserver_;
  ::std::string* gpsupdate_;
  static ::std::string* _default_gpsupdate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(22 + 31) / 32];

  friend void  protobuf_AddDesc_FalconResourceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconResourceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconResourceMessages_2eproto();

  void InitAsDefaultInstance();
  static RotorHGIOConfig* default_instance_;
};
// -------------------------------------------------------------------

class RotorESAConfig : public ::google::protobuf::Message {
 public:
  RotorESAConfig();
  virtual ~RotorESAConfig();

  RotorESAConfig(const RotorESAConfig& from);

  inline RotorESAConfig& operator=(const RotorESAConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RotorESAConfig& default_instance();

  void Swap(RotorESAConfig* other);

  // implements Message ----------------------------------------------

  RotorESAConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RotorESAConfig& from);
  void MergeFrom(const RotorESAConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ROTOR_ESA_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string IP = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIPFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional int32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // optional float AzOffset = 4;
  inline bool has_azoffset() const;
  inline void clear_azoffset();
  static const int kAzOffsetFieldNumber = 4;
  inline float azoffset() const;
  inline void set_azoffset(float value);

  // optional bool hardLimit = 5;
  inline bool has_hardlimit() const;
  inline void clear_hardlimit();
  static const int kHardLimitFieldNumber = 5;
  inline bool hardlimit() const;
  inline void set_hardlimit(bool value);

  // optional float minScanAngle = 6;
  inline bool has_minscanangle() const;
  inline void clear_minscanangle();
  static const int kMinScanAngleFieldNumber = 6;
  inline float minscanangle() const;
  inline void set_minscanangle(float value);

  // optional float maxScanAngle = 7;
  inline bool has_maxscanangle() const;
  inline void clear_maxscanangle();
  static const int kMaxScanAngleFieldNumber = 7;
  inline float maxscanangle() const;
  inline void set_maxscanangle(float value);

  // optional float pointHoldIncrement = 8;
  inline bool has_pointholdincrement() const;
  inline void clear_pointholdincrement();
  static const int kPointHoldIncrementFieldNumber = 8;
  inline float pointholdincrement() const;
  inline void set_pointholdincrement(float value);

  // optional float energyScanSpeed = 9 [default = 4];
  inline bool has_energyscanspeed() const;
  inline void clear_energyscanspeed();
  static const int kEnergyScanSpeedFieldNumber = 9;
  inline float energyscanspeed() const;
  inline void set_energyscanspeed(float value);

  // optional float startDeviation = 10 [default = 180];
  inline bool has_startdeviation() const;
  inline void clear_startdeviation();
  static const int kStartDeviationFieldNumber = 10;
  inline float startdeviation() const;
  inline void set_startdeviation(float value);

  // optional float energyTrackTime = 11 [default = 20];
  inline bool has_energytracktime() const;
  inline void clear_energytracktime();
  static const int kEnergyTrackTimeFieldNumber = 11;
  inline float energytracktime() const;
  inline void set_energytracktime(float value);

  // optional string scanScrypt = 12 [default = "NONE"];
  inline bool has_scanscrypt() const;
  inline void clear_scanscrypt();
  static const int kScanScryptFieldNumber = 12;
  inline const ::std::string& scanscrypt() const;
  inline void set_scanscrypt(const ::std::string& value);
  inline void set_scanscrypt(const char* value);
  inline void set_scanscrypt(const char* value, size_t size);
  inline ::std::string* mutable_scanscrypt();
  inline ::std::string* release_scanscrypt();
  inline void set_allocated_scanscrypt(::std::string* scanscrypt);

  // optional float azCloseEnough = 13 [default = 0.5];
  inline bool has_azcloseenough() const;
  inline void clear_azcloseenough();
  static const int kAzCloseEnoughFieldNumber = 13;
  inline float azcloseenough() const;
  inline void set_azcloseenough(float value);

  // optional bool elDisabled = 14 [default = true];
  inline bool has_eldisabled() const;
  inline void clear_eldisabled();
  static const int kElDisabledFieldNumber = 14;
  inline bool eldisabled() const;
  inline void set_eldisabled(bool value);

  // @@protoc_insertion_point(class_scope:falcon_res_msg.RotorESAConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_azoffset();
  inline void clear_has_azoffset();
  inline void set_has_hardlimit();
  inline void clear_has_hardlimit();
  inline void set_has_minscanangle();
  inline void clear_has_minscanangle();
  inline void set_has_maxscanangle();
  inline void clear_has_maxscanangle();
  inline void set_has_pointholdincrement();
  inline void clear_has_pointholdincrement();
  inline void set_has_energyscanspeed();
  inline void clear_has_energyscanspeed();
  inline void set_has_startdeviation();
  inline void clear_has_startdeviation();
  inline void set_has_energytracktime();
  inline void clear_has_energytracktime();
  inline void set_has_scanscrypt();
  inline void clear_has_scanscrypt();
  inline void set_has_azcloseenough();
  inline void clear_has_azcloseenough();
  inline void set_has_eldisabled();
  inline void clear_has_eldisabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* ip_;
  ::google::protobuf::int32 port_;
  float azoffset_;
  float minscanangle_;
  float maxscanangle_;
  float pointholdincrement_;
  float energyscanspeed_;
  bool hardlimit_;
  bool eldisabled_;
  float startdeviation_;
  ::std::string* scanscrypt_;
  static ::std::string* _default_scanscrypt_;
  float energytracktime_;
  float azcloseenough_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_FalconResourceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconResourceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconResourceMessages_2eproto();

  void InitAsDefaultInstance();
  static RotorESAConfig* default_instance_;
};
// -------------------------------------------------------------------

class DSSwitchConfig : public ::google::protobuf::Message {
 public:
  DSSwitchConfig();
  virtual ~DSSwitchConfig();

  DSSwitchConfig(const DSSwitchConfig& from);

  inline DSSwitchConfig& operator=(const DSSwitchConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DSSwitchConfig& default_instance();

  void Swap(DSSwitchConfig* other);

  // implements Message ----------------------------------------------

  DSSwitchConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DSSwitchConfig& from);
  void MergeFrom(const DSSwitchConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "DSSWITCH_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string baseURL = 2;
  inline bool has_baseurl() const;
  inline void clear_baseurl();
  static const int kBaseURLFieldNumber = 2;
  inline const ::std::string& baseurl() const;
  inline void set_baseurl(const ::std::string& value);
  inline void set_baseurl(const char* value);
  inline void set_baseurl(const char* value, size_t size);
  inline ::std::string* mutable_baseurl();
  inline ::std::string* release_baseurl();
  inline void set_allocated_baseurl(::std::string* baseurl);

  // optional string inputPath = 3;
  inline bool has_inputpath() const;
  inline void clear_inputpath();
  static const int kInputPathFieldNumber = 3;
  inline const ::std::string& inputpath() const;
  inline void set_inputpath(const ::std::string& value);
  inline void set_inputpath(const char* value);
  inline void set_inputpath(const char* value, size_t size);
  inline ::std::string* mutable_inputpath();
  inline ::std::string* release_inputpath();
  inline void set_allocated_inputpath(::std::string* inputpath);

  // optional string outputPath = 4;
  inline bool has_outputpath() const;
  inline void clear_outputpath();
  static const int kOutputPathFieldNumber = 4;
  inline const ::std::string& outputpath() const;
  inline void set_outputpath(const ::std::string& value);
  inline void set_outputpath(const char* value);
  inline void set_outputpath(const char* value, size_t size);
  inline ::std::string* mutable_outputpath();
  inline ::std::string* release_outputpath();
  inline void set_allocated_outputpath(::std::string* outputpath);

  // optional string userName = 5;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUserNameFieldNumber = 5;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string password = 6;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 6;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional float sleepTime = 7;
  inline bool has_sleeptime() const;
  inline void clear_sleeptime();
  static const int kSleepTimeFieldNumber = 7;
  inline float sleeptime() const;
  inline void set_sleeptime(float value);

  // optional int32 slaveTimeout = 8 [default = 180];
  inline bool has_slavetimeout() const;
  inline void clear_slavetimeout();
  static const int kSlaveTimeoutFieldNumber = 8;
  inline ::google::protobuf::int32 slavetimeout() const;
  inline void set_slavetimeout(::google::protobuf::int32 value);

  // optional float energyScanSec = 9 [default = 10];
  inline bool has_energyscansec() const;
  inline void clear_energyscansec();
  static const int kEnergyScanSecFieldNumber = 9;
  inline float energyscansec() const;
  inline void set_energyscansec(float value);

  // optional float energyTrackTime = 10 [default = 300];
  inline bool has_energytracktime() const;
  inline void clear_energytracktime();
  static const int kEnergyTrackTimeFieldNumber = 10;
  inline float energytracktime() const;
  inline void set_energytracktime(float value);

  // @@protoc_insertion_point(class_scope:falcon_res_msg.DSSwitchConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_baseurl();
  inline void clear_has_baseurl();
  inline void set_has_inputpath();
  inline void clear_has_inputpath();
  inline void set_has_outputpath();
  inline void clear_has_outputpath();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_sleeptime();
  inline void clear_has_sleeptime();
  inline void set_has_slavetimeout();
  inline void clear_has_slavetimeout();
  inline void set_has_energyscansec();
  inline void clear_has_energyscansec();
  inline void set_has_energytracktime();
  inline void clear_has_energytracktime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* baseurl_;
  ::std::string* inputpath_;
  ::std::string* outputpath_;
  ::std::string* username_;
  ::std::string* password_;
  float sleeptime_;
  ::google::protobuf::int32 slavetimeout_;
  float energyscansec_;
  float energytracktime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_FalconResourceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconResourceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconResourceMessages_2eproto();

  void InitAsDefaultInstance();
  static DSSwitchConfig* default_instance_;
};
// -------------------------------------------------------------------

class DummyConfig : public ::google::protobuf::Message {
 public:
  DummyConfig();
  virtual ~DummyConfig();

  DummyConfig(const DummyConfig& from);

  inline DummyConfig& operator=(const DummyConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DummyConfig& default_instance();

  void Swap(DummyConfig* other);

  // implements Message ----------------------------------------------

  DummyConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DummyConfig& from);
  void MergeFrom(const DummyConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "DummyConfig"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:falcon_res_msg.DummyConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* message_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconResourceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconResourceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconResourceMessages_2eproto();

  void InitAsDefaultInstance();
  static DummyConfig* default_instance_;
};
// -------------------------------------------------------------------

class MMSXTConfig : public ::google::protobuf::Message {
 public:
  MMSXTConfig();
  virtual ~MMSXTConfig();

  MMSXTConfig(const MMSXTConfig& from);

  inline MMSXTConfig& operator=(const MMSXTConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MMSXTConfig& default_instance();

  void Swap(MMSXTConfig* other);

  // implements Message ----------------------------------------------

  MMSXTConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MMSXTConfig& from);
  void MergeFrom(const MMSXTConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "MMSXT_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 transmitter = 2;
  inline bool has_transmitter() const;
  inline void clear_transmitter();
  static const int kTransmitterFieldNumber = 2;
  inline ::google::protobuf::int32 transmitter() const;
  inline void set_transmitter(::google::protobuf::int32 value);

  // optional string MMSXTCtrlIp = 3;
  inline bool has_mmsxtctrlip() const;
  inline void clear_mmsxtctrlip();
  static const int kMMSXTCtrlIpFieldNumber = 3;
  inline const ::std::string& mmsxtctrlip() const;
  inline void set_mmsxtctrlip(const ::std::string& value);
  inline void set_mmsxtctrlip(const char* value);
  inline void set_mmsxtctrlip(const char* value, size_t size);
  inline ::std::string* mutable_mmsxtctrlip();
  inline ::std::string* release_mmsxtctrlip();
  inline void set_allocated_mmsxtctrlip(::std::string* mmsxtctrlip);

  // optional int32 controlPort = 4 [default = 23];
  inline bool has_controlport() const;
  inline void clear_controlport();
  static const int kControlPortFieldNumber = 4;
  inline ::google::protobuf::int32 controlport() const;
  inline void set_controlport(::google::protobuf::int32 value);

  // optional string MMSXTDataIp = 5;
  inline bool has_mmsxtdataip() const;
  inline void clear_mmsxtdataip();
  static const int kMMSXTDataIpFieldNumber = 5;
  inline const ::std::string& mmsxtdataip() const;
  inline void set_mmsxtdataip(const ::std::string& value);
  inline void set_mmsxtdataip(const char* value);
  inline void set_mmsxtdataip(const char* value, size_t size);
  inline ::std::string* mutable_mmsxtdataip();
  inline ::std::string* release_mmsxtdataip();
  inline void set_allocated_mmsxtdataip(::std::string* mmsxtdataip);

  // optional int32 dataPort = 6 [default = 49300];
  inline bool has_dataport() const;
  inline void clear_dataport();
  static const int kDataPortFieldNumber = 6;
  inline ::google::protobuf::int32 dataport() const;
  inline void set_dataport(::google::protobuf::int32 value);

  // optional string uniqTXID = 7 [default = "999"];
  inline bool has_uniqtxid() const;
  inline void clear_uniqtxid();
  static const int kUniqTXIDFieldNumber = 7;
  inline const ::std::string& uniqtxid() const;
  inline void set_uniqtxid(const ::std::string& value);
  inline void set_uniqtxid(const char* value);
  inline void set_uniqtxid(const char* value, size_t size);
  inline ::std::string* mutable_uniqtxid();
  inline ::std::string* release_uniqtxid();
  inline void set_allocated_uniqtxid(::std::string* uniqtxid);

  // optional int32 txcuPort = 8 [default = -1];
  inline bool has_txcuport() const;
  inline void clear_txcuport();
  static const int kTxcuPortFieldNumber = 8;
  inline ::google::protobuf::int32 txcuport() const;
  inline void set_txcuport(::google::protobuf::int32 value);

  // optional string txcuIP = 9 [default = ""];
  inline bool has_txcuip() const;
  inline void clear_txcuip();
  static const int kTxcuIPFieldNumber = 9;
  inline const ::std::string& txcuip() const;
  inline void set_txcuip(const ::std::string& value);
  inline void set_txcuip(const char* value);
  inline void set_txcuip(const char* value, size_t size);
  inline ::std::string* mutable_txcuip();
  inline ::std::string* release_txcuip();
  inline void set_allocated_txcuip(::std::string* txcuip);

  // @@protoc_insertion_point(class_scope:falcon_res_msg.MMSXTConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_transmitter();
  inline void clear_has_transmitter();
  inline void set_has_mmsxtctrlip();
  inline void clear_has_mmsxtctrlip();
  inline void set_has_controlport();
  inline void clear_has_controlport();
  inline void set_has_mmsxtdataip();
  inline void clear_has_mmsxtdataip();
  inline void set_has_dataport();
  inline void clear_has_dataport();
  inline void set_has_uniqtxid();
  inline void clear_has_uniqtxid();
  inline void set_has_txcuport();
  inline void clear_has_txcuport();
  inline void set_has_txcuip();
  inline void clear_has_txcuip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* mmsxtctrlip_;
  ::google::protobuf::int32 transmitter_;
  ::google::protobuf::int32 controlport_;
  ::std::string* mmsxtdataip_;
  ::std::string* uniqtxid_;
  static ::std::string* _default_uniqtxid_;
  ::google::protobuf::int32 dataport_;
  ::google::protobuf::int32 txcuport_;
  ::std::string* txcuip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_FalconResourceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconResourceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconResourceMessages_2eproto();

  void InitAsDefaultInstance();
  static MMSXTConfig* default_instance_;
};
// -------------------------------------------------------------------

class AmpConfig : public ::google::protobuf::Message {
 public:
  AmpConfig();
  virtual ~AmpConfig();

  AmpConfig(const AmpConfig& from);

  inline AmpConfig& operator=(const AmpConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AmpConfig& default_instance();

  void Swap(AmpConfig* other);

  // implements Message ----------------------------------------------

  AmpConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AmpConfig& from);
  void MergeFrom(const AmpConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "AMP_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string IP = 2 [default = "nportserver"];
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIPFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional int32 port = 3 [default = 4012];
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // optional bool hardware = 4;
  inline bool has_hardware() const;
  inline void clear_hardware();
  static const int kHardwareFieldNumber = 4;
  inline bool hardware() const;
  inline void set_hardware(bool value);

  // optional int32 init_atten = 5;
  inline bool has_init_atten() const;
  inline void clear_init_atten();
  static const int kInitAttenFieldNumber = 5;
  inline ::google::protobuf::int32 init_atten() const;
  inline void set_init_atten(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_res_msg.AmpConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_hardware();
  inline void clear_has_hardware();
  inline void set_has_init_atten();
  inline void clear_has_init_atten();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* ip_;
  static ::std::string* _default_ip_;
  ::google::protobuf::int32 port_;
  bool hardware_;
  ::google::protobuf::int32 init_atten_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_FalconResourceMessages_2eproto();
  friend void protobuf_AssignDesc_FalconResourceMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconResourceMessages_2eproto();

  void InitAsDefaultInstance();
  static AmpConfig* default_instance_;
};
// ===================================================================


// ===================================================================

// DummyRcvConfig

// optional string msgName = 1 [default = "DUMMYRCV_CONFIG"];
inline bool DummyRcvConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DummyRcvConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DummyRcvConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DummyRcvConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& DummyRcvConfig::msgname() const {
  return *msgname_;
}
inline void DummyRcvConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void DummyRcvConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void DummyRcvConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DummyRcvConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* DummyRcvConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void DummyRcvConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 channel = 2;
inline bool DummyRcvConfig::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DummyRcvConfig::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DummyRcvConfig::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DummyRcvConfig::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 DummyRcvConfig::channel() const {
  return channel_;
}
inline void DummyRcvConfig::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// optional int32 baseAux = 3;
inline bool DummyRcvConfig::has_baseaux() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DummyRcvConfig::set_has_baseaux() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DummyRcvConfig::clear_has_baseaux() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DummyRcvConfig::clear_baseaux() {
  baseaux_ = 0;
  clear_has_baseaux();
}
inline ::google::protobuf::int32 DummyRcvConfig::baseaux() const {
  return baseaux_;
}
inline void DummyRcvConfig::set_baseaux(::google::protobuf::int32 value) {
  set_has_baseaux();
  baseaux_ = value;
}

// optional string rx = 4;
inline bool DummyRcvConfig::has_rx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DummyRcvConfig::set_has_rx() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DummyRcvConfig::clear_has_rx() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DummyRcvConfig::clear_rx() {
  if (rx_ != &::google::protobuf::internal::kEmptyString) {
    rx_->clear();
  }
  clear_has_rx();
}
inline const ::std::string& DummyRcvConfig::rx() const {
  return *rx_;
}
inline void DummyRcvConfig::set_rx(const ::std::string& value) {
  set_has_rx();
  if (rx_ == &::google::protobuf::internal::kEmptyString) {
    rx_ = new ::std::string;
  }
  rx_->assign(value);
}
inline void DummyRcvConfig::set_rx(const char* value) {
  set_has_rx();
  if (rx_ == &::google::protobuf::internal::kEmptyString) {
    rx_ = new ::std::string;
  }
  rx_->assign(value);
}
inline void DummyRcvConfig::set_rx(const char* value, size_t size) {
  set_has_rx();
  if (rx_ == &::google::protobuf::internal::kEmptyString) {
    rx_ = new ::std::string;
  }
  rx_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DummyRcvConfig::mutable_rx() {
  set_has_rx();
  if (rx_ == &::google::protobuf::internal::kEmptyString) {
    rx_ = new ::std::string;
  }
  return rx_;
}
inline ::std::string* DummyRcvConfig::release_rx() {
  clear_has_rx();
  if (rx_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rx_;
    rx_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DummyRcvConfig::set_allocated_rx(::std::string* rx) {
  if (rx_ != &::google::protobuf::internal::kEmptyString) {
    delete rx_;
  }
  if (rx) {
    set_has_rx();
    rx_ = rx;
  } else {
    clear_has_rx();
    rx_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string host = 5 [default = "local"];
inline bool DummyRcvConfig::has_host() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DummyRcvConfig::set_has_host() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DummyRcvConfig::clear_has_host() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DummyRcvConfig::clear_host() {
  if (host_ != _default_host_) {
    host_->assign(*_default_host_);
  }
  clear_has_host();
}
inline const ::std::string& DummyRcvConfig::host() const {
  return *host_;
}
inline void DummyRcvConfig::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == _default_host_) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void DummyRcvConfig::set_host(const char* value) {
  set_has_host();
  if (host_ == _default_host_) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void DummyRcvConfig::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == _default_host_) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DummyRcvConfig::mutable_host() {
  set_has_host();
  if (host_ == _default_host_) {
    host_ = new ::std::string(*_default_host_);
  }
  return host_;
}
inline ::std::string* DummyRcvConfig::release_host() {
  clear_has_host();
  if (host_ == _default_host_) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(_default_host_);
    return temp;
  }
}
inline void DummyRcvConfig::set_allocated_host(::std::string* host) {
  if (host_ != _default_host_) {
    delete host_;
  }
  if (host) {
    set_has_host();
    host_ = host;
  } else {
    clear_has_host();
    host_ = const_cast< ::std::string*>(_default_host_);
  }
}

// optional float fs = 6 [default = 1e+08];
inline bool DummyRcvConfig::has_fs() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DummyRcvConfig::set_has_fs() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DummyRcvConfig::clear_has_fs() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DummyRcvConfig::clear_fs() {
  fs_ = 1e+08f;
  clear_has_fs();
}
inline float DummyRcvConfig::fs() const {
  return fs_;
}
inline void DummyRcvConfig::set_fs(float value) {
  set_has_fs();
  fs_ = value;
}

// optional float minRF = 7 [default = 2e+07];
inline bool DummyRcvConfig::has_minrf() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DummyRcvConfig::set_has_minrf() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DummyRcvConfig::clear_has_minrf() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DummyRcvConfig::clear_minrf() {
  minrf_ = 2e+07f;
  clear_has_minrf();
}
inline float DummyRcvConfig::minrf() const {
  return minrf_;
}
inline void DummyRcvConfig::set_minrf(float value) {
  set_has_minrf();
  minrf_ = value;
}

// optional float maxRF = 8 [default = 3e+09];
inline bool DummyRcvConfig::has_maxrf() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DummyRcvConfig::set_has_maxrf() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DummyRcvConfig::clear_has_maxrf() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DummyRcvConfig::clear_maxrf() {
  maxrf_ = 3e+09f;
  clear_has_maxrf();
}
inline float DummyRcvConfig::maxrf() const {
  return maxrf_;
}
inline void DummyRcvConfig::set_maxrf(float value) {
  set_has_maxrf();
  maxrf_ = value;
}

// optional string uniqRXID = 9 [default = "999"];
inline bool DummyRcvConfig::has_uniqrxid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DummyRcvConfig::set_has_uniqrxid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DummyRcvConfig::clear_has_uniqrxid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DummyRcvConfig::clear_uniqrxid() {
  if (uniqrxid_ != _default_uniqrxid_) {
    uniqrxid_->assign(*_default_uniqrxid_);
  }
  clear_has_uniqrxid();
}
inline const ::std::string& DummyRcvConfig::uniqrxid() const {
  return *uniqrxid_;
}
inline void DummyRcvConfig::set_uniqrxid(const ::std::string& value) {
  set_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    uniqrxid_ = new ::std::string;
  }
  uniqrxid_->assign(value);
}
inline void DummyRcvConfig::set_uniqrxid(const char* value) {
  set_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    uniqrxid_ = new ::std::string;
  }
  uniqrxid_->assign(value);
}
inline void DummyRcvConfig::set_uniqrxid(const char* value, size_t size) {
  set_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    uniqrxid_ = new ::std::string;
  }
  uniqrxid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DummyRcvConfig::mutable_uniqrxid() {
  set_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    uniqrxid_ = new ::std::string(*_default_uniqrxid_);
  }
  return uniqrxid_;
}
inline ::std::string* DummyRcvConfig::release_uniqrxid() {
  clear_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    return NULL;
  } else {
    ::std::string* temp = uniqrxid_;
    uniqrxid_ = const_cast< ::std::string*>(_default_uniqrxid_);
    return temp;
  }
}
inline void DummyRcvConfig::set_allocated_uniqrxid(::std::string* uniqrxid) {
  if (uniqrxid_ != _default_uniqrxid_) {
    delete uniqrxid_;
  }
  if (uniqrxid) {
    set_has_uniqrxid();
    uniqrxid_ = uniqrxid;
  } else {
    clear_has_uniqrxid();
    uniqrxid_ = const_cast< ::std::string*>(_default_uniqrxid_);
  }
}

// optional int32 pair = 10;
inline bool DummyRcvConfig::has_pair() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DummyRcvConfig::set_has_pair() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DummyRcvConfig::clear_has_pair() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DummyRcvConfig::clear_pair() {
  pair_ = 0;
  clear_has_pair();
}
inline ::google::protobuf::int32 DummyRcvConfig::pair() const {
  return pair_;
}
inline void DummyRcvConfig::set_pair(::google::protobuf::int32 value) {
  set_has_pair();
  pair_ = value;
}

// optional int32 testDur = 11;
inline bool DummyRcvConfig::has_testdur() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DummyRcvConfig::set_has_testdur() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DummyRcvConfig::clear_has_testdur() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DummyRcvConfig::clear_testdur() {
  testdur_ = 0;
  clear_has_testdur();
}
inline ::google::protobuf::int32 DummyRcvConfig::testdur() const {
  return testdur_;
}
inline void DummyRcvConfig::set_testdur(::google::protobuf::int32 value) {
  set_has_testdur();
  testdur_ = value;
}

// -------------------------------------------------------------------

// PICConfig

// optional string msgName = 1 [default = "PIC_CONFIG"];
inline bool PICConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PICConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PICConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PICConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& PICConfig::msgname() const {
  return *msgname_;
}
inline void PICConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void PICConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void PICConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PICConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* PICConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void PICConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 channel = 2;
inline bool PICConfig::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PICConfig::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PICConfig::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PICConfig::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 PICConfig::channel() const {
  return channel_;
}
inline void PICConfig::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// optional int32 baseAux = 3;
inline bool PICConfig::has_baseaux() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PICConfig::set_has_baseaux() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PICConfig::clear_has_baseaux() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PICConfig::clear_baseaux() {
  baseaux_ = 0;
  clear_has_baseaux();
}
inline ::google::protobuf::int32 PICConfig::baseaux() const {
  return baseaux_;
}
inline void PICConfig::set_baseaux(::google::protobuf::int32 value) {
  set_has_baseaux();
  baseaux_ = value;
}

// optional string rx = 4;
inline bool PICConfig::has_rx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PICConfig::set_has_rx() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PICConfig::clear_has_rx() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PICConfig::clear_rx() {
  if (rx_ != &::google::protobuf::internal::kEmptyString) {
    rx_->clear();
  }
  clear_has_rx();
}
inline const ::std::string& PICConfig::rx() const {
  return *rx_;
}
inline void PICConfig::set_rx(const ::std::string& value) {
  set_has_rx();
  if (rx_ == &::google::protobuf::internal::kEmptyString) {
    rx_ = new ::std::string;
  }
  rx_->assign(value);
}
inline void PICConfig::set_rx(const char* value) {
  set_has_rx();
  if (rx_ == &::google::protobuf::internal::kEmptyString) {
    rx_ = new ::std::string;
  }
  rx_->assign(value);
}
inline void PICConfig::set_rx(const char* value, size_t size) {
  set_has_rx();
  if (rx_ == &::google::protobuf::internal::kEmptyString) {
    rx_ = new ::std::string;
  }
  rx_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PICConfig::mutable_rx() {
  set_has_rx();
  if (rx_ == &::google::protobuf::internal::kEmptyString) {
    rx_ = new ::std::string;
  }
  return rx_;
}
inline ::std::string* PICConfig::release_rx() {
  clear_has_rx();
  if (rx_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rx_;
    rx_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PICConfig::set_allocated_rx(::std::string* rx) {
  if (rx_ != &::google::protobuf::internal::kEmptyString) {
    delete rx_;
  }
  if (rx) {
    set_has_rx();
    rx_ = rx;
  } else {
    clear_has_rx();
    rx_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pic = 5;
inline bool PICConfig::has_pic() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PICConfig::set_has_pic() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PICConfig::clear_has_pic() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PICConfig::clear_pic() {
  if (pic_ != &::google::protobuf::internal::kEmptyString) {
    pic_->clear();
  }
  clear_has_pic();
}
inline const ::std::string& PICConfig::pic() const {
  return *pic_;
}
inline void PICConfig::set_pic(const ::std::string& value) {
  set_has_pic();
  if (pic_ == &::google::protobuf::internal::kEmptyString) {
    pic_ = new ::std::string;
  }
  pic_->assign(value);
}
inline void PICConfig::set_pic(const char* value) {
  set_has_pic();
  if (pic_ == &::google::protobuf::internal::kEmptyString) {
    pic_ = new ::std::string;
  }
  pic_->assign(value);
}
inline void PICConfig::set_pic(const char* value, size_t size) {
  set_has_pic();
  if (pic_ == &::google::protobuf::internal::kEmptyString) {
    pic_ = new ::std::string;
  }
  pic_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PICConfig::mutable_pic() {
  set_has_pic();
  if (pic_ == &::google::protobuf::internal::kEmptyString) {
    pic_ = new ::std::string;
  }
  return pic_;
}
inline ::std::string* PICConfig::release_pic() {
  clear_has_pic();
  if (pic_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pic_;
    pic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PICConfig::set_allocated_pic(::std::string* pic) {
  if (pic_ != &::google::protobuf::internal::kEmptyString) {
    delete pic_;
  }
  if (pic) {
    set_has_pic();
    pic_ = pic;
  } else {
    clear_has_pic();
    pic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string picflags = 6;
inline bool PICConfig::has_picflags() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PICConfig::set_has_picflags() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PICConfig::clear_has_picflags() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PICConfig::clear_picflags() {
  if (picflags_ != &::google::protobuf::internal::kEmptyString) {
    picflags_->clear();
  }
  clear_has_picflags();
}
inline const ::std::string& PICConfig::picflags() const {
  return *picflags_;
}
inline void PICConfig::set_picflags(const ::std::string& value) {
  set_has_picflags();
  if (picflags_ == &::google::protobuf::internal::kEmptyString) {
    picflags_ = new ::std::string;
  }
  picflags_->assign(value);
}
inline void PICConfig::set_picflags(const char* value) {
  set_has_picflags();
  if (picflags_ == &::google::protobuf::internal::kEmptyString) {
    picflags_ = new ::std::string;
  }
  picflags_->assign(value);
}
inline void PICConfig::set_picflags(const char* value, size_t size) {
  set_has_picflags();
  if (picflags_ == &::google::protobuf::internal::kEmptyString) {
    picflags_ = new ::std::string;
  }
  picflags_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PICConfig::mutable_picflags() {
  set_has_picflags();
  if (picflags_ == &::google::protobuf::internal::kEmptyString) {
    picflags_ = new ::std::string;
  }
  return picflags_;
}
inline ::std::string* PICConfig::release_picflags() {
  clear_has_picflags();
  if (picflags_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = picflags_;
    picflags_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PICConfig::set_allocated_picflags(::std::string* picflags) {
  if (picflags_ != &::google::protobuf::internal::kEmptyString) {
    delete picflags_;
  }
  if (picflags) {
    set_has_picflags();
    picflags_ = picflags;
  } else {
    clear_has_picflags();
    picflags_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string picside = 7;
inline bool PICConfig::has_picside() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PICConfig::set_has_picside() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PICConfig::clear_has_picside() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PICConfig::clear_picside() {
  if (picside_ != &::google::protobuf::internal::kEmptyString) {
    picside_->clear();
  }
  clear_has_picside();
}
inline const ::std::string& PICConfig::picside() const {
  return *picside_;
}
inline void PICConfig::set_picside(const ::std::string& value) {
  set_has_picside();
  if (picside_ == &::google::protobuf::internal::kEmptyString) {
    picside_ = new ::std::string;
  }
  picside_->assign(value);
}
inline void PICConfig::set_picside(const char* value) {
  set_has_picside();
  if (picside_ == &::google::protobuf::internal::kEmptyString) {
    picside_ = new ::std::string;
  }
  picside_->assign(value);
}
inline void PICConfig::set_picside(const char* value, size_t size) {
  set_has_picside();
  if (picside_ == &::google::protobuf::internal::kEmptyString) {
    picside_ = new ::std::string;
  }
  picside_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PICConfig::mutable_picside() {
  set_has_picside();
  if (picside_ == &::google::protobuf::internal::kEmptyString) {
    picside_ = new ::std::string;
  }
  return picside_;
}
inline ::std::string* PICConfig::release_picside() {
  clear_has_picside();
  if (picside_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = picside_;
    picside_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PICConfig::set_allocated_picside(::std::string* picside) {
  if (picside_ != &::google::protobuf::internal::kEmptyString) {
    delete picside_;
  }
  if (picside) {
    set_has_picside();
    picside_ = picside;
  } else {
    clear_has_picside();
    picside_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string host = 8 [default = "local"];
inline bool PICConfig::has_host() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PICConfig::set_has_host() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PICConfig::clear_has_host() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PICConfig::clear_host() {
  if (host_ != _default_host_) {
    host_->assign(*_default_host_);
  }
  clear_has_host();
}
inline const ::std::string& PICConfig::host() const {
  return *host_;
}
inline void PICConfig::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == _default_host_) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void PICConfig::set_host(const char* value) {
  set_has_host();
  if (host_ == _default_host_) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void PICConfig::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == _default_host_) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PICConfig::mutable_host() {
  set_has_host();
  if (host_ == _default_host_) {
    host_ = new ::std::string(*_default_host_);
  }
  return host_;
}
inline ::std::string* PICConfig::release_host() {
  clear_has_host();
  if (host_ == _default_host_) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(_default_host_);
    return temp;
  }
}
inline void PICConfig::set_allocated_host(::std::string* host) {
  if (host_ != _default_host_) {
    delete host_;
  }
  if (host) {
    set_has_host();
    host_ = host;
  } else {
    clear_has_host();
    host_ = const_cast< ::std::string*>(_default_host_);
  }
}

// optional float fs = 9 [default = 1e+08];
inline bool PICConfig::has_fs() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PICConfig::set_has_fs() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PICConfig::clear_has_fs() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PICConfig::clear_fs() {
  fs_ = 1e+08f;
  clear_has_fs();
}
inline float PICConfig::fs() const {
  return fs_;
}
inline void PICConfig::set_fs(float value) {
  set_has_fs();
  fs_ = value;
}

// optional float minRF = 10 [default = 2e+07];
inline bool PICConfig::has_minrf() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PICConfig::set_has_minrf() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PICConfig::clear_has_minrf() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PICConfig::clear_minrf() {
  minrf_ = 2e+07f;
  clear_has_minrf();
}
inline float PICConfig::minrf() const {
  return minrf_;
}
inline void PICConfig::set_minrf(float value) {
  set_has_minrf();
  minrf_ = value;
}

// optional float maxRF = 11 [default = 3e+09];
inline bool PICConfig::has_maxrf() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PICConfig::set_has_maxrf() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PICConfig::clear_has_maxrf() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PICConfig::clear_maxrf() {
  maxrf_ = 3e+09f;
  clear_has_maxrf();
}
inline float PICConfig::maxrf() const {
  return maxrf_;
}
inline void PICConfig::set_maxrf(float value) {
  set_has_maxrf();
  maxrf_ = value;
}

// optional string uniqRXID = 12 [default = "999"];
inline bool PICConfig::has_uniqrxid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PICConfig::set_has_uniqrxid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PICConfig::clear_has_uniqrxid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PICConfig::clear_uniqrxid() {
  if (uniqrxid_ != _default_uniqrxid_) {
    uniqrxid_->assign(*_default_uniqrxid_);
  }
  clear_has_uniqrxid();
}
inline const ::std::string& PICConfig::uniqrxid() const {
  return *uniqrxid_;
}
inline void PICConfig::set_uniqrxid(const ::std::string& value) {
  set_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    uniqrxid_ = new ::std::string;
  }
  uniqrxid_->assign(value);
}
inline void PICConfig::set_uniqrxid(const char* value) {
  set_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    uniqrxid_ = new ::std::string;
  }
  uniqrxid_->assign(value);
}
inline void PICConfig::set_uniqrxid(const char* value, size_t size) {
  set_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    uniqrxid_ = new ::std::string;
  }
  uniqrxid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PICConfig::mutable_uniqrxid() {
  set_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    uniqrxid_ = new ::std::string(*_default_uniqrxid_);
  }
  return uniqrxid_;
}
inline ::std::string* PICConfig::release_uniqrxid() {
  clear_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    return NULL;
  } else {
    ::std::string* temp = uniqrxid_;
    uniqrxid_ = const_cast< ::std::string*>(_default_uniqrxid_);
    return temp;
  }
}
inline void PICConfig::set_allocated_uniqrxid(::std::string* uniqrxid) {
  if (uniqrxid_ != _default_uniqrxid_) {
    delete uniqrxid_;
  }
  if (uniqrxid) {
    set_has_uniqrxid();
    uniqrxid_ = uniqrxid;
  } else {
    clear_has_uniqrxid();
    uniqrxid_ = const_cast< ::std::string*>(_default_uniqrxid_);
  }
}

// optional int32 pair = 13;
inline bool PICConfig::has_pair() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PICConfig::set_has_pair() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PICConfig::clear_has_pair() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PICConfig::clear_pair() {
  pair_ = 0;
  clear_has_pair();
}
inline ::google::protobuf::int32 PICConfig::pair() const {
  return pair_;
}
inline void PICConfig::set_pair(::google::protobuf::int32 value) {
  set_has_pair();
  pair_ = value;
}

// optional int32 testDur = 14;
inline bool PICConfig::has_testdur() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PICConfig::set_has_testdur() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PICConfig::clear_has_testdur() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PICConfig::clear_testdur() {
  testdur_ = 0;
  clear_has_testdur();
}
inline ::google::protobuf::int32 PICConfig::testdur() const {
  return testdur_;
}
inline void PICConfig::set_testdur(::google::protobuf::int32 value) {
  set_has_testdur();
  testdur_ = value;
}

// -------------------------------------------------------------------

// MMSConfig

// optional string msgName = 1 [default = "MMS_CONFIG"];
inline bool MMSConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MMSConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MMSConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MMSConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& MMSConfig::msgname() const {
  return *msgname_;
}
inline void MMSConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void MMSConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void MMSConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* MMSConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void MMSConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 channel = 2;
inline bool MMSConfig::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MMSConfig::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MMSConfig::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MMSConfig::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 MMSConfig::channel() const {
  return channel_;
}
inline void MMSConfig::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// optional int32 baseAux = 3;
inline bool MMSConfig::has_baseaux() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MMSConfig::set_has_baseaux() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MMSConfig::clear_has_baseaux() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MMSConfig::clear_baseaux() {
  baseaux_ = 0;
  clear_has_baseaux();
}
inline ::google::protobuf::int32 MMSConfig::baseaux() const {
  return baseaux_;
}
inline void MMSConfig::set_baseaux(::google::protobuf::int32 value) {
  set_has_baseaux();
  baseaux_ = value;
}

// optional string IP = 4;
inline bool MMSConfig::has_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MMSConfig::set_has_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MMSConfig::clear_has_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MMSConfig::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& MMSConfig::ip() const {
  return *ip_;
}
inline void MMSConfig::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void MMSConfig::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void MMSConfig::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSConfig::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* MMSConfig::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MMSConfig::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 controlPort = 5;
inline bool MMSConfig::has_controlport() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MMSConfig::set_has_controlport() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MMSConfig::clear_has_controlport() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MMSConfig::clear_controlport() {
  controlport_ = 0;
  clear_has_controlport();
}
inline ::google::protobuf::int32 MMSConfig::controlport() const {
  return controlport_;
}
inline void MMSConfig::set_controlport(::google::protobuf::int32 value) {
  set_has_controlport();
  controlport_ = value;
}

// optional int32 dataPort = 6;
inline bool MMSConfig::has_dataport() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MMSConfig::set_has_dataport() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MMSConfig::clear_has_dataport() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MMSConfig::clear_dataport() {
  dataport_ = 0;
  clear_has_dataport();
}
inline ::google::protobuf::int32 MMSConfig::dataport() const {
  return dataport_;
}
inline void MMSConfig::set_dataport(::google::protobuf::int32 value) {
  set_has_dataport();
  dataport_ = value;
}

// optional string interfaceIP = 7;
inline bool MMSConfig::has_interfaceip() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MMSConfig::set_has_interfaceip() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MMSConfig::clear_has_interfaceip() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MMSConfig::clear_interfaceip() {
  if (interfaceip_ != &::google::protobuf::internal::kEmptyString) {
    interfaceip_->clear();
  }
  clear_has_interfaceip();
}
inline const ::std::string& MMSConfig::interfaceip() const {
  return *interfaceip_;
}
inline void MMSConfig::set_interfaceip(const ::std::string& value) {
  set_has_interfaceip();
  if (interfaceip_ == &::google::protobuf::internal::kEmptyString) {
    interfaceip_ = new ::std::string;
  }
  interfaceip_->assign(value);
}
inline void MMSConfig::set_interfaceip(const char* value) {
  set_has_interfaceip();
  if (interfaceip_ == &::google::protobuf::internal::kEmptyString) {
    interfaceip_ = new ::std::string;
  }
  interfaceip_->assign(value);
}
inline void MMSConfig::set_interfaceip(const char* value, size_t size) {
  set_has_interfaceip();
  if (interfaceip_ == &::google::protobuf::internal::kEmptyString) {
    interfaceip_ = new ::std::string;
  }
  interfaceip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSConfig::mutable_interfaceip() {
  set_has_interfaceip();
  if (interfaceip_ == &::google::protobuf::internal::kEmptyString) {
    interfaceip_ = new ::std::string;
  }
  return interfaceip_;
}
inline ::std::string* MMSConfig::release_interfaceip() {
  clear_has_interfaceip();
  if (interfaceip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = interfaceip_;
    interfaceip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MMSConfig::set_allocated_interfaceip(::std::string* interfaceip) {
  if (interfaceip_ != &::google::protobuf::internal::kEmptyString) {
    delete interfaceip_;
  }
  if (interfaceip) {
    set_has_interfaceip();
    interfaceip_ = interfaceip;
  } else {
    clear_has_interfaceip();
    interfaceip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 receiver = 8;
inline bool MMSConfig::has_receiver() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MMSConfig::set_has_receiver() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MMSConfig::clear_has_receiver() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MMSConfig::clear_receiver() {
  receiver_ = 0;
  clear_has_receiver();
}
inline ::google::protobuf::int32 MMSConfig::receiver() const {
  return receiver_;
}
inline void MMSConfig::set_receiver(::google::protobuf::int32 value) {
  set_has_receiver();
  receiver_ = value;
}

// optional string host = 9 [default = "local"];
inline bool MMSConfig::has_host() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MMSConfig::set_has_host() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MMSConfig::clear_has_host() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MMSConfig::clear_host() {
  if (host_ != _default_host_) {
    host_->assign(*_default_host_);
  }
  clear_has_host();
}
inline const ::std::string& MMSConfig::host() const {
  return *host_;
}
inline void MMSConfig::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == _default_host_) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void MMSConfig::set_host(const char* value) {
  set_has_host();
  if (host_ == _default_host_) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void MMSConfig::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == _default_host_) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSConfig::mutable_host() {
  set_has_host();
  if (host_ == _default_host_) {
    host_ = new ::std::string(*_default_host_);
  }
  return host_;
}
inline ::std::string* MMSConfig::release_host() {
  clear_has_host();
  if (host_ == _default_host_) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(_default_host_);
    return temp;
  }
}
inline void MMSConfig::set_allocated_host(::std::string* host) {
  if (host_ != _default_host_) {
    delete host_;
  }
  if (host) {
    set_has_host();
    host_ = host;
  } else {
    clear_has_host();
    host_ = const_cast< ::std::string*>(_default_host_);
  }
}

// optional float fs = 10 [default = 1e+08];
inline bool MMSConfig::has_fs() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MMSConfig::set_has_fs() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MMSConfig::clear_has_fs() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MMSConfig::clear_fs() {
  fs_ = 1e+08f;
  clear_has_fs();
}
inline float MMSConfig::fs() const {
  return fs_;
}
inline void MMSConfig::set_fs(float value) {
  set_has_fs();
  fs_ = value;
}

// optional float minRF = 11 [default = 2e+07];
inline bool MMSConfig::has_minrf() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MMSConfig::set_has_minrf() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MMSConfig::clear_has_minrf() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MMSConfig::clear_minrf() {
  minrf_ = 2e+07f;
  clear_has_minrf();
}
inline float MMSConfig::minrf() const {
  return minrf_;
}
inline void MMSConfig::set_minrf(float value) {
  set_has_minrf();
  minrf_ = value;
}

// optional float maxRF = 12 [default = 3e+09];
inline bool MMSConfig::has_maxrf() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MMSConfig::set_has_maxrf() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MMSConfig::clear_has_maxrf() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MMSConfig::clear_maxrf() {
  maxrf_ = 3e+09f;
  clear_has_maxrf();
}
inline float MMSConfig::maxrf() const {
  return maxrf_;
}
inline void MMSConfig::set_maxrf(float value) {
  set_has_maxrf();
  maxrf_ = value;
}

// optional string cal30abw = 13 [default = "mms_30abw.csv"];
inline bool MMSConfig::has_cal30abw() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MMSConfig::set_has_cal30abw() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MMSConfig::clear_has_cal30abw() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MMSConfig::clear_cal30abw() {
  if (cal30abw_ != _default_cal30abw_) {
    cal30abw_->assign(*_default_cal30abw_);
  }
  clear_has_cal30abw();
}
inline const ::std::string& MMSConfig::cal30abw() const {
  return *cal30abw_;
}
inline void MMSConfig::set_cal30abw(const ::std::string& value) {
  set_has_cal30abw();
  if (cal30abw_ == _default_cal30abw_) {
    cal30abw_ = new ::std::string;
  }
  cal30abw_->assign(value);
}
inline void MMSConfig::set_cal30abw(const char* value) {
  set_has_cal30abw();
  if (cal30abw_ == _default_cal30abw_) {
    cal30abw_ = new ::std::string;
  }
  cal30abw_->assign(value);
}
inline void MMSConfig::set_cal30abw(const char* value, size_t size) {
  set_has_cal30abw();
  if (cal30abw_ == _default_cal30abw_) {
    cal30abw_ = new ::std::string;
  }
  cal30abw_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSConfig::mutable_cal30abw() {
  set_has_cal30abw();
  if (cal30abw_ == _default_cal30abw_) {
    cal30abw_ = new ::std::string(*_default_cal30abw_);
  }
  return cal30abw_;
}
inline ::std::string* MMSConfig::release_cal30abw() {
  clear_has_cal30abw();
  if (cal30abw_ == _default_cal30abw_) {
    return NULL;
  } else {
    ::std::string* temp = cal30abw_;
    cal30abw_ = const_cast< ::std::string*>(_default_cal30abw_);
    return temp;
  }
}
inline void MMSConfig::set_allocated_cal30abw(::std::string* cal30abw) {
  if (cal30abw_ != _default_cal30abw_) {
    delete cal30abw_;
  }
  if (cal30abw) {
    set_has_cal30abw();
    cal30abw_ = cal30abw;
  } else {
    clear_has_cal30abw();
    cal30abw_ = const_cast< ::std::string*>(_default_cal30abw_);
  }
}

// optional string cal5abw = 14 [default = "mms_5abw.csv"];
inline bool MMSConfig::has_cal5abw() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MMSConfig::set_has_cal5abw() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MMSConfig::clear_has_cal5abw() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MMSConfig::clear_cal5abw() {
  if (cal5abw_ != _default_cal5abw_) {
    cal5abw_->assign(*_default_cal5abw_);
  }
  clear_has_cal5abw();
}
inline const ::std::string& MMSConfig::cal5abw() const {
  return *cal5abw_;
}
inline void MMSConfig::set_cal5abw(const ::std::string& value) {
  set_has_cal5abw();
  if (cal5abw_ == _default_cal5abw_) {
    cal5abw_ = new ::std::string;
  }
  cal5abw_->assign(value);
}
inline void MMSConfig::set_cal5abw(const char* value) {
  set_has_cal5abw();
  if (cal5abw_ == _default_cal5abw_) {
    cal5abw_ = new ::std::string;
  }
  cal5abw_->assign(value);
}
inline void MMSConfig::set_cal5abw(const char* value, size_t size) {
  set_has_cal5abw();
  if (cal5abw_ == _default_cal5abw_) {
    cal5abw_ = new ::std::string;
  }
  cal5abw_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSConfig::mutable_cal5abw() {
  set_has_cal5abw();
  if (cal5abw_ == _default_cal5abw_) {
    cal5abw_ = new ::std::string(*_default_cal5abw_);
  }
  return cal5abw_;
}
inline ::std::string* MMSConfig::release_cal5abw() {
  clear_has_cal5abw();
  if (cal5abw_ == _default_cal5abw_) {
    return NULL;
  } else {
    ::std::string* temp = cal5abw_;
    cal5abw_ = const_cast< ::std::string*>(_default_cal5abw_);
    return temp;
  }
}
inline void MMSConfig::set_allocated_cal5abw(::std::string* cal5abw) {
  if (cal5abw_ != _default_cal5abw_) {
    delete cal5abw_;
  }
  if (cal5abw) {
    set_has_cal5abw();
    cal5abw_ = cal5abw;
  } else {
    clear_has_cal5abw();
    cal5abw_ = const_cast< ::std::string*>(_default_cal5abw_);
  }
}

// optional string uniqRXID = 15 [default = "999"];
inline bool MMSConfig::has_uniqrxid() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MMSConfig::set_has_uniqrxid() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MMSConfig::clear_has_uniqrxid() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MMSConfig::clear_uniqrxid() {
  if (uniqrxid_ != _default_uniqrxid_) {
    uniqrxid_->assign(*_default_uniqrxid_);
  }
  clear_has_uniqrxid();
}
inline const ::std::string& MMSConfig::uniqrxid() const {
  return *uniqrxid_;
}
inline void MMSConfig::set_uniqrxid(const ::std::string& value) {
  set_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    uniqrxid_ = new ::std::string;
  }
  uniqrxid_->assign(value);
}
inline void MMSConfig::set_uniqrxid(const char* value) {
  set_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    uniqrxid_ = new ::std::string;
  }
  uniqrxid_->assign(value);
}
inline void MMSConfig::set_uniqrxid(const char* value, size_t size) {
  set_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    uniqrxid_ = new ::std::string;
  }
  uniqrxid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSConfig::mutable_uniqrxid() {
  set_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    uniqrxid_ = new ::std::string(*_default_uniqrxid_);
  }
  return uniqrxid_;
}
inline ::std::string* MMSConfig::release_uniqrxid() {
  clear_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    return NULL;
  } else {
    ::std::string* temp = uniqrxid_;
    uniqrxid_ = const_cast< ::std::string*>(_default_uniqrxid_);
    return temp;
  }
}
inline void MMSConfig::set_allocated_uniqrxid(::std::string* uniqrxid) {
  if (uniqrxid_ != _default_uniqrxid_) {
    delete uniqrxid_;
  }
  if (uniqrxid) {
    set_has_uniqrxid();
    uniqrxid_ = uniqrxid;
  } else {
    clear_has_uniqrxid();
    uniqrxid_ = const_cast< ::std::string*>(_default_uniqrxid_);
  }
}

// optional int32 pair = 16;
inline bool MMSConfig::has_pair() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MMSConfig::set_has_pair() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MMSConfig::clear_has_pair() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MMSConfig::clear_pair() {
  pair_ = 0;
  clear_has_pair();
}
inline ::google::protobuf::int32 MMSConfig::pair() const {
  return pair_;
}
inline void MMSConfig::set_pair(::google::protobuf::int32 value) {
  set_has_pair();
  pair_ = value;
}

// optional int32 testDur = 17;
inline bool MMSConfig::has_testdur() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MMSConfig::set_has_testdur() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MMSConfig::clear_has_testdur() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MMSConfig::clear_testdur() {
  testdur_ = 0;
  clear_has_testdur();
}
inline ::google::protobuf::int32 MMSConfig::testdur() const {
  return testdur_;
}
inline void MMSConfig::set_testdur(::google::protobuf::int32 value) {
  set_has_testdur();
  testdur_ = value;
}

// optional int32 rfcuPort = 18 [default = -1];
inline bool MMSConfig::has_rfcuport() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MMSConfig::set_has_rfcuport() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MMSConfig::clear_has_rfcuport() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MMSConfig::clear_rfcuport() {
  rfcuport_ = -1;
  clear_has_rfcuport();
}
inline ::google::protobuf::int32 MMSConfig::rfcuport() const {
  return rfcuport_;
}
inline void MMSConfig::set_rfcuport(::google::protobuf::int32 value) {
  set_has_rfcuport();
  rfcuport_ = value;
}

// optional string rfcuIP = 19 [default = ""];
inline bool MMSConfig::has_rfcuip() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MMSConfig::set_has_rfcuip() {
  _has_bits_[0] |= 0x00040000u;
}
inline void MMSConfig::clear_has_rfcuip() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void MMSConfig::clear_rfcuip() {
  if (rfcuip_ != &::google::protobuf::internal::kEmptyString) {
    rfcuip_->clear();
  }
  clear_has_rfcuip();
}
inline const ::std::string& MMSConfig::rfcuip() const {
  return *rfcuip_;
}
inline void MMSConfig::set_rfcuip(const ::std::string& value) {
  set_has_rfcuip();
  if (rfcuip_ == &::google::protobuf::internal::kEmptyString) {
    rfcuip_ = new ::std::string;
  }
  rfcuip_->assign(value);
}
inline void MMSConfig::set_rfcuip(const char* value) {
  set_has_rfcuip();
  if (rfcuip_ == &::google::protobuf::internal::kEmptyString) {
    rfcuip_ = new ::std::string;
  }
  rfcuip_->assign(value);
}
inline void MMSConfig::set_rfcuip(const char* value, size_t size) {
  set_has_rfcuip();
  if (rfcuip_ == &::google::protobuf::internal::kEmptyString) {
    rfcuip_ = new ::std::string;
  }
  rfcuip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSConfig::mutable_rfcuip() {
  set_has_rfcuip();
  if (rfcuip_ == &::google::protobuf::internal::kEmptyString) {
    rfcuip_ = new ::std::string;
  }
  return rfcuip_;
}
inline ::std::string* MMSConfig::release_rfcuip() {
  clear_has_rfcuip();
  if (rfcuip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rfcuip_;
    rfcuip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MMSConfig::set_allocated_rfcuip(::std::string* rfcuip) {
  if (rfcuip_ != &::google::protobuf::internal::kEmptyString) {
    delete rfcuip_;
  }
  if (rfcuip) {
    set_has_rfcuip();
    rfcuip_ = rfcuip;
  } else {
    clear_has_rfcuip();
    rfcuip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ZACQConfig

// optional string msgName = 1 [default = "ZACQ_CONFIG"];
inline bool ZACQConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ZACQConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ZACQConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ZACQConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ZACQConfig::msgname() const {
  return *msgname_;
}
inline void ZACQConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ZACQConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ZACQConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZACQConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ZACQConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ZACQConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 channel = 2;
inline bool ZACQConfig::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ZACQConfig::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ZACQConfig::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ZACQConfig::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 ZACQConfig::channel() const {
  return channel_;
}
inline void ZACQConfig::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// optional int32 baseAux = 3;
inline bool ZACQConfig::has_baseaux() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ZACQConfig::set_has_baseaux() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ZACQConfig::clear_has_baseaux() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ZACQConfig::clear_baseaux() {
  baseaux_ = 0;
  clear_has_baseaux();
}
inline ::google::protobuf::int32 ZACQConfig::baseaux() const {
  return baseaux_;
}
inline void ZACQConfig::set_baseaux(::google::protobuf::int32 value) {
  set_has_baseaux();
  baseaux_ = value;
}

// optional string rx = 4;
inline bool ZACQConfig::has_rx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ZACQConfig::set_has_rx() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ZACQConfig::clear_has_rx() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ZACQConfig::clear_rx() {
  if (rx_ != &::google::protobuf::internal::kEmptyString) {
    rx_->clear();
  }
  clear_has_rx();
}
inline const ::std::string& ZACQConfig::rx() const {
  return *rx_;
}
inline void ZACQConfig::set_rx(const ::std::string& value) {
  set_has_rx();
  if (rx_ == &::google::protobuf::internal::kEmptyString) {
    rx_ = new ::std::string;
  }
  rx_->assign(value);
}
inline void ZACQConfig::set_rx(const char* value) {
  set_has_rx();
  if (rx_ == &::google::protobuf::internal::kEmptyString) {
    rx_ = new ::std::string;
  }
  rx_->assign(value);
}
inline void ZACQConfig::set_rx(const char* value, size_t size) {
  set_has_rx();
  if (rx_ == &::google::protobuf::internal::kEmptyString) {
    rx_ = new ::std::string;
  }
  rx_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZACQConfig::mutable_rx() {
  set_has_rx();
  if (rx_ == &::google::protobuf::internal::kEmptyString) {
    rx_ = new ::std::string;
  }
  return rx_;
}
inline ::std::string* ZACQConfig::release_rx() {
  clear_has_rx();
  if (rx_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rx_;
    rx_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ZACQConfig::set_allocated_rx(::std::string* rx) {
  if (rx_ != &::google::protobuf::internal::kEmptyString) {
    delete rx_;
  }
  if (rx) {
    set_has_rx();
    rx_ = rx;
  } else {
    clear_has_rx();
    rx_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string host = 5 [default = "local"];
inline bool ZACQConfig::has_host() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ZACQConfig::set_has_host() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ZACQConfig::clear_has_host() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ZACQConfig::clear_host() {
  if (host_ != _default_host_) {
    host_->assign(*_default_host_);
  }
  clear_has_host();
}
inline const ::std::string& ZACQConfig::host() const {
  return *host_;
}
inline void ZACQConfig::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == _default_host_) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void ZACQConfig::set_host(const char* value) {
  set_has_host();
  if (host_ == _default_host_) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void ZACQConfig::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == _default_host_) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZACQConfig::mutable_host() {
  set_has_host();
  if (host_ == _default_host_) {
    host_ = new ::std::string(*_default_host_);
  }
  return host_;
}
inline ::std::string* ZACQConfig::release_host() {
  clear_has_host();
  if (host_ == _default_host_) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(_default_host_);
    return temp;
  }
}
inline void ZACQConfig::set_allocated_host(::std::string* host) {
  if (host_ != _default_host_) {
    delete host_;
  }
  if (host) {
    set_has_host();
    host_ = host;
  } else {
    clear_has_host();
    host_ = const_cast< ::std::string*>(_default_host_);
  }
}

// optional float fs = 6 [default = 1e+08];
inline bool ZACQConfig::has_fs() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ZACQConfig::set_has_fs() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ZACQConfig::clear_has_fs() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ZACQConfig::clear_fs() {
  fs_ = 1e+08f;
  clear_has_fs();
}
inline float ZACQConfig::fs() const {
  return fs_;
}
inline void ZACQConfig::set_fs(float value) {
  set_has_fs();
  fs_ = value;
}

// optional float minRF = 7 [default = 2e+07];
inline bool ZACQConfig::has_minrf() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ZACQConfig::set_has_minrf() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ZACQConfig::clear_has_minrf() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ZACQConfig::clear_minrf() {
  minrf_ = 2e+07f;
  clear_has_minrf();
}
inline float ZACQConfig::minrf() const {
  return minrf_;
}
inline void ZACQConfig::set_minrf(float value) {
  set_has_minrf();
  minrf_ = value;
}

// optional float maxRF = 8 [default = 3e+09];
inline bool ZACQConfig::has_maxrf() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ZACQConfig::set_has_maxrf() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ZACQConfig::clear_has_maxrf() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ZACQConfig::clear_maxrf() {
  maxrf_ = 3e+09f;
  clear_has_maxrf();
}
inline float ZACQConfig::maxrf() const {
  return maxrf_;
}
inline void ZACQConfig::set_maxrf(float value) {
  set_has_maxrf();
  maxrf_ = value;
}

// optional string uniqRXID = 9 [default = "999"];
inline bool ZACQConfig::has_uniqrxid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ZACQConfig::set_has_uniqrxid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ZACQConfig::clear_has_uniqrxid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ZACQConfig::clear_uniqrxid() {
  if (uniqrxid_ != _default_uniqrxid_) {
    uniqrxid_->assign(*_default_uniqrxid_);
  }
  clear_has_uniqrxid();
}
inline const ::std::string& ZACQConfig::uniqrxid() const {
  return *uniqrxid_;
}
inline void ZACQConfig::set_uniqrxid(const ::std::string& value) {
  set_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    uniqrxid_ = new ::std::string;
  }
  uniqrxid_->assign(value);
}
inline void ZACQConfig::set_uniqrxid(const char* value) {
  set_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    uniqrxid_ = new ::std::string;
  }
  uniqrxid_->assign(value);
}
inline void ZACQConfig::set_uniqrxid(const char* value, size_t size) {
  set_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    uniqrxid_ = new ::std::string;
  }
  uniqrxid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZACQConfig::mutable_uniqrxid() {
  set_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    uniqrxid_ = new ::std::string(*_default_uniqrxid_);
  }
  return uniqrxid_;
}
inline ::std::string* ZACQConfig::release_uniqrxid() {
  clear_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    return NULL;
  } else {
    ::std::string* temp = uniqrxid_;
    uniqrxid_ = const_cast< ::std::string*>(_default_uniqrxid_);
    return temp;
  }
}
inline void ZACQConfig::set_allocated_uniqrxid(::std::string* uniqrxid) {
  if (uniqrxid_ != _default_uniqrxid_) {
    delete uniqrxid_;
  }
  if (uniqrxid) {
    set_has_uniqrxid();
    uniqrxid_ = uniqrxid;
  } else {
    clear_has_uniqrxid();
    uniqrxid_ = const_cast< ::std::string*>(_default_uniqrxid_);
  }
}

// optional int32 pair = 10;
inline bool ZACQConfig::has_pair() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ZACQConfig::set_has_pair() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ZACQConfig::clear_has_pair() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ZACQConfig::clear_pair() {
  pair_ = 0;
  clear_has_pair();
}
inline ::google::protobuf::int32 ZACQConfig::pair() const {
  return pair_;
}
inline void ZACQConfig::set_pair(::google::protobuf::int32 value) {
  set_has_pair();
  pair_ = value;
}

// optional int32 testDur = 11;
inline bool ZACQConfig::has_testdur() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ZACQConfig::set_has_testdur() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ZACQConfig::clear_has_testdur() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ZACQConfig::clear_testdur() {
  testdur_ = 0;
  clear_has_testdur();
}
inline ::google::protobuf::int32 ZACQConfig::testdur() const {
  return testdur_;
}
inline void ZACQConfig::set_testdur(::google::protobuf::int32 value) {
  set_has_testdur();
  testdur_ = value;
}

// optional string initScript = 12;
inline bool ZACQConfig::has_initscript() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ZACQConfig::set_has_initscript() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ZACQConfig::clear_has_initscript() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ZACQConfig::clear_initscript() {
  if (initscript_ != &::google::protobuf::internal::kEmptyString) {
    initscript_->clear();
  }
  clear_has_initscript();
}
inline const ::std::string& ZACQConfig::initscript() const {
  return *initscript_;
}
inline void ZACQConfig::set_initscript(const ::std::string& value) {
  set_has_initscript();
  if (initscript_ == &::google::protobuf::internal::kEmptyString) {
    initscript_ = new ::std::string;
  }
  initscript_->assign(value);
}
inline void ZACQConfig::set_initscript(const char* value) {
  set_has_initscript();
  if (initscript_ == &::google::protobuf::internal::kEmptyString) {
    initscript_ = new ::std::string;
  }
  initscript_->assign(value);
}
inline void ZACQConfig::set_initscript(const char* value, size_t size) {
  set_has_initscript();
  if (initscript_ == &::google::protobuf::internal::kEmptyString) {
    initscript_ = new ::std::string;
  }
  initscript_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZACQConfig::mutable_initscript() {
  set_has_initscript();
  if (initscript_ == &::google::protobuf::internal::kEmptyString) {
    initscript_ = new ::std::string;
  }
  return initscript_;
}
inline ::std::string* ZACQConfig::release_initscript() {
  clear_has_initscript();
  if (initscript_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = initscript_;
    initscript_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ZACQConfig::set_allocated_initscript(::std::string* initscript) {
  if (initscript_ != &::google::protobuf::internal::kEmptyString) {
    delete initscript_;
  }
  if (initscript) {
    set_has_initscript();
    initscript_ = initscript;
  } else {
    clear_has_initscript();
    initscript_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// USRPRxTxConfig

// optional string msgName = 1 [default = "USRP_RXTX_CONFIG"];
inline bool USRPRxTxConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void USRPRxTxConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void USRPRxTxConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void USRPRxTxConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& USRPRxTxConfig::msgname() const {
  return *msgname_;
}
inline void USRPRxTxConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void USRPRxTxConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void USRPRxTxConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* USRPRxTxConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* USRPRxTxConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void USRPRxTxConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 channel = 2;
inline bool USRPRxTxConfig::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void USRPRxTxConfig::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void USRPRxTxConfig::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void USRPRxTxConfig::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 USRPRxTxConfig::channel() const {
  return channel_;
}
inline void USRPRxTxConfig::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// optional int32 baseAux = 3;
inline bool USRPRxTxConfig::has_baseaux() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void USRPRxTxConfig::set_has_baseaux() {
  _has_bits_[0] |= 0x00000004u;
}
inline void USRPRxTxConfig::clear_has_baseaux() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void USRPRxTxConfig::clear_baseaux() {
  baseaux_ = 0;
  clear_has_baseaux();
}
inline ::google::protobuf::int32 USRPRxTxConfig::baseaux() const {
  return baseaux_;
}
inline void USRPRxTxConfig::set_baseaux(::google::protobuf::int32 value) {
  set_has_baseaux();
  baseaux_ = value;
}

// optional string args = 4 [default = "addr=192.168.10.2"];
inline bool USRPRxTxConfig::has_args() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void USRPRxTxConfig::set_has_args() {
  _has_bits_[0] |= 0x00000008u;
}
inline void USRPRxTxConfig::clear_has_args() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void USRPRxTxConfig::clear_args() {
  if (args_ != _default_args_) {
    args_->assign(*_default_args_);
  }
  clear_has_args();
}
inline const ::std::string& USRPRxTxConfig::args() const {
  return *args_;
}
inline void USRPRxTxConfig::set_args(const ::std::string& value) {
  set_has_args();
  if (args_ == _default_args_) {
    args_ = new ::std::string;
  }
  args_->assign(value);
}
inline void USRPRxTxConfig::set_args(const char* value) {
  set_has_args();
  if (args_ == _default_args_) {
    args_ = new ::std::string;
  }
  args_->assign(value);
}
inline void USRPRxTxConfig::set_args(const char* value, size_t size) {
  set_has_args();
  if (args_ == _default_args_) {
    args_ = new ::std::string;
  }
  args_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* USRPRxTxConfig::mutable_args() {
  set_has_args();
  if (args_ == _default_args_) {
    args_ = new ::std::string(*_default_args_);
  }
  return args_;
}
inline ::std::string* USRPRxTxConfig::release_args() {
  clear_has_args();
  if (args_ == _default_args_) {
    return NULL;
  } else {
    ::std::string* temp = args_;
    args_ = const_cast< ::std::string*>(_default_args_);
    return temp;
  }
}
inline void USRPRxTxConfig::set_allocated_args(::std::string* args) {
  if (args_ != _default_args_) {
    delete args_;
  }
  if (args) {
    set_has_args();
    args_ = args;
  } else {
    clear_has_args();
    args_ = const_cast< ::std::string*>(_default_args_);
  }
}

// optional float minRF = 5;
inline bool USRPRxTxConfig::has_minrf() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void USRPRxTxConfig::set_has_minrf() {
  _has_bits_[0] |= 0x00000010u;
}
inline void USRPRxTxConfig::clear_has_minrf() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void USRPRxTxConfig::clear_minrf() {
  minrf_ = 0;
  clear_has_minrf();
}
inline float USRPRxTxConfig::minrf() const {
  return minrf_;
}
inline void USRPRxTxConfig::set_minrf(float value) {
  set_has_minrf();
  minrf_ = value;
}

// optional float maxRF = 6;
inline bool USRPRxTxConfig::has_maxrf() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void USRPRxTxConfig::set_has_maxrf() {
  _has_bits_[0] |= 0x00000020u;
}
inline void USRPRxTxConfig::clear_has_maxrf() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void USRPRxTxConfig::clear_maxrf() {
  maxrf_ = 0;
  clear_has_maxrf();
}
inline float USRPRxTxConfig::maxrf() const {
  return maxrf_;
}
inline void USRPRxTxConfig::set_maxrf(float value) {
  set_has_maxrf();
  maxrf_ = value;
}

// optional float fs = 7 [default = 1e+08];
inline bool USRPRxTxConfig::has_fs() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void USRPRxTxConfig::set_has_fs() {
  _has_bits_[0] |= 0x00000040u;
}
inline void USRPRxTxConfig::clear_has_fs() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void USRPRxTxConfig::clear_fs() {
  fs_ = 1e+08f;
  clear_has_fs();
}
inline float USRPRxTxConfig::fs() const {
  return fs_;
}
inline void USRPRxTxConfig::set_fs(float value) {
  set_has_fs();
  fs_ = value;
}

// optional string uniqRXID = 8 [default = "999"];
inline bool USRPRxTxConfig::has_uniqrxid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void USRPRxTxConfig::set_has_uniqrxid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void USRPRxTxConfig::clear_has_uniqrxid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void USRPRxTxConfig::clear_uniqrxid() {
  if (uniqrxid_ != _default_uniqrxid_) {
    uniqrxid_->assign(*_default_uniqrxid_);
  }
  clear_has_uniqrxid();
}
inline const ::std::string& USRPRxTxConfig::uniqrxid() const {
  return *uniqrxid_;
}
inline void USRPRxTxConfig::set_uniqrxid(const ::std::string& value) {
  set_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    uniqrxid_ = new ::std::string;
  }
  uniqrxid_->assign(value);
}
inline void USRPRxTxConfig::set_uniqrxid(const char* value) {
  set_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    uniqrxid_ = new ::std::string;
  }
  uniqrxid_->assign(value);
}
inline void USRPRxTxConfig::set_uniqrxid(const char* value, size_t size) {
  set_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    uniqrxid_ = new ::std::string;
  }
  uniqrxid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* USRPRxTxConfig::mutable_uniqrxid() {
  set_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    uniqrxid_ = new ::std::string(*_default_uniqrxid_);
  }
  return uniqrxid_;
}
inline ::std::string* USRPRxTxConfig::release_uniqrxid() {
  clear_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    return NULL;
  } else {
    ::std::string* temp = uniqrxid_;
    uniqrxid_ = const_cast< ::std::string*>(_default_uniqrxid_);
    return temp;
  }
}
inline void USRPRxTxConfig::set_allocated_uniqrxid(::std::string* uniqrxid) {
  if (uniqrxid_ != _default_uniqrxid_) {
    delete uniqrxid_;
  }
  if (uniqrxid) {
    set_has_uniqrxid();
    uniqrxid_ = uniqrxid;
  } else {
    clear_has_uniqrxid();
    uniqrxid_ = const_cast< ::std::string*>(_default_uniqrxid_);
  }
}

// -------------------------------------------------------------------

// EPIQRxTxConfig

// optional string msgName = 1 [default = "EPIQ_RXTX_CONFIG"];
inline bool EPIQRxTxConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EPIQRxTxConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EPIQRxTxConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EPIQRxTxConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& EPIQRxTxConfig::msgname() const {
  return *msgname_;
}
inline void EPIQRxTxConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EPIQRxTxConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EPIQRxTxConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EPIQRxTxConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* EPIQRxTxConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void EPIQRxTxConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 channel = 2;
inline bool EPIQRxTxConfig::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EPIQRxTxConfig::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EPIQRxTxConfig::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EPIQRxTxConfig::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 EPIQRxTxConfig::channel() const {
  return channel_;
}
inline void EPIQRxTxConfig::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// optional int32 baseAux = 3;
inline bool EPIQRxTxConfig::has_baseaux() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EPIQRxTxConfig::set_has_baseaux() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EPIQRxTxConfig::clear_has_baseaux() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EPIQRxTxConfig::clear_baseaux() {
  baseaux_ = 0;
  clear_has_baseaux();
}
inline ::google::protobuf::int32 EPIQRxTxConfig::baseaux() const {
  return baseaux_;
}
inline void EPIQRxTxConfig::set_baseaux(::google::protobuf::int32 value) {
  set_has_baseaux();
  baseaux_ = value;
}

// optional int32 controlPort = 4;
inline bool EPIQRxTxConfig::has_controlport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EPIQRxTxConfig::set_has_controlport() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EPIQRxTxConfig::clear_has_controlport() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EPIQRxTxConfig::clear_controlport() {
  controlport_ = 0;
  clear_has_controlport();
}
inline ::google::protobuf::int32 EPIQRxTxConfig::controlport() const {
  return controlport_;
}
inline void EPIQRxTxConfig::set_controlport(::google::protobuf::int32 value) {
  set_has_controlport();
  controlport_ = value;
}

// optional int32 rfPort = 5;
inline bool EPIQRxTxConfig::has_rfport() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EPIQRxTxConfig::set_has_rfport() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EPIQRxTxConfig::clear_has_rfport() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EPIQRxTxConfig::clear_rfport() {
  rfport_ = 0;
  clear_has_rfport();
}
inline ::google::protobuf::int32 EPIQRxTxConfig::rfport() const {
  return rfport_;
}
inline void EPIQRxTxConfig::set_rfport(::google::protobuf::int32 value) {
  set_has_rfport();
  rfport_ = value;
}

// optional string host = 6 [default = "local"];
inline bool EPIQRxTxConfig::has_host() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EPIQRxTxConfig::set_has_host() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EPIQRxTxConfig::clear_has_host() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EPIQRxTxConfig::clear_host() {
  if (host_ != _default_host_) {
    host_->assign(*_default_host_);
  }
  clear_has_host();
}
inline const ::std::string& EPIQRxTxConfig::host() const {
  return *host_;
}
inline void EPIQRxTxConfig::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == _default_host_) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void EPIQRxTxConfig::set_host(const char* value) {
  set_has_host();
  if (host_ == _default_host_) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void EPIQRxTxConfig::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == _default_host_) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EPIQRxTxConfig::mutable_host() {
  set_has_host();
  if (host_ == _default_host_) {
    host_ = new ::std::string(*_default_host_);
  }
  return host_;
}
inline ::std::string* EPIQRxTxConfig::release_host() {
  clear_has_host();
  if (host_ == _default_host_) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(_default_host_);
    return temp;
  }
}
inline void EPIQRxTxConfig::set_allocated_host(::std::string* host) {
  if (host_ != _default_host_) {
    delete host_;
  }
  if (host) {
    set_has_host();
    host_ = host;
  } else {
    clear_has_host();
    host_ = const_cast< ::std::string*>(_default_host_);
  }
}

// optional float minRF = 7;
inline bool EPIQRxTxConfig::has_minrf() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EPIQRxTxConfig::set_has_minrf() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EPIQRxTxConfig::clear_has_minrf() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EPIQRxTxConfig::clear_minrf() {
  minrf_ = 0;
  clear_has_minrf();
}
inline float EPIQRxTxConfig::minrf() const {
  return minrf_;
}
inline void EPIQRxTxConfig::set_minrf(float value) {
  set_has_minrf();
  minrf_ = value;
}

// optional float maxRF = 8;
inline bool EPIQRxTxConfig::has_maxrf() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EPIQRxTxConfig::set_has_maxrf() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EPIQRxTxConfig::clear_has_maxrf() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EPIQRxTxConfig::clear_maxrf() {
  maxrf_ = 0;
  clear_has_maxrf();
}
inline float EPIQRxTxConfig::maxrf() const {
  return maxrf_;
}
inline void EPIQRxTxConfig::set_maxrf(float value) {
  set_has_maxrf();
  maxrf_ = value;
}

// optional float fs = 9 [default = 2.5e+07];
inline bool EPIQRxTxConfig::has_fs() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EPIQRxTxConfig::set_has_fs() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EPIQRxTxConfig::clear_has_fs() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EPIQRxTxConfig::clear_fs() {
  fs_ = 2.5e+07f;
  clear_has_fs();
}
inline float EPIQRxTxConfig::fs() const {
  return fs_;
}
inline void EPIQRxTxConfig::set_fs(float value) {
  set_has_fs();
  fs_ = value;
}

// optional string uniqRXID = 10 [default = "999"];
inline bool EPIQRxTxConfig::has_uniqrxid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EPIQRxTxConfig::set_has_uniqrxid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EPIQRxTxConfig::clear_has_uniqrxid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EPIQRxTxConfig::clear_uniqrxid() {
  if (uniqrxid_ != _default_uniqrxid_) {
    uniqrxid_->assign(*_default_uniqrxid_);
  }
  clear_has_uniqrxid();
}
inline const ::std::string& EPIQRxTxConfig::uniqrxid() const {
  return *uniqrxid_;
}
inline void EPIQRxTxConfig::set_uniqrxid(const ::std::string& value) {
  set_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    uniqrxid_ = new ::std::string;
  }
  uniqrxid_->assign(value);
}
inline void EPIQRxTxConfig::set_uniqrxid(const char* value) {
  set_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    uniqrxid_ = new ::std::string;
  }
  uniqrxid_->assign(value);
}
inline void EPIQRxTxConfig::set_uniqrxid(const char* value, size_t size) {
  set_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    uniqrxid_ = new ::std::string;
  }
  uniqrxid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EPIQRxTxConfig::mutable_uniqrxid() {
  set_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    uniqrxid_ = new ::std::string(*_default_uniqrxid_);
  }
  return uniqrxid_;
}
inline ::std::string* EPIQRxTxConfig::release_uniqrxid() {
  clear_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    return NULL;
  } else {
    ::std::string* temp = uniqrxid_;
    uniqrxid_ = const_cast< ::std::string*>(_default_uniqrxid_);
    return temp;
  }
}
inline void EPIQRxTxConfig::set_allocated_uniqrxid(::std::string* uniqrxid) {
  if (uniqrxid_ != _default_uniqrxid_) {
    delete uniqrxid_;
  }
  if (uniqrxid) {
    set_has_uniqrxid();
    uniqrxid_ = uniqrxid;
  } else {
    clear_has_uniqrxid();
    uniqrxid_ = const_cast< ::std::string*>(_default_uniqrxid_);
  }
}

// optional string uniqTXID = 11 [default = "999"];
inline bool EPIQRxTxConfig::has_uniqtxid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void EPIQRxTxConfig::set_has_uniqtxid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void EPIQRxTxConfig::clear_has_uniqtxid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void EPIQRxTxConfig::clear_uniqtxid() {
  if (uniqtxid_ != _default_uniqtxid_) {
    uniqtxid_->assign(*_default_uniqtxid_);
  }
  clear_has_uniqtxid();
}
inline const ::std::string& EPIQRxTxConfig::uniqtxid() const {
  return *uniqtxid_;
}
inline void EPIQRxTxConfig::set_uniqtxid(const ::std::string& value) {
  set_has_uniqtxid();
  if (uniqtxid_ == _default_uniqtxid_) {
    uniqtxid_ = new ::std::string;
  }
  uniqtxid_->assign(value);
}
inline void EPIQRxTxConfig::set_uniqtxid(const char* value) {
  set_has_uniqtxid();
  if (uniqtxid_ == _default_uniqtxid_) {
    uniqtxid_ = new ::std::string;
  }
  uniqtxid_->assign(value);
}
inline void EPIQRxTxConfig::set_uniqtxid(const char* value, size_t size) {
  set_has_uniqtxid();
  if (uniqtxid_ == _default_uniqtxid_) {
    uniqtxid_ = new ::std::string;
  }
  uniqtxid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EPIQRxTxConfig::mutable_uniqtxid() {
  set_has_uniqtxid();
  if (uniqtxid_ == _default_uniqtxid_) {
    uniqtxid_ = new ::std::string(*_default_uniqtxid_);
  }
  return uniqtxid_;
}
inline ::std::string* EPIQRxTxConfig::release_uniqtxid() {
  clear_has_uniqtxid();
  if (uniqtxid_ == _default_uniqtxid_) {
    return NULL;
  } else {
    ::std::string* temp = uniqtxid_;
    uniqtxid_ = const_cast< ::std::string*>(_default_uniqtxid_);
    return temp;
  }
}
inline void EPIQRxTxConfig::set_allocated_uniqtxid(::std::string* uniqtxid) {
  if (uniqtxid_ != _default_uniqtxid_) {
    delete uniqtxid_;
  }
  if (uniqtxid) {
    set_has_uniqtxid();
    uniqtxid_ = uniqtxid;
  } else {
    clear_has_uniqtxid();
    uniqtxid_ = const_cast< ::std::string*>(_default_uniqtxid_);
  }
}

// optional float delayReset = 12 [default = -1];
inline bool EPIQRxTxConfig::has_delayreset() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void EPIQRxTxConfig::set_has_delayreset() {
  _has_bits_[0] |= 0x00000800u;
}
inline void EPIQRxTxConfig::clear_has_delayreset() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void EPIQRxTxConfig::clear_delayreset() {
  delayreset_ = -1;
  clear_has_delayreset();
}
inline float EPIQRxTxConfig::delayreset() const {
  return delayreset_;
}
inline void EPIQRxTxConfig::set_delayreset(float value) {
  set_has_delayreset();
  delayreset_ = value;
}

// -------------------------------------------------------------------

// RTLSDRConfig

// optional string msgName = 1 [default = "RTLSDR_CONFIG"];
inline bool RTLSDRConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RTLSDRConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RTLSDRConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RTLSDRConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& RTLSDRConfig::msgname() const {
  return *msgname_;
}
inline void RTLSDRConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RTLSDRConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RTLSDRConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RTLSDRConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* RTLSDRConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void RTLSDRConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 channel = 2;
inline bool RTLSDRConfig::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RTLSDRConfig::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RTLSDRConfig::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RTLSDRConfig::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 RTLSDRConfig::channel() const {
  return channel_;
}
inline void RTLSDRConfig::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// optional int32 baseAux = 3;
inline bool RTLSDRConfig::has_baseaux() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RTLSDRConfig::set_has_baseaux() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RTLSDRConfig::clear_has_baseaux() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RTLSDRConfig::clear_baseaux() {
  baseaux_ = 0;
  clear_has_baseaux();
}
inline ::google::protobuf::int32 RTLSDRConfig::baseaux() const {
  return baseaux_;
}
inline void RTLSDRConfig::set_baseaux(::google::protobuf::int32 value) {
  set_has_baseaux();
  baseaux_ = value;
}

// optional int32 controlPort = 4;
inline bool RTLSDRConfig::has_controlport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RTLSDRConfig::set_has_controlport() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RTLSDRConfig::clear_has_controlport() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RTLSDRConfig::clear_controlport() {
  controlport_ = 0;
  clear_has_controlport();
}
inline ::google::protobuf::int32 RTLSDRConfig::controlport() const {
  return controlport_;
}
inline void RTLSDRConfig::set_controlport(::google::protobuf::int32 value) {
  set_has_controlport();
  controlport_ = value;
}

// optional string host = 5 [default = "local"];
inline bool RTLSDRConfig::has_host() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RTLSDRConfig::set_has_host() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RTLSDRConfig::clear_has_host() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RTLSDRConfig::clear_host() {
  if (host_ != _default_host_) {
    host_->assign(*_default_host_);
  }
  clear_has_host();
}
inline const ::std::string& RTLSDRConfig::host() const {
  return *host_;
}
inline void RTLSDRConfig::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == _default_host_) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void RTLSDRConfig::set_host(const char* value) {
  set_has_host();
  if (host_ == _default_host_) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void RTLSDRConfig::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == _default_host_) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RTLSDRConfig::mutable_host() {
  set_has_host();
  if (host_ == _default_host_) {
    host_ = new ::std::string(*_default_host_);
  }
  return host_;
}
inline ::std::string* RTLSDRConfig::release_host() {
  clear_has_host();
  if (host_ == _default_host_) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(_default_host_);
    return temp;
  }
}
inline void RTLSDRConfig::set_allocated_host(::std::string* host) {
  if (host_ != _default_host_) {
    delete host_;
  }
  if (host) {
    set_has_host();
    host_ = host;
  } else {
    clear_has_host();
    host_ = const_cast< ::std::string*>(_default_host_);
  }
}

// optional float minRF = 6;
inline bool RTLSDRConfig::has_minrf() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RTLSDRConfig::set_has_minrf() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RTLSDRConfig::clear_has_minrf() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RTLSDRConfig::clear_minrf() {
  minrf_ = 0;
  clear_has_minrf();
}
inline float RTLSDRConfig::minrf() const {
  return minrf_;
}
inline void RTLSDRConfig::set_minrf(float value) {
  set_has_minrf();
  minrf_ = value;
}

// optional float maxRF = 7;
inline bool RTLSDRConfig::has_maxrf() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RTLSDRConfig::set_has_maxrf() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RTLSDRConfig::clear_has_maxrf() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RTLSDRConfig::clear_maxrf() {
  maxrf_ = 0;
  clear_has_maxrf();
}
inline float RTLSDRConfig::maxrf() const {
  return maxrf_;
}
inline void RTLSDRConfig::set_maxrf(float value) {
  set_has_maxrf();
  maxrf_ = value;
}

// optional float fs = 8 [default = 2.048e+06];
inline bool RTLSDRConfig::has_fs() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RTLSDRConfig::set_has_fs() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RTLSDRConfig::clear_has_fs() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RTLSDRConfig::clear_fs() {
  fs_ = 2.048e+06f;
  clear_has_fs();
}
inline float RTLSDRConfig::fs() const {
  return fs_;
}
inline void RTLSDRConfig::set_fs(float value) {
  set_has_fs();
  fs_ = value;
}

// optional string uniqRXID = 9 [default = "999"];
inline bool RTLSDRConfig::has_uniqrxid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RTLSDRConfig::set_has_uniqrxid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RTLSDRConfig::clear_has_uniqrxid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RTLSDRConfig::clear_uniqrxid() {
  if (uniqrxid_ != _default_uniqrxid_) {
    uniqrxid_->assign(*_default_uniqrxid_);
  }
  clear_has_uniqrxid();
}
inline const ::std::string& RTLSDRConfig::uniqrxid() const {
  return *uniqrxid_;
}
inline void RTLSDRConfig::set_uniqrxid(const ::std::string& value) {
  set_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    uniqrxid_ = new ::std::string;
  }
  uniqrxid_->assign(value);
}
inline void RTLSDRConfig::set_uniqrxid(const char* value) {
  set_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    uniqrxid_ = new ::std::string;
  }
  uniqrxid_->assign(value);
}
inline void RTLSDRConfig::set_uniqrxid(const char* value, size_t size) {
  set_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    uniqrxid_ = new ::std::string;
  }
  uniqrxid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RTLSDRConfig::mutable_uniqrxid() {
  set_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    uniqrxid_ = new ::std::string(*_default_uniqrxid_);
  }
  return uniqrxid_;
}
inline ::std::string* RTLSDRConfig::release_uniqrxid() {
  clear_has_uniqrxid();
  if (uniqrxid_ == _default_uniqrxid_) {
    return NULL;
  } else {
    ::std::string* temp = uniqrxid_;
    uniqrxid_ = const_cast< ::std::string*>(_default_uniqrxid_);
    return temp;
  }
}
inline void RTLSDRConfig::set_allocated_uniqrxid(::std::string* uniqrxid) {
  if (uniqrxid_ != _default_uniqrxid_) {
    delete uniqrxid_;
  }
  if (uniqrxid) {
    set_has_uniqrxid();
    uniqrxid_ = uniqrxid;
  } else {
    clear_has_uniqrxid();
    uniqrxid_ = const_cast< ::std::string*>(_default_uniqrxid_);
  }
}

// -------------------------------------------------------------------

// USRPRxConfig

// optional string msgName = 1 [default = "USRP_RX_CONFIG"];
inline bool USRPRxConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void USRPRxConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void USRPRxConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void USRPRxConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& USRPRxConfig::msgname() const {
  return *msgname_;
}
inline void USRPRxConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void USRPRxConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void USRPRxConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* USRPRxConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* USRPRxConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void USRPRxConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 channel = 2;
inline bool USRPRxConfig::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void USRPRxConfig::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void USRPRxConfig::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void USRPRxConfig::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 USRPRxConfig::channel() const {
  return channel_;
}
inline void USRPRxConfig::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// optional int32 baseAux = 3;
inline bool USRPRxConfig::has_baseaux() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void USRPRxConfig::set_has_baseaux() {
  _has_bits_[0] |= 0x00000004u;
}
inline void USRPRxConfig::clear_has_baseaux() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void USRPRxConfig::clear_baseaux() {
  baseaux_ = 0;
  clear_has_baseaux();
}
inline ::google::protobuf::int32 USRPRxConfig::baseaux() const {
  return baseaux_;
}
inline void USRPRxConfig::set_baseaux(::google::protobuf::int32 value) {
  set_has_baseaux();
  baseaux_ = value;
}

// optional string args = 4 [default = "addr=192.168.10.2"];
inline bool USRPRxConfig::has_args() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void USRPRxConfig::set_has_args() {
  _has_bits_[0] |= 0x00000008u;
}
inline void USRPRxConfig::clear_has_args() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void USRPRxConfig::clear_args() {
  if (args_ != _default_args_) {
    args_->assign(*_default_args_);
  }
  clear_has_args();
}
inline const ::std::string& USRPRxConfig::args() const {
  return *args_;
}
inline void USRPRxConfig::set_args(const ::std::string& value) {
  set_has_args();
  if (args_ == _default_args_) {
    args_ = new ::std::string;
  }
  args_->assign(value);
}
inline void USRPRxConfig::set_args(const char* value) {
  set_has_args();
  if (args_ == _default_args_) {
    args_ = new ::std::string;
  }
  args_->assign(value);
}
inline void USRPRxConfig::set_args(const char* value, size_t size) {
  set_has_args();
  if (args_ == _default_args_) {
    args_ = new ::std::string;
  }
  args_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* USRPRxConfig::mutable_args() {
  set_has_args();
  if (args_ == _default_args_) {
    args_ = new ::std::string(*_default_args_);
  }
  return args_;
}
inline ::std::string* USRPRxConfig::release_args() {
  clear_has_args();
  if (args_ == _default_args_) {
    return NULL;
  } else {
    ::std::string* temp = args_;
    args_ = const_cast< ::std::string*>(_default_args_);
    return temp;
  }
}
inline void USRPRxConfig::set_allocated_args(::std::string* args) {
  if (args_ != _default_args_) {
    delete args_;
  }
  if (args) {
    set_has_args();
    args_ = args;
  } else {
    clear_has_args();
    args_ = const_cast< ::std::string*>(_default_args_);
  }
}

// optional int32 usrpchan = 5;
inline bool USRPRxConfig::has_usrpchan() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void USRPRxConfig::set_has_usrpchan() {
  _has_bits_[0] |= 0x00000010u;
}
inline void USRPRxConfig::clear_has_usrpchan() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void USRPRxConfig::clear_usrpchan() {
  usrpchan_ = 0;
  clear_has_usrpchan();
}
inline ::google::protobuf::int32 USRPRxConfig::usrpchan() const {
  return usrpchan_;
}
inline void USRPRxConfig::set_usrpchan(::google::protobuf::int32 value) {
  set_has_usrpchan();
  usrpchan_ = value;
}

// optional float minRF = 6;
inline bool USRPRxConfig::has_minrf() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void USRPRxConfig::set_has_minrf() {
  _has_bits_[0] |= 0x00000020u;
}
inline void USRPRxConfig::clear_has_minrf() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void USRPRxConfig::clear_minrf() {
  minrf_ = 0;
  clear_has_minrf();
}
inline float USRPRxConfig::minrf() const {
  return minrf_;
}
inline void USRPRxConfig::set_minrf(float value) {
  set_has_minrf();
  minrf_ = value;
}

// optional float maxRF = 7;
inline bool USRPRxConfig::has_maxrf() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void USRPRxConfig::set_has_maxrf() {
  _has_bits_[0] |= 0x00000040u;
}
inline void USRPRxConfig::clear_has_maxrf() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void USRPRxConfig::clear_maxrf() {
  maxrf_ = 0;
  clear_has_maxrf();
}
inline float USRPRxConfig::maxrf() const {
  return maxrf_;
}
inline void USRPRxConfig::set_maxrf(float value) {
  set_has_maxrf();
  maxrf_ = value;
}

// optional float fs = 8 [default = 1e+08];
inline bool USRPRxConfig::has_fs() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void USRPRxConfig::set_has_fs() {
  _has_bits_[0] |= 0x00000080u;
}
inline void USRPRxConfig::clear_has_fs() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void USRPRxConfig::clear_fs() {
  fs_ = 1e+08f;
  clear_has_fs();
}
inline float USRPRxConfig::fs() const {
  return fs_;
}
inline void USRPRxConfig::set_fs(float value) {
  set_has_fs();
  fs_ = value;
}

// -------------------------------------------------------------------

// PentekConfig

// optional string msgName = 1 [default = "PENTEK_CONFIG"];
inline bool PentekConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PentekConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PentekConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PentekConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& PentekConfig::msgname() const {
  return *msgname_;
}
inline void PentekConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void PentekConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void PentekConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PentekConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* PentekConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void PentekConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional float clkFreq = 2 [default = 4e+08];
inline bool PentekConfig::has_clkfreq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PentekConfig::set_has_clkfreq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PentekConfig::clear_has_clkfreq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PentekConfig::clear_clkfreq() {
  clkfreq_ = 4e+08f;
  clear_has_clkfreq();
}
inline float PentekConfig::clkfreq() const {
  return clkfreq_;
}
inline void PentekConfig::set_clkfreq(float value) {
  set_has_clkfreq();
  clkfreq_ = value;
}

// optional int32 dacInterp = 3 [default = 16];
inline bool PentekConfig::has_dacinterp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PentekConfig::set_has_dacinterp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PentekConfig::clear_has_dacinterp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PentekConfig::clear_dacinterp() {
  dacinterp_ = 16;
  clear_has_dacinterp();
}
inline ::google::protobuf::int32 PentekConfig::dacinterp() const {
  return dacinterp_;
}
inline void PentekConfig::set_dacinterp(::google::protobuf::int32 value) {
  set_has_dacinterp();
  dacinterp_ = value;
}

// optional int32 coreInterp = 4 [default = 1];
inline bool PentekConfig::has_coreinterp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PentekConfig::set_has_coreinterp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PentekConfig::clear_has_coreinterp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PentekConfig::clear_coreinterp() {
  coreinterp_ = 1;
  clear_has_coreinterp();
}
inline ::google::protobuf::int32 PentekConfig::coreinterp() const {
  return coreinterp_;
}
inline void PentekConfig::set_coreinterp(::google::protobuf::int32 value) {
  set_has_coreinterp();
  coreinterp_ = value;
}

// optional int32 baseChan = 5 [default = 1];
inline bool PentekConfig::has_basechan() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PentekConfig::set_has_basechan() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PentekConfig::clear_has_basechan() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PentekConfig::clear_basechan() {
  basechan_ = 1;
  clear_has_basechan();
}
inline ::google::protobuf::int32 PentekConfig::basechan() const {
  return basechan_;
}
inline void PentekConfig::set_basechan(::google::protobuf::int32 value) {
  set_has_basechan();
  basechan_ = value;
}

// optional int32 numBuffers = 6 [default = 2];
inline bool PentekConfig::has_numbuffers() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PentekConfig::set_has_numbuffers() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PentekConfig::clear_has_numbuffers() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PentekConfig::clear_numbuffers() {
  numbuffers_ = 2;
  clear_has_numbuffers();
}
inline ::google::protobuf::int32 PentekConfig::numbuffers() const {
  return numbuffers_;
}
inline void PentekConfig::set_numbuffers(::google::protobuf::int32 value) {
  set_has_numbuffers();
  numbuffers_ = value;
}

// optional float freqShift = 7 [default = 0];
inline bool PentekConfig::has_freqshift() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PentekConfig::set_has_freqshift() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PentekConfig::clear_has_freqshift() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PentekConfig::clear_freqshift() {
  freqshift_ = 0;
  clear_has_freqshift();
}
inline float PentekConfig::freqshift() const {
  return freqshift_;
}
inline void PentekConfig::set_freqshift(float value) {
  set_has_freqshift();
  freqshift_ = value;
}

// optional string siggenIP = 8;
inline bool PentekConfig::has_siggenip() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PentekConfig::set_has_siggenip() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PentekConfig::clear_has_siggenip() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PentekConfig::clear_siggenip() {
  if (siggenip_ != &::google::protobuf::internal::kEmptyString) {
    siggenip_->clear();
  }
  clear_has_siggenip();
}
inline const ::std::string& PentekConfig::siggenip() const {
  return *siggenip_;
}
inline void PentekConfig::set_siggenip(const ::std::string& value) {
  set_has_siggenip();
  if (siggenip_ == &::google::protobuf::internal::kEmptyString) {
    siggenip_ = new ::std::string;
  }
  siggenip_->assign(value);
}
inline void PentekConfig::set_siggenip(const char* value) {
  set_has_siggenip();
  if (siggenip_ == &::google::protobuf::internal::kEmptyString) {
    siggenip_ = new ::std::string;
  }
  siggenip_->assign(value);
}
inline void PentekConfig::set_siggenip(const char* value, size_t size) {
  set_has_siggenip();
  if (siggenip_ == &::google::protobuf::internal::kEmptyString) {
    siggenip_ = new ::std::string;
  }
  siggenip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PentekConfig::mutable_siggenip() {
  set_has_siggenip();
  if (siggenip_ == &::google::protobuf::internal::kEmptyString) {
    siggenip_ = new ::std::string;
  }
  return siggenip_;
}
inline ::std::string* PentekConfig::release_siggenip() {
  clear_has_siggenip();
  if (siggenip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = siggenip_;
    siggenip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PentekConfig::set_allocated_siggenip(::std::string* siggenip) {
  if (siggenip_ != &::google::protobuf::internal::kEmptyString) {
    delete siggenip_;
  }
  if (siggenip) {
    set_has_siggenip();
    siggenip_ = siggenip;
  } else {
    clear_has_siggenip();
    siggenip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .falcon_res_msg.PentekConfig.SiggenType siggenType = 9 [default = ROHDE_SCHWARZ];
inline bool PentekConfig::has_siggentype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PentekConfig::set_has_siggentype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PentekConfig::clear_has_siggentype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PentekConfig::clear_siggentype() {
  siggentype_ = 0;
  clear_has_siggentype();
}
inline ::falcon_res_msg::PentekConfig_SiggenType PentekConfig::siggentype() const {
  return static_cast< ::falcon_res_msg::PentekConfig_SiggenType >(siggentype_);
}
inline void PentekConfig::set_siggentype(::falcon_res_msg::PentekConfig_SiggenType value) {
  assert(::falcon_res_msg::PentekConfig_SiggenType_IsValid(value));
  set_has_siggentype();
  siggentype_ = value;
}

// -------------------------------------------------------------------

// USRPTxConfig

// optional string msgName = 1 [default = "USRP_TX_CONFIG"];
inline bool USRPTxConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void USRPTxConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void USRPTxConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void USRPTxConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& USRPTxConfig::msgname() const {
  return *msgname_;
}
inline void USRPTxConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void USRPTxConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void USRPTxConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* USRPTxConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* USRPTxConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void USRPTxConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string args = 2 [default = "addr=192.168.10.2"];
inline bool USRPTxConfig::has_args() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void USRPTxConfig::set_has_args() {
  _has_bits_[0] |= 0x00000002u;
}
inline void USRPTxConfig::clear_has_args() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void USRPTxConfig::clear_args() {
  if (args_ != _default_args_) {
    args_->assign(*_default_args_);
  }
  clear_has_args();
}
inline const ::std::string& USRPTxConfig::args() const {
  return *args_;
}
inline void USRPTxConfig::set_args(const ::std::string& value) {
  set_has_args();
  if (args_ == _default_args_) {
    args_ = new ::std::string;
  }
  args_->assign(value);
}
inline void USRPTxConfig::set_args(const char* value) {
  set_has_args();
  if (args_ == _default_args_) {
    args_ = new ::std::string;
  }
  args_->assign(value);
}
inline void USRPTxConfig::set_args(const char* value, size_t size) {
  set_has_args();
  if (args_ == _default_args_) {
    args_ = new ::std::string;
  }
  args_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* USRPTxConfig::mutable_args() {
  set_has_args();
  if (args_ == _default_args_) {
    args_ = new ::std::string(*_default_args_);
  }
  return args_;
}
inline ::std::string* USRPTxConfig::release_args() {
  clear_has_args();
  if (args_ == _default_args_) {
    return NULL;
  } else {
    ::std::string* temp = args_;
    args_ = const_cast< ::std::string*>(_default_args_);
    return temp;
  }
}
inline void USRPTxConfig::set_allocated_args(::std::string* args) {
  if (args_ != _default_args_) {
    delete args_;
  }
  if (args) {
    set_has_args();
    args_ = args;
  } else {
    clear_has_args();
    args_ = const_cast< ::std::string*>(_default_args_);
  }
}

// optional int32 usrpchan = 3;
inline bool USRPTxConfig::has_usrpchan() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void USRPTxConfig::set_has_usrpchan() {
  _has_bits_[0] |= 0x00000004u;
}
inline void USRPTxConfig::clear_has_usrpchan() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void USRPTxConfig::clear_usrpchan() {
  usrpchan_ = 0;
  clear_has_usrpchan();
}
inline ::google::protobuf::int32 USRPTxConfig::usrpchan() const {
  return usrpchan_;
}
inline void USRPTxConfig::set_usrpchan(::google::protobuf::int32 value) {
  set_has_usrpchan();
  usrpchan_ = value;
}

// optional float minRF = 4;
inline bool USRPTxConfig::has_minrf() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void USRPTxConfig::set_has_minrf() {
  _has_bits_[0] |= 0x00000008u;
}
inline void USRPTxConfig::clear_has_minrf() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void USRPTxConfig::clear_minrf() {
  minrf_ = 0;
  clear_has_minrf();
}
inline float USRPTxConfig::minrf() const {
  return minrf_;
}
inline void USRPTxConfig::set_minrf(float value) {
  set_has_minrf();
  minrf_ = value;
}

// optional float maxRF = 5;
inline bool USRPTxConfig::has_maxrf() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void USRPTxConfig::set_has_maxrf() {
  _has_bits_[0] |= 0x00000010u;
}
inline void USRPTxConfig::clear_has_maxrf() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void USRPTxConfig::clear_maxrf() {
  maxrf_ = 0;
  clear_has_maxrf();
}
inline float USRPTxConfig::maxrf() const {
  return maxrf_;
}
inline void USRPTxConfig::set_maxrf(float value) {
  set_has_maxrf();
  maxrf_ = value;
}

// -------------------------------------------------------------------

// RFSwitchConfig

// optional string msgName = 1 [default = "RFSWITCH_CONFIG"];
inline bool RFSwitchConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RFSwitchConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RFSwitchConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RFSwitchConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& RFSwitchConfig::msgname() const {
  return *msgname_;
}
inline void RFSwitchConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RFSwitchConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RFSwitchConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RFSwitchConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* RFSwitchConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void RFSwitchConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string IP = 2 [default = "nportserver"];
inline bool RFSwitchConfig::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RFSwitchConfig::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RFSwitchConfig::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RFSwitchConfig::clear_ip() {
  if (ip_ != _default_ip_) {
    ip_->assign(*_default_ip_);
  }
  clear_has_ip();
}
inline const ::std::string& RFSwitchConfig::ip() const {
  return *ip_;
}
inline void RFSwitchConfig::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == _default_ip_) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RFSwitchConfig::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == _default_ip_) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RFSwitchConfig::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == _default_ip_) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RFSwitchConfig::mutable_ip() {
  set_has_ip();
  if (ip_ == _default_ip_) {
    ip_ = new ::std::string(*_default_ip_);
  }
  return ip_;
}
inline ::std::string* RFSwitchConfig::release_ip() {
  clear_has_ip();
  if (ip_ == _default_ip_) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(_default_ip_);
    return temp;
  }
}
inline void RFSwitchConfig::set_allocated_ip(::std::string* ip) {
  if (ip_ != _default_ip_) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(_default_ip_);
  }
}

// optional int32 slaveTimeout = 3 [default = 180];
inline bool RFSwitchConfig::has_slavetimeout() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RFSwitchConfig::set_has_slavetimeout() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RFSwitchConfig::clear_has_slavetimeout() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RFSwitchConfig::clear_slavetimeout() {
  slavetimeout_ = 180;
  clear_has_slavetimeout();
}
inline ::google::protobuf::int32 RFSwitchConfig::slavetimeout() const {
  return slavetimeout_;
}
inline void RFSwitchConfig::set_slavetimeout(::google::protobuf::int32 value) {
  set_has_slavetimeout();
  slavetimeout_ = value;
}

// optional float energyScanSec = 4 [default = 10];
inline bool RFSwitchConfig::has_energyscansec() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RFSwitchConfig::set_has_energyscansec() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RFSwitchConfig::clear_has_energyscansec() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RFSwitchConfig::clear_energyscansec() {
  energyscansec_ = 10;
  clear_has_energyscansec();
}
inline float RFSwitchConfig::energyscansec() const {
  return energyscansec_;
}
inline void RFSwitchConfig::set_energyscansec(float value) {
  set_has_energyscansec();
  energyscansec_ = value;
}

// optional float energyTrackTime = 5 [default = 300];
inline bool RFSwitchConfig::has_energytracktime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RFSwitchConfig::set_has_energytracktime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RFSwitchConfig::clear_has_energytracktime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RFSwitchConfig::clear_energytracktime() {
  energytracktime_ = 300;
  clear_has_energytracktime();
}
inline float RFSwitchConfig::energytracktime() const {
  return energytracktime_;
}
inline void RFSwitchConfig::set_energytracktime(float value) {
  set_has_energytracktime();
  energytracktime_ = value;
}

// optional int32 port = 6 [default = 4003];
inline bool RFSwitchConfig::has_port() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RFSwitchConfig::set_has_port() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RFSwitchConfig::clear_has_port() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RFSwitchConfig::clear_port() {
  port_ = 4003;
  clear_has_port();
}
inline ::google::protobuf::int32 RFSwitchConfig::port() const {
  return port_;
}
inline void RFSwitchConfig::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// optional bool setOnLaunch = 7 [default = false];
inline bool RFSwitchConfig::has_setonlaunch() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RFSwitchConfig::set_has_setonlaunch() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RFSwitchConfig::clear_has_setonlaunch() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RFSwitchConfig::clear_setonlaunch() {
  setonlaunch_ = false;
  clear_has_setonlaunch();
}
inline bool RFSwitchConfig::setonlaunch() const {
  return setonlaunch_;
}
inline void RFSwitchConfig::set_setonlaunch(bool value) {
  set_has_setonlaunch();
  setonlaunch_ = value;
}

// -------------------------------------------------------------------

// RFSwitchSerialConfig

// optional string msgName = 1 [default = "RFSWITCH_SERIAL_CONFIG"];
inline bool RFSwitchSerialConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RFSwitchSerialConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RFSwitchSerialConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RFSwitchSerialConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& RFSwitchSerialConfig::msgname() const {
  return *msgname_;
}
inline void RFSwitchSerialConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RFSwitchSerialConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RFSwitchSerialConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RFSwitchSerialConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* RFSwitchSerialConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void RFSwitchSerialConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string device = 2 [default = "/dev/ttyS0"];
inline bool RFSwitchSerialConfig::has_device() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RFSwitchSerialConfig::set_has_device() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RFSwitchSerialConfig::clear_has_device() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RFSwitchSerialConfig::clear_device() {
  if (device_ != _default_device_) {
    device_->assign(*_default_device_);
  }
  clear_has_device();
}
inline const ::std::string& RFSwitchSerialConfig::device() const {
  return *device_;
}
inline void RFSwitchSerialConfig::set_device(const ::std::string& value) {
  set_has_device();
  if (device_ == _default_device_) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void RFSwitchSerialConfig::set_device(const char* value) {
  set_has_device();
  if (device_ == _default_device_) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void RFSwitchSerialConfig::set_device(const char* value, size_t size) {
  set_has_device();
  if (device_ == _default_device_) {
    device_ = new ::std::string;
  }
  device_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RFSwitchSerialConfig::mutable_device() {
  set_has_device();
  if (device_ == _default_device_) {
    device_ = new ::std::string(*_default_device_);
  }
  return device_;
}
inline ::std::string* RFSwitchSerialConfig::release_device() {
  clear_has_device();
  if (device_ == _default_device_) {
    return NULL;
  } else {
    ::std::string* temp = device_;
    device_ = const_cast< ::std::string*>(_default_device_);
    return temp;
  }
}
inline void RFSwitchSerialConfig::set_allocated_device(::std::string* device) {
  if (device_ != _default_device_) {
    delete device_;
  }
  if (device) {
    set_has_device();
    device_ = device;
  } else {
    clear_has_device();
    device_ = const_cast< ::std::string*>(_default_device_);
  }
}

// optional int32 baud = 3 [default = 9600];
inline bool RFSwitchSerialConfig::has_baud() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RFSwitchSerialConfig::set_has_baud() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RFSwitchSerialConfig::clear_has_baud() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RFSwitchSerialConfig::clear_baud() {
  baud_ = 9600;
  clear_has_baud();
}
inline ::google::protobuf::int32 RFSwitchSerialConfig::baud() const {
  return baud_;
}
inline void RFSwitchSerialConfig::set_baud(::google::protobuf::int32 value) {
  set_has_baud();
  baud_ = value;
}

// optional int32 slaveTimeout = 4 [default = 180];
inline bool RFSwitchSerialConfig::has_slavetimeout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RFSwitchSerialConfig::set_has_slavetimeout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RFSwitchSerialConfig::clear_has_slavetimeout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RFSwitchSerialConfig::clear_slavetimeout() {
  slavetimeout_ = 180;
  clear_has_slavetimeout();
}
inline ::google::protobuf::int32 RFSwitchSerialConfig::slavetimeout() const {
  return slavetimeout_;
}
inline void RFSwitchSerialConfig::set_slavetimeout(::google::protobuf::int32 value) {
  set_has_slavetimeout();
  slavetimeout_ = value;
}

// optional float energyScanSec = 5 [default = 10];
inline bool RFSwitchSerialConfig::has_energyscansec() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RFSwitchSerialConfig::set_has_energyscansec() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RFSwitchSerialConfig::clear_has_energyscansec() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RFSwitchSerialConfig::clear_energyscansec() {
  energyscansec_ = 10;
  clear_has_energyscansec();
}
inline float RFSwitchSerialConfig::energyscansec() const {
  return energyscansec_;
}
inline void RFSwitchSerialConfig::set_energyscansec(float value) {
  set_has_energyscansec();
  energyscansec_ = value;
}

// optional float energyTrackTime = 6 [default = 300];
inline bool RFSwitchSerialConfig::has_energytracktime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RFSwitchSerialConfig::set_has_energytracktime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RFSwitchSerialConfig::clear_has_energytracktime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RFSwitchSerialConfig::clear_energytracktime() {
  energytracktime_ = 300;
  clear_has_energytracktime();
}
inline float RFSwitchSerialConfig::energytracktime() const {
  return energytracktime_;
}
inline void RFSwitchSerialConfig::set_energytracktime(float value) {
  set_has_energytracktime();
  energytracktime_ = value;
}

// -------------------------------------------------------------------

// CPSwitchConfig

// optional string msgName = 1 [default = "CPSWITCH_CONFIG"];
inline bool CPSwitchConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CPSwitchConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CPSwitchConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CPSwitchConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& CPSwitchConfig::msgname() const {
  return *msgname_;
}
inline void CPSwitchConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void CPSwitchConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void CPSwitchConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CPSwitchConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* CPSwitchConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void CPSwitchConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string IP = 2;
inline bool CPSwitchConfig::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CPSwitchConfig::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CPSwitchConfig::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CPSwitchConfig::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& CPSwitchConfig::ip() const {
  return *ip_;
}
inline void CPSwitchConfig::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void CPSwitchConfig::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void CPSwitchConfig::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CPSwitchConfig::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* CPSwitchConfig::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CPSwitchConfig::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 port = 3 [default = 23];
inline bool CPSwitchConfig::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CPSwitchConfig::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CPSwitchConfig::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CPSwitchConfig::clear_port() {
  port_ = 23;
  clear_has_port();
}
inline ::google::protobuf::int32 CPSwitchConfig::port() const {
  return port_;
}
inline void CPSwitchConfig::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// optional int32 slaveTimeout = 4 [default = 180];
inline bool CPSwitchConfig::has_slavetimeout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CPSwitchConfig::set_has_slavetimeout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CPSwitchConfig::clear_has_slavetimeout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CPSwitchConfig::clear_slavetimeout() {
  slavetimeout_ = 180;
  clear_has_slavetimeout();
}
inline ::google::protobuf::int32 CPSwitchConfig::slavetimeout() const {
  return slavetimeout_;
}
inline void CPSwitchConfig::set_slavetimeout(::google::protobuf::int32 value) {
  set_has_slavetimeout();
  slavetimeout_ = value;
}

// optional float energyScanSec = 5 [default = 10];
inline bool CPSwitchConfig::has_energyscansec() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CPSwitchConfig::set_has_energyscansec() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CPSwitchConfig::clear_has_energyscansec() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CPSwitchConfig::clear_energyscansec() {
  energyscansec_ = 10;
  clear_has_energyscansec();
}
inline float CPSwitchConfig::energyscansec() const {
  return energyscansec_;
}
inline void CPSwitchConfig::set_energyscansec(float value) {
  set_has_energyscansec();
  energyscansec_ = value;
}

// optional float energyTrackTime = 6 [default = 300];
inline bool CPSwitchConfig::has_energytracktime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CPSwitchConfig::set_has_energytracktime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CPSwitchConfig::clear_has_energytracktime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CPSwitchConfig::clear_energytracktime() {
  energytracktime_ = 300;
  clear_has_energytracktime();
}
inline float CPSwitchConfig::energytracktime() const {
  return energytracktime_;
}
inline void CPSwitchConfig::set_energytracktime(float value) {
  set_has_energytracktime();
  energytracktime_ = value;
}

// -------------------------------------------------------------------

// AntennaConfig

// optional string msgName = 1 [default = "ANTENNA_CONFIG"];
inline bool AntennaConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AntennaConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AntennaConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AntennaConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& AntennaConfig::msgname() const {
  return *msgname_;
}
inline void AntennaConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AntennaConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AntennaConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AntennaConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* AntennaConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void AntennaConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional float minRF = 2;
inline bool AntennaConfig::has_minrf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AntennaConfig::set_has_minrf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AntennaConfig::clear_has_minrf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AntennaConfig::clear_minrf() {
  minrf_ = 0;
  clear_has_minrf();
}
inline float AntennaConfig::minrf() const {
  return minrf_;
}
inline void AntennaConfig::set_minrf(float value) {
  set_has_minrf();
  minrf_ = value;
}

// optional float maxRF = 3;
inline bool AntennaConfig::has_maxrf() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AntennaConfig::set_has_maxrf() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AntennaConfig::clear_has_maxrf() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AntennaConfig::clear_maxrf() {
  maxrf_ = 0;
  clear_has_maxrf();
}
inline float AntennaConfig::maxrf() const {
  return maxrf_;
}
inline void AntennaConfig::set_maxrf(float value) {
  set_has_maxrf();
  maxrf_ = value;
}

// optional float fixedAngle = 4 [default = -999];
inline bool AntennaConfig::has_fixedangle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AntennaConfig::set_has_fixedangle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AntennaConfig::clear_has_fixedangle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AntennaConfig::clear_fixedangle() {
  fixedangle_ = -999;
  clear_has_fixedangle();
}
inline float AntennaConfig::fixedangle() const {
  return fixedangle_;
}
inline void AntennaConfig::set_fixedangle(float value) {
  set_has_fixedangle();
  fixedangle_ = value;
}

// optional float latitude = 5 [default = 0];
inline bool AntennaConfig::has_latitude() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AntennaConfig::set_has_latitude() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AntennaConfig::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AntennaConfig::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline float AntennaConfig::latitude() const {
  return latitude_;
}
inline void AntennaConfig::set_latitude(float value) {
  set_has_latitude();
  latitude_ = value;
}

// optional float longitude = 6 [default = 0];
inline bool AntennaConfig::has_longitude() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AntennaConfig::set_has_longitude() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AntennaConfig::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AntennaConfig::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline float AntennaConfig::longitude() const {
  return longitude_;
}
inline void AntennaConfig::set_longitude(float value) {
  set_has_longitude();
  longitude_ = value;
}

// optional float altitude = 7 [default = 0];
inline bool AntennaConfig::has_altitude() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AntennaConfig::set_has_altitude() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AntennaConfig::clear_has_altitude() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AntennaConfig::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline float AntennaConfig::altitude() const {
  return altitude_;
}
inline void AntennaConfig::set_altitude(float value) {
  set_has_altitude();
  altitude_ = value;
}

// optional float beamwidth = 8 [default = 0];
inline bool AntennaConfig::has_beamwidth() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AntennaConfig::set_has_beamwidth() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AntennaConfig::clear_has_beamwidth() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AntennaConfig::clear_beamwidth() {
  beamwidth_ = 0;
  clear_has_beamwidth();
}
inline float AntennaConfig::beamwidth() const {
  return beamwidth_;
}
inline void AntennaConfig::set_beamwidth(float value) {
  set_has_beamwidth();
  beamwidth_ = value;
}

// optional float dwncnvtLO = 9 [default = 0];
inline bool AntennaConfig::has_dwncnvtlo() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AntennaConfig::set_has_dwncnvtlo() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AntennaConfig::clear_has_dwncnvtlo() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AntennaConfig::clear_dwncnvtlo() {
  dwncnvtlo_ = 0;
  clear_has_dwncnvtlo();
}
inline float AntennaConfig::dwncnvtlo() const {
  return dwncnvtlo_;
}
inline void AntennaConfig::set_dwncnvtlo(float value) {
  set_has_dwncnvtlo();
  dwncnvtlo_ = value;
}

// optional int32 ssc = 10 [default = -1];
inline bool AntennaConfig::has_ssc() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AntennaConfig::set_has_ssc() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AntennaConfig::clear_has_ssc() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AntennaConfig::clear_ssc() {
  ssc_ = -1;
  clear_has_ssc();
}
inline ::google::protobuf::int32 AntennaConfig::ssc() const {
  return ssc_;
}
inline void AntennaConfig::set_ssc(::google::protobuf::int32 value) {
  set_has_ssc();
  ssc_ = value;
}

// optional string band = 11;
inline bool AntennaConfig::has_band() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AntennaConfig::set_has_band() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AntennaConfig::clear_has_band() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AntennaConfig::clear_band() {
  if (band_ != &::google::protobuf::internal::kEmptyString) {
    band_->clear();
  }
  clear_has_band();
}
inline const ::std::string& AntennaConfig::band() const {
  return *band_;
}
inline void AntennaConfig::set_band(const ::std::string& value) {
  set_has_band();
  if (band_ == &::google::protobuf::internal::kEmptyString) {
    band_ = new ::std::string;
  }
  band_->assign(value);
}
inline void AntennaConfig::set_band(const char* value) {
  set_has_band();
  if (band_ == &::google::protobuf::internal::kEmptyString) {
    band_ = new ::std::string;
  }
  band_->assign(value);
}
inline void AntennaConfig::set_band(const char* value, size_t size) {
  set_has_band();
  if (band_ == &::google::protobuf::internal::kEmptyString) {
    band_ = new ::std::string;
  }
  band_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AntennaConfig::mutable_band() {
  set_has_band();
  if (band_ == &::google::protobuf::internal::kEmptyString) {
    band_ = new ::std::string;
  }
  return band_;
}
inline ::std::string* AntennaConfig::release_band() {
  clear_has_band();
  if (band_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = band_;
    band_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AntennaConfig::set_allocated_band(::std::string* band) {
  if (band_ != &::google::protobuf::internal::kEmptyString) {
    delete band_;
  }
  if (band) {
    set_has_band();
    band_ = band;
  } else {
    clear_has_band();
    band_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string polarization = 12;
inline bool AntennaConfig::has_polarization() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AntennaConfig::set_has_polarization() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AntennaConfig::clear_has_polarization() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AntennaConfig::clear_polarization() {
  if (polarization_ != &::google::protobuf::internal::kEmptyString) {
    polarization_->clear();
  }
  clear_has_polarization();
}
inline const ::std::string& AntennaConfig::polarization() const {
  return *polarization_;
}
inline void AntennaConfig::set_polarization(const ::std::string& value) {
  set_has_polarization();
  if (polarization_ == &::google::protobuf::internal::kEmptyString) {
    polarization_ = new ::std::string;
  }
  polarization_->assign(value);
}
inline void AntennaConfig::set_polarization(const char* value) {
  set_has_polarization();
  if (polarization_ == &::google::protobuf::internal::kEmptyString) {
    polarization_ = new ::std::string;
  }
  polarization_->assign(value);
}
inline void AntennaConfig::set_polarization(const char* value, size_t size) {
  set_has_polarization();
  if (polarization_ == &::google::protobuf::internal::kEmptyString) {
    polarization_ = new ::std::string;
  }
  polarization_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AntennaConfig::mutable_polarization() {
  set_has_polarization();
  if (polarization_ == &::google::protobuf::internal::kEmptyString) {
    polarization_ = new ::std::string;
  }
  return polarization_;
}
inline ::std::string* AntennaConfig::release_polarization() {
  clear_has_polarization();
  if (polarization_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = polarization_;
    polarization_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AntennaConfig::set_allocated_polarization(::std::string* polarization) {
  if (polarization_ != &::google::protobuf::internal::kEmptyString) {
    delete polarization_;
  }
  if (polarization) {
    set_has_polarization();
    polarization_ = polarization;
  } else {
    clear_has_polarization();
    polarization_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 group = 13;
inline bool AntennaConfig::has_group() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AntennaConfig::set_has_group() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AntennaConfig::clear_has_group() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AntennaConfig::clear_group() {
  group_ = 0;
  clear_has_group();
}
inline ::google::protobuf::int32 AntennaConfig::group() const {
  return group_;
}
inline void AntennaConfig::set_group(::google::protobuf::int32 value) {
  set_has_group();
  group_ = value;
}

// optional float sightDistance = 14 [default = 500];
inline bool AntennaConfig::has_sightdistance() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AntennaConfig::set_has_sightdistance() {
  _has_bits_[0] |= 0x00002000u;
}
inline void AntennaConfig::clear_has_sightdistance() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void AntennaConfig::clear_sightdistance() {
  sightdistance_ = 500;
  clear_has_sightdistance();
}
inline float AntennaConfig::sightdistance() const {
  return sightdistance_;
}
inline void AntennaConfig::set_sightdistance(float value) {
  set_has_sightdistance();
  sightdistance_ = value;
}

// optional string noiseTest = 15 [default = "NO_TEST"];
inline bool AntennaConfig::has_noisetest() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void AntennaConfig::set_has_noisetest() {
  _has_bits_[0] |= 0x00004000u;
}
inline void AntennaConfig::clear_has_noisetest() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void AntennaConfig::clear_noisetest() {
  if (noisetest_ != _default_noisetest_) {
    noisetest_->assign(*_default_noisetest_);
  }
  clear_has_noisetest();
}
inline const ::std::string& AntennaConfig::noisetest() const {
  return *noisetest_;
}
inline void AntennaConfig::set_noisetest(const ::std::string& value) {
  set_has_noisetest();
  if (noisetest_ == _default_noisetest_) {
    noisetest_ = new ::std::string;
  }
  noisetest_->assign(value);
}
inline void AntennaConfig::set_noisetest(const char* value) {
  set_has_noisetest();
  if (noisetest_ == _default_noisetest_) {
    noisetest_ = new ::std::string;
  }
  noisetest_->assign(value);
}
inline void AntennaConfig::set_noisetest(const char* value, size_t size) {
  set_has_noisetest();
  if (noisetest_ == _default_noisetest_) {
    noisetest_ = new ::std::string;
  }
  noisetest_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AntennaConfig::mutable_noisetest() {
  set_has_noisetest();
  if (noisetest_ == _default_noisetest_) {
    noisetest_ = new ::std::string(*_default_noisetest_);
  }
  return noisetest_;
}
inline ::std::string* AntennaConfig::release_noisetest() {
  clear_has_noisetest();
  if (noisetest_ == _default_noisetest_) {
    return NULL;
  } else {
    ::std::string* temp = noisetest_;
    noisetest_ = const_cast< ::std::string*>(_default_noisetest_);
    return temp;
  }
}
inline void AntennaConfig::set_allocated_noisetest(::std::string* noisetest) {
  if (noisetest_ != _default_noisetest_) {
    delete noisetest_;
  }
  if (noisetest) {
    set_has_noisetest();
    noisetest_ = noisetest;
  } else {
    clear_has_noisetest();
    noisetest_ = const_cast< ::std::string*>(_default_noisetest_);
  }
}

// -------------------------------------------------------------------

// RotorRPMConfig

// optional string msgName = 1 [default = "ROTOR_RPM_CONFIG"];
inline bool RotorRPMConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RotorRPMConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RotorRPMConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RotorRPMConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& RotorRPMConfig::msgname() const {
  return *msgname_;
}
inline void RotorRPMConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RotorRPMConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RotorRPMConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorRPMConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* RotorRPMConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void RotorRPMConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string IP = 2;
inline bool RotorRPMConfig::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RotorRPMConfig::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RotorRPMConfig::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RotorRPMConfig::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& RotorRPMConfig::ip() const {
  return *ip_;
}
inline void RotorRPMConfig::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RotorRPMConfig::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RotorRPMConfig::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorRPMConfig::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* RotorRPMConfig::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RotorRPMConfig::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 port = 3;
inline bool RotorRPMConfig::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RotorRPMConfig::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RotorRPMConfig::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RotorRPMConfig::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 RotorRPMConfig::port() const {
  return port_;
}
inline void RotorRPMConfig::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// optional float AzOffset = 4;
inline bool RotorRPMConfig::has_azoffset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RotorRPMConfig::set_has_azoffset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RotorRPMConfig::clear_has_azoffset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RotorRPMConfig::clear_azoffset() {
  azoffset_ = 0;
  clear_has_azoffset();
}
inline float RotorRPMConfig::azoffset() const {
  return azoffset_;
}
inline void RotorRPMConfig::set_azoffset(float value) {
  set_has_azoffset();
  azoffset_ = value;
}

// optional float ElOffset = 5;
inline bool RotorRPMConfig::has_eloffset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RotorRPMConfig::set_has_eloffset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RotorRPMConfig::clear_has_eloffset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RotorRPMConfig::clear_eloffset() {
  eloffset_ = 0;
  clear_has_eloffset();
}
inline float RotorRPMConfig::eloffset() const {
  return eloffset_;
}
inline void RotorRPMConfig::set_eloffset(float value) {
  set_has_eloffset();
  eloffset_ = value;
}

// optional bool hardLimit = 6;
inline bool RotorRPMConfig::has_hardlimit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RotorRPMConfig::set_has_hardlimit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RotorRPMConfig::clear_has_hardlimit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RotorRPMConfig::clear_hardlimit() {
  hardlimit_ = false;
  clear_has_hardlimit();
}
inline bool RotorRPMConfig::hardlimit() const {
  return hardlimit_;
}
inline void RotorRPMConfig::set_hardlimit(bool value) {
  set_has_hardlimit();
  hardlimit_ = value;
}

// optional float minScanAngle = 7;
inline bool RotorRPMConfig::has_minscanangle() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RotorRPMConfig::set_has_minscanangle() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RotorRPMConfig::clear_has_minscanangle() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RotorRPMConfig::clear_minscanangle() {
  minscanangle_ = 0;
  clear_has_minscanangle();
}
inline float RotorRPMConfig::minscanangle() const {
  return minscanangle_;
}
inline void RotorRPMConfig::set_minscanangle(float value) {
  set_has_minscanangle();
  minscanangle_ = value;
}

// optional float maxScanAngle = 8;
inline bool RotorRPMConfig::has_maxscanangle() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RotorRPMConfig::set_has_maxscanangle() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RotorRPMConfig::clear_has_maxscanangle() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RotorRPMConfig::clear_maxscanangle() {
  maxscanangle_ = 0;
  clear_has_maxscanangle();
}
inline float RotorRPMConfig::maxscanangle() const {
  return maxscanangle_;
}
inline void RotorRPMConfig::set_maxscanangle(float value) {
  set_has_maxscanangle();
  maxscanangle_ = value;
}

// optional float minElevation = 9;
inline bool RotorRPMConfig::has_minelevation() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RotorRPMConfig::set_has_minelevation() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RotorRPMConfig::clear_has_minelevation() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RotorRPMConfig::clear_minelevation() {
  minelevation_ = 0;
  clear_has_minelevation();
}
inline float RotorRPMConfig::minelevation() const {
  return minelevation_;
}
inline void RotorRPMConfig::set_minelevation(float value) {
  set_has_minelevation();
  minelevation_ = value;
}

// optional float maxElevation = 10;
inline bool RotorRPMConfig::has_maxelevation() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RotorRPMConfig::set_has_maxelevation() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RotorRPMConfig::clear_has_maxelevation() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RotorRPMConfig::clear_maxelevation() {
  maxelevation_ = 0;
  clear_has_maxelevation();
}
inline float RotorRPMConfig::maxelevation() const {
  return maxelevation_;
}
inline void RotorRPMConfig::set_maxelevation(float value) {
  set_has_maxelevation();
  maxelevation_ = value;
}

// optional float scanElevation = 11;
inline bool RotorRPMConfig::has_scanelevation() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RotorRPMConfig::set_has_scanelevation() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RotorRPMConfig::clear_has_scanelevation() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RotorRPMConfig::clear_scanelevation() {
  scanelevation_ = 0;
  clear_has_scanelevation();
}
inline float RotorRPMConfig::scanelevation() const {
  return scanelevation_;
}
inline void RotorRPMConfig::set_scanelevation(float value) {
  set_has_scanelevation();
  scanelevation_ = value;
}

// optional float multicastRate = 12;
inline bool RotorRPMConfig::has_multicastrate() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RotorRPMConfig::set_has_multicastrate() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RotorRPMConfig::clear_has_multicastrate() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RotorRPMConfig::clear_multicastrate() {
  multicastrate_ = 0;
  clear_has_multicastrate();
}
inline float RotorRPMConfig::multicastrate() const {
  return multicastrate_;
}
inline void RotorRPMConfig::set_multicastrate(float value) {
  set_has_multicastrate();
  multicastrate_ = value;
}

// optional float pointHoldIncrement = 13;
inline bool RotorRPMConfig::has_pointholdincrement() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RotorRPMConfig::set_has_pointholdincrement() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RotorRPMConfig::clear_has_pointholdincrement() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RotorRPMConfig::clear_pointholdincrement() {
  pointholdincrement_ = 0;
  clear_has_pointholdincrement();
}
inline float RotorRPMConfig::pointholdincrement() const {
  return pointholdincrement_;
}
inline void RotorRPMConfig::set_pointholdincrement(float value) {
  set_has_pointholdincrement();
  pointholdincrement_ = value;
}

// optional float energyScanSpeed = 14 [default = 4];
inline bool RotorRPMConfig::has_energyscanspeed() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RotorRPMConfig::set_has_energyscanspeed() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RotorRPMConfig::clear_has_energyscanspeed() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RotorRPMConfig::clear_energyscanspeed() {
  energyscanspeed_ = 4;
  clear_has_energyscanspeed();
}
inline float RotorRPMConfig::energyscanspeed() const {
  return energyscanspeed_;
}
inline void RotorRPMConfig::set_energyscanspeed(float value) {
  set_has_energyscanspeed();
  energyscanspeed_ = value;
}

// optional float startDeviation = 15 [default = 180];
inline bool RotorRPMConfig::has_startdeviation() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RotorRPMConfig::set_has_startdeviation() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RotorRPMConfig::clear_has_startdeviation() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RotorRPMConfig::clear_startdeviation() {
  startdeviation_ = 180;
  clear_has_startdeviation();
}
inline float RotorRPMConfig::startdeviation() const {
  return startdeviation_;
}
inline void RotorRPMConfig::set_startdeviation(float value) {
  set_has_startdeviation();
  startdeviation_ = value;
}

// optional float energyTrackTime = 16 [default = 30];
inline bool RotorRPMConfig::has_energytracktime() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RotorRPMConfig::set_has_energytracktime() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RotorRPMConfig::clear_has_energytracktime() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RotorRPMConfig::clear_energytracktime() {
  energytracktime_ = 30;
  clear_has_energytracktime();
}
inline float RotorRPMConfig::energytracktime() const {
  return energytracktime_;
}
inline void RotorRPMConfig::set_energytracktime(float value) {
  set_has_energytracktime();
  energytracktime_ = value;
}

// optional string scanScrypt = 17 [default = "NONE"];
inline bool RotorRPMConfig::has_scanscrypt() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void RotorRPMConfig::set_has_scanscrypt() {
  _has_bits_[0] |= 0x00010000u;
}
inline void RotorRPMConfig::clear_has_scanscrypt() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void RotorRPMConfig::clear_scanscrypt() {
  if (scanscrypt_ != _default_scanscrypt_) {
    scanscrypt_->assign(*_default_scanscrypt_);
  }
  clear_has_scanscrypt();
}
inline const ::std::string& RotorRPMConfig::scanscrypt() const {
  return *scanscrypt_;
}
inline void RotorRPMConfig::set_scanscrypt(const ::std::string& value) {
  set_has_scanscrypt();
  if (scanscrypt_ == _default_scanscrypt_) {
    scanscrypt_ = new ::std::string;
  }
  scanscrypt_->assign(value);
}
inline void RotorRPMConfig::set_scanscrypt(const char* value) {
  set_has_scanscrypt();
  if (scanscrypt_ == _default_scanscrypt_) {
    scanscrypt_ = new ::std::string;
  }
  scanscrypt_->assign(value);
}
inline void RotorRPMConfig::set_scanscrypt(const char* value, size_t size) {
  set_has_scanscrypt();
  if (scanscrypt_ == _default_scanscrypt_) {
    scanscrypt_ = new ::std::string;
  }
  scanscrypt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorRPMConfig::mutable_scanscrypt() {
  set_has_scanscrypt();
  if (scanscrypt_ == _default_scanscrypt_) {
    scanscrypt_ = new ::std::string(*_default_scanscrypt_);
  }
  return scanscrypt_;
}
inline ::std::string* RotorRPMConfig::release_scanscrypt() {
  clear_has_scanscrypt();
  if (scanscrypt_ == _default_scanscrypt_) {
    return NULL;
  } else {
    ::std::string* temp = scanscrypt_;
    scanscrypt_ = const_cast< ::std::string*>(_default_scanscrypt_);
    return temp;
  }
}
inline void RotorRPMConfig::set_allocated_scanscrypt(::std::string* scanscrypt) {
  if (scanscrypt_ != _default_scanscrypt_) {
    delete scanscrypt_;
  }
  if (scanscrypt) {
    set_has_scanscrypt();
    scanscrypt_ = scanscrypt;
  } else {
    clear_has_scanscrypt();
    scanscrypt_ = const_cast< ::std::string*>(_default_scanscrypt_);
  }
}

// optional string gpsServer = 18 [default = "OFF"];
inline bool RotorRPMConfig::has_gpsserver() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void RotorRPMConfig::set_has_gpsserver() {
  _has_bits_[0] |= 0x00020000u;
}
inline void RotorRPMConfig::clear_has_gpsserver() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void RotorRPMConfig::clear_gpsserver() {
  if (gpsserver_ != _default_gpsserver_) {
    gpsserver_->assign(*_default_gpsserver_);
  }
  clear_has_gpsserver();
}
inline const ::std::string& RotorRPMConfig::gpsserver() const {
  return *gpsserver_;
}
inline void RotorRPMConfig::set_gpsserver(const ::std::string& value) {
  set_has_gpsserver();
  if (gpsserver_ == _default_gpsserver_) {
    gpsserver_ = new ::std::string;
  }
  gpsserver_->assign(value);
}
inline void RotorRPMConfig::set_gpsserver(const char* value) {
  set_has_gpsserver();
  if (gpsserver_ == _default_gpsserver_) {
    gpsserver_ = new ::std::string;
  }
  gpsserver_->assign(value);
}
inline void RotorRPMConfig::set_gpsserver(const char* value, size_t size) {
  set_has_gpsserver();
  if (gpsserver_ == _default_gpsserver_) {
    gpsserver_ = new ::std::string;
  }
  gpsserver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorRPMConfig::mutable_gpsserver() {
  set_has_gpsserver();
  if (gpsserver_ == _default_gpsserver_) {
    gpsserver_ = new ::std::string(*_default_gpsserver_);
  }
  return gpsserver_;
}
inline ::std::string* RotorRPMConfig::release_gpsserver() {
  clear_has_gpsserver();
  if (gpsserver_ == _default_gpsserver_) {
    return NULL;
  } else {
    ::std::string* temp = gpsserver_;
    gpsserver_ = const_cast< ::std::string*>(_default_gpsserver_);
    return temp;
  }
}
inline void RotorRPMConfig::set_allocated_gpsserver(::std::string* gpsserver) {
  if (gpsserver_ != _default_gpsserver_) {
    delete gpsserver_;
  }
  if (gpsserver) {
    set_has_gpsserver();
    gpsserver_ = gpsserver;
  } else {
    clear_has_gpsserver();
    gpsserver_ = const_cast< ::std::string*>(_default_gpsserver_);
  }
}

// optional string gpsUpdate = 19 [default = "ON"];
inline bool RotorRPMConfig::has_gpsupdate() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void RotorRPMConfig::set_has_gpsupdate() {
  _has_bits_[0] |= 0x00040000u;
}
inline void RotorRPMConfig::clear_has_gpsupdate() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void RotorRPMConfig::clear_gpsupdate() {
  if (gpsupdate_ != _default_gpsupdate_) {
    gpsupdate_->assign(*_default_gpsupdate_);
  }
  clear_has_gpsupdate();
}
inline const ::std::string& RotorRPMConfig::gpsupdate() const {
  return *gpsupdate_;
}
inline void RotorRPMConfig::set_gpsupdate(const ::std::string& value) {
  set_has_gpsupdate();
  if (gpsupdate_ == _default_gpsupdate_) {
    gpsupdate_ = new ::std::string;
  }
  gpsupdate_->assign(value);
}
inline void RotorRPMConfig::set_gpsupdate(const char* value) {
  set_has_gpsupdate();
  if (gpsupdate_ == _default_gpsupdate_) {
    gpsupdate_ = new ::std::string;
  }
  gpsupdate_->assign(value);
}
inline void RotorRPMConfig::set_gpsupdate(const char* value, size_t size) {
  set_has_gpsupdate();
  if (gpsupdate_ == _default_gpsupdate_) {
    gpsupdate_ = new ::std::string;
  }
  gpsupdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorRPMConfig::mutable_gpsupdate() {
  set_has_gpsupdate();
  if (gpsupdate_ == _default_gpsupdate_) {
    gpsupdate_ = new ::std::string(*_default_gpsupdate_);
  }
  return gpsupdate_;
}
inline ::std::string* RotorRPMConfig::release_gpsupdate() {
  clear_has_gpsupdate();
  if (gpsupdate_ == _default_gpsupdate_) {
    return NULL;
  } else {
    ::std::string* temp = gpsupdate_;
    gpsupdate_ = const_cast< ::std::string*>(_default_gpsupdate_);
    return temp;
  }
}
inline void RotorRPMConfig::set_allocated_gpsupdate(::std::string* gpsupdate) {
  if (gpsupdate_ != _default_gpsupdate_) {
    delete gpsupdate_;
  }
  if (gpsupdate) {
    set_has_gpsupdate();
    gpsupdate_ = gpsupdate;
  } else {
    clear_has_gpsupdate();
    gpsupdate_ = const_cast< ::std::string*>(_default_gpsupdate_);
  }
}

// optional bool elDisabled = 20 [default = false];
inline bool RotorRPMConfig::has_eldisabled() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void RotorRPMConfig::set_has_eldisabled() {
  _has_bits_[0] |= 0x00080000u;
}
inline void RotorRPMConfig::clear_has_eldisabled() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void RotorRPMConfig::clear_eldisabled() {
  eldisabled_ = false;
  clear_has_eldisabled();
}
inline bool RotorRPMConfig::eldisabled() const {
  return eldisabled_;
}
inline void RotorRPMConfig::set_eldisabled(bool value) {
  set_has_eldisabled();
  eldisabled_ = value;
}

// optional bool invertAz = 21 [default = false];
inline bool RotorRPMConfig::has_invertaz() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void RotorRPMConfig::set_has_invertaz() {
  _has_bits_[0] |= 0x00100000u;
}
inline void RotorRPMConfig::clear_has_invertaz() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void RotorRPMConfig::clear_invertaz() {
  invertaz_ = false;
  clear_has_invertaz();
}
inline bool RotorRPMConfig::invertaz() const {
  return invertaz_;
}
inline void RotorRPMConfig::set_invertaz(bool value) {
  set_has_invertaz();
  invertaz_ = value;
}

// optional float maxVelocity = 22 [default = 10];
inline bool RotorRPMConfig::has_maxvelocity() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void RotorRPMConfig::set_has_maxvelocity() {
  _has_bits_[0] |= 0x00200000u;
}
inline void RotorRPMConfig::clear_has_maxvelocity() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void RotorRPMConfig::clear_maxvelocity() {
  maxvelocity_ = 10;
  clear_has_maxvelocity();
}
inline float RotorRPMConfig::maxvelocity() const {
  return maxvelocity_;
}
inline void RotorRPMConfig::set_maxvelocity(float value) {
  set_has_maxvelocity();
  maxvelocity_ = value;
}

// optional bool dynamicVel = 23 [default = false];
inline bool RotorRPMConfig::has_dynamicvel() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void RotorRPMConfig::set_has_dynamicvel() {
  _has_bits_[0] |= 0x00400000u;
}
inline void RotorRPMConfig::clear_has_dynamicvel() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void RotorRPMConfig::clear_dynamicvel() {
  dynamicvel_ = false;
  clear_has_dynamicvel();
}
inline bool RotorRPMConfig::dynamicvel() const {
  return dynamicvel_;
}
inline void RotorRPMConfig::set_dynamicvel(bool value) {
  set_has_dynamicvel();
  dynamicvel_ = value;
}

// optional bool slewEnabled = 24 [default = false];
inline bool RotorRPMConfig::has_slewenabled() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void RotorRPMConfig::set_has_slewenabled() {
  _has_bits_[0] |= 0x00800000u;
}
inline void RotorRPMConfig::clear_has_slewenabled() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void RotorRPMConfig::clear_slewenabled() {
  slewenabled_ = false;
  clear_has_slewenabled();
}
inline bool RotorRPMConfig::slewenabled() const {
  return slewenabled_;
}
inline void RotorRPMConfig::set_slewenabled(bool value) {
  set_has_slewenabled();
  slewenabled_ = value;
}

// optional float azCloseEnough = 25 [default = 0.5];
inline bool RotorRPMConfig::has_azcloseenough() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void RotorRPMConfig::set_has_azcloseenough() {
  _has_bits_[0] |= 0x01000000u;
}
inline void RotorRPMConfig::clear_has_azcloseenough() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void RotorRPMConfig::clear_azcloseenough() {
  azcloseenough_ = 0.5f;
  clear_has_azcloseenough();
}
inline float RotorRPMConfig::azcloseenough() const {
  return azcloseenough_;
}
inline void RotorRPMConfig::set_azcloseenough(float value) {
  set_has_azcloseenough();
  azcloseenough_ = value;
}

// -------------------------------------------------------------------

// RotorProtatorConfig

// optional string msgName = 1 [default = "ROTOR_PROTATOR_CONFIG"];
inline bool RotorProtatorConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RotorProtatorConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RotorProtatorConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RotorProtatorConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& RotorProtatorConfig::msgname() const {
  return *msgname_;
}
inline void RotorProtatorConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RotorProtatorConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RotorProtatorConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorProtatorConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* RotorProtatorConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void RotorProtatorConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string IP = 2;
inline bool RotorProtatorConfig::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RotorProtatorConfig::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RotorProtatorConfig::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RotorProtatorConfig::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& RotorProtatorConfig::ip() const {
  return *ip_;
}
inline void RotorProtatorConfig::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RotorProtatorConfig::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RotorProtatorConfig::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorProtatorConfig::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* RotorProtatorConfig::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RotorProtatorConfig::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 port = 3;
inline bool RotorProtatorConfig::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RotorProtatorConfig::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RotorProtatorConfig::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RotorProtatorConfig::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 RotorProtatorConfig::port() const {
  return port_;
}
inline void RotorProtatorConfig::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// optional float AzOffset = 4;
inline bool RotorProtatorConfig::has_azoffset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RotorProtatorConfig::set_has_azoffset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RotorProtatorConfig::clear_has_azoffset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RotorProtatorConfig::clear_azoffset() {
  azoffset_ = 0;
  clear_has_azoffset();
}
inline float RotorProtatorConfig::azoffset() const {
  return azoffset_;
}
inline void RotorProtatorConfig::set_azoffset(float value) {
  set_has_azoffset();
  azoffset_ = value;
}

// optional bool hardLimit = 5;
inline bool RotorProtatorConfig::has_hardlimit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RotorProtatorConfig::set_has_hardlimit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RotorProtatorConfig::clear_has_hardlimit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RotorProtatorConfig::clear_hardlimit() {
  hardlimit_ = false;
  clear_has_hardlimit();
}
inline bool RotorProtatorConfig::hardlimit() const {
  return hardlimit_;
}
inline void RotorProtatorConfig::set_hardlimit(bool value) {
  set_has_hardlimit();
  hardlimit_ = value;
}

// optional float minScanAngle = 6;
inline bool RotorProtatorConfig::has_minscanangle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RotorProtatorConfig::set_has_minscanangle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RotorProtatorConfig::clear_has_minscanangle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RotorProtatorConfig::clear_minscanangle() {
  minscanangle_ = 0;
  clear_has_minscanangle();
}
inline float RotorProtatorConfig::minscanangle() const {
  return minscanangle_;
}
inline void RotorProtatorConfig::set_minscanangle(float value) {
  set_has_minscanangle();
  minscanangle_ = value;
}

// optional float maxScanAngle = 7;
inline bool RotorProtatorConfig::has_maxscanangle() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RotorProtatorConfig::set_has_maxscanangle() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RotorProtatorConfig::clear_has_maxscanangle() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RotorProtatorConfig::clear_maxscanangle() {
  maxscanangle_ = 0;
  clear_has_maxscanangle();
}
inline float RotorProtatorConfig::maxscanangle() const {
  return maxscanangle_;
}
inline void RotorProtatorConfig::set_maxscanangle(float value) {
  set_has_maxscanangle();
  maxscanangle_ = value;
}

// optional float multicastRate = 8;
inline bool RotorProtatorConfig::has_multicastrate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RotorProtatorConfig::set_has_multicastrate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RotorProtatorConfig::clear_has_multicastrate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RotorProtatorConfig::clear_multicastrate() {
  multicastrate_ = 0;
  clear_has_multicastrate();
}
inline float RotorProtatorConfig::multicastrate() const {
  return multicastrate_;
}
inline void RotorProtatorConfig::set_multicastrate(float value) {
  set_has_multicastrate();
  multicastrate_ = value;
}

// optional float pointHoldIncrement = 9;
inline bool RotorProtatorConfig::has_pointholdincrement() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RotorProtatorConfig::set_has_pointholdincrement() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RotorProtatorConfig::clear_has_pointholdincrement() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RotorProtatorConfig::clear_pointholdincrement() {
  pointholdincrement_ = 0;
  clear_has_pointholdincrement();
}
inline float RotorProtatorConfig::pointholdincrement() const {
  return pointholdincrement_;
}
inline void RotorProtatorConfig::set_pointholdincrement(float value) {
  set_has_pointholdincrement();
  pointholdincrement_ = value;
}

// optional float energyScanSpeed = 10 [default = 20];
inline bool RotorProtatorConfig::has_energyscanspeed() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RotorProtatorConfig::set_has_energyscanspeed() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RotorProtatorConfig::clear_has_energyscanspeed() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RotorProtatorConfig::clear_energyscanspeed() {
  energyscanspeed_ = 20;
  clear_has_energyscanspeed();
}
inline float RotorProtatorConfig::energyscanspeed() const {
  return energyscanspeed_;
}
inline void RotorProtatorConfig::set_energyscanspeed(float value) {
  set_has_energyscanspeed();
  energyscanspeed_ = value;
}

// optional float startDeviation = 11 [default = 180];
inline bool RotorProtatorConfig::has_startdeviation() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RotorProtatorConfig::set_has_startdeviation() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RotorProtatorConfig::clear_has_startdeviation() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RotorProtatorConfig::clear_startdeviation() {
  startdeviation_ = 180;
  clear_has_startdeviation();
}
inline float RotorProtatorConfig::startdeviation() const {
  return startdeviation_;
}
inline void RotorProtatorConfig::set_startdeviation(float value) {
  set_has_startdeviation();
  startdeviation_ = value;
}

// optional float energyTrackTime = 12 [default = 500];
inline bool RotorProtatorConfig::has_energytracktime() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RotorProtatorConfig::set_has_energytracktime() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RotorProtatorConfig::clear_has_energytracktime() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RotorProtatorConfig::clear_energytracktime() {
  energytracktime_ = 500;
  clear_has_energytracktime();
}
inline float RotorProtatorConfig::energytracktime() const {
  return energytracktime_;
}
inline void RotorProtatorConfig::set_energytracktime(float value) {
  set_has_energytracktime();
  energytracktime_ = value;
}

// optional string scanScrypt = 13 [default = "NONE"];
inline bool RotorProtatorConfig::has_scanscrypt() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RotorProtatorConfig::set_has_scanscrypt() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RotorProtatorConfig::clear_has_scanscrypt() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RotorProtatorConfig::clear_scanscrypt() {
  if (scanscrypt_ != _default_scanscrypt_) {
    scanscrypt_->assign(*_default_scanscrypt_);
  }
  clear_has_scanscrypt();
}
inline const ::std::string& RotorProtatorConfig::scanscrypt() const {
  return *scanscrypt_;
}
inline void RotorProtatorConfig::set_scanscrypt(const ::std::string& value) {
  set_has_scanscrypt();
  if (scanscrypt_ == _default_scanscrypt_) {
    scanscrypt_ = new ::std::string;
  }
  scanscrypt_->assign(value);
}
inline void RotorProtatorConfig::set_scanscrypt(const char* value) {
  set_has_scanscrypt();
  if (scanscrypt_ == _default_scanscrypt_) {
    scanscrypt_ = new ::std::string;
  }
  scanscrypt_->assign(value);
}
inline void RotorProtatorConfig::set_scanscrypt(const char* value, size_t size) {
  set_has_scanscrypt();
  if (scanscrypt_ == _default_scanscrypt_) {
    scanscrypt_ = new ::std::string;
  }
  scanscrypt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorProtatorConfig::mutable_scanscrypt() {
  set_has_scanscrypt();
  if (scanscrypt_ == _default_scanscrypt_) {
    scanscrypt_ = new ::std::string(*_default_scanscrypt_);
  }
  return scanscrypt_;
}
inline ::std::string* RotorProtatorConfig::release_scanscrypt() {
  clear_has_scanscrypt();
  if (scanscrypt_ == _default_scanscrypt_) {
    return NULL;
  } else {
    ::std::string* temp = scanscrypt_;
    scanscrypt_ = const_cast< ::std::string*>(_default_scanscrypt_);
    return temp;
  }
}
inline void RotorProtatorConfig::set_allocated_scanscrypt(::std::string* scanscrypt) {
  if (scanscrypt_ != _default_scanscrypt_) {
    delete scanscrypt_;
  }
  if (scanscrypt) {
    set_has_scanscrypt();
    scanscrypt_ = scanscrypt;
  } else {
    clear_has_scanscrypt();
    scanscrypt_ = const_cast< ::std::string*>(_default_scanscrypt_);
  }
}

// optional string gpsServer = 14 [default = "OFF"];
inline bool RotorProtatorConfig::has_gpsserver() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RotorProtatorConfig::set_has_gpsserver() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RotorProtatorConfig::clear_has_gpsserver() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RotorProtatorConfig::clear_gpsserver() {
  if (gpsserver_ != _default_gpsserver_) {
    gpsserver_->assign(*_default_gpsserver_);
  }
  clear_has_gpsserver();
}
inline const ::std::string& RotorProtatorConfig::gpsserver() const {
  return *gpsserver_;
}
inline void RotorProtatorConfig::set_gpsserver(const ::std::string& value) {
  set_has_gpsserver();
  if (gpsserver_ == _default_gpsserver_) {
    gpsserver_ = new ::std::string;
  }
  gpsserver_->assign(value);
}
inline void RotorProtatorConfig::set_gpsserver(const char* value) {
  set_has_gpsserver();
  if (gpsserver_ == _default_gpsserver_) {
    gpsserver_ = new ::std::string;
  }
  gpsserver_->assign(value);
}
inline void RotorProtatorConfig::set_gpsserver(const char* value, size_t size) {
  set_has_gpsserver();
  if (gpsserver_ == _default_gpsserver_) {
    gpsserver_ = new ::std::string;
  }
  gpsserver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorProtatorConfig::mutable_gpsserver() {
  set_has_gpsserver();
  if (gpsserver_ == _default_gpsserver_) {
    gpsserver_ = new ::std::string(*_default_gpsserver_);
  }
  return gpsserver_;
}
inline ::std::string* RotorProtatorConfig::release_gpsserver() {
  clear_has_gpsserver();
  if (gpsserver_ == _default_gpsserver_) {
    return NULL;
  } else {
    ::std::string* temp = gpsserver_;
    gpsserver_ = const_cast< ::std::string*>(_default_gpsserver_);
    return temp;
  }
}
inline void RotorProtatorConfig::set_allocated_gpsserver(::std::string* gpsserver) {
  if (gpsserver_ != _default_gpsserver_) {
    delete gpsserver_;
  }
  if (gpsserver) {
    set_has_gpsserver();
    gpsserver_ = gpsserver;
  } else {
    clear_has_gpsserver();
    gpsserver_ = const_cast< ::std::string*>(_default_gpsserver_);
  }
}

// optional string gpsUpdate = 15 [default = "ON"];
inline bool RotorProtatorConfig::has_gpsupdate() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RotorProtatorConfig::set_has_gpsupdate() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RotorProtatorConfig::clear_has_gpsupdate() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RotorProtatorConfig::clear_gpsupdate() {
  if (gpsupdate_ != _default_gpsupdate_) {
    gpsupdate_->assign(*_default_gpsupdate_);
  }
  clear_has_gpsupdate();
}
inline const ::std::string& RotorProtatorConfig::gpsupdate() const {
  return *gpsupdate_;
}
inline void RotorProtatorConfig::set_gpsupdate(const ::std::string& value) {
  set_has_gpsupdate();
  if (gpsupdate_ == _default_gpsupdate_) {
    gpsupdate_ = new ::std::string;
  }
  gpsupdate_->assign(value);
}
inline void RotorProtatorConfig::set_gpsupdate(const char* value) {
  set_has_gpsupdate();
  if (gpsupdate_ == _default_gpsupdate_) {
    gpsupdate_ = new ::std::string;
  }
  gpsupdate_->assign(value);
}
inline void RotorProtatorConfig::set_gpsupdate(const char* value, size_t size) {
  set_has_gpsupdate();
  if (gpsupdate_ == _default_gpsupdate_) {
    gpsupdate_ = new ::std::string;
  }
  gpsupdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorProtatorConfig::mutable_gpsupdate() {
  set_has_gpsupdate();
  if (gpsupdate_ == _default_gpsupdate_) {
    gpsupdate_ = new ::std::string(*_default_gpsupdate_);
  }
  return gpsupdate_;
}
inline ::std::string* RotorProtatorConfig::release_gpsupdate() {
  clear_has_gpsupdate();
  if (gpsupdate_ == _default_gpsupdate_) {
    return NULL;
  } else {
    ::std::string* temp = gpsupdate_;
    gpsupdate_ = const_cast< ::std::string*>(_default_gpsupdate_);
    return temp;
  }
}
inline void RotorProtatorConfig::set_allocated_gpsupdate(::std::string* gpsupdate) {
  if (gpsupdate_ != _default_gpsupdate_) {
    delete gpsupdate_;
  }
  if (gpsupdate) {
    set_has_gpsupdate();
    gpsupdate_ = gpsupdate;
  } else {
    clear_has_gpsupdate();
    gpsupdate_ = const_cast< ::std::string*>(_default_gpsupdate_);
  }
}

// optional float azCloseEnough = 16 [default = 5];
inline bool RotorProtatorConfig::has_azcloseenough() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RotorProtatorConfig::set_has_azcloseenough() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RotorProtatorConfig::clear_has_azcloseenough() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RotorProtatorConfig::clear_azcloseenough() {
  azcloseenough_ = 5;
  clear_has_azcloseenough();
}
inline float RotorProtatorConfig::azcloseenough() const {
  return azcloseenough_;
}
inline void RotorProtatorConfig::set_azcloseenough(float value) {
  set_has_azcloseenough();
  azcloseenough_ = value;
}

// optional bool elDisabled = 17 [default = true];
inline bool RotorProtatorConfig::has_eldisabled() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void RotorProtatorConfig::set_has_eldisabled() {
  _has_bits_[0] |= 0x00010000u;
}
inline void RotorProtatorConfig::clear_has_eldisabled() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void RotorProtatorConfig::clear_eldisabled() {
  eldisabled_ = true;
  clear_has_eldisabled();
}
inline bool RotorProtatorConfig::eldisabled() const {
  return eldisabled_;
}
inline void RotorProtatorConfig::set_eldisabled(bool value) {
  set_has_eldisabled();
  eldisabled_ = value;
}

// -------------------------------------------------------------------

// RotorProsistelConfig

// optional string msgName = 1 [default = "ROTOR_PROSISTEL_CONFIG"];
inline bool RotorProsistelConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RotorProsistelConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RotorProsistelConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RotorProsistelConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& RotorProsistelConfig::msgname() const {
  return *msgname_;
}
inline void RotorProsistelConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RotorProsistelConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RotorProsistelConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorProsistelConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* RotorProsistelConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void RotorProsistelConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string IP = 2;
inline bool RotorProsistelConfig::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RotorProsistelConfig::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RotorProsistelConfig::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RotorProsistelConfig::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& RotorProsistelConfig::ip() const {
  return *ip_;
}
inline void RotorProsistelConfig::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RotorProsistelConfig::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RotorProsistelConfig::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorProsistelConfig::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* RotorProsistelConfig::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RotorProsistelConfig::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 port = 3;
inline bool RotorProsistelConfig::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RotorProsistelConfig::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RotorProsistelConfig::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RotorProsistelConfig::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 RotorProsistelConfig::port() const {
  return port_;
}
inline void RotorProsistelConfig::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// optional float AzOffset = 4;
inline bool RotorProsistelConfig::has_azoffset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RotorProsistelConfig::set_has_azoffset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RotorProsistelConfig::clear_has_azoffset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RotorProsistelConfig::clear_azoffset() {
  azoffset_ = 0;
  clear_has_azoffset();
}
inline float RotorProsistelConfig::azoffset() const {
  return azoffset_;
}
inline void RotorProsistelConfig::set_azoffset(float value) {
  set_has_azoffset();
  azoffset_ = value;
}

// optional bool hardLimit = 5;
inline bool RotorProsistelConfig::has_hardlimit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RotorProsistelConfig::set_has_hardlimit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RotorProsistelConfig::clear_has_hardlimit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RotorProsistelConfig::clear_hardlimit() {
  hardlimit_ = false;
  clear_has_hardlimit();
}
inline bool RotorProsistelConfig::hardlimit() const {
  return hardlimit_;
}
inline void RotorProsistelConfig::set_hardlimit(bool value) {
  set_has_hardlimit();
  hardlimit_ = value;
}

// optional float minScanAngle = 6;
inline bool RotorProsistelConfig::has_minscanangle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RotorProsistelConfig::set_has_minscanangle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RotorProsistelConfig::clear_has_minscanangle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RotorProsistelConfig::clear_minscanangle() {
  minscanangle_ = 0;
  clear_has_minscanangle();
}
inline float RotorProsistelConfig::minscanangle() const {
  return minscanangle_;
}
inline void RotorProsistelConfig::set_minscanangle(float value) {
  set_has_minscanangle();
  minscanangle_ = value;
}

// optional float maxScanAngle = 7;
inline bool RotorProsistelConfig::has_maxscanangle() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RotorProsistelConfig::set_has_maxscanangle() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RotorProsistelConfig::clear_has_maxscanangle() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RotorProsistelConfig::clear_maxscanangle() {
  maxscanangle_ = 0;
  clear_has_maxscanangle();
}
inline float RotorProsistelConfig::maxscanangle() const {
  return maxscanangle_;
}
inline void RotorProsistelConfig::set_maxscanangle(float value) {
  set_has_maxscanangle();
  maxscanangle_ = value;
}

// optional float multicastRate = 8;
inline bool RotorProsistelConfig::has_multicastrate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RotorProsistelConfig::set_has_multicastrate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RotorProsistelConfig::clear_has_multicastrate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RotorProsistelConfig::clear_multicastrate() {
  multicastrate_ = 0;
  clear_has_multicastrate();
}
inline float RotorProsistelConfig::multicastrate() const {
  return multicastrate_;
}
inline void RotorProsistelConfig::set_multicastrate(float value) {
  set_has_multicastrate();
  multicastrate_ = value;
}

// optional float pointHoldIncrement = 9;
inline bool RotorProsistelConfig::has_pointholdincrement() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RotorProsistelConfig::set_has_pointholdincrement() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RotorProsistelConfig::clear_has_pointholdincrement() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RotorProsistelConfig::clear_pointholdincrement() {
  pointholdincrement_ = 0;
  clear_has_pointholdincrement();
}
inline float RotorProsistelConfig::pointholdincrement() const {
  return pointholdincrement_;
}
inline void RotorProsistelConfig::set_pointholdincrement(float value) {
  set_has_pointholdincrement();
  pointholdincrement_ = value;
}

// optional float energyScanSpeed = 10 [default = 20];
inline bool RotorProsistelConfig::has_energyscanspeed() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RotorProsistelConfig::set_has_energyscanspeed() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RotorProsistelConfig::clear_has_energyscanspeed() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RotorProsistelConfig::clear_energyscanspeed() {
  energyscanspeed_ = 20;
  clear_has_energyscanspeed();
}
inline float RotorProsistelConfig::energyscanspeed() const {
  return energyscanspeed_;
}
inline void RotorProsistelConfig::set_energyscanspeed(float value) {
  set_has_energyscanspeed();
  energyscanspeed_ = value;
}

// optional float startDeviation = 11 [default = 180];
inline bool RotorProsistelConfig::has_startdeviation() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RotorProsistelConfig::set_has_startdeviation() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RotorProsistelConfig::clear_has_startdeviation() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RotorProsistelConfig::clear_startdeviation() {
  startdeviation_ = 180;
  clear_has_startdeviation();
}
inline float RotorProsistelConfig::startdeviation() const {
  return startdeviation_;
}
inline void RotorProsistelConfig::set_startdeviation(float value) {
  set_has_startdeviation();
  startdeviation_ = value;
}

// optional float energyTrackTime = 12 [default = 500];
inline bool RotorProsistelConfig::has_energytracktime() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RotorProsistelConfig::set_has_energytracktime() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RotorProsistelConfig::clear_has_energytracktime() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RotorProsistelConfig::clear_energytracktime() {
  energytracktime_ = 500;
  clear_has_energytracktime();
}
inline float RotorProsistelConfig::energytracktime() const {
  return energytracktime_;
}
inline void RotorProsistelConfig::set_energytracktime(float value) {
  set_has_energytracktime();
  energytracktime_ = value;
}

// optional string scanScrypt = 13 [default = "NONE"];
inline bool RotorProsistelConfig::has_scanscrypt() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RotorProsistelConfig::set_has_scanscrypt() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RotorProsistelConfig::clear_has_scanscrypt() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RotorProsistelConfig::clear_scanscrypt() {
  if (scanscrypt_ != _default_scanscrypt_) {
    scanscrypt_->assign(*_default_scanscrypt_);
  }
  clear_has_scanscrypt();
}
inline const ::std::string& RotorProsistelConfig::scanscrypt() const {
  return *scanscrypt_;
}
inline void RotorProsistelConfig::set_scanscrypt(const ::std::string& value) {
  set_has_scanscrypt();
  if (scanscrypt_ == _default_scanscrypt_) {
    scanscrypt_ = new ::std::string;
  }
  scanscrypt_->assign(value);
}
inline void RotorProsistelConfig::set_scanscrypt(const char* value) {
  set_has_scanscrypt();
  if (scanscrypt_ == _default_scanscrypt_) {
    scanscrypt_ = new ::std::string;
  }
  scanscrypt_->assign(value);
}
inline void RotorProsistelConfig::set_scanscrypt(const char* value, size_t size) {
  set_has_scanscrypt();
  if (scanscrypt_ == _default_scanscrypt_) {
    scanscrypt_ = new ::std::string;
  }
  scanscrypt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorProsistelConfig::mutable_scanscrypt() {
  set_has_scanscrypt();
  if (scanscrypt_ == _default_scanscrypt_) {
    scanscrypt_ = new ::std::string(*_default_scanscrypt_);
  }
  return scanscrypt_;
}
inline ::std::string* RotorProsistelConfig::release_scanscrypt() {
  clear_has_scanscrypt();
  if (scanscrypt_ == _default_scanscrypt_) {
    return NULL;
  } else {
    ::std::string* temp = scanscrypt_;
    scanscrypt_ = const_cast< ::std::string*>(_default_scanscrypt_);
    return temp;
  }
}
inline void RotorProsistelConfig::set_allocated_scanscrypt(::std::string* scanscrypt) {
  if (scanscrypt_ != _default_scanscrypt_) {
    delete scanscrypt_;
  }
  if (scanscrypt) {
    set_has_scanscrypt();
    scanscrypt_ = scanscrypt;
  } else {
    clear_has_scanscrypt();
    scanscrypt_ = const_cast< ::std::string*>(_default_scanscrypt_);
  }
}

// optional string gpsServer = 14 [default = "OFF"];
inline bool RotorProsistelConfig::has_gpsserver() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RotorProsistelConfig::set_has_gpsserver() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RotorProsistelConfig::clear_has_gpsserver() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RotorProsistelConfig::clear_gpsserver() {
  if (gpsserver_ != _default_gpsserver_) {
    gpsserver_->assign(*_default_gpsserver_);
  }
  clear_has_gpsserver();
}
inline const ::std::string& RotorProsistelConfig::gpsserver() const {
  return *gpsserver_;
}
inline void RotorProsistelConfig::set_gpsserver(const ::std::string& value) {
  set_has_gpsserver();
  if (gpsserver_ == _default_gpsserver_) {
    gpsserver_ = new ::std::string;
  }
  gpsserver_->assign(value);
}
inline void RotorProsistelConfig::set_gpsserver(const char* value) {
  set_has_gpsserver();
  if (gpsserver_ == _default_gpsserver_) {
    gpsserver_ = new ::std::string;
  }
  gpsserver_->assign(value);
}
inline void RotorProsistelConfig::set_gpsserver(const char* value, size_t size) {
  set_has_gpsserver();
  if (gpsserver_ == _default_gpsserver_) {
    gpsserver_ = new ::std::string;
  }
  gpsserver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorProsistelConfig::mutable_gpsserver() {
  set_has_gpsserver();
  if (gpsserver_ == _default_gpsserver_) {
    gpsserver_ = new ::std::string(*_default_gpsserver_);
  }
  return gpsserver_;
}
inline ::std::string* RotorProsistelConfig::release_gpsserver() {
  clear_has_gpsserver();
  if (gpsserver_ == _default_gpsserver_) {
    return NULL;
  } else {
    ::std::string* temp = gpsserver_;
    gpsserver_ = const_cast< ::std::string*>(_default_gpsserver_);
    return temp;
  }
}
inline void RotorProsistelConfig::set_allocated_gpsserver(::std::string* gpsserver) {
  if (gpsserver_ != _default_gpsserver_) {
    delete gpsserver_;
  }
  if (gpsserver) {
    set_has_gpsserver();
    gpsserver_ = gpsserver;
  } else {
    clear_has_gpsserver();
    gpsserver_ = const_cast< ::std::string*>(_default_gpsserver_);
  }
}

// optional string gpsUpdate = 15 [default = "ON"];
inline bool RotorProsistelConfig::has_gpsupdate() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RotorProsistelConfig::set_has_gpsupdate() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RotorProsistelConfig::clear_has_gpsupdate() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RotorProsistelConfig::clear_gpsupdate() {
  if (gpsupdate_ != _default_gpsupdate_) {
    gpsupdate_->assign(*_default_gpsupdate_);
  }
  clear_has_gpsupdate();
}
inline const ::std::string& RotorProsistelConfig::gpsupdate() const {
  return *gpsupdate_;
}
inline void RotorProsistelConfig::set_gpsupdate(const ::std::string& value) {
  set_has_gpsupdate();
  if (gpsupdate_ == _default_gpsupdate_) {
    gpsupdate_ = new ::std::string;
  }
  gpsupdate_->assign(value);
}
inline void RotorProsistelConfig::set_gpsupdate(const char* value) {
  set_has_gpsupdate();
  if (gpsupdate_ == _default_gpsupdate_) {
    gpsupdate_ = new ::std::string;
  }
  gpsupdate_->assign(value);
}
inline void RotorProsistelConfig::set_gpsupdate(const char* value, size_t size) {
  set_has_gpsupdate();
  if (gpsupdate_ == _default_gpsupdate_) {
    gpsupdate_ = new ::std::string;
  }
  gpsupdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorProsistelConfig::mutable_gpsupdate() {
  set_has_gpsupdate();
  if (gpsupdate_ == _default_gpsupdate_) {
    gpsupdate_ = new ::std::string(*_default_gpsupdate_);
  }
  return gpsupdate_;
}
inline ::std::string* RotorProsistelConfig::release_gpsupdate() {
  clear_has_gpsupdate();
  if (gpsupdate_ == _default_gpsupdate_) {
    return NULL;
  } else {
    ::std::string* temp = gpsupdate_;
    gpsupdate_ = const_cast< ::std::string*>(_default_gpsupdate_);
    return temp;
  }
}
inline void RotorProsistelConfig::set_allocated_gpsupdate(::std::string* gpsupdate) {
  if (gpsupdate_ != _default_gpsupdate_) {
    delete gpsupdate_;
  }
  if (gpsupdate) {
    set_has_gpsupdate();
    gpsupdate_ = gpsupdate;
  } else {
    clear_has_gpsupdate();
    gpsupdate_ = const_cast< ::std::string*>(_default_gpsupdate_);
  }
}

// optional float azCloseEnough = 16 [default = 5];
inline bool RotorProsistelConfig::has_azcloseenough() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RotorProsistelConfig::set_has_azcloseenough() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RotorProsistelConfig::clear_has_azcloseenough() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RotorProsistelConfig::clear_azcloseenough() {
  azcloseenough_ = 5;
  clear_has_azcloseenough();
}
inline float RotorProsistelConfig::azcloseenough() const {
  return azcloseenough_;
}
inline void RotorProsistelConfig::set_azcloseenough(float value) {
  set_has_azcloseenough();
  azcloseenough_ = value;
}

// optional bool elDisabled = 17 [default = false];
inline bool RotorProsistelConfig::has_eldisabled() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void RotorProsistelConfig::set_has_eldisabled() {
  _has_bits_[0] |= 0x00010000u;
}
inline void RotorProsistelConfig::clear_has_eldisabled() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void RotorProsistelConfig::clear_eldisabled() {
  eldisabled_ = false;
  clear_has_eldisabled();
}
inline bool RotorProsistelConfig::eldisabled() const {
  return eldisabled_;
}
inline void RotorProsistelConfig::set_eldisabled(bool value) {
  set_has_eldisabled();
  eldisabled_ = value;
}

// -------------------------------------------------------------------

// RotorEzrotorConfig

// optional string msgName = 1 [default = "EZROTOR_CONFIG"];
inline bool RotorEzrotorConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RotorEzrotorConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RotorEzrotorConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RotorEzrotorConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& RotorEzrotorConfig::msgname() const {
  return *msgname_;
}
inline void RotorEzrotorConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RotorEzrotorConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RotorEzrotorConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorEzrotorConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* RotorEzrotorConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void RotorEzrotorConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string IP = 2;
inline bool RotorEzrotorConfig::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RotorEzrotorConfig::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RotorEzrotorConfig::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RotorEzrotorConfig::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& RotorEzrotorConfig::ip() const {
  return *ip_;
}
inline void RotorEzrotorConfig::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RotorEzrotorConfig::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RotorEzrotorConfig::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorEzrotorConfig::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* RotorEzrotorConfig::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RotorEzrotorConfig::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 port = 3;
inline bool RotorEzrotorConfig::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RotorEzrotorConfig::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RotorEzrotorConfig::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RotorEzrotorConfig::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 RotorEzrotorConfig::port() const {
  return port_;
}
inline void RotorEzrotorConfig::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// optional float AzOffset = 4;
inline bool RotorEzrotorConfig::has_azoffset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RotorEzrotorConfig::set_has_azoffset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RotorEzrotorConfig::clear_has_azoffset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RotorEzrotorConfig::clear_azoffset() {
  azoffset_ = 0;
  clear_has_azoffset();
}
inline float RotorEzrotorConfig::azoffset() const {
  return azoffset_;
}
inline void RotorEzrotorConfig::set_azoffset(float value) {
  set_has_azoffset();
  azoffset_ = value;
}

// optional bool hardLimit = 5;
inline bool RotorEzrotorConfig::has_hardlimit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RotorEzrotorConfig::set_has_hardlimit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RotorEzrotorConfig::clear_has_hardlimit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RotorEzrotorConfig::clear_hardlimit() {
  hardlimit_ = false;
  clear_has_hardlimit();
}
inline bool RotorEzrotorConfig::hardlimit() const {
  return hardlimit_;
}
inline void RotorEzrotorConfig::set_hardlimit(bool value) {
  set_has_hardlimit();
  hardlimit_ = value;
}

// optional float minScanAngle = 6;
inline bool RotorEzrotorConfig::has_minscanangle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RotorEzrotorConfig::set_has_minscanangle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RotorEzrotorConfig::clear_has_minscanangle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RotorEzrotorConfig::clear_minscanangle() {
  minscanangle_ = 0;
  clear_has_minscanangle();
}
inline float RotorEzrotorConfig::minscanangle() const {
  return minscanangle_;
}
inline void RotorEzrotorConfig::set_minscanangle(float value) {
  set_has_minscanangle();
  minscanangle_ = value;
}

// optional float maxScanAngle = 7;
inline bool RotorEzrotorConfig::has_maxscanangle() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RotorEzrotorConfig::set_has_maxscanangle() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RotorEzrotorConfig::clear_has_maxscanangle() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RotorEzrotorConfig::clear_maxscanangle() {
  maxscanangle_ = 0;
  clear_has_maxscanangle();
}
inline float RotorEzrotorConfig::maxscanangle() const {
  return maxscanangle_;
}
inline void RotorEzrotorConfig::set_maxscanangle(float value) {
  set_has_maxscanangle();
  maxscanangle_ = value;
}

// optional float multicastRate = 8;
inline bool RotorEzrotorConfig::has_multicastrate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RotorEzrotorConfig::set_has_multicastrate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RotorEzrotorConfig::clear_has_multicastrate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RotorEzrotorConfig::clear_multicastrate() {
  multicastrate_ = 0;
  clear_has_multicastrate();
}
inline float RotorEzrotorConfig::multicastrate() const {
  return multicastrate_;
}
inline void RotorEzrotorConfig::set_multicastrate(float value) {
  set_has_multicastrate();
  multicastrate_ = value;
}

// optional float pointHoldIncrement = 9;
inline bool RotorEzrotorConfig::has_pointholdincrement() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RotorEzrotorConfig::set_has_pointholdincrement() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RotorEzrotorConfig::clear_has_pointholdincrement() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RotorEzrotorConfig::clear_pointholdincrement() {
  pointholdincrement_ = 0;
  clear_has_pointholdincrement();
}
inline float RotorEzrotorConfig::pointholdincrement() const {
  return pointholdincrement_;
}
inline void RotorEzrotorConfig::set_pointholdincrement(float value) {
  set_has_pointholdincrement();
  pointholdincrement_ = value;
}

// optional float energyScanSpeed = 10 [default = 20];
inline bool RotorEzrotorConfig::has_energyscanspeed() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RotorEzrotorConfig::set_has_energyscanspeed() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RotorEzrotorConfig::clear_has_energyscanspeed() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RotorEzrotorConfig::clear_energyscanspeed() {
  energyscanspeed_ = 20;
  clear_has_energyscanspeed();
}
inline float RotorEzrotorConfig::energyscanspeed() const {
  return energyscanspeed_;
}
inline void RotorEzrotorConfig::set_energyscanspeed(float value) {
  set_has_energyscanspeed();
  energyscanspeed_ = value;
}

// optional float startDeviation = 11 [default = 180];
inline bool RotorEzrotorConfig::has_startdeviation() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RotorEzrotorConfig::set_has_startdeviation() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RotorEzrotorConfig::clear_has_startdeviation() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RotorEzrotorConfig::clear_startdeviation() {
  startdeviation_ = 180;
  clear_has_startdeviation();
}
inline float RotorEzrotorConfig::startdeviation() const {
  return startdeviation_;
}
inline void RotorEzrotorConfig::set_startdeviation(float value) {
  set_has_startdeviation();
  startdeviation_ = value;
}

// optional float energyTrackTime = 12 [default = 500];
inline bool RotorEzrotorConfig::has_energytracktime() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RotorEzrotorConfig::set_has_energytracktime() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RotorEzrotorConfig::clear_has_energytracktime() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RotorEzrotorConfig::clear_energytracktime() {
  energytracktime_ = 500;
  clear_has_energytracktime();
}
inline float RotorEzrotorConfig::energytracktime() const {
  return energytracktime_;
}
inline void RotorEzrotorConfig::set_energytracktime(float value) {
  set_has_energytracktime();
  energytracktime_ = value;
}

// optional string scanScrypt = 13 [default = "NONE"];
inline bool RotorEzrotorConfig::has_scanscrypt() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RotorEzrotorConfig::set_has_scanscrypt() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RotorEzrotorConfig::clear_has_scanscrypt() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RotorEzrotorConfig::clear_scanscrypt() {
  if (scanscrypt_ != _default_scanscrypt_) {
    scanscrypt_->assign(*_default_scanscrypt_);
  }
  clear_has_scanscrypt();
}
inline const ::std::string& RotorEzrotorConfig::scanscrypt() const {
  return *scanscrypt_;
}
inline void RotorEzrotorConfig::set_scanscrypt(const ::std::string& value) {
  set_has_scanscrypt();
  if (scanscrypt_ == _default_scanscrypt_) {
    scanscrypt_ = new ::std::string;
  }
  scanscrypt_->assign(value);
}
inline void RotorEzrotorConfig::set_scanscrypt(const char* value) {
  set_has_scanscrypt();
  if (scanscrypt_ == _default_scanscrypt_) {
    scanscrypt_ = new ::std::string;
  }
  scanscrypt_->assign(value);
}
inline void RotorEzrotorConfig::set_scanscrypt(const char* value, size_t size) {
  set_has_scanscrypt();
  if (scanscrypt_ == _default_scanscrypt_) {
    scanscrypt_ = new ::std::string;
  }
  scanscrypt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorEzrotorConfig::mutable_scanscrypt() {
  set_has_scanscrypt();
  if (scanscrypt_ == _default_scanscrypt_) {
    scanscrypt_ = new ::std::string(*_default_scanscrypt_);
  }
  return scanscrypt_;
}
inline ::std::string* RotorEzrotorConfig::release_scanscrypt() {
  clear_has_scanscrypt();
  if (scanscrypt_ == _default_scanscrypt_) {
    return NULL;
  } else {
    ::std::string* temp = scanscrypt_;
    scanscrypt_ = const_cast< ::std::string*>(_default_scanscrypt_);
    return temp;
  }
}
inline void RotorEzrotorConfig::set_allocated_scanscrypt(::std::string* scanscrypt) {
  if (scanscrypt_ != _default_scanscrypt_) {
    delete scanscrypt_;
  }
  if (scanscrypt) {
    set_has_scanscrypt();
    scanscrypt_ = scanscrypt;
  } else {
    clear_has_scanscrypt();
    scanscrypt_ = const_cast< ::std::string*>(_default_scanscrypt_);
  }
}

// optional string gpsServer = 14 [default = "OFF"];
inline bool RotorEzrotorConfig::has_gpsserver() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RotorEzrotorConfig::set_has_gpsserver() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RotorEzrotorConfig::clear_has_gpsserver() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RotorEzrotorConfig::clear_gpsserver() {
  if (gpsserver_ != _default_gpsserver_) {
    gpsserver_->assign(*_default_gpsserver_);
  }
  clear_has_gpsserver();
}
inline const ::std::string& RotorEzrotorConfig::gpsserver() const {
  return *gpsserver_;
}
inline void RotorEzrotorConfig::set_gpsserver(const ::std::string& value) {
  set_has_gpsserver();
  if (gpsserver_ == _default_gpsserver_) {
    gpsserver_ = new ::std::string;
  }
  gpsserver_->assign(value);
}
inline void RotorEzrotorConfig::set_gpsserver(const char* value) {
  set_has_gpsserver();
  if (gpsserver_ == _default_gpsserver_) {
    gpsserver_ = new ::std::string;
  }
  gpsserver_->assign(value);
}
inline void RotorEzrotorConfig::set_gpsserver(const char* value, size_t size) {
  set_has_gpsserver();
  if (gpsserver_ == _default_gpsserver_) {
    gpsserver_ = new ::std::string;
  }
  gpsserver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorEzrotorConfig::mutable_gpsserver() {
  set_has_gpsserver();
  if (gpsserver_ == _default_gpsserver_) {
    gpsserver_ = new ::std::string(*_default_gpsserver_);
  }
  return gpsserver_;
}
inline ::std::string* RotorEzrotorConfig::release_gpsserver() {
  clear_has_gpsserver();
  if (gpsserver_ == _default_gpsserver_) {
    return NULL;
  } else {
    ::std::string* temp = gpsserver_;
    gpsserver_ = const_cast< ::std::string*>(_default_gpsserver_);
    return temp;
  }
}
inline void RotorEzrotorConfig::set_allocated_gpsserver(::std::string* gpsserver) {
  if (gpsserver_ != _default_gpsserver_) {
    delete gpsserver_;
  }
  if (gpsserver) {
    set_has_gpsserver();
    gpsserver_ = gpsserver;
  } else {
    clear_has_gpsserver();
    gpsserver_ = const_cast< ::std::string*>(_default_gpsserver_);
  }
}

// optional string gpsUpdate = 15 [default = "ON"];
inline bool RotorEzrotorConfig::has_gpsupdate() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RotorEzrotorConfig::set_has_gpsupdate() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RotorEzrotorConfig::clear_has_gpsupdate() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RotorEzrotorConfig::clear_gpsupdate() {
  if (gpsupdate_ != _default_gpsupdate_) {
    gpsupdate_->assign(*_default_gpsupdate_);
  }
  clear_has_gpsupdate();
}
inline const ::std::string& RotorEzrotorConfig::gpsupdate() const {
  return *gpsupdate_;
}
inline void RotorEzrotorConfig::set_gpsupdate(const ::std::string& value) {
  set_has_gpsupdate();
  if (gpsupdate_ == _default_gpsupdate_) {
    gpsupdate_ = new ::std::string;
  }
  gpsupdate_->assign(value);
}
inline void RotorEzrotorConfig::set_gpsupdate(const char* value) {
  set_has_gpsupdate();
  if (gpsupdate_ == _default_gpsupdate_) {
    gpsupdate_ = new ::std::string;
  }
  gpsupdate_->assign(value);
}
inline void RotorEzrotorConfig::set_gpsupdate(const char* value, size_t size) {
  set_has_gpsupdate();
  if (gpsupdate_ == _default_gpsupdate_) {
    gpsupdate_ = new ::std::string;
  }
  gpsupdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorEzrotorConfig::mutable_gpsupdate() {
  set_has_gpsupdate();
  if (gpsupdate_ == _default_gpsupdate_) {
    gpsupdate_ = new ::std::string(*_default_gpsupdate_);
  }
  return gpsupdate_;
}
inline ::std::string* RotorEzrotorConfig::release_gpsupdate() {
  clear_has_gpsupdate();
  if (gpsupdate_ == _default_gpsupdate_) {
    return NULL;
  } else {
    ::std::string* temp = gpsupdate_;
    gpsupdate_ = const_cast< ::std::string*>(_default_gpsupdate_);
    return temp;
  }
}
inline void RotorEzrotorConfig::set_allocated_gpsupdate(::std::string* gpsupdate) {
  if (gpsupdate_ != _default_gpsupdate_) {
    delete gpsupdate_;
  }
  if (gpsupdate) {
    set_has_gpsupdate();
    gpsupdate_ = gpsupdate;
  } else {
    clear_has_gpsupdate();
    gpsupdate_ = const_cast< ::std::string*>(_default_gpsupdate_);
  }
}

// optional float azCloseEnough = 16 [default = 5];
inline bool RotorEzrotorConfig::has_azcloseenough() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RotorEzrotorConfig::set_has_azcloseenough() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RotorEzrotorConfig::clear_has_azcloseenough() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RotorEzrotorConfig::clear_azcloseenough() {
  azcloseenough_ = 5;
  clear_has_azcloseenough();
}
inline float RotorEzrotorConfig::azcloseenough() const {
  return azcloseenough_;
}
inline void RotorEzrotorConfig::set_azcloseenough(float value) {
  set_has_azcloseenough();
  azcloseenough_ = value;
}

// optional bool elDisabled = 17 [default = false];
inline bool RotorEzrotorConfig::has_eldisabled() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void RotorEzrotorConfig::set_has_eldisabled() {
  _has_bits_[0] |= 0x00010000u;
}
inline void RotorEzrotorConfig::clear_has_eldisabled() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void RotorEzrotorConfig::clear_eldisabled() {
  eldisabled_ = false;
  clear_has_eldisabled();
}
inline bool RotorEzrotorConfig::eldisabled() const {
  return eldisabled_;
}
inline void RotorEzrotorConfig::set_eldisabled(bool value) {
  set_has_eldisabled();
  eldisabled_ = value;
}

// -------------------------------------------------------------------

// RotorHGIOConfig

// optional string msgName = 1 [default = "HGIO_CONFIG"];
inline bool RotorHGIOConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RotorHGIOConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RotorHGIOConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RotorHGIOConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& RotorHGIOConfig::msgname() const {
  return *msgname_;
}
inline void RotorHGIOConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RotorHGIOConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RotorHGIOConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorHGIOConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* RotorHGIOConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void RotorHGIOConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string IP = 2;
inline bool RotorHGIOConfig::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RotorHGIOConfig::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RotorHGIOConfig::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RotorHGIOConfig::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& RotorHGIOConfig::ip() const {
  return *ip_;
}
inline void RotorHGIOConfig::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RotorHGIOConfig::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RotorHGIOConfig::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorHGIOConfig::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* RotorHGIOConfig::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RotorHGIOConfig::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 port = 3;
inline bool RotorHGIOConfig::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RotorHGIOConfig::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RotorHGIOConfig::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RotorHGIOConfig::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 RotorHGIOConfig::port() const {
  return port_;
}
inline void RotorHGIOConfig::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// optional float AzOffset = 4;
inline bool RotorHGIOConfig::has_azoffset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RotorHGIOConfig::set_has_azoffset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RotorHGIOConfig::clear_has_azoffset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RotorHGIOConfig::clear_azoffset() {
  azoffset_ = 0;
  clear_has_azoffset();
}
inline float RotorHGIOConfig::azoffset() const {
  return azoffset_;
}
inline void RotorHGIOConfig::set_azoffset(float value) {
  set_has_azoffset();
  azoffset_ = value;
}

// optional bool hardLimit = 5 [default = false];
inline bool RotorHGIOConfig::has_hardlimit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RotorHGIOConfig::set_has_hardlimit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RotorHGIOConfig::clear_has_hardlimit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RotorHGIOConfig::clear_hardlimit() {
  hardlimit_ = false;
  clear_has_hardlimit();
}
inline bool RotorHGIOConfig::hardlimit() const {
  return hardlimit_;
}
inline void RotorHGIOConfig::set_hardlimit(bool value) {
  set_has_hardlimit();
  hardlimit_ = value;
}

// optional float minScanAngle = 6;
inline bool RotorHGIOConfig::has_minscanangle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RotorHGIOConfig::set_has_minscanangle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RotorHGIOConfig::clear_has_minscanangle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RotorHGIOConfig::clear_minscanangle() {
  minscanangle_ = 0;
  clear_has_minscanangle();
}
inline float RotorHGIOConfig::minscanangle() const {
  return minscanangle_;
}
inline void RotorHGIOConfig::set_minscanangle(float value) {
  set_has_minscanangle();
  minscanangle_ = value;
}

// optional float maxScanAngle = 7;
inline bool RotorHGIOConfig::has_maxscanangle() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RotorHGIOConfig::set_has_maxscanangle() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RotorHGIOConfig::clear_has_maxscanangle() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RotorHGIOConfig::clear_maxscanangle() {
  maxscanangle_ = 0;
  clear_has_maxscanangle();
}
inline float RotorHGIOConfig::maxscanangle() const {
  return maxscanangle_;
}
inline void RotorHGIOConfig::set_maxscanangle(float value) {
  set_has_maxscanangle();
  maxscanangle_ = value;
}

// optional float minElevation = 8;
inline bool RotorHGIOConfig::has_minelevation() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RotorHGIOConfig::set_has_minelevation() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RotorHGIOConfig::clear_has_minelevation() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RotorHGIOConfig::clear_minelevation() {
  minelevation_ = 0;
  clear_has_minelevation();
}
inline float RotorHGIOConfig::minelevation() const {
  return minelevation_;
}
inline void RotorHGIOConfig::set_minelevation(float value) {
  set_has_minelevation();
  minelevation_ = value;
}

// optional float maxElevation = 9;
inline bool RotorHGIOConfig::has_maxelevation() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RotorHGIOConfig::set_has_maxelevation() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RotorHGIOConfig::clear_has_maxelevation() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RotorHGIOConfig::clear_maxelevation() {
  maxelevation_ = 0;
  clear_has_maxelevation();
}
inline float RotorHGIOConfig::maxelevation() const {
  return maxelevation_;
}
inline void RotorHGIOConfig::set_maxelevation(float value) {
  set_has_maxelevation();
  maxelevation_ = value;
}

// optional float scanElevation = 10;
inline bool RotorHGIOConfig::has_scanelevation() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RotorHGIOConfig::set_has_scanelevation() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RotorHGIOConfig::clear_has_scanelevation() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RotorHGIOConfig::clear_scanelevation() {
  scanelevation_ = 0;
  clear_has_scanelevation();
}
inline float RotorHGIOConfig::scanelevation() const {
  return scanelevation_;
}
inline void RotorHGIOConfig::set_scanelevation(float value) {
  set_has_scanelevation();
  scanelevation_ = value;
}

// optional float multicastRate = 11;
inline bool RotorHGIOConfig::has_multicastrate() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RotorHGIOConfig::set_has_multicastrate() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RotorHGIOConfig::clear_has_multicastrate() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RotorHGIOConfig::clear_multicastrate() {
  multicastrate_ = 0;
  clear_has_multicastrate();
}
inline float RotorHGIOConfig::multicastrate() const {
  return multicastrate_;
}
inline void RotorHGIOConfig::set_multicastrate(float value) {
  set_has_multicastrate();
  multicastrate_ = value;
}

// optional float pointHoldIncrement = 12;
inline bool RotorHGIOConfig::has_pointholdincrement() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RotorHGIOConfig::set_has_pointholdincrement() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RotorHGIOConfig::clear_has_pointholdincrement() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RotorHGIOConfig::clear_pointholdincrement() {
  pointholdincrement_ = 0;
  clear_has_pointholdincrement();
}
inline float RotorHGIOConfig::pointholdincrement() const {
  return pointholdincrement_;
}
inline void RotorHGIOConfig::set_pointholdincrement(float value) {
  set_has_pointholdincrement();
  pointholdincrement_ = value;
}

// optional float energyScanSpeed = 13 [default = 5];
inline bool RotorHGIOConfig::has_energyscanspeed() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RotorHGIOConfig::set_has_energyscanspeed() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RotorHGIOConfig::clear_has_energyscanspeed() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RotorHGIOConfig::clear_energyscanspeed() {
  energyscanspeed_ = 5;
  clear_has_energyscanspeed();
}
inline float RotorHGIOConfig::energyscanspeed() const {
  return energyscanspeed_;
}
inline void RotorHGIOConfig::set_energyscanspeed(float value) {
  set_has_energyscanspeed();
  energyscanspeed_ = value;
}

// optional float startDeviation = 14 [default = 180];
inline bool RotorHGIOConfig::has_startdeviation() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RotorHGIOConfig::set_has_startdeviation() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RotorHGIOConfig::clear_has_startdeviation() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RotorHGIOConfig::clear_startdeviation() {
  startdeviation_ = 180;
  clear_has_startdeviation();
}
inline float RotorHGIOConfig::startdeviation() const {
  return startdeviation_;
}
inline void RotorHGIOConfig::set_startdeviation(float value) {
  set_has_startdeviation();
  startdeviation_ = value;
}

// optional float energyTrackTime = 15 [default = 500];
inline bool RotorHGIOConfig::has_energytracktime() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RotorHGIOConfig::set_has_energytracktime() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RotorHGIOConfig::clear_has_energytracktime() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RotorHGIOConfig::clear_energytracktime() {
  energytracktime_ = 500;
  clear_has_energytracktime();
}
inline float RotorHGIOConfig::energytracktime() const {
  return energytracktime_;
}
inline void RotorHGIOConfig::set_energytracktime(float value) {
  set_has_energytracktime();
  energytracktime_ = value;
}

// optional bool useGps = 16 [default = false];
inline bool RotorHGIOConfig::has_usegps() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RotorHGIOConfig::set_has_usegps() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RotorHGIOConfig::clear_has_usegps() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RotorHGIOConfig::clear_usegps() {
  usegps_ = false;
  clear_has_usegps();
}
inline bool RotorHGIOConfig::usegps() const {
  return usegps_;
}
inline void RotorHGIOConfig::set_usegps(bool value) {
  set_has_usegps();
  usegps_ = value;
}

// optional string scanScrypt = 17 [default = "NONE"];
inline bool RotorHGIOConfig::has_scanscrypt() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void RotorHGIOConfig::set_has_scanscrypt() {
  _has_bits_[0] |= 0x00010000u;
}
inline void RotorHGIOConfig::clear_has_scanscrypt() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void RotorHGIOConfig::clear_scanscrypt() {
  if (scanscrypt_ != _default_scanscrypt_) {
    scanscrypt_->assign(*_default_scanscrypt_);
  }
  clear_has_scanscrypt();
}
inline const ::std::string& RotorHGIOConfig::scanscrypt() const {
  return *scanscrypt_;
}
inline void RotorHGIOConfig::set_scanscrypt(const ::std::string& value) {
  set_has_scanscrypt();
  if (scanscrypt_ == _default_scanscrypt_) {
    scanscrypt_ = new ::std::string;
  }
  scanscrypt_->assign(value);
}
inline void RotorHGIOConfig::set_scanscrypt(const char* value) {
  set_has_scanscrypt();
  if (scanscrypt_ == _default_scanscrypt_) {
    scanscrypt_ = new ::std::string;
  }
  scanscrypt_->assign(value);
}
inline void RotorHGIOConfig::set_scanscrypt(const char* value, size_t size) {
  set_has_scanscrypt();
  if (scanscrypt_ == _default_scanscrypt_) {
    scanscrypt_ = new ::std::string;
  }
  scanscrypt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorHGIOConfig::mutable_scanscrypt() {
  set_has_scanscrypt();
  if (scanscrypt_ == _default_scanscrypt_) {
    scanscrypt_ = new ::std::string(*_default_scanscrypt_);
  }
  return scanscrypt_;
}
inline ::std::string* RotorHGIOConfig::release_scanscrypt() {
  clear_has_scanscrypt();
  if (scanscrypt_ == _default_scanscrypt_) {
    return NULL;
  } else {
    ::std::string* temp = scanscrypt_;
    scanscrypt_ = const_cast< ::std::string*>(_default_scanscrypt_);
    return temp;
  }
}
inline void RotorHGIOConfig::set_allocated_scanscrypt(::std::string* scanscrypt) {
  if (scanscrypt_ != _default_scanscrypt_) {
    delete scanscrypt_;
  }
  if (scanscrypt) {
    set_has_scanscrypt();
    scanscrypt_ = scanscrypt;
  } else {
    clear_has_scanscrypt();
    scanscrypt_ = const_cast< ::std::string*>(_default_scanscrypt_);
  }
}

// optional string gpsServer = 18 [default = "OFF"];
inline bool RotorHGIOConfig::has_gpsserver() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void RotorHGIOConfig::set_has_gpsserver() {
  _has_bits_[0] |= 0x00020000u;
}
inline void RotorHGIOConfig::clear_has_gpsserver() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void RotorHGIOConfig::clear_gpsserver() {
  if (gpsserver_ != _default_gpsserver_) {
    gpsserver_->assign(*_default_gpsserver_);
  }
  clear_has_gpsserver();
}
inline const ::std::string& RotorHGIOConfig::gpsserver() const {
  return *gpsserver_;
}
inline void RotorHGIOConfig::set_gpsserver(const ::std::string& value) {
  set_has_gpsserver();
  if (gpsserver_ == _default_gpsserver_) {
    gpsserver_ = new ::std::string;
  }
  gpsserver_->assign(value);
}
inline void RotorHGIOConfig::set_gpsserver(const char* value) {
  set_has_gpsserver();
  if (gpsserver_ == _default_gpsserver_) {
    gpsserver_ = new ::std::string;
  }
  gpsserver_->assign(value);
}
inline void RotorHGIOConfig::set_gpsserver(const char* value, size_t size) {
  set_has_gpsserver();
  if (gpsserver_ == _default_gpsserver_) {
    gpsserver_ = new ::std::string;
  }
  gpsserver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorHGIOConfig::mutable_gpsserver() {
  set_has_gpsserver();
  if (gpsserver_ == _default_gpsserver_) {
    gpsserver_ = new ::std::string(*_default_gpsserver_);
  }
  return gpsserver_;
}
inline ::std::string* RotorHGIOConfig::release_gpsserver() {
  clear_has_gpsserver();
  if (gpsserver_ == _default_gpsserver_) {
    return NULL;
  } else {
    ::std::string* temp = gpsserver_;
    gpsserver_ = const_cast< ::std::string*>(_default_gpsserver_);
    return temp;
  }
}
inline void RotorHGIOConfig::set_allocated_gpsserver(::std::string* gpsserver) {
  if (gpsserver_ != _default_gpsserver_) {
    delete gpsserver_;
  }
  if (gpsserver) {
    set_has_gpsserver();
    gpsserver_ = gpsserver;
  } else {
    clear_has_gpsserver();
    gpsserver_ = const_cast< ::std::string*>(_default_gpsserver_);
  }
}

// optional string gpsUpdate = 19 [default = "ON"];
inline bool RotorHGIOConfig::has_gpsupdate() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void RotorHGIOConfig::set_has_gpsupdate() {
  _has_bits_[0] |= 0x00040000u;
}
inline void RotorHGIOConfig::clear_has_gpsupdate() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void RotorHGIOConfig::clear_gpsupdate() {
  if (gpsupdate_ != _default_gpsupdate_) {
    gpsupdate_->assign(*_default_gpsupdate_);
  }
  clear_has_gpsupdate();
}
inline const ::std::string& RotorHGIOConfig::gpsupdate() const {
  return *gpsupdate_;
}
inline void RotorHGIOConfig::set_gpsupdate(const ::std::string& value) {
  set_has_gpsupdate();
  if (gpsupdate_ == _default_gpsupdate_) {
    gpsupdate_ = new ::std::string;
  }
  gpsupdate_->assign(value);
}
inline void RotorHGIOConfig::set_gpsupdate(const char* value) {
  set_has_gpsupdate();
  if (gpsupdate_ == _default_gpsupdate_) {
    gpsupdate_ = new ::std::string;
  }
  gpsupdate_->assign(value);
}
inline void RotorHGIOConfig::set_gpsupdate(const char* value, size_t size) {
  set_has_gpsupdate();
  if (gpsupdate_ == _default_gpsupdate_) {
    gpsupdate_ = new ::std::string;
  }
  gpsupdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorHGIOConfig::mutable_gpsupdate() {
  set_has_gpsupdate();
  if (gpsupdate_ == _default_gpsupdate_) {
    gpsupdate_ = new ::std::string(*_default_gpsupdate_);
  }
  return gpsupdate_;
}
inline ::std::string* RotorHGIOConfig::release_gpsupdate() {
  clear_has_gpsupdate();
  if (gpsupdate_ == _default_gpsupdate_) {
    return NULL;
  } else {
    ::std::string* temp = gpsupdate_;
    gpsupdate_ = const_cast< ::std::string*>(_default_gpsupdate_);
    return temp;
  }
}
inline void RotorHGIOConfig::set_allocated_gpsupdate(::std::string* gpsupdate) {
  if (gpsupdate_ != _default_gpsupdate_) {
    delete gpsupdate_;
  }
  if (gpsupdate) {
    set_has_gpsupdate();
    gpsupdate_ = gpsupdate;
  } else {
    clear_has_gpsupdate();
    gpsupdate_ = const_cast< ::std::string*>(_default_gpsupdate_);
  }
}

// optional float azCloseEnough = 20 [default = 0.5];
inline bool RotorHGIOConfig::has_azcloseenough() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void RotorHGIOConfig::set_has_azcloseenough() {
  _has_bits_[0] |= 0x00080000u;
}
inline void RotorHGIOConfig::clear_has_azcloseenough() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void RotorHGIOConfig::clear_azcloseenough() {
  azcloseenough_ = 0.5f;
  clear_has_azcloseenough();
}
inline float RotorHGIOConfig::azcloseenough() const {
  return azcloseenough_;
}
inline void RotorHGIOConfig::set_azcloseenough(float value) {
  set_has_azcloseenough();
  azcloseenough_ = value;
}

// optional bool elDisabled = 21 [default = false];
inline bool RotorHGIOConfig::has_eldisabled() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void RotorHGIOConfig::set_has_eldisabled() {
  _has_bits_[0] |= 0x00100000u;
}
inline void RotorHGIOConfig::clear_has_eldisabled() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void RotorHGIOConfig::clear_eldisabled() {
  eldisabled_ = false;
  clear_has_eldisabled();
}
inline bool RotorHGIOConfig::eldisabled() const {
  return eldisabled_;
}
inline void RotorHGIOConfig::set_eldisabled(bool value) {
  set_has_eldisabled();
  eldisabled_ = value;
}

// optional bool slewEnabled = 22 [default = false];
inline bool RotorHGIOConfig::has_slewenabled() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void RotorHGIOConfig::set_has_slewenabled() {
  _has_bits_[0] |= 0x00200000u;
}
inline void RotorHGIOConfig::clear_has_slewenabled() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void RotorHGIOConfig::clear_slewenabled() {
  slewenabled_ = false;
  clear_has_slewenabled();
}
inline bool RotorHGIOConfig::slewenabled() const {
  return slewenabled_;
}
inline void RotorHGIOConfig::set_slewenabled(bool value) {
  set_has_slewenabled();
  slewenabled_ = value;
}

// -------------------------------------------------------------------

// RotorESAConfig

// optional string msgName = 1 [default = "ROTOR_ESA_CONFIG"];
inline bool RotorESAConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RotorESAConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RotorESAConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RotorESAConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& RotorESAConfig::msgname() const {
  return *msgname_;
}
inline void RotorESAConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RotorESAConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RotorESAConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorESAConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* RotorESAConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void RotorESAConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string IP = 2;
inline bool RotorESAConfig::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RotorESAConfig::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RotorESAConfig::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RotorESAConfig::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& RotorESAConfig::ip() const {
  return *ip_;
}
inline void RotorESAConfig::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RotorESAConfig::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RotorESAConfig::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorESAConfig::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* RotorESAConfig::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RotorESAConfig::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 port = 3;
inline bool RotorESAConfig::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RotorESAConfig::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RotorESAConfig::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RotorESAConfig::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 RotorESAConfig::port() const {
  return port_;
}
inline void RotorESAConfig::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// optional float AzOffset = 4;
inline bool RotorESAConfig::has_azoffset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RotorESAConfig::set_has_azoffset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RotorESAConfig::clear_has_azoffset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RotorESAConfig::clear_azoffset() {
  azoffset_ = 0;
  clear_has_azoffset();
}
inline float RotorESAConfig::azoffset() const {
  return azoffset_;
}
inline void RotorESAConfig::set_azoffset(float value) {
  set_has_azoffset();
  azoffset_ = value;
}

// optional bool hardLimit = 5;
inline bool RotorESAConfig::has_hardlimit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RotorESAConfig::set_has_hardlimit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RotorESAConfig::clear_has_hardlimit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RotorESAConfig::clear_hardlimit() {
  hardlimit_ = false;
  clear_has_hardlimit();
}
inline bool RotorESAConfig::hardlimit() const {
  return hardlimit_;
}
inline void RotorESAConfig::set_hardlimit(bool value) {
  set_has_hardlimit();
  hardlimit_ = value;
}

// optional float minScanAngle = 6;
inline bool RotorESAConfig::has_minscanangle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RotorESAConfig::set_has_minscanangle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RotorESAConfig::clear_has_minscanangle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RotorESAConfig::clear_minscanangle() {
  minscanangle_ = 0;
  clear_has_minscanangle();
}
inline float RotorESAConfig::minscanangle() const {
  return minscanangle_;
}
inline void RotorESAConfig::set_minscanangle(float value) {
  set_has_minscanangle();
  minscanangle_ = value;
}

// optional float maxScanAngle = 7;
inline bool RotorESAConfig::has_maxscanangle() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RotorESAConfig::set_has_maxscanangle() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RotorESAConfig::clear_has_maxscanangle() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RotorESAConfig::clear_maxscanangle() {
  maxscanangle_ = 0;
  clear_has_maxscanangle();
}
inline float RotorESAConfig::maxscanangle() const {
  return maxscanangle_;
}
inline void RotorESAConfig::set_maxscanangle(float value) {
  set_has_maxscanangle();
  maxscanangle_ = value;
}

// optional float pointHoldIncrement = 8;
inline bool RotorESAConfig::has_pointholdincrement() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RotorESAConfig::set_has_pointholdincrement() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RotorESAConfig::clear_has_pointholdincrement() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RotorESAConfig::clear_pointholdincrement() {
  pointholdincrement_ = 0;
  clear_has_pointholdincrement();
}
inline float RotorESAConfig::pointholdincrement() const {
  return pointholdincrement_;
}
inline void RotorESAConfig::set_pointholdincrement(float value) {
  set_has_pointholdincrement();
  pointholdincrement_ = value;
}

// optional float energyScanSpeed = 9 [default = 4];
inline bool RotorESAConfig::has_energyscanspeed() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RotorESAConfig::set_has_energyscanspeed() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RotorESAConfig::clear_has_energyscanspeed() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RotorESAConfig::clear_energyscanspeed() {
  energyscanspeed_ = 4;
  clear_has_energyscanspeed();
}
inline float RotorESAConfig::energyscanspeed() const {
  return energyscanspeed_;
}
inline void RotorESAConfig::set_energyscanspeed(float value) {
  set_has_energyscanspeed();
  energyscanspeed_ = value;
}

// optional float startDeviation = 10 [default = 180];
inline bool RotorESAConfig::has_startdeviation() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RotorESAConfig::set_has_startdeviation() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RotorESAConfig::clear_has_startdeviation() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RotorESAConfig::clear_startdeviation() {
  startdeviation_ = 180;
  clear_has_startdeviation();
}
inline float RotorESAConfig::startdeviation() const {
  return startdeviation_;
}
inline void RotorESAConfig::set_startdeviation(float value) {
  set_has_startdeviation();
  startdeviation_ = value;
}

// optional float energyTrackTime = 11 [default = 20];
inline bool RotorESAConfig::has_energytracktime() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RotorESAConfig::set_has_energytracktime() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RotorESAConfig::clear_has_energytracktime() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RotorESAConfig::clear_energytracktime() {
  energytracktime_ = 20;
  clear_has_energytracktime();
}
inline float RotorESAConfig::energytracktime() const {
  return energytracktime_;
}
inline void RotorESAConfig::set_energytracktime(float value) {
  set_has_energytracktime();
  energytracktime_ = value;
}

// optional string scanScrypt = 12 [default = "NONE"];
inline bool RotorESAConfig::has_scanscrypt() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RotorESAConfig::set_has_scanscrypt() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RotorESAConfig::clear_has_scanscrypt() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RotorESAConfig::clear_scanscrypt() {
  if (scanscrypt_ != _default_scanscrypt_) {
    scanscrypt_->assign(*_default_scanscrypt_);
  }
  clear_has_scanscrypt();
}
inline const ::std::string& RotorESAConfig::scanscrypt() const {
  return *scanscrypt_;
}
inline void RotorESAConfig::set_scanscrypt(const ::std::string& value) {
  set_has_scanscrypt();
  if (scanscrypt_ == _default_scanscrypt_) {
    scanscrypt_ = new ::std::string;
  }
  scanscrypt_->assign(value);
}
inline void RotorESAConfig::set_scanscrypt(const char* value) {
  set_has_scanscrypt();
  if (scanscrypt_ == _default_scanscrypt_) {
    scanscrypt_ = new ::std::string;
  }
  scanscrypt_->assign(value);
}
inline void RotorESAConfig::set_scanscrypt(const char* value, size_t size) {
  set_has_scanscrypt();
  if (scanscrypt_ == _default_scanscrypt_) {
    scanscrypt_ = new ::std::string;
  }
  scanscrypt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorESAConfig::mutable_scanscrypt() {
  set_has_scanscrypt();
  if (scanscrypt_ == _default_scanscrypt_) {
    scanscrypt_ = new ::std::string(*_default_scanscrypt_);
  }
  return scanscrypt_;
}
inline ::std::string* RotorESAConfig::release_scanscrypt() {
  clear_has_scanscrypt();
  if (scanscrypt_ == _default_scanscrypt_) {
    return NULL;
  } else {
    ::std::string* temp = scanscrypt_;
    scanscrypt_ = const_cast< ::std::string*>(_default_scanscrypt_);
    return temp;
  }
}
inline void RotorESAConfig::set_allocated_scanscrypt(::std::string* scanscrypt) {
  if (scanscrypt_ != _default_scanscrypt_) {
    delete scanscrypt_;
  }
  if (scanscrypt) {
    set_has_scanscrypt();
    scanscrypt_ = scanscrypt;
  } else {
    clear_has_scanscrypt();
    scanscrypt_ = const_cast< ::std::string*>(_default_scanscrypt_);
  }
}

// optional float azCloseEnough = 13 [default = 0.5];
inline bool RotorESAConfig::has_azcloseenough() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RotorESAConfig::set_has_azcloseenough() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RotorESAConfig::clear_has_azcloseenough() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RotorESAConfig::clear_azcloseenough() {
  azcloseenough_ = 0.5f;
  clear_has_azcloseenough();
}
inline float RotorESAConfig::azcloseenough() const {
  return azcloseenough_;
}
inline void RotorESAConfig::set_azcloseenough(float value) {
  set_has_azcloseenough();
  azcloseenough_ = value;
}

// optional bool elDisabled = 14 [default = true];
inline bool RotorESAConfig::has_eldisabled() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RotorESAConfig::set_has_eldisabled() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RotorESAConfig::clear_has_eldisabled() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RotorESAConfig::clear_eldisabled() {
  eldisabled_ = true;
  clear_has_eldisabled();
}
inline bool RotorESAConfig::eldisabled() const {
  return eldisabled_;
}
inline void RotorESAConfig::set_eldisabled(bool value) {
  set_has_eldisabled();
  eldisabled_ = value;
}

// -------------------------------------------------------------------

// DSSwitchConfig

// optional string msgName = 1 [default = "DSSWITCH_CONFIG"];
inline bool DSSwitchConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DSSwitchConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DSSwitchConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DSSwitchConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& DSSwitchConfig::msgname() const {
  return *msgname_;
}
inline void DSSwitchConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void DSSwitchConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void DSSwitchConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DSSwitchConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* DSSwitchConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void DSSwitchConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string baseURL = 2;
inline bool DSSwitchConfig::has_baseurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DSSwitchConfig::set_has_baseurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DSSwitchConfig::clear_has_baseurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DSSwitchConfig::clear_baseurl() {
  if (baseurl_ != &::google::protobuf::internal::kEmptyString) {
    baseurl_->clear();
  }
  clear_has_baseurl();
}
inline const ::std::string& DSSwitchConfig::baseurl() const {
  return *baseurl_;
}
inline void DSSwitchConfig::set_baseurl(const ::std::string& value) {
  set_has_baseurl();
  if (baseurl_ == &::google::protobuf::internal::kEmptyString) {
    baseurl_ = new ::std::string;
  }
  baseurl_->assign(value);
}
inline void DSSwitchConfig::set_baseurl(const char* value) {
  set_has_baseurl();
  if (baseurl_ == &::google::protobuf::internal::kEmptyString) {
    baseurl_ = new ::std::string;
  }
  baseurl_->assign(value);
}
inline void DSSwitchConfig::set_baseurl(const char* value, size_t size) {
  set_has_baseurl();
  if (baseurl_ == &::google::protobuf::internal::kEmptyString) {
    baseurl_ = new ::std::string;
  }
  baseurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DSSwitchConfig::mutable_baseurl() {
  set_has_baseurl();
  if (baseurl_ == &::google::protobuf::internal::kEmptyString) {
    baseurl_ = new ::std::string;
  }
  return baseurl_;
}
inline ::std::string* DSSwitchConfig::release_baseurl() {
  clear_has_baseurl();
  if (baseurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = baseurl_;
    baseurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DSSwitchConfig::set_allocated_baseurl(::std::string* baseurl) {
  if (baseurl_ != &::google::protobuf::internal::kEmptyString) {
    delete baseurl_;
  }
  if (baseurl) {
    set_has_baseurl();
    baseurl_ = baseurl;
  } else {
    clear_has_baseurl();
    baseurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string inputPath = 3;
inline bool DSSwitchConfig::has_inputpath() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DSSwitchConfig::set_has_inputpath() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DSSwitchConfig::clear_has_inputpath() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DSSwitchConfig::clear_inputpath() {
  if (inputpath_ != &::google::protobuf::internal::kEmptyString) {
    inputpath_->clear();
  }
  clear_has_inputpath();
}
inline const ::std::string& DSSwitchConfig::inputpath() const {
  return *inputpath_;
}
inline void DSSwitchConfig::set_inputpath(const ::std::string& value) {
  set_has_inputpath();
  if (inputpath_ == &::google::protobuf::internal::kEmptyString) {
    inputpath_ = new ::std::string;
  }
  inputpath_->assign(value);
}
inline void DSSwitchConfig::set_inputpath(const char* value) {
  set_has_inputpath();
  if (inputpath_ == &::google::protobuf::internal::kEmptyString) {
    inputpath_ = new ::std::string;
  }
  inputpath_->assign(value);
}
inline void DSSwitchConfig::set_inputpath(const char* value, size_t size) {
  set_has_inputpath();
  if (inputpath_ == &::google::protobuf::internal::kEmptyString) {
    inputpath_ = new ::std::string;
  }
  inputpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DSSwitchConfig::mutable_inputpath() {
  set_has_inputpath();
  if (inputpath_ == &::google::protobuf::internal::kEmptyString) {
    inputpath_ = new ::std::string;
  }
  return inputpath_;
}
inline ::std::string* DSSwitchConfig::release_inputpath() {
  clear_has_inputpath();
  if (inputpath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inputpath_;
    inputpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DSSwitchConfig::set_allocated_inputpath(::std::string* inputpath) {
  if (inputpath_ != &::google::protobuf::internal::kEmptyString) {
    delete inputpath_;
  }
  if (inputpath) {
    set_has_inputpath();
    inputpath_ = inputpath;
  } else {
    clear_has_inputpath();
    inputpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string outputPath = 4;
inline bool DSSwitchConfig::has_outputpath() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DSSwitchConfig::set_has_outputpath() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DSSwitchConfig::clear_has_outputpath() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DSSwitchConfig::clear_outputpath() {
  if (outputpath_ != &::google::protobuf::internal::kEmptyString) {
    outputpath_->clear();
  }
  clear_has_outputpath();
}
inline const ::std::string& DSSwitchConfig::outputpath() const {
  return *outputpath_;
}
inline void DSSwitchConfig::set_outputpath(const ::std::string& value) {
  set_has_outputpath();
  if (outputpath_ == &::google::protobuf::internal::kEmptyString) {
    outputpath_ = new ::std::string;
  }
  outputpath_->assign(value);
}
inline void DSSwitchConfig::set_outputpath(const char* value) {
  set_has_outputpath();
  if (outputpath_ == &::google::protobuf::internal::kEmptyString) {
    outputpath_ = new ::std::string;
  }
  outputpath_->assign(value);
}
inline void DSSwitchConfig::set_outputpath(const char* value, size_t size) {
  set_has_outputpath();
  if (outputpath_ == &::google::protobuf::internal::kEmptyString) {
    outputpath_ = new ::std::string;
  }
  outputpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DSSwitchConfig::mutable_outputpath() {
  set_has_outputpath();
  if (outputpath_ == &::google::protobuf::internal::kEmptyString) {
    outputpath_ = new ::std::string;
  }
  return outputpath_;
}
inline ::std::string* DSSwitchConfig::release_outputpath() {
  clear_has_outputpath();
  if (outputpath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = outputpath_;
    outputpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DSSwitchConfig::set_allocated_outputpath(::std::string* outputpath) {
  if (outputpath_ != &::google::protobuf::internal::kEmptyString) {
    delete outputpath_;
  }
  if (outputpath) {
    set_has_outputpath();
    outputpath_ = outputpath;
  } else {
    clear_has_outputpath();
    outputpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string userName = 5;
inline bool DSSwitchConfig::has_username() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DSSwitchConfig::set_has_username() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DSSwitchConfig::clear_has_username() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DSSwitchConfig::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& DSSwitchConfig::username() const {
  return *username_;
}
inline void DSSwitchConfig::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void DSSwitchConfig::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void DSSwitchConfig::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DSSwitchConfig::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* DSSwitchConfig::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DSSwitchConfig::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 6;
inline bool DSSwitchConfig::has_password() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DSSwitchConfig::set_has_password() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DSSwitchConfig::clear_has_password() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DSSwitchConfig::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& DSSwitchConfig::password() const {
  return *password_;
}
inline void DSSwitchConfig::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void DSSwitchConfig::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void DSSwitchConfig::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DSSwitchConfig::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* DSSwitchConfig::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DSSwitchConfig::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float sleepTime = 7;
inline bool DSSwitchConfig::has_sleeptime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DSSwitchConfig::set_has_sleeptime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DSSwitchConfig::clear_has_sleeptime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DSSwitchConfig::clear_sleeptime() {
  sleeptime_ = 0;
  clear_has_sleeptime();
}
inline float DSSwitchConfig::sleeptime() const {
  return sleeptime_;
}
inline void DSSwitchConfig::set_sleeptime(float value) {
  set_has_sleeptime();
  sleeptime_ = value;
}

// optional int32 slaveTimeout = 8 [default = 180];
inline bool DSSwitchConfig::has_slavetimeout() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DSSwitchConfig::set_has_slavetimeout() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DSSwitchConfig::clear_has_slavetimeout() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DSSwitchConfig::clear_slavetimeout() {
  slavetimeout_ = 180;
  clear_has_slavetimeout();
}
inline ::google::protobuf::int32 DSSwitchConfig::slavetimeout() const {
  return slavetimeout_;
}
inline void DSSwitchConfig::set_slavetimeout(::google::protobuf::int32 value) {
  set_has_slavetimeout();
  slavetimeout_ = value;
}

// optional float energyScanSec = 9 [default = 10];
inline bool DSSwitchConfig::has_energyscansec() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DSSwitchConfig::set_has_energyscansec() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DSSwitchConfig::clear_has_energyscansec() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DSSwitchConfig::clear_energyscansec() {
  energyscansec_ = 10;
  clear_has_energyscansec();
}
inline float DSSwitchConfig::energyscansec() const {
  return energyscansec_;
}
inline void DSSwitchConfig::set_energyscansec(float value) {
  set_has_energyscansec();
  energyscansec_ = value;
}

// optional float energyTrackTime = 10 [default = 300];
inline bool DSSwitchConfig::has_energytracktime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DSSwitchConfig::set_has_energytracktime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DSSwitchConfig::clear_has_energytracktime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DSSwitchConfig::clear_energytracktime() {
  energytracktime_ = 300;
  clear_has_energytracktime();
}
inline float DSSwitchConfig::energytracktime() const {
  return energytracktime_;
}
inline void DSSwitchConfig::set_energytracktime(float value) {
  set_has_energytracktime();
  energytracktime_ = value;
}

// -------------------------------------------------------------------

// DummyConfig

// optional string msgName = 1 [default = "DummyConfig"];
inline bool DummyConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DummyConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DummyConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DummyConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& DummyConfig::msgname() const {
  return *msgname_;
}
inline void DummyConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void DummyConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void DummyConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DummyConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* DummyConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void DummyConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string message = 2;
inline bool DummyConfig::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DummyConfig::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DummyConfig::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DummyConfig::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& DummyConfig::message() const {
  return *message_;
}
inline void DummyConfig::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void DummyConfig::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void DummyConfig::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DummyConfig::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* DummyConfig::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DummyConfig::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MMSXTConfig

// optional string msgName = 1 [default = "MMSXT_CONFIG"];
inline bool MMSXTConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MMSXTConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MMSXTConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MMSXTConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& MMSXTConfig::msgname() const {
  return *msgname_;
}
inline void MMSXTConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void MMSXTConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void MMSXTConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSXTConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* MMSXTConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void MMSXTConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 transmitter = 2;
inline bool MMSXTConfig::has_transmitter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MMSXTConfig::set_has_transmitter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MMSXTConfig::clear_has_transmitter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MMSXTConfig::clear_transmitter() {
  transmitter_ = 0;
  clear_has_transmitter();
}
inline ::google::protobuf::int32 MMSXTConfig::transmitter() const {
  return transmitter_;
}
inline void MMSXTConfig::set_transmitter(::google::protobuf::int32 value) {
  set_has_transmitter();
  transmitter_ = value;
}

// optional string MMSXTCtrlIp = 3;
inline bool MMSXTConfig::has_mmsxtctrlip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MMSXTConfig::set_has_mmsxtctrlip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MMSXTConfig::clear_has_mmsxtctrlip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MMSXTConfig::clear_mmsxtctrlip() {
  if (mmsxtctrlip_ != &::google::protobuf::internal::kEmptyString) {
    mmsxtctrlip_->clear();
  }
  clear_has_mmsxtctrlip();
}
inline const ::std::string& MMSXTConfig::mmsxtctrlip() const {
  return *mmsxtctrlip_;
}
inline void MMSXTConfig::set_mmsxtctrlip(const ::std::string& value) {
  set_has_mmsxtctrlip();
  if (mmsxtctrlip_ == &::google::protobuf::internal::kEmptyString) {
    mmsxtctrlip_ = new ::std::string;
  }
  mmsxtctrlip_->assign(value);
}
inline void MMSXTConfig::set_mmsxtctrlip(const char* value) {
  set_has_mmsxtctrlip();
  if (mmsxtctrlip_ == &::google::protobuf::internal::kEmptyString) {
    mmsxtctrlip_ = new ::std::string;
  }
  mmsxtctrlip_->assign(value);
}
inline void MMSXTConfig::set_mmsxtctrlip(const char* value, size_t size) {
  set_has_mmsxtctrlip();
  if (mmsxtctrlip_ == &::google::protobuf::internal::kEmptyString) {
    mmsxtctrlip_ = new ::std::string;
  }
  mmsxtctrlip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSXTConfig::mutable_mmsxtctrlip() {
  set_has_mmsxtctrlip();
  if (mmsxtctrlip_ == &::google::protobuf::internal::kEmptyString) {
    mmsxtctrlip_ = new ::std::string;
  }
  return mmsxtctrlip_;
}
inline ::std::string* MMSXTConfig::release_mmsxtctrlip() {
  clear_has_mmsxtctrlip();
  if (mmsxtctrlip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mmsxtctrlip_;
    mmsxtctrlip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MMSXTConfig::set_allocated_mmsxtctrlip(::std::string* mmsxtctrlip) {
  if (mmsxtctrlip_ != &::google::protobuf::internal::kEmptyString) {
    delete mmsxtctrlip_;
  }
  if (mmsxtctrlip) {
    set_has_mmsxtctrlip();
    mmsxtctrlip_ = mmsxtctrlip;
  } else {
    clear_has_mmsxtctrlip();
    mmsxtctrlip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 controlPort = 4 [default = 23];
inline bool MMSXTConfig::has_controlport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MMSXTConfig::set_has_controlport() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MMSXTConfig::clear_has_controlport() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MMSXTConfig::clear_controlport() {
  controlport_ = 23;
  clear_has_controlport();
}
inline ::google::protobuf::int32 MMSXTConfig::controlport() const {
  return controlport_;
}
inline void MMSXTConfig::set_controlport(::google::protobuf::int32 value) {
  set_has_controlport();
  controlport_ = value;
}

// optional string MMSXTDataIp = 5;
inline bool MMSXTConfig::has_mmsxtdataip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MMSXTConfig::set_has_mmsxtdataip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MMSXTConfig::clear_has_mmsxtdataip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MMSXTConfig::clear_mmsxtdataip() {
  if (mmsxtdataip_ != &::google::protobuf::internal::kEmptyString) {
    mmsxtdataip_->clear();
  }
  clear_has_mmsxtdataip();
}
inline const ::std::string& MMSXTConfig::mmsxtdataip() const {
  return *mmsxtdataip_;
}
inline void MMSXTConfig::set_mmsxtdataip(const ::std::string& value) {
  set_has_mmsxtdataip();
  if (mmsxtdataip_ == &::google::protobuf::internal::kEmptyString) {
    mmsxtdataip_ = new ::std::string;
  }
  mmsxtdataip_->assign(value);
}
inline void MMSXTConfig::set_mmsxtdataip(const char* value) {
  set_has_mmsxtdataip();
  if (mmsxtdataip_ == &::google::protobuf::internal::kEmptyString) {
    mmsxtdataip_ = new ::std::string;
  }
  mmsxtdataip_->assign(value);
}
inline void MMSXTConfig::set_mmsxtdataip(const char* value, size_t size) {
  set_has_mmsxtdataip();
  if (mmsxtdataip_ == &::google::protobuf::internal::kEmptyString) {
    mmsxtdataip_ = new ::std::string;
  }
  mmsxtdataip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSXTConfig::mutable_mmsxtdataip() {
  set_has_mmsxtdataip();
  if (mmsxtdataip_ == &::google::protobuf::internal::kEmptyString) {
    mmsxtdataip_ = new ::std::string;
  }
  return mmsxtdataip_;
}
inline ::std::string* MMSXTConfig::release_mmsxtdataip() {
  clear_has_mmsxtdataip();
  if (mmsxtdataip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mmsxtdataip_;
    mmsxtdataip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MMSXTConfig::set_allocated_mmsxtdataip(::std::string* mmsxtdataip) {
  if (mmsxtdataip_ != &::google::protobuf::internal::kEmptyString) {
    delete mmsxtdataip_;
  }
  if (mmsxtdataip) {
    set_has_mmsxtdataip();
    mmsxtdataip_ = mmsxtdataip;
  } else {
    clear_has_mmsxtdataip();
    mmsxtdataip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 dataPort = 6 [default = 49300];
inline bool MMSXTConfig::has_dataport() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MMSXTConfig::set_has_dataport() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MMSXTConfig::clear_has_dataport() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MMSXTConfig::clear_dataport() {
  dataport_ = 49300;
  clear_has_dataport();
}
inline ::google::protobuf::int32 MMSXTConfig::dataport() const {
  return dataport_;
}
inline void MMSXTConfig::set_dataport(::google::protobuf::int32 value) {
  set_has_dataport();
  dataport_ = value;
}

// optional string uniqTXID = 7 [default = "999"];
inline bool MMSXTConfig::has_uniqtxid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MMSXTConfig::set_has_uniqtxid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MMSXTConfig::clear_has_uniqtxid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MMSXTConfig::clear_uniqtxid() {
  if (uniqtxid_ != _default_uniqtxid_) {
    uniqtxid_->assign(*_default_uniqtxid_);
  }
  clear_has_uniqtxid();
}
inline const ::std::string& MMSXTConfig::uniqtxid() const {
  return *uniqtxid_;
}
inline void MMSXTConfig::set_uniqtxid(const ::std::string& value) {
  set_has_uniqtxid();
  if (uniqtxid_ == _default_uniqtxid_) {
    uniqtxid_ = new ::std::string;
  }
  uniqtxid_->assign(value);
}
inline void MMSXTConfig::set_uniqtxid(const char* value) {
  set_has_uniqtxid();
  if (uniqtxid_ == _default_uniqtxid_) {
    uniqtxid_ = new ::std::string;
  }
  uniqtxid_->assign(value);
}
inline void MMSXTConfig::set_uniqtxid(const char* value, size_t size) {
  set_has_uniqtxid();
  if (uniqtxid_ == _default_uniqtxid_) {
    uniqtxid_ = new ::std::string;
  }
  uniqtxid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSXTConfig::mutable_uniqtxid() {
  set_has_uniqtxid();
  if (uniqtxid_ == _default_uniqtxid_) {
    uniqtxid_ = new ::std::string(*_default_uniqtxid_);
  }
  return uniqtxid_;
}
inline ::std::string* MMSXTConfig::release_uniqtxid() {
  clear_has_uniqtxid();
  if (uniqtxid_ == _default_uniqtxid_) {
    return NULL;
  } else {
    ::std::string* temp = uniqtxid_;
    uniqtxid_ = const_cast< ::std::string*>(_default_uniqtxid_);
    return temp;
  }
}
inline void MMSXTConfig::set_allocated_uniqtxid(::std::string* uniqtxid) {
  if (uniqtxid_ != _default_uniqtxid_) {
    delete uniqtxid_;
  }
  if (uniqtxid) {
    set_has_uniqtxid();
    uniqtxid_ = uniqtxid;
  } else {
    clear_has_uniqtxid();
    uniqtxid_ = const_cast< ::std::string*>(_default_uniqtxid_);
  }
}

// optional int32 txcuPort = 8 [default = -1];
inline bool MMSXTConfig::has_txcuport() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MMSXTConfig::set_has_txcuport() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MMSXTConfig::clear_has_txcuport() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MMSXTConfig::clear_txcuport() {
  txcuport_ = -1;
  clear_has_txcuport();
}
inline ::google::protobuf::int32 MMSXTConfig::txcuport() const {
  return txcuport_;
}
inline void MMSXTConfig::set_txcuport(::google::protobuf::int32 value) {
  set_has_txcuport();
  txcuport_ = value;
}

// optional string txcuIP = 9 [default = ""];
inline bool MMSXTConfig::has_txcuip() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MMSXTConfig::set_has_txcuip() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MMSXTConfig::clear_has_txcuip() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MMSXTConfig::clear_txcuip() {
  if (txcuip_ != &::google::protobuf::internal::kEmptyString) {
    txcuip_->clear();
  }
  clear_has_txcuip();
}
inline const ::std::string& MMSXTConfig::txcuip() const {
  return *txcuip_;
}
inline void MMSXTConfig::set_txcuip(const ::std::string& value) {
  set_has_txcuip();
  if (txcuip_ == &::google::protobuf::internal::kEmptyString) {
    txcuip_ = new ::std::string;
  }
  txcuip_->assign(value);
}
inline void MMSXTConfig::set_txcuip(const char* value) {
  set_has_txcuip();
  if (txcuip_ == &::google::protobuf::internal::kEmptyString) {
    txcuip_ = new ::std::string;
  }
  txcuip_->assign(value);
}
inline void MMSXTConfig::set_txcuip(const char* value, size_t size) {
  set_has_txcuip();
  if (txcuip_ == &::google::protobuf::internal::kEmptyString) {
    txcuip_ = new ::std::string;
  }
  txcuip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MMSXTConfig::mutable_txcuip() {
  set_has_txcuip();
  if (txcuip_ == &::google::protobuf::internal::kEmptyString) {
    txcuip_ = new ::std::string;
  }
  return txcuip_;
}
inline ::std::string* MMSXTConfig::release_txcuip() {
  clear_has_txcuip();
  if (txcuip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txcuip_;
    txcuip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MMSXTConfig::set_allocated_txcuip(::std::string* txcuip) {
  if (txcuip_ != &::google::protobuf::internal::kEmptyString) {
    delete txcuip_;
  }
  if (txcuip) {
    set_has_txcuip();
    txcuip_ = txcuip;
  } else {
    clear_has_txcuip();
    txcuip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AmpConfig

// optional string msgName = 1 [default = "AMP_CONFIG"];
inline bool AmpConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AmpConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AmpConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AmpConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& AmpConfig::msgname() const {
  return *msgname_;
}
inline void AmpConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AmpConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AmpConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AmpConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* AmpConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void AmpConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string IP = 2 [default = "nportserver"];
inline bool AmpConfig::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AmpConfig::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AmpConfig::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AmpConfig::clear_ip() {
  if (ip_ != _default_ip_) {
    ip_->assign(*_default_ip_);
  }
  clear_has_ip();
}
inline const ::std::string& AmpConfig::ip() const {
  return *ip_;
}
inline void AmpConfig::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == _default_ip_) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void AmpConfig::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == _default_ip_) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void AmpConfig::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == _default_ip_) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AmpConfig::mutable_ip() {
  set_has_ip();
  if (ip_ == _default_ip_) {
    ip_ = new ::std::string(*_default_ip_);
  }
  return ip_;
}
inline ::std::string* AmpConfig::release_ip() {
  clear_has_ip();
  if (ip_ == _default_ip_) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(_default_ip_);
    return temp;
  }
}
inline void AmpConfig::set_allocated_ip(::std::string* ip) {
  if (ip_ != _default_ip_) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(_default_ip_);
  }
}

// optional int32 port = 3 [default = 4012];
inline bool AmpConfig::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AmpConfig::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AmpConfig::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AmpConfig::clear_port() {
  port_ = 4012;
  clear_has_port();
}
inline ::google::protobuf::int32 AmpConfig::port() const {
  return port_;
}
inline void AmpConfig::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// optional bool hardware = 4;
inline bool AmpConfig::has_hardware() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AmpConfig::set_has_hardware() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AmpConfig::clear_has_hardware() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AmpConfig::clear_hardware() {
  hardware_ = false;
  clear_has_hardware();
}
inline bool AmpConfig::hardware() const {
  return hardware_;
}
inline void AmpConfig::set_hardware(bool value) {
  set_has_hardware();
  hardware_ = value;
}

// optional int32 init_atten = 5;
inline bool AmpConfig::has_init_atten() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AmpConfig::set_has_init_atten() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AmpConfig::clear_has_init_atten() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AmpConfig::clear_init_atten() {
  init_atten_ = 0;
  clear_has_init_atten();
}
inline ::google::protobuf::int32 AmpConfig::init_atten() const {
  return init_atten_;
}
inline void AmpConfig::set_init_atten(::google::protobuf::int32 value) {
  set_has_init_atten();
  init_atten_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace falcon_res_msg

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_res_msg::PentekConfig_SiggenType>() {
  return ::falcon_res_msg::PentekConfig_SiggenType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_FalconResourceMessages_2eproto__INCLUDED
