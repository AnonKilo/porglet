// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GalileoMessages.proto

#ifndef PROTOBUF_GalileoMessages_2eproto__INCLUDED
#define PROTOBUF_GalileoMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace galileo_msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_GalileoMessages_2eproto();
void protobuf_AssignDesc_GalileoMessages_2eproto();
void protobuf_ShutdownFile_GalileoMessages_2eproto();

class Cluster;
class ProcessorResults;
class ClusterMapping;
class AggregatorResults;
class LearnEmitter;
class AggregatorStatus;
class AggregatorClear;

// ===================================================================

class Cluster : public ::google::protobuf::Message {
 public:
  Cluster();
  virtual ~Cluster();

  Cluster(const Cluster& from);

  inline Cluster& operator=(const Cluster& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Cluster& default_instance();

  void Swap(Cluster* other);

  // implements Message ----------------------------------------------

  Cluster* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Cluster& from);
  void MergeFrom(const Cluster& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "CLUSTER"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 incomingCID = 2;
  inline bool has_incomingcid() const;
  inline void clear_incomingcid();
  static const int kIncomingCIDFieldNumber = 2;
  inline ::google::protobuf::int32 incomingcid() const;
  inline void set_incomingcid(::google::protobuf::int32 value);

  // optional int32 label = 3;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 3;
  inline ::google::protobuf::int32 label() const;
  inline void set_label(::google::protobuf::int32 value);

  // repeated int32 indices = 4;
  inline int indices_size() const;
  inline void clear_indices();
  static const int kIndicesFieldNumber = 4;
  inline ::google::protobuf::int32 indices(int index) const;
  inline void set_indices(int index, ::google::protobuf::int32 value);
  inline void add_indices(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      indices() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_indices();

  // @@protoc_insertion_point(class_scope:galileo_msg.Cluster)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_incomingcid();
  inline void clear_has_incomingcid();
  inline void set_has_label();
  inline void clear_has_label();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 incomingcid_;
  ::google::protobuf::int32 label_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > indices_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_GalileoMessages_2eproto();
  friend void protobuf_AssignDesc_GalileoMessages_2eproto();
  friend void protobuf_ShutdownFile_GalileoMessages_2eproto();

  void InitAsDefaultInstance();
  static Cluster* default_instance_;
};
// -------------------------------------------------------------------

class ProcessorResults : public ::google::protobuf::Message {
 public:
  ProcessorResults();
  virtual ~ProcessorResults();

  ProcessorResults(const ProcessorResults& from);

  inline ProcessorResults& operator=(const ProcessorResults& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessorResults& default_instance();

  void Swap(ProcessorResults* other);

  // implements Message ----------------------------------------------

  ProcessorResults* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcessorResults& from);
  void MergeFrom(const ProcessorResults& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "PROCESSOR_RESULTS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string procInstanceID = 2;
  inline bool has_procinstanceid() const;
  inline void clear_procinstanceid();
  static const int kProcInstanceIDFieldNumber = 2;
  inline const ::std::string& procinstanceid() const;
  inline void set_procinstanceid(const ::std::string& value);
  inline void set_procinstanceid(const char* value);
  inline void set_procinstanceid(const char* value, size_t size);
  inline ::std::string* mutable_procinstanceid();
  inline ::std::string* release_procinstanceid();
  inline void set_allocated_procinstanceid(::std::string* procinstanceid);

  // optional string metaFile = 3;
  inline bool has_metafile() const;
  inline void clear_metafile();
  static const int kMetaFileFieldNumber = 3;
  inline const ::std::string& metafile() const;
  inline void set_metafile(const ::std::string& value);
  inline void set_metafile(const char* value);
  inline void set_metafile(const char* value, size_t size);
  inline ::std::string* mutable_metafile();
  inline ::std::string* release_metafile();
  inline void set_allocated_metafile(::std::string* metafile);

  // optional string IQIndexFile = 4;
  inline bool has_iqindexfile() const;
  inline void clear_iqindexfile();
  static const int kIQIndexFileFieldNumber = 4;
  inline const ::std::string& iqindexfile() const;
  inline void set_iqindexfile(const ::std::string& value);
  inline void set_iqindexfile(const char* value);
  inline void set_iqindexfile(const char* value, size_t size);
  inline ::std::string* mutable_iqindexfile();
  inline ::std::string* release_iqindexfile();
  inline void set_allocated_iqindexfile(::std::string* iqindexfile);

  // optional string subGraphFile = 5;
  inline bool has_subgraphfile() const;
  inline void clear_subgraphfile();
  static const int kSubGraphFileFieldNumber = 5;
  inline const ::std::string& subgraphfile() const;
  inline void set_subgraphfile(const ::std::string& value);
  inline void set_subgraphfile(const char* value);
  inline void set_subgraphfile(const char* value, size_t size);
  inline ::std::string* mutable_subgraphfile();
  inline ::std::string* release_subgraphfile();
  inline void set_allocated_subgraphfile(::std::string* subgraphfile);

  // repeated .galileo_msg.Cluster incomingClusters = 6;
  inline int incomingclusters_size() const;
  inline void clear_incomingclusters();
  static const int kIncomingClustersFieldNumber = 6;
  inline const ::galileo_msg::Cluster& incomingclusters(int index) const;
  inline ::galileo_msg::Cluster* mutable_incomingclusters(int index);
  inline ::galileo_msg::Cluster* add_incomingclusters();
  inline const ::google::protobuf::RepeatedPtrField< ::galileo_msg::Cluster >&
      incomingclusters() const;
  inline ::google::protobuf::RepeatedPtrField< ::galileo_msg::Cluster >*
      mutable_incomingclusters();

  // optional bool cycloDisabled = 7;
  inline bool has_cyclodisabled() const;
  inline void clear_cyclodisabled();
  static const int kCycloDisabledFieldNumber = 7;
  inline bool cyclodisabled() const;
  inline void set_cyclodisabled(bool value);

  // optional double timeRes = 8;
  inline bool has_timeres() const;
  inline void clear_timeres();
  static const int kTimeResFieldNumber = 8;
  inline double timeres() const;
  inline void set_timeres(double value);

  // optional double freqRes = 9;
  inline bool has_freqres() const;
  inline void clear_freqres();
  static const int kFreqResFieldNumber = 9;
  inline double freqres() const;
  inline void set_freqres(double value);

  // optional string segmenterName = 10;
  inline bool has_segmentername() const;
  inline void clear_segmentername();
  static const int kSegmenterNameFieldNumber = 10;
  inline const ::std::string& segmentername() const;
  inline void set_segmentername(const ::std::string& value);
  inline void set_segmentername(const char* value);
  inline void set_segmentername(const char* value, size_t size);
  inline ::std::string* mutable_segmentername();
  inline ::std::string* release_segmentername();
  inline void set_allocated_segmentername(::std::string* segmentername);

  // @@protoc_insertion_point(class_scope:galileo_msg.ProcessorResults)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_procinstanceid();
  inline void clear_has_procinstanceid();
  inline void set_has_metafile();
  inline void clear_has_metafile();
  inline void set_has_iqindexfile();
  inline void clear_has_iqindexfile();
  inline void set_has_subgraphfile();
  inline void clear_has_subgraphfile();
  inline void set_has_cyclodisabled();
  inline void clear_has_cyclodisabled();
  inline void set_has_timeres();
  inline void clear_has_timeres();
  inline void set_has_freqres();
  inline void clear_has_freqres();
  inline void set_has_segmentername();
  inline void clear_has_segmentername();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* procinstanceid_;
  ::std::string* metafile_;
  ::std::string* iqindexfile_;
  ::std::string* subgraphfile_;
  ::google::protobuf::RepeatedPtrField< ::galileo_msg::Cluster > incomingclusters_;
  double timeres_;
  double freqres_;
  ::std::string* segmentername_;
  bool cyclodisabled_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_GalileoMessages_2eproto();
  friend void protobuf_AssignDesc_GalileoMessages_2eproto();
  friend void protobuf_ShutdownFile_GalileoMessages_2eproto();

  void InitAsDefaultInstance();
  static ProcessorResults* default_instance_;
};
// -------------------------------------------------------------------

class ClusterMapping : public ::google::protobuf::Message {
 public:
  ClusterMapping();
  virtual ~ClusterMapping();

  ClusterMapping(const ClusterMapping& from);

  inline ClusterMapping& operator=(const ClusterMapping& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClusterMapping& default_instance();

  void Swap(ClusterMapping* other);

  // implements Message ----------------------------------------------

  ClusterMapping* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClusterMapping& from);
  void MergeFrom(const ClusterMapping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "CLUSTER_MAPPING"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 incomingCID = 2 [default = 0];
  inline bool has_incomingcid() const;
  inline void clear_incomingcid();
  static const int kIncomingCIDFieldNumber = 2;
  inline ::google::protobuf::int32 incomingcid() const;
  inline void set_incomingcid(::google::protobuf::int32 value);

  // optional string clusterID = 3 [default = ""];
  inline bool has_clusterid() const;
  inline void clear_clusterid();
  static const int kClusterIDFieldNumber = 3;
  inline const ::std::string& clusterid() const;
  inline void set_clusterid(const ::std::string& value);
  inline void set_clusterid(const char* value);
  inline void set_clusterid(const char* value, size_t size);
  inline ::std::string* mutable_clusterid();
  inline ::std::string* release_clusterid();
  inline void set_allocated_clusterid(::std::string* clusterid);

  // optional bool newCluster = 4 [default = false];
  inline bool has_newcluster() const;
  inline void clear_newcluster();
  static const int kNewClusterFieldNumber = 4;
  inline bool newcluster() const;
  inline void set_newcluster(bool value);

  // @@protoc_insertion_point(class_scope:galileo_msg.ClusterMapping)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_incomingcid();
  inline void clear_has_incomingcid();
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  inline void set_has_newcluster();
  inline void clear_has_newcluster();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* clusterid_;
  ::google::protobuf::int32 incomingcid_;
  bool newcluster_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_GalileoMessages_2eproto();
  friend void protobuf_AssignDesc_GalileoMessages_2eproto();
  friend void protobuf_ShutdownFile_GalileoMessages_2eproto();

  void InitAsDefaultInstance();
  static ClusterMapping* default_instance_;
};
// -------------------------------------------------------------------

class AggregatorResults : public ::google::protobuf::Message {
 public:
  AggregatorResults();
  virtual ~AggregatorResults();

  AggregatorResults(const AggregatorResults& from);

  inline AggregatorResults& operator=(const AggregatorResults& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AggregatorResults& default_instance();

  void Swap(AggregatorResults* other);

  // implements Message ----------------------------------------------

  AggregatorResults* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AggregatorResults& from);
  void MergeFrom(const AggregatorResults& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "AGGREGATOR_RESULTS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // repeated .galileo_msg.ClusterMapping clusterMap = 2;
  inline int clustermap_size() const;
  inline void clear_clustermap();
  static const int kClusterMapFieldNumber = 2;
  inline const ::galileo_msg::ClusterMapping& clustermap(int index) const;
  inline ::galileo_msg::ClusterMapping* mutable_clustermap(int index);
  inline ::galileo_msg::ClusterMapping* add_clustermap();
  inline const ::google::protobuf::RepeatedPtrField< ::galileo_msg::ClusterMapping >&
      clustermap() const;
  inline ::google::protobuf::RepeatedPtrField< ::galileo_msg::ClusterMapping >*
      mutable_clustermap();

  // optional string procInstanceID = 3;
  inline bool has_procinstanceid() const;
  inline void clear_procinstanceid();
  static const int kProcInstanceIDFieldNumber = 3;
  inline const ::std::string& procinstanceid() const;
  inline void set_procinstanceid(const ::std::string& value);
  inline void set_procinstanceid(const char* value);
  inline void set_procinstanceid(const char* value, size_t size);
  inline ::std::string* mutable_procinstanceid();
  inline ::std::string* release_procinstanceid();
  inline void set_allocated_procinstanceid(::std::string* procinstanceid);

  // @@protoc_insertion_point(class_scope:galileo_msg.AggregatorResults)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_procinstanceid();
  inline void clear_has_procinstanceid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::RepeatedPtrField< ::galileo_msg::ClusterMapping > clustermap_;
  ::std::string* procinstanceid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_GalileoMessages_2eproto();
  friend void protobuf_AssignDesc_GalileoMessages_2eproto();
  friend void protobuf_ShutdownFile_GalileoMessages_2eproto();

  void InitAsDefaultInstance();
  static AggregatorResults* default_instance_;
};
// -------------------------------------------------------------------

class LearnEmitter : public ::google::protobuf::Message {
 public:
  LearnEmitter();
  virtual ~LearnEmitter();

  LearnEmitter(const LearnEmitter& from);

  inline LearnEmitter& operator=(const LearnEmitter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LearnEmitter& default_instance();

  void Swap(LearnEmitter* other);

  // implements Message ----------------------------------------------

  LearnEmitter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LearnEmitter& from);
  void MergeFrom(const LearnEmitter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "LEARN_EMITTER"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string clusterID = 2 [default = ""];
  inline bool has_clusterid() const;
  inline void clear_clusterid();
  static const int kClusterIDFieldNumber = 2;
  inline const ::std::string& clusterid() const;
  inline void set_clusterid(const ::std::string& value);
  inline void set_clusterid(const char* value);
  inline void set_clusterid(const char* value, size_t size);
  inline ::std::string* mutable_clusterid();
  inline ::std::string* release_clusterid();
  inline void set_allocated_clusterid(::std::string* clusterid);

  // optional string emitterName = 3 [default = "DEFAULT"];
  inline bool has_emittername() const;
  inline void clear_emittername();
  static const int kEmitterNameFieldNumber = 3;
  inline const ::std::string& emittername() const;
  inline void set_emittername(const ::std::string& value);
  inline void set_emittername(const char* value);
  inline void set_emittername(const char* value, size_t size);
  inline ::std::string* mutable_emittername();
  inline ::std::string* release_emittername();
  inline void set_allocated_emittername(::std::string* emittername);

  // optional string designation = 4 [default = "gray"];
  inline bool has_designation() const;
  inline void clear_designation();
  static const int kDesignationFieldNumber = 4;
  inline const ::std::string& designation() const;
  inline void set_designation(const ::std::string& value);
  inline void set_designation(const char* value);
  inline void set_designation(const char* value, size_t size);
  inline ::std::string* mutable_designation();
  inline ::std::string* release_designation();
  inline void set_allocated_designation(::std::string* designation);

  // @@protoc_insertion_point(class_scope:galileo_msg.LearnEmitter)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  inline void set_has_emittername();
  inline void clear_has_emittername();
  inline void set_has_designation();
  inline void clear_has_designation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* clusterid_;
  ::std::string* emittername_;
  static ::std::string* _default_emittername_;
  ::std::string* designation_;
  static ::std::string* _default_designation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_GalileoMessages_2eproto();
  friend void protobuf_AssignDesc_GalileoMessages_2eproto();
  friend void protobuf_ShutdownFile_GalileoMessages_2eproto();

  void InitAsDefaultInstance();
  static LearnEmitter* default_instance_;
};
// -------------------------------------------------------------------

class AggregatorStatus : public ::google::protobuf::Message {
 public:
  AggregatorStatus();
  virtual ~AggregatorStatus();

  AggregatorStatus(const AggregatorStatus& from);

  inline AggregatorStatus& operator=(const AggregatorStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AggregatorStatus& default_instance();

  void Swap(AggregatorStatus* other);

  // implements Message ----------------------------------------------

  AggregatorStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AggregatorStatus& from);
  void MergeFrom(const AggregatorStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "AGGREGATOR_STATUS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional bool shouldExit = 2;
  inline bool has_shouldexit() const;
  inline void clear_shouldexit();
  static const int kShouldExitFieldNumber = 2;
  inline bool shouldexit() const;
  inline void set_shouldexit(bool value);

  // optional bool exited = 3;
  inline bool has_exited() const;
  inline void clear_exited();
  static const int kExitedFieldNumber = 3;
  inline bool exited() const;
  inline void set_exited(bool value);

  // @@protoc_insertion_point(class_scope:galileo_msg.AggregatorStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_shouldexit();
  inline void clear_has_shouldexit();
  inline void set_has_exited();
  inline void clear_has_exited();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  bool shouldexit_;
  bool exited_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_GalileoMessages_2eproto();
  friend void protobuf_AssignDesc_GalileoMessages_2eproto();
  friend void protobuf_ShutdownFile_GalileoMessages_2eproto();

  void InitAsDefaultInstance();
  static AggregatorStatus* default_instance_;
};
// -------------------------------------------------------------------

class AggregatorClear : public ::google::protobuf::Message {
 public:
  AggregatorClear();
  virtual ~AggregatorClear();

  AggregatorClear(const AggregatorClear& from);

  inline AggregatorClear& operator=(const AggregatorClear& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AggregatorClear& default_instance();

  void Swap(AggregatorClear* other);

  // implements Message ----------------------------------------------

  AggregatorClear* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AggregatorClear& from);
  void MergeFrom(const AggregatorClear& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "AGGREGATOR_CLEAR"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional bool shouldClear = 2;
  inline bool has_shouldclear() const;
  inline void clear_shouldclear();
  static const int kShouldClearFieldNumber = 2;
  inline bool shouldclear() const;
  inline void set_shouldclear(bool value);

  // optional bool cleared = 3;
  inline bool has_cleared() const;
  inline void clear_cleared();
  static const int kClearedFieldNumber = 3;
  inline bool cleared() const;
  inline void set_cleared(bool value);

  // @@protoc_insertion_point(class_scope:galileo_msg.AggregatorClear)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_shouldclear();
  inline void clear_has_shouldclear();
  inline void set_has_cleared();
  inline void clear_has_cleared();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  bool shouldclear_;
  bool cleared_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_GalileoMessages_2eproto();
  friend void protobuf_AssignDesc_GalileoMessages_2eproto();
  friend void protobuf_ShutdownFile_GalileoMessages_2eproto();

  void InitAsDefaultInstance();
  static AggregatorClear* default_instance_;
};
// ===================================================================


// ===================================================================

// Cluster

// optional string msgName = 1 [default = "CLUSTER"];
inline bool Cluster::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Cluster::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Cluster::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Cluster::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& Cluster::msgname() const {
  return *msgname_;
}
inline void Cluster::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void Cluster::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void Cluster::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Cluster::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* Cluster::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void Cluster::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 incomingCID = 2;
inline bool Cluster::has_incomingcid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Cluster::set_has_incomingcid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Cluster::clear_has_incomingcid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Cluster::clear_incomingcid() {
  incomingcid_ = 0;
  clear_has_incomingcid();
}
inline ::google::protobuf::int32 Cluster::incomingcid() const {
  return incomingcid_;
}
inline void Cluster::set_incomingcid(::google::protobuf::int32 value) {
  set_has_incomingcid();
  incomingcid_ = value;
}

// optional int32 label = 3;
inline bool Cluster::has_label() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Cluster::set_has_label() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Cluster::clear_has_label() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Cluster::clear_label() {
  label_ = 0;
  clear_has_label();
}
inline ::google::protobuf::int32 Cluster::label() const {
  return label_;
}
inline void Cluster::set_label(::google::protobuf::int32 value) {
  set_has_label();
  label_ = value;
}

// repeated int32 indices = 4;
inline int Cluster::indices_size() const {
  return indices_.size();
}
inline void Cluster::clear_indices() {
  indices_.Clear();
}
inline ::google::protobuf::int32 Cluster::indices(int index) const {
  return indices_.Get(index);
}
inline void Cluster::set_indices(int index, ::google::protobuf::int32 value) {
  indices_.Set(index, value);
}
inline void Cluster::add_indices(::google::protobuf::int32 value) {
  indices_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Cluster::indices() const {
  return indices_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Cluster::mutable_indices() {
  return &indices_;
}

// -------------------------------------------------------------------

// ProcessorResults

// optional string msgName = 1 [default = "PROCESSOR_RESULTS"];
inline bool ProcessorResults::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProcessorResults::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProcessorResults::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProcessorResults::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ProcessorResults::msgname() const {
  return *msgname_;
}
inline void ProcessorResults::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ProcessorResults::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ProcessorResults::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessorResults::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ProcessorResults::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ProcessorResults::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string procInstanceID = 2;
inline bool ProcessorResults::has_procinstanceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProcessorResults::set_has_procinstanceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProcessorResults::clear_has_procinstanceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProcessorResults::clear_procinstanceid() {
  if (procinstanceid_ != &::google::protobuf::internal::kEmptyString) {
    procinstanceid_->clear();
  }
  clear_has_procinstanceid();
}
inline const ::std::string& ProcessorResults::procinstanceid() const {
  return *procinstanceid_;
}
inline void ProcessorResults::set_procinstanceid(const ::std::string& value) {
  set_has_procinstanceid();
  if (procinstanceid_ == &::google::protobuf::internal::kEmptyString) {
    procinstanceid_ = new ::std::string;
  }
  procinstanceid_->assign(value);
}
inline void ProcessorResults::set_procinstanceid(const char* value) {
  set_has_procinstanceid();
  if (procinstanceid_ == &::google::protobuf::internal::kEmptyString) {
    procinstanceid_ = new ::std::string;
  }
  procinstanceid_->assign(value);
}
inline void ProcessorResults::set_procinstanceid(const char* value, size_t size) {
  set_has_procinstanceid();
  if (procinstanceid_ == &::google::protobuf::internal::kEmptyString) {
    procinstanceid_ = new ::std::string;
  }
  procinstanceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessorResults::mutable_procinstanceid() {
  set_has_procinstanceid();
  if (procinstanceid_ == &::google::protobuf::internal::kEmptyString) {
    procinstanceid_ = new ::std::string;
  }
  return procinstanceid_;
}
inline ::std::string* ProcessorResults::release_procinstanceid() {
  clear_has_procinstanceid();
  if (procinstanceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = procinstanceid_;
    procinstanceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProcessorResults::set_allocated_procinstanceid(::std::string* procinstanceid) {
  if (procinstanceid_ != &::google::protobuf::internal::kEmptyString) {
    delete procinstanceid_;
  }
  if (procinstanceid) {
    set_has_procinstanceid();
    procinstanceid_ = procinstanceid;
  } else {
    clear_has_procinstanceid();
    procinstanceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string metaFile = 3;
inline bool ProcessorResults::has_metafile() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProcessorResults::set_has_metafile() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProcessorResults::clear_has_metafile() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProcessorResults::clear_metafile() {
  if (metafile_ != &::google::protobuf::internal::kEmptyString) {
    metafile_->clear();
  }
  clear_has_metafile();
}
inline const ::std::string& ProcessorResults::metafile() const {
  return *metafile_;
}
inline void ProcessorResults::set_metafile(const ::std::string& value) {
  set_has_metafile();
  if (metafile_ == &::google::protobuf::internal::kEmptyString) {
    metafile_ = new ::std::string;
  }
  metafile_->assign(value);
}
inline void ProcessorResults::set_metafile(const char* value) {
  set_has_metafile();
  if (metafile_ == &::google::protobuf::internal::kEmptyString) {
    metafile_ = new ::std::string;
  }
  metafile_->assign(value);
}
inline void ProcessorResults::set_metafile(const char* value, size_t size) {
  set_has_metafile();
  if (metafile_ == &::google::protobuf::internal::kEmptyString) {
    metafile_ = new ::std::string;
  }
  metafile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessorResults::mutable_metafile() {
  set_has_metafile();
  if (metafile_ == &::google::protobuf::internal::kEmptyString) {
    metafile_ = new ::std::string;
  }
  return metafile_;
}
inline ::std::string* ProcessorResults::release_metafile() {
  clear_has_metafile();
  if (metafile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = metafile_;
    metafile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProcessorResults::set_allocated_metafile(::std::string* metafile) {
  if (metafile_ != &::google::protobuf::internal::kEmptyString) {
    delete metafile_;
  }
  if (metafile) {
    set_has_metafile();
    metafile_ = metafile;
  } else {
    clear_has_metafile();
    metafile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string IQIndexFile = 4;
inline bool ProcessorResults::has_iqindexfile() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProcessorResults::set_has_iqindexfile() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProcessorResults::clear_has_iqindexfile() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProcessorResults::clear_iqindexfile() {
  if (iqindexfile_ != &::google::protobuf::internal::kEmptyString) {
    iqindexfile_->clear();
  }
  clear_has_iqindexfile();
}
inline const ::std::string& ProcessorResults::iqindexfile() const {
  return *iqindexfile_;
}
inline void ProcessorResults::set_iqindexfile(const ::std::string& value) {
  set_has_iqindexfile();
  if (iqindexfile_ == &::google::protobuf::internal::kEmptyString) {
    iqindexfile_ = new ::std::string;
  }
  iqindexfile_->assign(value);
}
inline void ProcessorResults::set_iqindexfile(const char* value) {
  set_has_iqindexfile();
  if (iqindexfile_ == &::google::protobuf::internal::kEmptyString) {
    iqindexfile_ = new ::std::string;
  }
  iqindexfile_->assign(value);
}
inline void ProcessorResults::set_iqindexfile(const char* value, size_t size) {
  set_has_iqindexfile();
  if (iqindexfile_ == &::google::protobuf::internal::kEmptyString) {
    iqindexfile_ = new ::std::string;
  }
  iqindexfile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessorResults::mutable_iqindexfile() {
  set_has_iqindexfile();
  if (iqindexfile_ == &::google::protobuf::internal::kEmptyString) {
    iqindexfile_ = new ::std::string;
  }
  return iqindexfile_;
}
inline ::std::string* ProcessorResults::release_iqindexfile() {
  clear_has_iqindexfile();
  if (iqindexfile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = iqindexfile_;
    iqindexfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProcessorResults::set_allocated_iqindexfile(::std::string* iqindexfile) {
  if (iqindexfile_ != &::google::protobuf::internal::kEmptyString) {
    delete iqindexfile_;
  }
  if (iqindexfile) {
    set_has_iqindexfile();
    iqindexfile_ = iqindexfile;
  } else {
    clear_has_iqindexfile();
    iqindexfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string subGraphFile = 5;
inline bool ProcessorResults::has_subgraphfile() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProcessorResults::set_has_subgraphfile() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProcessorResults::clear_has_subgraphfile() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProcessorResults::clear_subgraphfile() {
  if (subgraphfile_ != &::google::protobuf::internal::kEmptyString) {
    subgraphfile_->clear();
  }
  clear_has_subgraphfile();
}
inline const ::std::string& ProcessorResults::subgraphfile() const {
  return *subgraphfile_;
}
inline void ProcessorResults::set_subgraphfile(const ::std::string& value) {
  set_has_subgraphfile();
  if (subgraphfile_ == &::google::protobuf::internal::kEmptyString) {
    subgraphfile_ = new ::std::string;
  }
  subgraphfile_->assign(value);
}
inline void ProcessorResults::set_subgraphfile(const char* value) {
  set_has_subgraphfile();
  if (subgraphfile_ == &::google::protobuf::internal::kEmptyString) {
    subgraphfile_ = new ::std::string;
  }
  subgraphfile_->assign(value);
}
inline void ProcessorResults::set_subgraphfile(const char* value, size_t size) {
  set_has_subgraphfile();
  if (subgraphfile_ == &::google::protobuf::internal::kEmptyString) {
    subgraphfile_ = new ::std::string;
  }
  subgraphfile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessorResults::mutable_subgraphfile() {
  set_has_subgraphfile();
  if (subgraphfile_ == &::google::protobuf::internal::kEmptyString) {
    subgraphfile_ = new ::std::string;
  }
  return subgraphfile_;
}
inline ::std::string* ProcessorResults::release_subgraphfile() {
  clear_has_subgraphfile();
  if (subgraphfile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subgraphfile_;
    subgraphfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProcessorResults::set_allocated_subgraphfile(::std::string* subgraphfile) {
  if (subgraphfile_ != &::google::protobuf::internal::kEmptyString) {
    delete subgraphfile_;
  }
  if (subgraphfile) {
    set_has_subgraphfile();
    subgraphfile_ = subgraphfile;
  } else {
    clear_has_subgraphfile();
    subgraphfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .galileo_msg.Cluster incomingClusters = 6;
inline int ProcessorResults::incomingclusters_size() const {
  return incomingclusters_.size();
}
inline void ProcessorResults::clear_incomingclusters() {
  incomingclusters_.Clear();
}
inline const ::galileo_msg::Cluster& ProcessorResults::incomingclusters(int index) const {
  return incomingclusters_.Get(index);
}
inline ::galileo_msg::Cluster* ProcessorResults::mutable_incomingclusters(int index) {
  return incomingclusters_.Mutable(index);
}
inline ::galileo_msg::Cluster* ProcessorResults::add_incomingclusters() {
  return incomingclusters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::galileo_msg::Cluster >&
ProcessorResults::incomingclusters() const {
  return incomingclusters_;
}
inline ::google::protobuf::RepeatedPtrField< ::galileo_msg::Cluster >*
ProcessorResults::mutable_incomingclusters() {
  return &incomingclusters_;
}

// optional bool cycloDisabled = 7;
inline bool ProcessorResults::has_cyclodisabled() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ProcessorResults::set_has_cyclodisabled() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ProcessorResults::clear_has_cyclodisabled() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ProcessorResults::clear_cyclodisabled() {
  cyclodisabled_ = false;
  clear_has_cyclodisabled();
}
inline bool ProcessorResults::cyclodisabled() const {
  return cyclodisabled_;
}
inline void ProcessorResults::set_cyclodisabled(bool value) {
  set_has_cyclodisabled();
  cyclodisabled_ = value;
}

// optional double timeRes = 8;
inline bool ProcessorResults::has_timeres() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ProcessorResults::set_has_timeres() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ProcessorResults::clear_has_timeres() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ProcessorResults::clear_timeres() {
  timeres_ = 0;
  clear_has_timeres();
}
inline double ProcessorResults::timeres() const {
  return timeres_;
}
inline void ProcessorResults::set_timeres(double value) {
  set_has_timeres();
  timeres_ = value;
}

// optional double freqRes = 9;
inline bool ProcessorResults::has_freqres() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ProcessorResults::set_has_freqres() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ProcessorResults::clear_has_freqres() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ProcessorResults::clear_freqres() {
  freqres_ = 0;
  clear_has_freqres();
}
inline double ProcessorResults::freqres() const {
  return freqres_;
}
inline void ProcessorResults::set_freqres(double value) {
  set_has_freqres();
  freqres_ = value;
}

// optional string segmenterName = 10;
inline bool ProcessorResults::has_segmentername() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ProcessorResults::set_has_segmentername() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ProcessorResults::clear_has_segmentername() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ProcessorResults::clear_segmentername() {
  if (segmentername_ != &::google::protobuf::internal::kEmptyString) {
    segmentername_->clear();
  }
  clear_has_segmentername();
}
inline const ::std::string& ProcessorResults::segmentername() const {
  return *segmentername_;
}
inline void ProcessorResults::set_segmentername(const ::std::string& value) {
  set_has_segmentername();
  if (segmentername_ == &::google::protobuf::internal::kEmptyString) {
    segmentername_ = new ::std::string;
  }
  segmentername_->assign(value);
}
inline void ProcessorResults::set_segmentername(const char* value) {
  set_has_segmentername();
  if (segmentername_ == &::google::protobuf::internal::kEmptyString) {
    segmentername_ = new ::std::string;
  }
  segmentername_->assign(value);
}
inline void ProcessorResults::set_segmentername(const char* value, size_t size) {
  set_has_segmentername();
  if (segmentername_ == &::google::protobuf::internal::kEmptyString) {
    segmentername_ = new ::std::string;
  }
  segmentername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessorResults::mutable_segmentername() {
  set_has_segmentername();
  if (segmentername_ == &::google::protobuf::internal::kEmptyString) {
    segmentername_ = new ::std::string;
  }
  return segmentername_;
}
inline ::std::string* ProcessorResults::release_segmentername() {
  clear_has_segmentername();
  if (segmentername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = segmentername_;
    segmentername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProcessorResults::set_allocated_segmentername(::std::string* segmentername) {
  if (segmentername_ != &::google::protobuf::internal::kEmptyString) {
    delete segmentername_;
  }
  if (segmentername) {
    set_has_segmentername();
    segmentername_ = segmentername;
  } else {
    clear_has_segmentername();
    segmentername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClusterMapping

// optional string msgName = 1 [default = "CLUSTER_MAPPING"];
inline bool ClusterMapping::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClusterMapping::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClusterMapping::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClusterMapping::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ClusterMapping::msgname() const {
  return *msgname_;
}
inline void ClusterMapping::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ClusterMapping::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ClusterMapping::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClusterMapping::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ClusterMapping::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ClusterMapping::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 incomingCID = 2 [default = 0];
inline bool ClusterMapping::has_incomingcid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClusterMapping::set_has_incomingcid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClusterMapping::clear_has_incomingcid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClusterMapping::clear_incomingcid() {
  incomingcid_ = 0;
  clear_has_incomingcid();
}
inline ::google::protobuf::int32 ClusterMapping::incomingcid() const {
  return incomingcid_;
}
inline void ClusterMapping::set_incomingcid(::google::protobuf::int32 value) {
  set_has_incomingcid();
  incomingcid_ = value;
}

// optional string clusterID = 3 [default = ""];
inline bool ClusterMapping::has_clusterid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClusterMapping::set_has_clusterid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClusterMapping::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClusterMapping::clear_clusterid() {
  if (clusterid_ != &::google::protobuf::internal::kEmptyString) {
    clusterid_->clear();
  }
  clear_has_clusterid();
}
inline const ::std::string& ClusterMapping::clusterid() const {
  return *clusterid_;
}
inline void ClusterMapping::set_clusterid(const ::std::string& value) {
  set_has_clusterid();
  if (clusterid_ == &::google::protobuf::internal::kEmptyString) {
    clusterid_ = new ::std::string;
  }
  clusterid_->assign(value);
}
inline void ClusterMapping::set_clusterid(const char* value) {
  set_has_clusterid();
  if (clusterid_ == &::google::protobuf::internal::kEmptyString) {
    clusterid_ = new ::std::string;
  }
  clusterid_->assign(value);
}
inline void ClusterMapping::set_clusterid(const char* value, size_t size) {
  set_has_clusterid();
  if (clusterid_ == &::google::protobuf::internal::kEmptyString) {
    clusterid_ = new ::std::string;
  }
  clusterid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClusterMapping::mutable_clusterid() {
  set_has_clusterid();
  if (clusterid_ == &::google::protobuf::internal::kEmptyString) {
    clusterid_ = new ::std::string;
  }
  return clusterid_;
}
inline ::std::string* ClusterMapping::release_clusterid() {
  clear_has_clusterid();
  if (clusterid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clusterid_;
    clusterid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClusterMapping::set_allocated_clusterid(::std::string* clusterid) {
  if (clusterid_ != &::google::protobuf::internal::kEmptyString) {
    delete clusterid_;
  }
  if (clusterid) {
    set_has_clusterid();
    clusterid_ = clusterid;
  } else {
    clear_has_clusterid();
    clusterid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool newCluster = 4 [default = false];
inline bool ClusterMapping::has_newcluster() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClusterMapping::set_has_newcluster() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClusterMapping::clear_has_newcluster() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClusterMapping::clear_newcluster() {
  newcluster_ = false;
  clear_has_newcluster();
}
inline bool ClusterMapping::newcluster() const {
  return newcluster_;
}
inline void ClusterMapping::set_newcluster(bool value) {
  set_has_newcluster();
  newcluster_ = value;
}

// -------------------------------------------------------------------

// AggregatorResults

// optional string msgName = 1 [default = "AGGREGATOR_RESULTS"];
inline bool AggregatorResults::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AggregatorResults::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AggregatorResults::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AggregatorResults::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& AggregatorResults::msgname() const {
  return *msgname_;
}
inline void AggregatorResults::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AggregatorResults::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AggregatorResults::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AggregatorResults::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* AggregatorResults::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void AggregatorResults::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// repeated .galileo_msg.ClusterMapping clusterMap = 2;
inline int AggregatorResults::clustermap_size() const {
  return clustermap_.size();
}
inline void AggregatorResults::clear_clustermap() {
  clustermap_.Clear();
}
inline const ::galileo_msg::ClusterMapping& AggregatorResults::clustermap(int index) const {
  return clustermap_.Get(index);
}
inline ::galileo_msg::ClusterMapping* AggregatorResults::mutable_clustermap(int index) {
  return clustermap_.Mutable(index);
}
inline ::galileo_msg::ClusterMapping* AggregatorResults::add_clustermap() {
  return clustermap_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::galileo_msg::ClusterMapping >&
AggregatorResults::clustermap() const {
  return clustermap_;
}
inline ::google::protobuf::RepeatedPtrField< ::galileo_msg::ClusterMapping >*
AggregatorResults::mutable_clustermap() {
  return &clustermap_;
}

// optional string procInstanceID = 3;
inline bool AggregatorResults::has_procinstanceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AggregatorResults::set_has_procinstanceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AggregatorResults::clear_has_procinstanceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AggregatorResults::clear_procinstanceid() {
  if (procinstanceid_ != &::google::protobuf::internal::kEmptyString) {
    procinstanceid_->clear();
  }
  clear_has_procinstanceid();
}
inline const ::std::string& AggregatorResults::procinstanceid() const {
  return *procinstanceid_;
}
inline void AggregatorResults::set_procinstanceid(const ::std::string& value) {
  set_has_procinstanceid();
  if (procinstanceid_ == &::google::protobuf::internal::kEmptyString) {
    procinstanceid_ = new ::std::string;
  }
  procinstanceid_->assign(value);
}
inline void AggregatorResults::set_procinstanceid(const char* value) {
  set_has_procinstanceid();
  if (procinstanceid_ == &::google::protobuf::internal::kEmptyString) {
    procinstanceid_ = new ::std::string;
  }
  procinstanceid_->assign(value);
}
inline void AggregatorResults::set_procinstanceid(const char* value, size_t size) {
  set_has_procinstanceid();
  if (procinstanceid_ == &::google::protobuf::internal::kEmptyString) {
    procinstanceid_ = new ::std::string;
  }
  procinstanceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AggregatorResults::mutable_procinstanceid() {
  set_has_procinstanceid();
  if (procinstanceid_ == &::google::protobuf::internal::kEmptyString) {
    procinstanceid_ = new ::std::string;
  }
  return procinstanceid_;
}
inline ::std::string* AggregatorResults::release_procinstanceid() {
  clear_has_procinstanceid();
  if (procinstanceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = procinstanceid_;
    procinstanceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AggregatorResults::set_allocated_procinstanceid(::std::string* procinstanceid) {
  if (procinstanceid_ != &::google::protobuf::internal::kEmptyString) {
    delete procinstanceid_;
  }
  if (procinstanceid) {
    set_has_procinstanceid();
    procinstanceid_ = procinstanceid;
  } else {
    clear_has_procinstanceid();
    procinstanceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LearnEmitter

// optional string msgName = 1 [default = "LEARN_EMITTER"];
inline bool LearnEmitter::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LearnEmitter::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LearnEmitter::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LearnEmitter::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& LearnEmitter::msgname() const {
  return *msgname_;
}
inline void LearnEmitter::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void LearnEmitter::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void LearnEmitter::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LearnEmitter::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* LearnEmitter::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void LearnEmitter::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string clusterID = 2 [default = ""];
inline bool LearnEmitter::has_clusterid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LearnEmitter::set_has_clusterid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LearnEmitter::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LearnEmitter::clear_clusterid() {
  if (clusterid_ != &::google::protobuf::internal::kEmptyString) {
    clusterid_->clear();
  }
  clear_has_clusterid();
}
inline const ::std::string& LearnEmitter::clusterid() const {
  return *clusterid_;
}
inline void LearnEmitter::set_clusterid(const ::std::string& value) {
  set_has_clusterid();
  if (clusterid_ == &::google::protobuf::internal::kEmptyString) {
    clusterid_ = new ::std::string;
  }
  clusterid_->assign(value);
}
inline void LearnEmitter::set_clusterid(const char* value) {
  set_has_clusterid();
  if (clusterid_ == &::google::protobuf::internal::kEmptyString) {
    clusterid_ = new ::std::string;
  }
  clusterid_->assign(value);
}
inline void LearnEmitter::set_clusterid(const char* value, size_t size) {
  set_has_clusterid();
  if (clusterid_ == &::google::protobuf::internal::kEmptyString) {
    clusterid_ = new ::std::string;
  }
  clusterid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LearnEmitter::mutable_clusterid() {
  set_has_clusterid();
  if (clusterid_ == &::google::protobuf::internal::kEmptyString) {
    clusterid_ = new ::std::string;
  }
  return clusterid_;
}
inline ::std::string* LearnEmitter::release_clusterid() {
  clear_has_clusterid();
  if (clusterid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clusterid_;
    clusterid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LearnEmitter::set_allocated_clusterid(::std::string* clusterid) {
  if (clusterid_ != &::google::protobuf::internal::kEmptyString) {
    delete clusterid_;
  }
  if (clusterid) {
    set_has_clusterid();
    clusterid_ = clusterid;
  } else {
    clear_has_clusterid();
    clusterid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string emitterName = 3 [default = "DEFAULT"];
inline bool LearnEmitter::has_emittername() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LearnEmitter::set_has_emittername() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LearnEmitter::clear_has_emittername() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LearnEmitter::clear_emittername() {
  if (emittername_ != _default_emittername_) {
    emittername_->assign(*_default_emittername_);
  }
  clear_has_emittername();
}
inline const ::std::string& LearnEmitter::emittername() const {
  return *emittername_;
}
inline void LearnEmitter::set_emittername(const ::std::string& value) {
  set_has_emittername();
  if (emittername_ == _default_emittername_) {
    emittername_ = new ::std::string;
  }
  emittername_->assign(value);
}
inline void LearnEmitter::set_emittername(const char* value) {
  set_has_emittername();
  if (emittername_ == _default_emittername_) {
    emittername_ = new ::std::string;
  }
  emittername_->assign(value);
}
inline void LearnEmitter::set_emittername(const char* value, size_t size) {
  set_has_emittername();
  if (emittername_ == _default_emittername_) {
    emittername_ = new ::std::string;
  }
  emittername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LearnEmitter::mutable_emittername() {
  set_has_emittername();
  if (emittername_ == _default_emittername_) {
    emittername_ = new ::std::string(*_default_emittername_);
  }
  return emittername_;
}
inline ::std::string* LearnEmitter::release_emittername() {
  clear_has_emittername();
  if (emittername_ == _default_emittername_) {
    return NULL;
  } else {
    ::std::string* temp = emittername_;
    emittername_ = const_cast< ::std::string*>(_default_emittername_);
    return temp;
  }
}
inline void LearnEmitter::set_allocated_emittername(::std::string* emittername) {
  if (emittername_ != _default_emittername_) {
    delete emittername_;
  }
  if (emittername) {
    set_has_emittername();
    emittername_ = emittername;
  } else {
    clear_has_emittername();
    emittername_ = const_cast< ::std::string*>(_default_emittername_);
  }
}

// optional string designation = 4 [default = "gray"];
inline bool LearnEmitter::has_designation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LearnEmitter::set_has_designation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LearnEmitter::clear_has_designation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LearnEmitter::clear_designation() {
  if (designation_ != _default_designation_) {
    designation_->assign(*_default_designation_);
  }
  clear_has_designation();
}
inline const ::std::string& LearnEmitter::designation() const {
  return *designation_;
}
inline void LearnEmitter::set_designation(const ::std::string& value) {
  set_has_designation();
  if (designation_ == _default_designation_) {
    designation_ = new ::std::string;
  }
  designation_->assign(value);
}
inline void LearnEmitter::set_designation(const char* value) {
  set_has_designation();
  if (designation_ == _default_designation_) {
    designation_ = new ::std::string;
  }
  designation_->assign(value);
}
inline void LearnEmitter::set_designation(const char* value, size_t size) {
  set_has_designation();
  if (designation_ == _default_designation_) {
    designation_ = new ::std::string;
  }
  designation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LearnEmitter::mutable_designation() {
  set_has_designation();
  if (designation_ == _default_designation_) {
    designation_ = new ::std::string(*_default_designation_);
  }
  return designation_;
}
inline ::std::string* LearnEmitter::release_designation() {
  clear_has_designation();
  if (designation_ == _default_designation_) {
    return NULL;
  } else {
    ::std::string* temp = designation_;
    designation_ = const_cast< ::std::string*>(_default_designation_);
    return temp;
  }
}
inline void LearnEmitter::set_allocated_designation(::std::string* designation) {
  if (designation_ != _default_designation_) {
    delete designation_;
  }
  if (designation) {
    set_has_designation();
    designation_ = designation;
  } else {
    clear_has_designation();
    designation_ = const_cast< ::std::string*>(_default_designation_);
  }
}

// -------------------------------------------------------------------

// AggregatorStatus

// optional string msgName = 1 [default = "AGGREGATOR_STATUS"];
inline bool AggregatorStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AggregatorStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AggregatorStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AggregatorStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& AggregatorStatus::msgname() const {
  return *msgname_;
}
inline void AggregatorStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AggregatorStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AggregatorStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AggregatorStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* AggregatorStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void AggregatorStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional bool shouldExit = 2;
inline bool AggregatorStatus::has_shouldexit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AggregatorStatus::set_has_shouldexit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AggregatorStatus::clear_has_shouldexit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AggregatorStatus::clear_shouldexit() {
  shouldexit_ = false;
  clear_has_shouldexit();
}
inline bool AggregatorStatus::shouldexit() const {
  return shouldexit_;
}
inline void AggregatorStatus::set_shouldexit(bool value) {
  set_has_shouldexit();
  shouldexit_ = value;
}

// optional bool exited = 3;
inline bool AggregatorStatus::has_exited() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AggregatorStatus::set_has_exited() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AggregatorStatus::clear_has_exited() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AggregatorStatus::clear_exited() {
  exited_ = false;
  clear_has_exited();
}
inline bool AggregatorStatus::exited() const {
  return exited_;
}
inline void AggregatorStatus::set_exited(bool value) {
  set_has_exited();
  exited_ = value;
}

// -------------------------------------------------------------------

// AggregatorClear

// optional string msgName = 1 [default = "AGGREGATOR_CLEAR"];
inline bool AggregatorClear::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AggregatorClear::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AggregatorClear::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AggregatorClear::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& AggregatorClear::msgname() const {
  return *msgname_;
}
inline void AggregatorClear::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AggregatorClear::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AggregatorClear::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AggregatorClear::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* AggregatorClear::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void AggregatorClear::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional bool shouldClear = 2;
inline bool AggregatorClear::has_shouldclear() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AggregatorClear::set_has_shouldclear() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AggregatorClear::clear_has_shouldclear() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AggregatorClear::clear_shouldclear() {
  shouldclear_ = false;
  clear_has_shouldclear();
}
inline bool AggregatorClear::shouldclear() const {
  return shouldclear_;
}
inline void AggregatorClear::set_shouldclear(bool value) {
  set_has_shouldclear();
  shouldclear_ = value;
}

// optional bool cleared = 3;
inline bool AggregatorClear::has_cleared() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AggregatorClear::set_has_cleared() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AggregatorClear::clear_has_cleared() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AggregatorClear::clear_cleared() {
  cleared_ = false;
  clear_has_cleared();
}
inline bool AggregatorClear::cleared() const {
  return cleared_;
}
inline void AggregatorClear::set_cleared(bool value) {
  set_has_cleared();
  cleared_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace galileo_msg

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_GalileoMessages_2eproto__INCLUDED
