// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ThunderbirdMessages.proto

#ifndef PROTOBUF_ThunderbirdMessages_2eproto__INCLUDED
#define PROTOBUF_ThunderbirdMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "FalconCommonMessages.pb.h"
// @@protoc_insertion_point(includes)

namespace fv {
namespace tb {
namespace protos {
namespace TBProtos {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

class CloseSelf;
class EWCommandRequest;
class Parameters;
class EWStatus;
class OutputChannelStatus;
class EWTransmittingRequest;
class EWCapabilityUnregister;
class EWCapability;
class EWCapabilities;
class EWCapabilityTransmitting;
class EWTransmitting;
class EWTechniqueDescriptions;
class EWTechniqueDescriptionsRequest;
class EWOption;
class EWOptions;
class EWOptionsRequest;
class EWStatusRequest;
class EWCapabilitiesRequest;
class EWOptionDelete;
class EWCeaseBuzzer;
class TxAntennaConfig;
class TxAmpConfig;
class TransmitterConfig;
class techniqueCommand;
class newSignalFrame;
class RegisterQuery;
class RegisterRequest;
class UnregisterRequest;
class RegisterResponse;
class HopAttackStatus;
class TxFreqRequest;
class EmergencyJam;
class JamOff;
class EWSDRRequest;
class EWSDRCommand;
class Aperture;
class Transceiver;
class ThreatStatus;
class EWSDRStatus;
class SetAppParameters;
class MissionMode;
class SignalEvent;
class TxSignalParams;
class TxFileStatus;
class CalibrationTimingResult;

enum OutputChannelStatus_TransmitState {
  OutputChannelStatus_TransmitState_READY = 0,
  OutputChannelStatus_TransmitState_NOT_READY = 1,
  OutputChannelStatus_TransmitState_ACTIVE = 2
};
bool OutputChannelStatus_TransmitState_IsValid(int value);
const OutputChannelStatus_TransmitState OutputChannelStatus_TransmitState_TransmitState_MIN = OutputChannelStatus_TransmitState_READY;
const OutputChannelStatus_TransmitState OutputChannelStatus_TransmitState_TransmitState_MAX = OutputChannelStatus_TransmitState_ACTIVE;
const int OutputChannelStatus_TransmitState_TransmitState_ARRAYSIZE = OutputChannelStatus_TransmitState_TransmitState_MAX + 1;

const ::google::protobuf::EnumDescriptor* OutputChannelStatus_TransmitState_descriptor();
inline const ::std::string& OutputChannelStatus_TransmitState_Name(OutputChannelStatus_TransmitState value) {
  return ::google::protobuf::internal::NameOfEnum(
    OutputChannelStatus_TransmitState_descriptor(), value);
}
inline bool OutputChannelStatus_TransmitState_Parse(
    const ::std::string& name, OutputChannelStatus_TransmitState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OutputChannelStatus_TransmitState>(
    OutputChannelStatus_TransmitState_descriptor(), name, value);
}
enum EWCapability_DetectionSource {
  EWCapability_DetectionSource_EXTERNALS = 0,
  EWCapability_DetectionSource_INTERNALS = 1,
  EWCapability_DetectionSource_SIGUP = 2,
  EWCapability_DetectionSource_THUNDERBIRD = 3
};
bool EWCapability_DetectionSource_IsValid(int value);
const EWCapability_DetectionSource EWCapability_DetectionSource_DetectionSource_MIN = EWCapability_DetectionSource_EXTERNALS;
const EWCapability_DetectionSource EWCapability_DetectionSource_DetectionSource_MAX = EWCapability_DetectionSource_THUNDERBIRD;
const int EWCapability_DetectionSource_DetectionSource_ARRAYSIZE = EWCapability_DetectionSource_DetectionSource_MAX + 1;

const ::google::protobuf::EnumDescriptor* EWCapability_DetectionSource_descriptor();
inline const ::std::string& EWCapability_DetectionSource_Name(EWCapability_DetectionSource value) {
  return ::google::protobuf::internal::NameOfEnum(
    EWCapability_DetectionSource_descriptor(), value);
}
inline bool EWCapability_DetectionSource_Parse(
    const ::std::string& name, EWCapability_DetectionSource* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EWCapability_DetectionSource>(
    EWCapability_DetectionSource_descriptor(), name, value);
}
enum EWOption_DetectionSource {
  EWOption_DetectionSource_EXTERNALS = 0,
  EWOption_DetectionSource_INTERNALS = 1,
  EWOption_DetectionSource_SIGUP = 2,
  EWOption_DetectionSource_THUNDERBIRD = 3
};
bool EWOption_DetectionSource_IsValid(int value);
const EWOption_DetectionSource EWOption_DetectionSource_DetectionSource_MIN = EWOption_DetectionSource_EXTERNALS;
const EWOption_DetectionSource EWOption_DetectionSource_DetectionSource_MAX = EWOption_DetectionSource_THUNDERBIRD;
const int EWOption_DetectionSource_DetectionSource_ARRAYSIZE = EWOption_DetectionSource_DetectionSource_MAX + 1;

const ::google::protobuf::EnumDescriptor* EWOption_DetectionSource_descriptor();
inline const ::std::string& EWOption_DetectionSource_Name(EWOption_DetectionSource value) {
  return ::google::protobuf::internal::NameOfEnum(
    EWOption_DetectionSource_descriptor(), value);
}
inline bool EWOption_DetectionSource_Parse(
    const ::std::string& name, EWOption_DetectionSource* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EWOption_DetectionSource>(
    EWOption_DetectionSource_descriptor(), name, value);
}
enum TransmitterConfig_SiggenType {
  TransmitterConfig_SiggenType_ROHDE_SCHWARZ = 0,
  TransmitterConfig_SiggenType_MMS_MUP = 1
};
bool TransmitterConfig_SiggenType_IsValid(int value);
const TransmitterConfig_SiggenType TransmitterConfig_SiggenType_SiggenType_MIN = TransmitterConfig_SiggenType_ROHDE_SCHWARZ;
const TransmitterConfig_SiggenType TransmitterConfig_SiggenType_SiggenType_MAX = TransmitterConfig_SiggenType_MMS_MUP;
const int TransmitterConfig_SiggenType_SiggenType_ARRAYSIZE = TransmitterConfig_SiggenType_SiggenType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TransmitterConfig_SiggenType_descriptor();
inline const ::std::string& TransmitterConfig_SiggenType_Name(TransmitterConfig_SiggenType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TransmitterConfig_SiggenType_descriptor(), value);
}
inline bool TransmitterConfig_SiggenType_Parse(
    const ::std::string& name, TransmitterConfig_SiggenType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TransmitterConfig_SiggenType>(
    TransmitterConfig_SiggenType_descriptor(), name, value);
}
enum techniqueCommand_CommandType {
  techniqueCommand_CommandType_TURNOFF = 0,
  techniqueCommand_CommandType_TURNON = 1,
  techniqueCommand_CommandType_UPDATE = 2,
  techniqueCommand_CommandType_RESET = 3
};
bool techniqueCommand_CommandType_IsValid(int value);
const techniqueCommand_CommandType techniqueCommand_CommandType_CommandType_MIN = techniqueCommand_CommandType_TURNOFF;
const techniqueCommand_CommandType techniqueCommand_CommandType_CommandType_MAX = techniqueCommand_CommandType_RESET;
const int techniqueCommand_CommandType_CommandType_ARRAYSIZE = techniqueCommand_CommandType_CommandType_MAX + 1;

const ::google::protobuf::EnumDescriptor* techniqueCommand_CommandType_descriptor();
inline const ::std::string& techniqueCommand_CommandType_Name(techniqueCommand_CommandType value) {
  return ::google::protobuf::internal::NameOfEnum(
    techniqueCommand_CommandType_descriptor(), value);
}
inline bool techniqueCommand_CommandType_Parse(
    const ::std::string& name, techniqueCommand_CommandType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<techniqueCommand_CommandType>(
    techniqueCommand_CommandType_descriptor(), name, value);
}
enum MissionMode_Mode {
  MissionMode_Mode_SEARCH = 1,
  MissionMode_Mode_AUTO = 2,
  MissionMode_Mode_TRACE = 3
};
bool MissionMode_Mode_IsValid(int value);
const MissionMode_Mode MissionMode_Mode_Mode_MIN = MissionMode_Mode_SEARCH;
const MissionMode_Mode MissionMode_Mode_Mode_MAX = MissionMode_Mode_TRACE;
const int MissionMode_Mode_Mode_ARRAYSIZE = MissionMode_Mode_Mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* MissionMode_Mode_descriptor();
inline const ::std::string& MissionMode_Mode_Name(MissionMode_Mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    MissionMode_Mode_descriptor(), value);
}
inline bool MissionMode_Mode_Parse(
    const ::std::string& name, MissionMode_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MissionMode_Mode>(
    MissionMode_Mode_descriptor(), name, value);
}
enum SignalEvent_Type {
  SignalEvent_Type_SIGDET = 0,
  SignalEvent_Type_SIGUP = 1,
  SignalEvent_Type_SIGDOWN = 2,
  SignalEvent_Type_SIGTIMEOUT = 3
};
bool SignalEvent_Type_IsValid(int value);
const SignalEvent_Type SignalEvent_Type_Type_MIN = SignalEvent_Type_SIGDET;
const SignalEvent_Type SignalEvent_Type_Type_MAX = SignalEvent_Type_SIGTIMEOUT;
const int SignalEvent_Type_Type_ARRAYSIZE = SignalEvent_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* SignalEvent_Type_descriptor();
inline const ::std::string& SignalEvent_Type_Name(SignalEvent_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    SignalEvent_Type_descriptor(), value);
}
inline bool SignalEvent_Type_Parse(
    const ::std::string& name, SignalEvent_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SignalEvent_Type>(
    SignalEvent_Type_descriptor(), name, value);
}
// ===================================================================

class CloseSelf : public ::google::protobuf::Message {
 public:
  CloseSelf();
  virtual ~CloseSelf();

  CloseSelf(const CloseSelf& from);

  inline CloseSelf& operator=(const CloseSelf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseSelf& default_instance();

  void Swap(CloseSelf* other);

  // implements Message ----------------------------------------------

  CloseSelf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CloseSelf& from);
  void MergeFrom(const CloseSelf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "CLOSESELF"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string uniqueWord = 2;
  inline bool has_uniqueword() const;
  inline void clear_uniqueword();
  static const int kUniqueWordFieldNumber = 2;
  inline const ::std::string& uniqueword() const;
  inline void set_uniqueword(const ::std::string& value);
  inline void set_uniqueword(const char* value);
  inline void set_uniqueword(const char* value, size_t size);
  inline ::std::string* mutable_uniqueword();
  inline ::std::string* release_uniqueword();
  inline void set_allocated_uniqueword(::std::string* uniqueword);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.CloseSelf)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_uniqueword();
  inline void clear_has_uniqueword();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* uniqueword_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static CloseSelf* default_instance_;
};
// -------------------------------------------------------------------

class EWCommandRequest : public ::google::protobuf::Message {
 public:
  EWCommandRequest();
  virtual ~EWCommandRequest();

  EWCommandRequest(const EWCommandRequest& from);

  inline EWCommandRequest& operator=(const EWCommandRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EWCommandRequest& default_instance();

  void Swap(EWCommandRequest* other);

  // implements Message ----------------------------------------------

  EWCommandRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EWCommandRequest& from);
  void MergeFrom(const EWCommandRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EW_COMMAND_REQUEST"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional .fv.tb.protos.TBProtos.EWCapability ewcap = 2;
  inline bool has_ewcap() const;
  inline void clear_ewcap();
  static const int kEwcapFieldNumber = 2;
  inline const ::fv::tb::protos::TBProtos::EWCapability& ewcap() const;
  inline ::fv::tb::protos::TBProtos::EWCapability* mutable_ewcap();
  inline ::fv::tb::protos::TBProtos::EWCapability* release_ewcap();
  inline void set_allocated_ewcap(::fv::tb::protos::TBProtos::EWCapability* ewcap);

  // optional bool active = 3;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 3;
  inline bool active() const;
  inline void set_active(bool value);

  // optional string sensorName = 4 [default = ""];
  inline bool has_sensorname() const;
  inline void clear_sensorname();
  static const int kSensorNameFieldNumber = 4;
  inline const ::std::string& sensorname() const;
  inline void set_sensorname(const ::std::string& value);
  inline void set_sensorname(const char* value);
  inline void set_sensorname(const char* value, size_t size);
  inline ::std::string* mutable_sensorname();
  inline ::std::string* release_sensorname();
  inline void set_allocated_sensorname(::std::string* sensorname);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.EWCommandRequest)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_ewcap();
  inline void clear_has_ewcap();
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_sensorname();
  inline void clear_has_sensorname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::fv::tb::protos::TBProtos::EWCapability* ewcap_;
  ::std::string* sensorname_;
  bool active_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static EWCommandRequest* default_instance_;
};
// -------------------------------------------------------------------

class Parameters : public ::google::protobuf::Message {
 public:
  Parameters();
  virtual ~Parameters();

  Parameters(const Parameters& from);

  inline Parameters& operator=(const Parameters& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Parameters& default_instance();

  void Swap(Parameters* other);

  // implements Message ----------------------------------------------

  Parameters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parameters& from);
  void MergeFrom(const Parameters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EW_PARAMETER"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional float jamCFMHz = 10;
  inline bool has_jamcfmhz() const;
  inline void clear_jamcfmhz();
  static const int kJamCFMHzFieldNumber = 10;
  inline float jamcfmhz() const;
  inline void set_jamcfmhz(float value);

  // optional float tuneCFMHz = 11;
  inline bool has_tunecfmhz() const;
  inline void clear_tunecfmhz();
  static const int kTuneCFMHzFieldNumber = 11;
  inline float tunecfmhz() const;
  inline void set_tunecfmhz(float value);

  // optional float jamBWMHz = 12;
  inline bool has_jambwmhz() const;
  inline void clear_jambwmhz();
  static const int kJamBWMHzFieldNumber = 12;
  inline float jambwmhz() const;
  inline void set_jambwmhz(float value);

  // optional float jamBaudrate = 13;
  inline bool has_jambaudrate() const;
  inline void clear_jambaudrate();
  static const int kJamBaudrateFieldNumber = 13;
  inline float jambaudrate() const;
  inline void set_jambaudrate(float value);

  // optional float jamDeviation = 14;
  inline bool has_jamdeviation() const;
  inline void clear_jamdeviation();
  static const int kJamDeviationFieldNumber = 14;
  inline float jamdeviation() const;
  inline void set_jamdeviation(float value);

  // optional float onCycle = 15;
  inline bool has_oncycle() const;
  inline void clear_oncycle();
  static const int kOnCycleFieldNumber = 15;
  inline float oncycle() const;
  inline void set_oncycle(float value);

  // optional float totalCycle = 16;
  inline bool has_totalcycle() const;
  inline void clear_totalcycle();
  static const int kTotalCycleFieldNumber = 16;
  inline float totalcycle() const;
  inline void set_totalcycle(float value);

  // optional int32 modeID = 17;
  inline bool has_modeid() const;
  inline void clear_modeid();
  static const int kModeIDFieldNumber = 17;
  inline ::google::protobuf::int32 modeid() const;
  inline void set_modeid(::google::protobuf::int32 value);

  // optional int32 sourceID = 18;
  inline bool has_sourceid() const;
  inline void clear_sourceid();
  static const int kSourceIDFieldNumber = 18;
  inline ::google::protobuf::int32 sourceid() const;
  inline void set_sourceid(::google::protobuf::int32 value);

  // optional int32 destinationID = 19;
  inline bool has_destinationid() const;
  inline void clear_destinationid();
  static const int kDestinationIDFieldNumber = 19;
  inline ::google::protobuf::int32 destinationid() const;
  inline void set_destinationid(::google::protobuf::int32 value);

  // optional int32 frameFormat = 20;
  inline bool has_frameformat() const;
  inline void clear_frameformat();
  static const int kFrameFormatFieldNumber = 20;
  inline ::google::protobuf::int32 frameformat() const;
  inline void set_frameformat(::google::protobuf::int32 value);

  // optional string textMessage = 21;
  inline bool has_textmessage() const;
  inline void clear_textmessage();
  static const int kTextMessageFieldNumber = 21;
  inline const ::std::string& textmessage() const;
  inline void set_textmessage(const ::std::string& value);
  inline void set_textmessage(const char* value);
  inline void set_textmessage(const char* value, size_t size);
  inline ::std::string* mutable_textmessage();
  inline ::std::string* release_textmessage();
  inline void set_allocated_textmessage(::std::string* textmessage);

  // optional double lat = 22;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 22;
  inline double lat() const;
  inline void set_lat(double value);

  // optional double lon = 23;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 23;
  inline double lon() const;
  inline void set_lon(double value);

  // optional int32 numTargets = 24;
  inline bool has_numtargets() const;
  inline void clear_numtargets();
  static const int kNumTargetsFieldNumber = 24;
  inline ::google::protobuf::int32 numtargets() const;
  inline void set_numtargets(::google::protobuf::int32 value);

  // repeated .falcon_common_msg.KeyValuePair kvps = 25;
  inline int kvps_size() const;
  inline void clear_kvps();
  static const int kKvpsFieldNumber = 25;
  inline const ::falcon_common_msg::KeyValuePair& kvps(int index) const;
  inline ::falcon_common_msg::KeyValuePair* mutable_kvps(int index);
  inline ::falcon_common_msg::KeyValuePair* add_kvps();
  inline const ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::KeyValuePair >&
      kvps() const;
  inline ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::KeyValuePair >*
      mutable_kvps();

  // optional double jamIFMHz = 26 [default = 0];
  inline bool has_jamifmhz() const;
  inline void clear_jamifmhz();
  static const int kJamIFMHzFieldNumber = 26;
  inline double jamifmhz() const;
  inline void set_jamifmhz(double value);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.Parameters)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_jamcfmhz();
  inline void clear_has_jamcfmhz();
  inline void set_has_tunecfmhz();
  inline void clear_has_tunecfmhz();
  inline void set_has_jambwmhz();
  inline void clear_has_jambwmhz();
  inline void set_has_jambaudrate();
  inline void clear_has_jambaudrate();
  inline void set_has_jamdeviation();
  inline void clear_has_jamdeviation();
  inline void set_has_oncycle();
  inline void clear_has_oncycle();
  inline void set_has_totalcycle();
  inline void clear_has_totalcycle();
  inline void set_has_modeid();
  inline void clear_has_modeid();
  inline void set_has_sourceid();
  inline void clear_has_sourceid();
  inline void set_has_destinationid();
  inline void clear_has_destinationid();
  inline void set_has_frameformat();
  inline void clear_has_frameformat();
  inline void set_has_textmessage();
  inline void clear_has_textmessage();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_numtargets();
  inline void clear_has_numtargets();
  inline void set_has_jamifmhz();
  inline void clear_has_jamifmhz();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  float jamcfmhz_;
  float tunecfmhz_;
  float jambwmhz_;
  float jambaudrate_;
  float jamdeviation_;
  float oncycle_;
  float totalcycle_;
  ::google::protobuf::int32 modeid_;
  ::google::protobuf::int32 sourceid_;
  ::google::protobuf::int32 destinationid_;
  ::std::string* textmessage_;
  double lat_;
  ::google::protobuf::int32 frameformat_;
  ::google::protobuf::int32 numtargets_;
  double lon_;
  ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::KeyValuePair > kvps_;
  double jamifmhz_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static Parameters* default_instance_;
};
// -------------------------------------------------------------------

class EWStatus : public ::google::protobuf::Message {
 public:
  EWStatus();
  virtual ~EWStatus();

  EWStatus(const EWStatus& from);

  inline EWStatus& operator=(const EWStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EWStatus& default_instance();

  void Swap(EWStatus* other);

  // implements Message ----------------------------------------------

  EWStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EWStatus& from);
  void MergeFrom(const EWStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EW_STATUS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // repeated .fv.tb.protos.TBProtos.OutputChannelStatus outputChannelStatus = 2;
  inline int outputchannelstatus_size() const;
  inline void clear_outputchannelstatus();
  static const int kOutputChannelStatusFieldNumber = 2;
  inline const ::fv::tb::protos::TBProtos::OutputChannelStatus& outputchannelstatus(int index) const;
  inline ::fv::tb::protos::TBProtos::OutputChannelStatus* mutable_outputchannelstatus(int index);
  inline ::fv::tb::protos::TBProtos::OutputChannelStatus* add_outputchannelstatus();
  inline const ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::OutputChannelStatus >&
      outputchannelstatus() const;
  inline ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::OutputChannelStatus >*
      mutable_outputchannelstatus();

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.EWStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::OutputChannelStatus > outputchannelstatus_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static EWStatus* default_instance_;
};
// -------------------------------------------------------------------

class OutputChannelStatus : public ::google::protobuf::Message {
 public:
  OutputChannelStatus();
  virtual ~OutputChannelStatus();

  OutputChannelStatus(const OutputChannelStatus& from);

  inline OutputChannelStatus& operator=(const OutputChannelStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OutputChannelStatus& default_instance();

  void Swap(OutputChannelStatus* other);

  // implements Message ----------------------------------------------

  OutputChannelStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OutputChannelStatus& from);
  void MergeFrom(const OutputChannelStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef OutputChannelStatus_TransmitState TransmitState;
  static const TransmitState READY = OutputChannelStatus_TransmitState_READY;
  static const TransmitState NOT_READY = OutputChannelStatus_TransmitState_NOT_READY;
  static const TransmitState ACTIVE = OutputChannelStatus_TransmitState_ACTIVE;
  static inline bool TransmitState_IsValid(int value) {
    return OutputChannelStatus_TransmitState_IsValid(value);
  }
  static const TransmitState TransmitState_MIN =
    OutputChannelStatus_TransmitState_TransmitState_MIN;
  static const TransmitState TransmitState_MAX =
    OutputChannelStatus_TransmitState_TransmitState_MAX;
  static const int TransmitState_ARRAYSIZE =
    OutputChannelStatus_TransmitState_TransmitState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TransmitState_descriptor() {
    return OutputChannelStatus_TransmitState_descriptor();
  }
  static inline const ::std::string& TransmitState_Name(TransmitState value) {
    return OutputChannelStatus_TransmitState_Name(value);
  }
  static inline bool TransmitState_Parse(const ::std::string& name,
      TransmitState* value) {
    return OutputChannelStatus_TransmitState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EW_OUTPUT_CHANNEL_STATUS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string effect = 2;
  inline bool has_effect() const;
  inline void clear_effect();
  static const int kEffectFieldNumber = 2;
  inline const ::std::string& effect() const;
  inline void set_effect(const ::std::string& value);
  inline void set_effect(const char* value);
  inline void set_effect(const char* value, size_t size);
  inline ::std::string* mutable_effect();
  inline ::std::string* release_effect();
  inline void set_allocated_effect(::std::string* effect);

  // optional double transmitFreq = 3;
  inline bool has_transmitfreq() const;
  inline void clear_transmitfreq();
  static const int kTransmitFreqFieldNumber = 3;
  inline double transmitfreq() const;
  inline void set_transmitfreq(double value);

  // optional string globalId = 4;
  inline bool has_globalid() const;
  inline void clear_globalid();
  static const int kGlobalIdFieldNumber = 4;
  inline const ::std::string& globalid() const;
  inline void set_globalid(const ::std::string& value);
  inline void set_globalid(const char* value);
  inline void set_globalid(const char* value, size_t size);
  inline ::std::string* mutable_globalid();
  inline ::std::string* release_globalid();
  inline void set_allocated_globalid(::std::string* globalid);

  // optional string antenna = 5;
  inline bool has_antenna() const;
  inline void clear_antenna();
  static const int kAntennaFieldNumber = 5;
  inline const ::std::string& antenna() const;
  inline void set_antenna(const ::std::string& value);
  inline void set_antenna(const char* value);
  inline void set_antenna(const char* value, size_t size);
  inline ::std::string* mutable_antenna();
  inline ::std::string* release_antenna();
  inline void set_allocated_antenna(::std::string* antenna);

  // optional .fv.tb.protos.TBProtos.OutputChannelStatus.TransmitState state = 6;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 6;
  inline ::fv::tb::protos::TBProtos::OutputChannelStatus_TransmitState state() const;
  inline void set_state(::fv::tb::protos::TBProtos::OutputChannelStatus_TransmitState value);

  // optional double powerMeter = 7;
  inline bool has_powermeter() const;
  inline void clear_powermeter();
  static const int kPowerMeterFieldNumber = 7;
  inline double powermeter() const;
  inline void set_powermeter(double value);

  // optional string resID = 8;
  inline bool has_resid() const;
  inline void clear_resid();
  static const int kResIDFieldNumber = 8;
  inline const ::std::string& resid() const;
  inline void set_resid(const ::std::string& value);
  inline void set_resid(const char* value);
  inline void set_resid(const char* value, size_t size);
  inline ::std::string* mutable_resid();
  inline ::std::string* release_resid();
  inline void set_allocated_resid(::std::string* resid);

  // optional string signalName = 9;
  inline bool has_signalname() const;
  inline void clear_signalname();
  static const int kSignalNameFieldNumber = 9;
  inline const ::std::string& signalname() const;
  inline void set_signalname(const ::std::string& value);
  inline void set_signalname(const char* value);
  inline void set_signalname(const char* value, size_t size);
  inline ::std::string* mutable_signalname();
  inline ::std::string* release_signalname();
  inline void set_allocated_signalname(::std::string* signalname);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.OutputChannelStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_effect();
  inline void clear_has_effect();
  inline void set_has_transmitfreq();
  inline void clear_has_transmitfreq();
  inline void set_has_globalid();
  inline void clear_has_globalid();
  inline void set_has_antenna();
  inline void clear_has_antenna();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_powermeter();
  inline void clear_has_powermeter();
  inline void set_has_resid();
  inline void clear_has_resid();
  inline void set_has_signalname();
  inline void clear_has_signalname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* effect_;
  double transmitfreq_;
  ::std::string* globalid_;
  ::std::string* antenna_;
  double powermeter_;
  ::std::string* resid_;
  ::std::string* signalname_;
  int state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static OutputChannelStatus* default_instance_;
};
// -------------------------------------------------------------------

class EWTransmittingRequest : public ::google::protobuf::Message {
 public:
  EWTransmittingRequest();
  virtual ~EWTransmittingRequest();

  EWTransmittingRequest(const EWTransmittingRequest& from);

  inline EWTransmittingRequest& operator=(const EWTransmittingRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EWTransmittingRequest& default_instance();

  void Swap(EWTransmittingRequest* other);

  // implements Message ----------------------------------------------

  EWTransmittingRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EWTransmittingRequest& from);
  void MergeFrom(const EWTransmittingRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EW_TRANSMITTING_REQUEST"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.EWTransmittingRequest)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static EWTransmittingRequest* default_instance_;
};
// -------------------------------------------------------------------

class EWCapabilityUnregister : public ::google::protobuf::Message {
 public:
  EWCapabilityUnregister();
  virtual ~EWCapabilityUnregister();

  EWCapabilityUnregister(const EWCapabilityUnregister& from);

  inline EWCapabilityUnregister& operator=(const EWCapabilityUnregister& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EWCapabilityUnregister& default_instance();

  void Swap(EWCapabilityUnregister* other);

  // implements Message ----------------------------------------------

  EWCapabilityUnregister* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EWCapabilityUnregister& from);
  void MergeFrom(const EWCapabilityUnregister& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EW_CAPABILITY_UNREGISTER"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string capabilityId = 2;
  inline bool has_capabilityid() const;
  inline void clear_capabilityid();
  static const int kCapabilityIdFieldNumber = 2;
  inline const ::std::string& capabilityid() const;
  inline void set_capabilityid(const ::std::string& value);
  inline void set_capabilityid(const char* value);
  inline void set_capabilityid(const char* value, size_t size);
  inline ::std::string* mutable_capabilityid();
  inline ::std::string* release_capabilityid();
  inline void set_allocated_capabilityid(::std::string* capabilityid);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.EWCapabilityUnregister)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_capabilityid();
  inline void clear_has_capabilityid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* capabilityid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static EWCapabilityUnregister* default_instance_;
};
// -------------------------------------------------------------------

class EWCapability : public ::google::protobuf::Message {
 public:
  EWCapability();
  virtual ~EWCapability();

  EWCapability(const EWCapability& from);

  inline EWCapability& operator=(const EWCapability& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EWCapability& default_instance();

  void Swap(EWCapability* other);

  // implements Message ----------------------------------------------

  EWCapability* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EWCapability& from);
  void MergeFrom(const EWCapability& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef EWCapability_DetectionSource DetectionSource;
  static const DetectionSource EXTERNALS = EWCapability_DetectionSource_EXTERNALS;
  static const DetectionSource INTERNALS = EWCapability_DetectionSource_INTERNALS;
  static const DetectionSource SIGUP = EWCapability_DetectionSource_SIGUP;
  static const DetectionSource THUNDERBIRD = EWCapability_DetectionSource_THUNDERBIRD;
  static inline bool DetectionSource_IsValid(int value) {
    return EWCapability_DetectionSource_IsValid(value);
  }
  static const DetectionSource DetectionSource_MIN =
    EWCapability_DetectionSource_DetectionSource_MIN;
  static const DetectionSource DetectionSource_MAX =
    EWCapability_DetectionSource_DetectionSource_MAX;
  static const int DetectionSource_ARRAYSIZE =
    EWCapability_DetectionSource_DetectionSource_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DetectionSource_descriptor() {
    return EWCapability_DetectionSource_descriptor();
  }
  static inline const ::std::string& DetectionSource_Name(DetectionSource value) {
    return EWCapability_DetectionSource_Name(value);
  }
  static inline bool DetectionSource_Parse(const ::std::string& name,
      DetectionSource* value) {
    return EWCapability_DetectionSource_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EW_CAPABILITIY"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string signalName = 2;
  inline bool has_signalname() const;
  inline void clear_signalname();
  static const int kSignalNameFieldNumber = 2;
  inline const ::std::string& signalname() const;
  inline void set_signalname(const ::std::string& value);
  inline void set_signalname(const char* value);
  inline void set_signalname(const char* value, size_t size);
  inline ::std::string* mutable_signalname();
  inline ::std::string* release_signalname();
  inline void set_allocated_signalname(::std::string* signalname);

  // optional string effect = 3;
  inline bool has_effect() const;
  inline void clear_effect();
  static const int kEffectFieldNumber = 3;
  inline const ::std::string& effect() const;
  inline void set_effect(const ::std::string& value);
  inline void set_effect(const char* value);
  inline void set_effect(const char* value, size_t size);
  inline ::std::string* mutable_effect();
  inline ::std::string* release_effect();
  inline void set_allocated_effect(::std::string* effect);

  // optional string capabilityId = 4;
  inline bool has_capabilityid() const;
  inline void clear_capabilityid();
  static const int kCapabilityIdFieldNumber = 4;
  inline const ::std::string& capabilityid() const;
  inline void set_capabilityid(const ::std::string& value);
  inline void set_capabilityid(const char* value);
  inline void set_capabilityid(const char* value, size_t size);
  inline ::std::string* mutable_capabilityid();
  inline ::std::string* release_capabilityid();
  inline void set_allocated_capabilityid(::std::string* capabilityid);

  // optional string globalID = 5;
  inline bool has_globalid() const;
  inline void clear_globalid();
  static const int kGlobalIDFieldNumber = 5;
  inline const ::std::string& globalid() const;
  inline void set_globalid(const ::std::string& value);
  inline void set_globalid(const char* value);
  inline void set_globalid(const char* value, size_t size);
  inline ::std::string* mutable_globalid();
  inline ::std::string* release_globalid();
  inline void set_allocated_globalid(::std::string* globalid);

  // optional float percentReady = 6 [default = 0];
  inline bool has_percentready() const;
  inline void clear_percentready();
  static const int kPercentReadyFieldNumber = 6;
  inline float percentready() const;
  inline void set_percentready(float value);

  // optional .fv.tb.protos.TBProtos.Parameters parameters = 7;
  inline bool has_parameters() const;
  inline void clear_parameters();
  static const int kParametersFieldNumber = 7;
  inline const ::fv::tb::protos::TBProtos::Parameters& parameters() const;
  inline ::fv::tb::protos::TBProtos::Parameters* mutable_parameters();
  inline ::fv::tb::protos::TBProtos::Parameters* release_parameters();
  inline void set_allocated_parameters(::fv::tb::protos::TBProtos::Parameters* parameters);

  // optional string tbUniqueID = 8;
  inline bool has_tbuniqueid() const;
  inline void clear_tbuniqueid();
  static const int kTbUniqueIDFieldNumber = 8;
  inline const ::std::string& tbuniqueid() const;
  inline void set_tbuniqueid(const ::std::string& value);
  inline void set_tbuniqueid(const char* value);
  inline void set_tbuniqueid(const char* value, size_t size);
  inline ::std::string* mutable_tbuniqueid();
  inline ::std::string* release_tbuniqueid();
  inline void set_allocated_tbuniqueid(::std::string* tbuniqueid);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.EWCapability)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_signalname();
  inline void clear_has_signalname();
  inline void set_has_effect();
  inline void clear_has_effect();
  inline void set_has_capabilityid();
  inline void clear_has_capabilityid();
  inline void set_has_globalid();
  inline void clear_has_globalid();
  inline void set_has_percentready();
  inline void clear_has_percentready();
  inline void set_has_parameters();
  inline void clear_has_parameters();
  inline void set_has_tbuniqueid();
  inline void clear_has_tbuniqueid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* signalname_;
  ::std::string* effect_;
  ::std::string* capabilityid_;
  ::std::string* globalid_;
  ::fv::tb::protos::TBProtos::Parameters* parameters_;
  ::std::string* tbuniqueid_;
  float percentready_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static EWCapability* default_instance_;
};
// -------------------------------------------------------------------

class EWCapabilities : public ::google::protobuf::Message {
 public:
  EWCapabilities();
  virtual ~EWCapabilities();

  EWCapabilities(const EWCapabilities& from);

  inline EWCapabilities& operator=(const EWCapabilities& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EWCapabilities& default_instance();

  void Swap(EWCapabilities* other);

  // implements Message ----------------------------------------------

  EWCapabilities* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EWCapabilities& from);
  void MergeFrom(const EWCapabilities& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EWCAPABILITIES"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // repeated .fv.tb.protos.TBProtos.EWCapability ewcap = 2;
  inline int ewcap_size() const;
  inline void clear_ewcap();
  static const int kEwcapFieldNumber = 2;
  inline const ::fv::tb::protos::TBProtos::EWCapability& ewcap(int index) const;
  inline ::fv::tb::protos::TBProtos::EWCapability* mutable_ewcap(int index);
  inline ::fv::tb::protos::TBProtos::EWCapability* add_ewcap();
  inline const ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::EWCapability >&
      ewcap() const;
  inline ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::EWCapability >*
      mutable_ewcap();

  // optional string sensorName = 3 [default = ""];
  inline bool has_sensorname() const;
  inline void clear_sensorname();
  static const int kSensorNameFieldNumber = 3;
  inline const ::std::string& sensorname() const;
  inline void set_sensorname(const ::std::string& value);
  inline void set_sensorname(const char* value);
  inline void set_sensorname(const char* value, size_t size);
  inline ::std::string* mutable_sensorname();
  inline ::std::string* release_sensorname();
  inline void set_allocated_sensorname(::std::string* sensorname);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.EWCapabilities)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_sensorname();
  inline void clear_has_sensorname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::EWCapability > ewcap_;
  ::std::string* sensorname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static EWCapabilities* default_instance_;
};
// -------------------------------------------------------------------

class EWCapabilityTransmitting : public ::google::protobuf::Message {
 public:
  EWCapabilityTransmitting();
  virtual ~EWCapabilityTransmitting();

  EWCapabilityTransmitting(const EWCapabilityTransmitting& from);

  inline EWCapabilityTransmitting& operator=(const EWCapabilityTransmitting& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EWCapabilityTransmitting& default_instance();

  void Swap(EWCapabilityTransmitting* other);

  // implements Message ----------------------------------------------

  EWCapabilityTransmitting* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EWCapabilityTransmitting& from);
  void MergeFrom(const EWCapabilityTransmitting& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EW_CAPABILITY_TRANSMITTING"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional .fv.tb.protos.TBProtos.EWCapability ewcap = 2;
  inline bool has_ewcap() const;
  inline void clear_ewcap();
  static const int kEwcapFieldNumber = 2;
  inline const ::fv::tb::protos::TBProtos::EWCapability& ewcap() const;
  inline ::fv::tb::protos::TBProtos::EWCapability* mutable_ewcap();
  inline ::fv::tb::protos::TBProtos::EWCapability* release_ewcap();
  inline void set_allocated_ewcap(::fv::tb::protos::TBProtos::EWCapability* ewcap);

  // optional bool active = 3 [default = false];
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 3;
  inline bool active() const;
  inline void set_active(bool value);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.EWCapabilityTransmitting)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_ewcap();
  inline void clear_has_ewcap();
  inline void set_has_active();
  inline void clear_has_active();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::fv::tb::protos::TBProtos::EWCapability* ewcap_;
  bool active_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static EWCapabilityTransmitting* default_instance_;
};
// -------------------------------------------------------------------

class EWTransmitting : public ::google::protobuf::Message {
 public:
  EWTransmitting();
  virtual ~EWTransmitting();

  EWTransmitting(const EWTransmitting& from);

  inline EWTransmitting& operator=(const EWTransmitting& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EWTransmitting& default_instance();

  void Swap(EWTransmitting* other);

  // implements Message ----------------------------------------------

  EWTransmitting* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EWTransmitting& from);
  void MergeFrom(const EWTransmitting& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EW_TRANSMITTING"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // repeated .fv.tb.protos.TBProtos.EWCapability ewcap = 2;
  inline int ewcap_size() const;
  inline void clear_ewcap();
  static const int kEwcapFieldNumber = 2;
  inline const ::fv::tb::protos::TBProtos::EWCapability& ewcap(int index) const;
  inline ::fv::tb::protos::TBProtos::EWCapability* mutable_ewcap(int index);
  inline ::fv::tb::protos::TBProtos::EWCapability* add_ewcap();
  inline const ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::EWCapability >&
      ewcap() const;
  inline ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::EWCapability >*
      mutable_ewcap();

  // optional string sensorName = 3;
  inline bool has_sensorname() const;
  inline void clear_sensorname();
  static const int kSensorNameFieldNumber = 3;
  inline const ::std::string& sensorname() const;
  inline void set_sensorname(const ::std::string& value);
  inline void set_sensorname(const char* value);
  inline void set_sensorname(const char* value, size_t size);
  inline ::std::string* mutable_sensorname();
  inline ::std::string* release_sensorname();
  inline void set_allocated_sensorname(::std::string* sensorname);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.EWTransmitting)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_sensorname();
  inline void clear_has_sensorname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::EWCapability > ewcap_;
  ::std::string* sensorname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static EWTransmitting* default_instance_;
};
// -------------------------------------------------------------------

class EWTechniqueDescriptions : public ::google::protobuf::Message {
 public:
  EWTechniqueDescriptions();
  virtual ~EWTechniqueDescriptions();

  EWTechniqueDescriptions(const EWTechniqueDescriptions& from);

  inline EWTechniqueDescriptions& operator=(const EWTechniqueDescriptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EWTechniqueDescriptions& default_instance();

  void Swap(EWTechniqueDescriptions* other);

  // implements Message ----------------------------------------------

  EWTechniqueDescriptions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EWTechniqueDescriptions& from);
  void MergeFrom(const EWTechniqueDescriptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EWTECHNIQUEDESCRIPTIONS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // repeated string techniqueDescription = 2;
  inline int techniquedescription_size() const;
  inline void clear_techniquedescription();
  static const int kTechniqueDescriptionFieldNumber = 2;
  inline const ::std::string& techniquedescription(int index) const;
  inline ::std::string* mutable_techniquedescription(int index);
  inline void set_techniquedescription(int index, const ::std::string& value);
  inline void set_techniquedescription(int index, const char* value);
  inline void set_techniquedescription(int index, const char* value, size_t size);
  inline ::std::string* add_techniquedescription();
  inline void add_techniquedescription(const ::std::string& value);
  inline void add_techniquedescription(const char* value);
  inline void add_techniquedescription(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& techniquedescription() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_techniquedescription();

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.EWTechniqueDescriptions)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::RepeatedPtrField< ::std::string> techniquedescription_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static EWTechniqueDescriptions* default_instance_;
};
// -------------------------------------------------------------------

class EWTechniqueDescriptionsRequest : public ::google::protobuf::Message {
 public:
  EWTechniqueDescriptionsRequest();
  virtual ~EWTechniqueDescriptionsRequest();

  EWTechniqueDescriptionsRequest(const EWTechniqueDescriptionsRequest& from);

  inline EWTechniqueDescriptionsRequest& operator=(const EWTechniqueDescriptionsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EWTechniqueDescriptionsRequest& default_instance();

  void Swap(EWTechniqueDescriptionsRequest* other);

  // implements Message ----------------------------------------------

  EWTechniqueDescriptionsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EWTechniqueDescriptionsRequest& from);
  void MergeFrom(const EWTechniqueDescriptionsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EWTECHNIQUEDESCRIPTIONSREQUEST"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.EWTechniqueDescriptionsRequest)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static EWTechniqueDescriptionsRequest* default_instance_;
};
// -------------------------------------------------------------------

class EWOption : public ::google::protobuf::Message {
 public:
  EWOption();
  virtual ~EWOption();

  EWOption(const EWOption& from);

  inline EWOption& operator=(const EWOption& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EWOption& default_instance();

  void Swap(EWOption* other);

  // implements Message ----------------------------------------------

  EWOption* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EWOption& from);
  void MergeFrom(const EWOption& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef EWOption_DetectionSource DetectionSource;
  static const DetectionSource EXTERNALS = EWOption_DetectionSource_EXTERNALS;
  static const DetectionSource INTERNALS = EWOption_DetectionSource_INTERNALS;
  static const DetectionSource SIGUP = EWOption_DetectionSource_SIGUP;
  static const DetectionSource THUNDERBIRD = EWOption_DetectionSource_THUNDERBIRD;
  static inline bool DetectionSource_IsValid(int value) {
    return EWOption_DetectionSource_IsValid(value);
  }
  static const DetectionSource DetectionSource_MIN =
    EWOption_DetectionSource_DetectionSource_MIN;
  static const DetectionSource DetectionSource_MAX =
    EWOption_DetectionSource_DetectionSource_MAX;
  static const int DetectionSource_ARRAYSIZE =
    EWOption_DetectionSource_DetectionSource_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DetectionSource_descriptor() {
    return EWOption_DetectionSource_descriptor();
  }
  static inline const ::std::string& DetectionSource_Name(DetectionSource value) {
    return EWOption_DetectionSource_Name(value);
  }
  static inline bool DetectionSource_Parse(const ::std::string& name,
      DetectionSource* value) {
    return EWOption_DetectionSource_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EW_OPTION"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string signalName = 2;
  inline bool has_signalname() const;
  inline void clear_signalname();
  static const int kSignalNameFieldNumber = 2;
  inline const ::std::string& signalname() const;
  inline void set_signalname(const ::std::string& value);
  inline void set_signalname(const char* value);
  inline void set_signalname(const char* value, size_t size);
  inline ::std::string* mutable_signalname();
  inline ::std::string* release_signalname();
  inline void set_allocated_signalname(::std::string* signalname);

  // repeated string effect = 3;
  inline int effect_size() const;
  inline void clear_effect();
  static const int kEffectFieldNumber = 3;
  inline const ::std::string& effect(int index) const;
  inline ::std::string* mutable_effect(int index);
  inline void set_effect(int index, const ::std::string& value);
  inline void set_effect(int index, const char* value);
  inline void set_effect(int index, const char* value, size_t size);
  inline ::std::string* add_effect();
  inline void add_effect(const ::std::string& value);
  inline void add_effect(const char* value);
  inline void add_effect(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& effect() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_effect();

  // optional .fv.tb.protos.TBProtos.EWOption.DetectionSource detectionSource = 4;
  inline bool has_detectionsource() const;
  inline void clear_detectionsource();
  static const int kDetectionSourceFieldNumber = 4;
  inline ::fv::tb::protos::TBProtos::EWOption_DetectionSource detectionsource() const;
  inline void set_detectionsource(::fv::tb::protos::TBProtos::EWOption_DetectionSource value);

  // optional string globalId = 5;
  inline bool has_globalid() const;
  inline void clear_globalid();
  static const int kGlobalIdFieldNumber = 5;
  inline const ::std::string& globalid() const;
  inline void set_globalid(const ::std::string& value);
  inline void set_globalid(const char* value);
  inline void set_globalid(const char* value, size_t size);
  inline ::std::string* mutable_globalid();
  inline ::std::string* release_globalid();
  inline void set_allocated_globalid(::std::string* globalid);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.EWOption)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_signalname();
  inline void clear_has_signalname();
  inline void set_has_detectionsource();
  inline void clear_has_detectionsource();
  inline void set_has_globalid();
  inline void clear_has_globalid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* signalname_;
  ::google::protobuf::RepeatedPtrField< ::std::string> effect_;
  ::std::string* globalid_;
  int detectionsource_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static EWOption* default_instance_;
};
// -------------------------------------------------------------------

class EWOptions : public ::google::protobuf::Message {
 public:
  EWOptions();
  virtual ~EWOptions();

  EWOptions(const EWOptions& from);

  inline EWOptions& operator=(const EWOptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EWOptions& default_instance();

  void Swap(EWOptions* other);

  // implements Message ----------------------------------------------

  EWOptions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EWOptions& from);
  void MergeFrom(const EWOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EW_OPTIONS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // repeated .fv.tb.protos.TBProtos.EWOption ewopt = 2;
  inline int ewopt_size() const;
  inline void clear_ewopt();
  static const int kEwoptFieldNumber = 2;
  inline const ::fv::tb::protos::TBProtos::EWOption& ewopt(int index) const;
  inline ::fv::tb::protos::TBProtos::EWOption* mutable_ewopt(int index);
  inline ::fv::tb::protos::TBProtos::EWOption* add_ewopt();
  inline const ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::EWOption >&
      ewopt() const;
  inline ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::EWOption >*
      mutable_ewopt();

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.EWOptions)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::EWOption > ewopt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static EWOptions* default_instance_;
};
// -------------------------------------------------------------------

class EWOptionsRequest : public ::google::protobuf::Message {
 public:
  EWOptionsRequest();
  virtual ~EWOptionsRequest();

  EWOptionsRequest(const EWOptionsRequest& from);

  inline EWOptionsRequest& operator=(const EWOptionsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EWOptionsRequest& default_instance();

  void Swap(EWOptionsRequest* other);

  // implements Message ----------------------------------------------

  EWOptionsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EWOptionsRequest& from);
  void MergeFrom(const EWOptionsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EW_OPTIONS_REQUEST"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.EWOptionsRequest)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static EWOptionsRequest* default_instance_;
};
// -------------------------------------------------------------------

class EWStatusRequest : public ::google::protobuf::Message {
 public:
  EWStatusRequest();
  virtual ~EWStatusRequest();

  EWStatusRequest(const EWStatusRequest& from);

  inline EWStatusRequest& operator=(const EWStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EWStatusRequest& default_instance();

  void Swap(EWStatusRequest* other);

  // implements Message ----------------------------------------------

  EWStatusRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EWStatusRequest& from);
  void MergeFrom(const EWStatusRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EW_STATUS_REQUEST"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.EWStatusRequest)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static EWStatusRequest* default_instance_;
};
// -------------------------------------------------------------------

class EWCapabilitiesRequest : public ::google::protobuf::Message {
 public:
  EWCapabilitiesRequest();
  virtual ~EWCapabilitiesRequest();

  EWCapabilitiesRequest(const EWCapabilitiesRequest& from);

  inline EWCapabilitiesRequest& operator=(const EWCapabilitiesRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EWCapabilitiesRequest& default_instance();

  void Swap(EWCapabilitiesRequest* other);

  // implements Message ----------------------------------------------

  EWCapabilitiesRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EWCapabilitiesRequest& from);
  void MergeFrom(const EWCapabilitiesRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EW_CAPABILITIES_REQUEST"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.EWCapabilitiesRequest)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static EWCapabilitiesRequest* default_instance_;
};
// -------------------------------------------------------------------

class EWOptionDelete : public ::google::protobuf::Message {
 public:
  EWOptionDelete();
  virtual ~EWOptionDelete();

  EWOptionDelete(const EWOptionDelete& from);

  inline EWOptionDelete& operator=(const EWOptionDelete& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EWOptionDelete& default_instance();

  void Swap(EWOptionDelete* other);

  // implements Message ----------------------------------------------

  EWOptionDelete* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EWOptionDelete& from);
  void MergeFrom(const EWOptionDelete& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EW_OPTION_DELETE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string globalId = 2;
  inline bool has_globalid() const;
  inline void clear_globalid();
  static const int kGlobalIdFieldNumber = 2;
  inline const ::std::string& globalid() const;
  inline void set_globalid(const ::std::string& value);
  inline void set_globalid(const char* value);
  inline void set_globalid(const char* value, size_t size);
  inline ::std::string* mutable_globalid();
  inline ::std::string* release_globalid();
  inline void set_allocated_globalid(::std::string* globalid);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.EWOptionDelete)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_globalid();
  inline void clear_has_globalid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* globalid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static EWOptionDelete* default_instance_;
};
// -------------------------------------------------------------------

class EWCeaseBuzzer : public ::google::protobuf::Message {
 public:
  EWCeaseBuzzer();
  virtual ~EWCeaseBuzzer();

  EWCeaseBuzzer(const EWCeaseBuzzer& from);

  inline EWCeaseBuzzer& operator=(const EWCeaseBuzzer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EWCeaseBuzzer& default_instance();

  void Swap(EWCeaseBuzzer* other);

  // implements Message ----------------------------------------------

  EWCeaseBuzzer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EWCeaseBuzzer& from);
  void MergeFrom(const EWCeaseBuzzer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EW_CEASE_BUZZER"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.EWCeaseBuzzer)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static EWCeaseBuzzer* default_instance_;
};
// -------------------------------------------------------------------

class TxAntennaConfig : public ::google::protobuf::Message {
 public:
  TxAntennaConfig();
  virtual ~TxAntennaConfig();

  TxAntennaConfig(const TxAntennaConfig& from);

  inline TxAntennaConfig& operator=(const TxAntennaConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxAntennaConfig& default_instance();

  void Swap(TxAntennaConfig* other);

  // implements Message ----------------------------------------------

  TxAntennaConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxAntennaConfig& from);
  void MergeFrom(const TxAntennaConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "TX_ANTENNA_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string antName = 2;
  inline bool has_antname() const;
  inline void clear_antname();
  static const int kAntNameFieldNumber = 2;
  inline const ::std::string& antname() const;
  inline void set_antname(const ::std::string& value);
  inline void set_antname(const char* value);
  inline void set_antname(const char* value, size_t size);
  inline ::std::string* mutable_antname();
  inline ::std::string* release_antname();
  inline void set_allocated_antname(::std::string* antname);

  // optional double minRF = 3;
  inline bool has_minrf() const;
  inline void clear_minrf();
  static const int kMinRFFieldNumber = 3;
  inline double minrf() const;
  inline void set_minrf(double value);

  // optional double maxRF = 4;
  inline bool has_maxrf() const;
  inline void clear_maxrf();
  static const int kMaxRFFieldNumber = 4;
  inline double maxrf() const;
  inline void set_maxrf(double value);

  // optional float fixedAngle = 5 [default = -999];
  inline bool has_fixedangle() const;
  inline void clear_fixedangle();
  static const int kFixedAngleFieldNumber = 5;
  inline float fixedangle() const;
  inline void set_fixedangle(float value);

  // optional float latitude = 6 [default = 0];
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 6;
  inline float latitude() const;
  inline void set_latitude(float value);

  // optional float longitude = 7 [default = 0];
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 7;
  inline float longitude() const;
  inline void set_longitude(float value);

  // optional float altitude = 8 [default = 0];
  inline bool has_altitude() const;
  inline void clear_altitude();
  static const int kAltitudeFieldNumber = 8;
  inline float altitude() const;
  inline void set_altitude(float value);

  // optional float beamwidth = 9 [default = 0];
  inline bool has_beamwidth() const;
  inline void clear_beamwidth();
  static const int kBeamwidthFieldNumber = 9;
  inline float beamwidth() const;
  inline void set_beamwidth(float value);

  // optional float dwncnvtLO = 10 [default = 0];
  inline bool has_dwncnvtlo() const;
  inline void clear_dwncnvtlo();
  static const int kDwncnvtLOFieldNumber = 10;
  inline float dwncnvtlo() const;
  inline void set_dwncnvtlo(float value);

  // optional int32 ssc = 11 [default = -1];
  inline bool has_ssc() const;
  inline void clear_ssc();
  static const int kSscFieldNumber = 11;
  inline ::google::protobuf::int32 ssc() const;
  inline void set_ssc(::google::protobuf::int32 value);

  // optional string band = 12;
  inline bool has_band() const;
  inline void clear_band();
  static const int kBandFieldNumber = 12;
  inline const ::std::string& band() const;
  inline void set_band(const ::std::string& value);
  inline void set_band(const char* value);
  inline void set_band(const char* value, size_t size);
  inline ::std::string* mutable_band();
  inline ::std::string* release_band();
  inline void set_allocated_band(::std::string* band);

  // optional string polarization = 13;
  inline bool has_polarization() const;
  inline void clear_polarization();
  static const int kPolarizationFieldNumber = 13;
  inline const ::std::string& polarization() const;
  inline void set_polarization(const ::std::string& value);
  inline void set_polarization(const char* value);
  inline void set_polarization(const char* value, size_t size);
  inline ::std::string* mutable_polarization();
  inline ::std::string* release_polarization();
  inline void set_allocated_polarization(::std::string* polarization);

  // optional int32 group = 14;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 14;
  inline ::google::protobuf::int32 group() const;
  inline void set_group(::google::protobuf::int32 value);

  // optional float sightDistance = 15 [default = 500];
  inline bool has_sightdistance() const;
  inline void clear_sightdistance();
  static const int kSightDistanceFieldNumber = 15;
  inline float sightdistance() const;
  inline void set_sightdistance(float value);

  // optional string noiseTest = 16 [default = "NO_TEST"];
  inline bool has_noisetest() const;
  inline void clear_noisetest();
  static const int kNoiseTestFieldNumber = 16;
  inline const ::std::string& noisetest() const;
  inline void set_noisetest(const ::std::string& value);
  inline void set_noisetest(const char* value);
  inline void set_noisetest(const char* value, size_t size);
  inline ::std::string* mutable_noisetest();
  inline ::std::string* release_noisetest();
  inline void set_allocated_noisetest(::std::string* noisetest);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.TxAntennaConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_antname();
  inline void clear_has_antname();
  inline void set_has_minrf();
  inline void clear_has_minrf();
  inline void set_has_maxrf();
  inline void clear_has_maxrf();
  inline void set_has_fixedangle();
  inline void clear_has_fixedangle();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_altitude();
  inline void clear_has_altitude();
  inline void set_has_beamwidth();
  inline void clear_has_beamwidth();
  inline void set_has_dwncnvtlo();
  inline void clear_has_dwncnvtlo();
  inline void set_has_ssc();
  inline void clear_has_ssc();
  inline void set_has_band();
  inline void clear_has_band();
  inline void set_has_polarization();
  inline void clear_has_polarization();
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_sightdistance();
  inline void clear_has_sightdistance();
  inline void set_has_noisetest();
  inline void clear_has_noisetest();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* antname_;
  double minrf_;
  double maxrf_;
  float fixedangle_;
  float latitude_;
  float longitude_;
  float altitude_;
  float beamwidth_;
  float dwncnvtlo_;
  ::std::string* band_;
  ::google::protobuf::int32 ssc_;
  ::google::protobuf::int32 group_;
  ::std::string* polarization_;
  ::std::string* noisetest_;
  static ::std::string* _default_noisetest_;
  float sightdistance_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static TxAntennaConfig* default_instance_;
};
// -------------------------------------------------------------------

class TxAmpConfig : public ::google::protobuf::Message {
 public:
  TxAmpConfig();
  virtual ~TxAmpConfig();

  TxAmpConfig(const TxAmpConfig& from);

  inline TxAmpConfig& operator=(const TxAmpConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxAmpConfig& default_instance();

  void Swap(TxAmpConfig* other);

  // implements Message ----------------------------------------------

  TxAmpConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxAmpConfig& from);
  void MergeFrom(const TxAmpConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "TX_AMP_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string ampName = 2;
  inline bool has_ampname() const;
  inline void clear_ampname();
  static const int kAmpNameFieldNumber = 2;
  inline const ::std::string& ampname() const;
  inline void set_ampname(const ::std::string& value);
  inline void set_ampname(const char* value);
  inline void set_ampname(const char* value, size_t size);
  inline ::std::string* mutable_ampname();
  inline ::std::string* release_ampname();
  inline void set_allocated_ampname(::std::string* ampname);

  // optional string IP = 3 [default = "nportserver"];
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIPFieldNumber = 3;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional int32 port = 4 [default = 4012];
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 4;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // optional bool hardware = 5;
  inline bool has_hardware() const;
  inline void clear_hardware();
  static const int kHardwareFieldNumber = 5;
  inline bool hardware() const;
  inline void set_hardware(bool value);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.TxAmpConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_ampname();
  inline void clear_has_ampname();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_hardware();
  inline void clear_has_hardware();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* ampname_;
  ::std::string* ip_;
  static ::std::string* _default_ip_;
  ::google::protobuf::int32 port_;
  bool hardware_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static TxAmpConfig* default_instance_;
};
// -------------------------------------------------------------------

class TransmitterConfig : public ::google::protobuf::Message {
 public:
  TransmitterConfig();
  virtual ~TransmitterConfig();

  TransmitterConfig(const TransmitterConfig& from);

  inline TransmitterConfig& operator=(const TransmitterConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransmitterConfig& default_instance();

  void Swap(TransmitterConfig* other);

  // implements Message ----------------------------------------------

  TransmitterConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransmitterConfig& from);
  void MergeFrom(const TransmitterConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TransmitterConfig_SiggenType SiggenType;
  static const SiggenType ROHDE_SCHWARZ = TransmitterConfig_SiggenType_ROHDE_SCHWARZ;
  static const SiggenType MMS_MUP = TransmitterConfig_SiggenType_MMS_MUP;
  static inline bool SiggenType_IsValid(int value) {
    return TransmitterConfig_SiggenType_IsValid(value);
  }
  static const SiggenType SiggenType_MIN =
    TransmitterConfig_SiggenType_SiggenType_MIN;
  static const SiggenType SiggenType_MAX =
    TransmitterConfig_SiggenType_SiggenType_MAX;
  static const int SiggenType_ARRAYSIZE =
    TransmitterConfig_SiggenType_SiggenType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SiggenType_descriptor() {
    return TransmitterConfig_SiggenType_descriptor();
  }
  static inline const ::std::string& SiggenType_Name(SiggenType value) {
    return TransmitterConfig_SiggenType_Name(value);
  }
  static inline bool SiggenType_Parse(const ::std::string& name,
      SiggenType* value) {
    return TransmitterConfig_SiggenType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "TRANSMITTER_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string txName = 2;
  inline bool has_txname() const;
  inline void clear_txname();
  static const int kTxNameFieldNumber = 2;
  inline const ::std::string& txname() const;
  inline void set_txname(const ::std::string& value);
  inline void set_txname(const char* value);
  inline void set_txname(const char* value, size_t size);
  inline ::std::string* mutable_txname();
  inline ::std::string* release_txname();
  inline void set_allocated_txname(::std::string* txname);

  // optional float clkFreq = 3 [default = 4e+08];
  inline bool has_clkfreq() const;
  inline void clear_clkfreq();
  static const int kClkFreqFieldNumber = 3;
  inline float clkfreq() const;
  inline void set_clkfreq(float value);

  // optional int32 dacInterp = 4 [default = 16];
  inline bool has_dacinterp() const;
  inline void clear_dacinterp();
  static const int kDacInterpFieldNumber = 4;
  inline ::google::protobuf::int32 dacinterp() const;
  inline void set_dacinterp(::google::protobuf::int32 value);

  // optional int32 coreInterp = 5 [default = 1];
  inline bool has_coreinterp() const;
  inline void clear_coreinterp();
  static const int kCoreInterpFieldNumber = 5;
  inline ::google::protobuf::int32 coreinterp() const;
  inline void set_coreinterp(::google::protobuf::int32 value);

  // optional int32 baseChan = 6 [default = 1];
  inline bool has_basechan() const;
  inline void clear_basechan();
  static const int kBaseChanFieldNumber = 6;
  inline ::google::protobuf::int32 basechan() const;
  inline void set_basechan(::google::protobuf::int32 value);

  // optional int32 numBuffers = 7 [default = 2];
  inline bool has_numbuffers() const;
  inline void clear_numbuffers();
  static const int kNumBuffersFieldNumber = 7;
  inline ::google::protobuf::int32 numbuffers() const;
  inline void set_numbuffers(::google::protobuf::int32 value);

  // optional float freqShift = 8 [default = 0];
  inline bool has_freqshift() const;
  inline void clear_freqshift();
  static const int kFreqShiftFieldNumber = 8;
  inline float freqshift() const;
  inline void set_freqshift(float value);

  // optional string siggenIP = 9;
  inline bool has_siggenip() const;
  inline void clear_siggenip();
  static const int kSiggenIPFieldNumber = 9;
  inline const ::std::string& siggenip() const;
  inline void set_siggenip(const ::std::string& value);
  inline void set_siggenip(const char* value);
  inline void set_siggenip(const char* value, size_t size);
  inline ::std::string* mutable_siggenip();
  inline ::std::string* release_siggenip();
  inline void set_allocated_siggenip(::std::string* siggenip);

  // optional .fv.tb.protos.TBProtos.TransmitterConfig.SiggenType siggenType = 10 [default = ROHDE_SCHWARZ];
  inline bool has_siggentype() const;
  inline void clear_siggentype();
  static const int kSiggenTypeFieldNumber = 10;
  inline ::fv::tb::protos::TBProtos::TransmitterConfig_SiggenType siggentype() const;
  inline void set_siggentype(::fv::tb::protos::TBProtos::TransmitterConfig_SiggenType value);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.TransmitterConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_txname();
  inline void clear_has_txname();
  inline void set_has_clkfreq();
  inline void clear_has_clkfreq();
  inline void set_has_dacinterp();
  inline void clear_has_dacinterp();
  inline void set_has_coreinterp();
  inline void clear_has_coreinterp();
  inline void set_has_basechan();
  inline void clear_has_basechan();
  inline void set_has_numbuffers();
  inline void clear_has_numbuffers();
  inline void set_has_freqshift();
  inline void clear_has_freqshift();
  inline void set_has_siggenip();
  inline void clear_has_siggenip();
  inline void set_has_siggentype();
  inline void clear_has_siggentype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* txname_;
  float clkfreq_;
  ::google::protobuf::int32 dacinterp_;
  ::google::protobuf::int32 coreinterp_;
  ::google::protobuf::int32 basechan_;
  ::google::protobuf::int32 numbuffers_;
  float freqshift_;
  ::std::string* siggenip_;
  int siggentype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static TransmitterConfig* default_instance_;
};
// -------------------------------------------------------------------

class techniqueCommand : public ::google::protobuf::Message {
 public:
  techniqueCommand();
  virtual ~techniqueCommand();

  techniqueCommand(const techniqueCommand& from);

  inline techniqueCommand& operator=(const techniqueCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const techniqueCommand& default_instance();

  void Swap(techniqueCommand* other);

  // implements Message ----------------------------------------------

  techniqueCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const techniqueCommand& from);
  void MergeFrom(const techniqueCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef techniqueCommand_CommandType CommandType;
  static const CommandType TURNOFF = techniqueCommand_CommandType_TURNOFF;
  static const CommandType TURNON = techniqueCommand_CommandType_TURNON;
  static const CommandType UPDATE = techniqueCommand_CommandType_UPDATE;
  static const CommandType RESET = techniqueCommand_CommandType_RESET;
  static inline bool CommandType_IsValid(int value) {
    return techniqueCommand_CommandType_IsValid(value);
  }
  static const CommandType CommandType_MIN =
    techniqueCommand_CommandType_CommandType_MIN;
  static const CommandType CommandType_MAX =
    techniqueCommand_CommandType_CommandType_MAX;
  static const int CommandType_ARRAYSIZE =
    techniqueCommand_CommandType_CommandType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CommandType_descriptor() {
    return techniqueCommand_CommandType_descriptor();
  }
  static inline const ::std::string& CommandType_Name(CommandType value) {
    return techniqueCommand_CommandType_Name(value);
  }
  static inline bool CommandType_Parse(const ::std::string& name,
      CommandType* value) {
    return techniqueCommand_CommandType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "TECHNIQUECOMMAND"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional .fv.tb.protos.TBProtos.techniqueCommand.CommandType command = 2;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 2;
  inline ::fv::tb::protos::TBProtos::techniqueCommand_CommandType command() const;
  inline void set_command(::fv::tb::protos::TBProtos::techniqueCommand_CommandType value);

  // optional .fv.tb.protos.TBProtos.EWCapability ewcap = 3;
  inline bool has_ewcap() const;
  inline void clear_ewcap();
  static const int kEwcapFieldNumber = 3;
  inline const ::fv::tb::protos::TBProtos::EWCapability& ewcap() const;
  inline ::fv::tb::protos::TBProtos::EWCapability* mutable_ewcap();
  inline ::fv::tb::protos::TBProtos::EWCapability* release_ewcap();
  inline void set_allocated_ewcap(::fv::tb::protos::TBProtos::EWCapability* ewcap);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.techniqueCommand)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_ewcap();
  inline void clear_has_ewcap();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::fv::tb::protos::TBProtos::EWCapability* ewcap_;
  int command_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static techniqueCommand* default_instance_;
};
// -------------------------------------------------------------------

class newSignalFrame : public ::google::protobuf::Message {
 public:
  newSignalFrame();
  virtual ~newSignalFrame();

  newSignalFrame(const newSignalFrame& from);

  inline newSignalFrame& operator=(const newSignalFrame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const newSignalFrame& default_instance();

  void Swap(newSignalFrame* other);

  // implements Message ----------------------------------------------

  newSignalFrame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const newSignalFrame& from);
  void MergeFrom(const newSignalFrame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "NEWSIGNALFRAME"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string radioName = 2;
  inline bool has_radioname() const;
  inline void clear_radioname();
  static const int kRadioNameFieldNumber = 2;
  inline const ::std::string& radioname() const;
  inline void set_radioname(const ::std::string& value);
  inline void set_radioname(const char* value);
  inline void set_radioname(const char* value, size_t size);
  inline ::std::string* mutable_radioname();
  inline ::std::string* release_radioname();
  inline void set_allocated_radioname(::std::string* radioname);

  // optional int32 frameID = 3;
  inline bool has_frameid() const;
  inline void clear_frameid();
  static const int kFrameIDFieldNumber = 3;
  inline ::google::protobuf::int32 frameid() const;
  inline void set_frameid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.newSignalFrame)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_radioname();
  inline void clear_has_radioname();
  inline void set_has_frameid();
  inline void clear_has_frameid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* radioname_;
  ::google::protobuf::int32 frameid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static newSignalFrame* default_instance_;
};
// -------------------------------------------------------------------

class RegisterQuery : public ::google::protobuf::Message {
 public:
  RegisterQuery();
  virtual ~RegisterQuery();

  RegisterQuery(const RegisterQuery& from);

  inline RegisterQuery& operator=(const RegisterQuery& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterQuery& default_instance();

  void Swap(RegisterQuery* other);

  // implements Message ----------------------------------------------

  RegisterQuery* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterQuery& from);
  void MergeFrom(const RegisterQuery& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "REGISTERQUERY"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string sensorName = 2;
  inline bool has_sensorname() const;
  inline void clear_sensorname();
  static const int kSensorNameFieldNumber = 2;
  inline const ::std::string& sensorname() const;
  inline void set_sensorname(const ::std::string& value);
  inline void set_sensorname(const char* value);
  inline void set_sensorname(const char* value, size_t size);
  inline ::std::string* mutable_sensorname();
  inline ::std::string* release_sensorname();
  inline void set_allocated_sensorname(::std::string* sensorname);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.RegisterQuery)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_sensorname();
  inline void clear_has_sensorname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* sensorname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static RegisterQuery* default_instance_;
};
// -------------------------------------------------------------------

class RegisterRequest : public ::google::protobuf::Message {
 public:
  RegisterRequest();
  virtual ~RegisterRequest();

  RegisterRequest(const RegisterRequest& from);

  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterRequest& default_instance();

  void Swap(RegisterRequest* other);

  // implements Message ----------------------------------------------

  RegisterRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterRequest& from);
  void MergeFrom(const RegisterRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "REGISTERREQUEST"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string platformName = 2;
  inline bool has_platformname() const;
  inline void clear_platformname();
  static const int kPlatformNameFieldNumber = 2;
  inline const ::std::string& platformname() const;
  inline void set_platformname(const ::std::string& value);
  inline void set_platformname(const char* value);
  inline void set_platformname(const char* value, size_t size);
  inline ::std::string* mutable_platformname();
  inline ::std::string* release_platformname();
  inline void set_allocated_platformname(::std::string* platformname);

  // optional string techniqueName = 3;
  inline bool has_techniquename() const;
  inline void clear_techniquename();
  static const int kTechniqueNameFieldNumber = 3;
  inline const ::std::string& techniquename() const;
  inline void set_techniquename(const ::std::string& value);
  inline void set_techniquename(const char* value);
  inline void set_techniquename(const char* value, size_t size);
  inline ::std::string* mutable_techniquename();
  inline ::std::string* release_techniquename();
  inline void set_allocated_techniquename(::std::string* techniquename);

  // optional string tbUniqueID = 4;
  inline bool has_tbuniqueid() const;
  inline void clear_tbuniqueid();
  static const int kTbUniqueIDFieldNumber = 4;
  inline const ::std::string& tbuniqueid() const;
  inline void set_tbuniqueid(const ::std::string& value);
  inline void set_tbuniqueid(const char* value);
  inline void set_tbuniqueid(const char* value, size_t size);
  inline ::std::string* mutable_tbuniqueid();
  inline ::std::string* release_tbuniqueid();
  inline void set_allocated_tbuniqueid(::std::string* tbuniqueid);

  // optional string dataPipeName = 5;
  inline bool has_datapipename() const;
  inline void clear_datapipename();
  static const int kDataPipeNameFieldNumber = 5;
  inline const ::std::string& datapipename() const;
  inline void set_datapipename(const ::std::string& value);
  inline void set_datapipename(const char* value);
  inline void set_datapipename(const char* value, size_t size);
  inline ::std::string* mutable_datapipename();
  inline ::std::string* release_datapipename();
  inline void set_allocated_datapipename(::std::string* datapipename);

  // optional string metaPipeName = 6;
  inline bool has_metapipename() const;
  inline void clear_metapipename();
  static const int kMetaPipeNameFieldNumber = 6;
  inline const ::std::string& metapipename() const;
  inline void set_metapipename(const ::std::string& value);
  inline void set_metapipename(const char* value);
  inline void set_metapipename(const char* value, size_t size);
  inline ::std::string* mutable_metapipename();
  inline ::std::string* release_metapipename();
  inline void set_allocated_metapipename(::std::string* metapipename);

  // optional string techniqueDescription = 7;
  inline bool has_techniquedescription() const;
  inline void clear_techniquedescription();
  static const int kTechniqueDescriptionFieldNumber = 7;
  inline const ::std::string& techniquedescription() const;
  inline void set_techniquedescription(const ::std::string& value);
  inline void set_techniquedescription(const char* value);
  inline void set_techniquedescription(const char* value, size_t size);
  inline ::std::string* mutable_techniquedescription();
  inline ::std::string* release_techniquedescription();
  inline void set_allocated_techniquedescription(::std::string* techniquedescription);

  // optional int32 numberOfZPipePorts = 8 [default = 1];
  inline bool has_numberofzpipeports() const;
  inline void clear_numberofzpipeports();
  static const int kNumberOfZPipePortsFieldNumber = 8;
  inline ::google::protobuf::int32 numberofzpipeports() const;
  inline void set_numberofzpipeports(::google::protobuf::int32 value);

  // optional string sensorName = 9;
  inline bool has_sensorname() const;
  inline void clear_sensorname();
  static const int kSensorNameFieldNumber = 9;
  inline const ::std::string& sensorname() const;
  inline void set_sensorname(const ::std::string& value);
  inline void set_sensorname(const char* value);
  inline void set_sensorname(const char* value, size_t size);
  inline ::std::string* mutable_sensorname();
  inline ::std::string* release_sensorname();
  inline void set_allocated_sensorname(::std::string* sensorname);

  // optional float estimatedCenterFreqMHz = 10;
  inline bool has_estimatedcenterfreqmhz() const;
  inline void clear_estimatedcenterfreqmhz();
  static const int kEstimatedCenterFreqMHzFieldNumber = 10;
  inline float estimatedcenterfreqmhz() const;
  inline void set_estimatedcenterfreqmhz(float value);

  // optional int32 overrideChannel = 11 [default = -1];
  inline bool has_overridechannel() const;
  inline void clear_overridechannel();
  static const int kOverrideChannelFieldNumber = 11;
  inline ::google::protobuf::int32 overridechannel() const;
  inline void set_overridechannel(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.RegisterRequest)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_platformname();
  inline void clear_has_platformname();
  inline void set_has_techniquename();
  inline void clear_has_techniquename();
  inline void set_has_tbuniqueid();
  inline void clear_has_tbuniqueid();
  inline void set_has_datapipename();
  inline void clear_has_datapipename();
  inline void set_has_metapipename();
  inline void clear_has_metapipename();
  inline void set_has_techniquedescription();
  inline void clear_has_techniquedescription();
  inline void set_has_numberofzpipeports();
  inline void clear_has_numberofzpipeports();
  inline void set_has_sensorname();
  inline void clear_has_sensorname();
  inline void set_has_estimatedcenterfreqmhz();
  inline void clear_has_estimatedcenterfreqmhz();
  inline void set_has_overridechannel();
  inline void clear_has_overridechannel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* platformname_;
  ::std::string* techniquename_;
  ::std::string* tbuniqueid_;
  ::std::string* datapipename_;
  ::std::string* metapipename_;
  ::std::string* techniquedescription_;
  ::std::string* sensorname_;
  ::google::protobuf::int32 numberofzpipeports_;
  float estimatedcenterfreqmhz_;
  ::google::protobuf::int32 overridechannel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static RegisterRequest* default_instance_;
};
// -------------------------------------------------------------------

class UnregisterRequest : public ::google::protobuf::Message {
 public:
  UnregisterRequest();
  virtual ~UnregisterRequest();

  UnregisterRequest(const UnregisterRequest& from);

  inline UnregisterRequest& operator=(const UnregisterRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnregisterRequest& default_instance();

  void Swap(UnregisterRequest* other);

  // implements Message ----------------------------------------------

  UnregisterRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnregisterRequest& from);
  void MergeFrom(const UnregisterRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "UNREGISTERREQUEST"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string tbUniqueID = 2;
  inline bool has_tbuniqueid() const;
  inline void clear_tbuniqueid();
  static const int kTbUniqueIDFieldNumber = 2;
  inline const ::std::string& tbuniqueid() const;
  inline void set_tbuniqueid(const ::std::string& value);
  inline void set_tbuniqueid(const char* value);
  inline void set_tbuniqueid(const char* value, size_t size);
  inline ::std::string* mutable_tbuniqueid();
  inline ::std::string* release_tbuniqueid();
  inline void set_allocated_tbuniqueid(::std::string* tbuniqueid);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.UnregisterRequest)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_tbuniqueid();
  inline void clear_has_tbuniqueid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* tbuniqueid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static UnregisterRequest* default_instance_;
};
// -------------------------------------------------------------------

class RegisterResponse : public ::google::protobuf::Message {
 public:
  RegisterResponse();
  virtual ~RegisterResponse();

  RegisterResponse(const RegisterResponse& from);

  inline RegisterResponse& operator=(const RegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterResponse& default_instance();

  void Swap(RegisterResponse* other);

  // implements Message ----------------------------------------------

  RegisterResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterResponse& from);
  void MergeFrom(const RegisterResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "REGISTERRESPONSE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string idNum = 2;
  inline bool has_idnum() const;
  inline void clear_idnum();
  static const int kIdNumFieldNumber = 2;
  inline const ::std::string& idnum() const;
  inline void set_idnum(const ::std::string& value);
  inline void set_idnum(const char* value);
  inline void set_idnum(const char* value, size_t size);
  inline ::std::string* mutable_idnum();
  inline ::std::string* release_idnum();
  inline void set_allocated_idnum(::std::string* idnum);

  // repeated int32 ports = 3;
  inline int ports_size() const;
  inline void clear_ports();
  static const int kPortsFieldNumber = 3;
  inline ::google::protobuf::int32 ports(int index) const;
  inline void set_ports(int index, ::google::protobuf::int32 value);
  inline void add_ports(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      ports() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_ports();

  // optional float sampleRateSps = 4;
  inline bool has_sampleratesps() const;
  inline void clear_sampleratesps();
  static const int kSampleRateSpsFieldNumber = 4;
  inline float sampleratesps() const;
  inline void set_sampleratesps(float value);

  // optional float minFreqMHz = 5 [default = 20];
  inline bool has_minfreqmhz() const;
  inline void clear_minfreqmhz();
  static const int kMinFreqMHzFieldNumber = 5;
  inline float minfreqmhz() const;
  inline void set_minfreqmhz(float value);

  // optional float maxFreqMHz = 6 [default = 6000];
  inline bool has_maxfreqmhz() const;
  inline void clear_maxfreqmhz();
  static const int kMaxFreqMHzFieldNumber = 6;
  inline float maxfreqmhz() const;
  inline void set_maxfreqmhz(float value);

  // optional int32 assignedChannel = 7;
  inline bool has_assignedchannel() const;
  inline void clear_assignedchannel();
  static const int kAssignedChannelFieldNumber = 7;
  inline ::google::protobuf::int32 assignedchannel() const;
  inline void set_assignedchannel(::google::protobuf::int32 value);

  // optional string sensorName = 9;
  inline bool has_sensorname() const;
  inline void clear_sensorname();
  static const int kSensorNameFieldNumber = 9;
  inline const ::std::string& sensorname() const;
  inline void set_sensorname(const ::std::string& value);
  inline void set_sensorname(const char* value);
  inline void set_sensorname(const char* value, size_t size);
  inline ::std::string* mutable_sensorname();
  inline ::std::string* release_sensorname();
  inline void set_allocated_sensorname(::std::string* sensorname);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.RegisterResponse)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_idnum();
  inline void clear_has_idnum();
  inline void set_has_sampleratesps();
  inline void clear_has_sampleratesps();
  inline void set_has_minfreqmhz();
  inline void clear_has_minfreqmhz();
  inline void set_has_maxfreqmhz();
  inline void clear_has_maxfreqmhz();
  inline void set_has_assignedchannel();
  inline void clear_has_assignedchannel();
  inline void set_has_sensorname();
  inline void clear_has_sensorname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* idnum_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > ports_;
  float sampleratesps_;
  float minfreqmhz_;
  float maxfreqmhz_;
  ::google::protobuf::int32 assignedchannel_;
  ::std::string* sensorname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static RegisterResponse* default_instance_;
};
// -------------------------------------------------------------------

class HopAttackStatus : public ::google::protobuf::Message {
 public:
  HopAttackStatus();
  virtual ~HopAttackStatus();

  HopAttackStatus(const HopAttackStatus& from);

  inline HopAttackStatus& operator=(const HopAttackStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HopAttackStatus& default_instance();

  void Swap(HopAttackStatus* other);

  // implements Message ----------------------------------------------

  HopAttackStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HopAttackStatus& from);
  void MergeFrom(const HopAttackStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "HOPATTACKSTATUS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string platform = 2;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 2;
  inline const ::std::string& platform() const;
  inline void set_platform(const ::std::string& value);
  inline void set_platform(const char* value);
  inline void set_platform(const char* value, size_t size);
  inline ::std::string* mutable_platform();
  inline ::std::string* release_platform();
  inline void set_allocated_platform(::std::string* platform);

  // optional int32 totalhops = 3;
  inline bool has_totalhops() const;
  inline void clear_totalhops();
  static const int kTotalhopsFieldNumber = 3;
  inline ::google::protobuf::int32 totalhops() const;
  inline void set_totalhops(::google::protobuf::int32 value);

  // optional int32 goodhops = 4;
  inline bool has_goodhops() const;
  inline void clear_goodhops();
  static const int kGoodhopsFieldNumber = 4;
  inline ::google::protobuf::int32 goodhops() const;
  inline void set_goodhops(::google::protobuf::int32 value);

  // optional float percentage = 5;
  inline bool has_percentage() const;
  inline void clear_percentage();
  static const int kPercentageFieldNumber = 5;
  inline float percentage() const;
  inline void set_percentage(float value);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.HopAttackStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_totalhops();
  inline void clear_has_totalhops();
  inline void set_has_goodhops();
  inline void clear_has_goodhops();
  inline void set_has_percentage();
  inline void clear_has_percentage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* platform_;
  ::google::protobuf::int32 totalhops_;
  ::google::protobuf::int32 goodhops_;
  float percentage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static HopAttackStatus* default_instance_;
};
// -------------------------------------------------------------------

class TxFreqRequest : public ::google::protobuf::Message {
 public:
  TxFreqRequest();
  virtual ~TxFreqRequest();

  TxFreqRequest(const TxFreqRequest& from);

  inline TxFreqRequest& operator=(const TxFreqRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxFreqRequest& default_instance();

  void Swap(TxFreqRequest* other);

  // implements Message ----------------------------------------------

  TxFreqRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxFreqRequest& from);
  void MergeFrom(const TxFreqRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "TXFREQREQUEST"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional float freqHz = 2;
  inline bool has_freqhz() const;
  inline void clear_freqhz();
  static const int kFreqHzFieldNumber = 2;
  inline float freqhz() const;
  inline void set_freqhz(float value);

  // optional string globalID = 3;
  inline bool has_globalid() const;
  inline void clear_globalid();
  static const int kGlobalIDFieldNumber = 3;
  inline const ::std::string& globalid() const;
  inline void set_globalid(const ::std::string& value);
  inline void set_globalid(const char* value);
  inline void set_globalid(const char* value, size_t size);
  inline ::std::string* mutable_globalid();
  inline ::std::string* release_globalid();
  inline void set_allocated_globalid(::std::string* globalid);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.TxFreqRequest)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_freqhz();
  inline void clear_has_freqhz();
  inline void set_has_globalid();
  inline void clear_has_globalid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* globalid_;
  float freqhz_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static TxFreqRequest* default_instance_;
};
// -------------------------------------------------------------------

class EmergencyJam : public ::google::protobuf::Message {
 public:
  EmergencyJam();
  virtual ~EmergencyJam();

  EmergencyJam(const EmergencyJam& from);

  inline EmergencyJam& operator=(const EmergencyJam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmergencyJam& default_instance();

  void Swap(EmergencyJam* other);

  // implements Message ----------------------------------------------

  EmergencyJam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmergencyJam& from);
  void MergeFrom(const EmergencyJam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EMERGENCYJAM"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional double centerFreq = 2 [default = 2440];
  inline bool has_centerfreq() const;
  inline void clear_centerfreq();
  static const int kCenterFreqFieldNumber = 2;
  inline double centerfreq() const;
  inline void set_centerfreq(double value);

  // optional double bandwidth = 3 [default = 84];
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandwidthFieldNumber = 3;
  inline double bandwidth() const;
  inline void set_bandwidth(double value);

  // optional int32 targetID = 4 [default = -1];
  inline bool has_targetid() const;
  inline void clear_targetid();
  static const int kTargetIDFieldNumber = 4;
  inline ::google::protobuf::int32 targetid() const;
  inline void set_targetid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.EmergencyJam)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_centerfreq();
  inline void clear_has_centerfreq();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();
  inline void set_has_targetid();
  inline void clear_has_targetid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  double centerfreq_;
  double bandwidth_;
  ::google::protobuf::int32 targetid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static EmergencyJam* default_instance_;
};
// -------------------------------------------------------------------

class JamOff : public ::google::protobuf::Message {
 public:
  JamOff();
  virtual ~JamOff();

  JamOff(const JamOff& from);

  inline JamOff& operator=(const JamOff& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JamOff& default_instance();

  void Swap(JamOff* other);

  // implements Message ----------------------------------------------

  JamOff* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JamOff& from);
  void MergeFrom(const JamOff& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "JAMOFF"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 targetID = 4 [default = -1];
  inline bool has_targetid() const;
  inline void clear_targetid();
  static const int kTargetIDFieldNumber = 4;
  inline ::google::protobuf::int32 targetid() const;
  inline void set_targetid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.JamOff)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_targetid();
  inline void clear_has_targetid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 targetid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static JamOff* default_instance_;
};
// -------------------------------------------------------------------

class EWSDRRequest : public ::google::protobuf::Message {
 public:
  EWSDRRequest();
  virtual ~EWSDRRequest();

  EWSDRRequest(const EWSDRRequest& from);

  inline EWSDRRequest& operator=(const EWSDRRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EWSDRRequest& default_instance();

  void Swap(EWSDRRequest* other);

  // implements Message ----------------------------------------------

  EWSDRRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EWSDRRequest& from);
  void MergeFrom(const EWSDRRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fv.tb.protos.TBProtos.Aperture aperture = 1;
  inline int aperture_size() const;
  inline void clear_aperture();
  static const int kApertureFieldNumber = 1;
  inline const ::fv::tb::protos::TBProtos::Aperture& aperture(int index) const;
  inline ::fv::tb::protos::TBProtos::Aperture* mutable_aperture(int index);
  inline ::fv::tb::protos::TBProtos::Aperture* add_aperture();
  inline const ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Aperture >&
      aperture() const;
  inline ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Aperture >*
      mutable_aperture();

  // repeated .fv.tb.protos.TBProtos.Transceiver transceiver = 2;
  inline int transceiver_size() const;
  inline void clear_transceiver();
  static const int kTransceiverFieldNumber = 2;
  inline const ::fv::tb::protos::TBProtos::Transceiver& transceiver(int index) const;
  inline ::fv::tb::protos::TBProtos::Transceiver* mutable_transceiver(int index);
  inline ::fv::tb::protos::TBProtos::Transceiver* add_transceiver();
  inline const ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Transceiver >&
      transceiver() const;
  inline ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Transceiver >*
      mutable_transceiver();

  // optional string guid = 3;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 3;
  inline const ::std::string& guid() const;
  inline void set_guid(const ::std::string& value);
  inline void set_guid(const char* value);
  inline void set_guid(const char* value, size_t size);
  inline ::std::string* mutable_guid();
  inline ::std::string* release_guid();
  inline void set_allocated_guid(::std::string* guid);

  // optional int32 priority = 4;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 4;
  inline ::google::protobuf::int32 priority() const;
  inline void set_priority(::google::protobuf::int32 value);

  // optional bool enabled = 5;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 5;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.EWSDRRequest)
 private:
  inline void set_has_guid();
  inline void clear_has_guid();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_enabled();
  inline void clear_has_enabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Aperture > aperture_;
  ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Transceiver > transceiver_;
  ::std::string* guid_;
  ::google::protobuf::int32 priority_;
  bool enabled_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static EWSDRRequest* default_instance_;
};
// -------------------------------------------------------------------

class EWSDRCommand : public ::google::protobuf::Message {
 public:
  EWSDRCommand();
  virtual ~EWSDRCommand();

  EWSDRCommand(const EWSDRCommand& from);

  inline EWSDRCommand& operator=(const EWSDRCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EWSDRCommand& default_instance();

  void Swap(EWSDRCommand* other);

  // implements Message ----------------------------------------------

  EWSDRCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EWSDRCommand& from);
  void MergeFrom(const EWSDRCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fv.tb.protos.TBProtos.Aperture aperture = 1;
  inline int aperture_size() const;
  inline void clear_aperture();
  static const int kApertureFieldNumber = 1;
  inline const ::fv::tb::protos::TBProtos::Aperture& aperture(int index) const;
  inline ::fv::tb::protos::TBProtos::Aperture* mutable_aperture(int index);
  inline ::fv::tb::protos::TBProtos::Aperture* add_aperture();
  inline const ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Aperture >&
      aperture() const;
  inline ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Aperture >*
      mutable_aperture();

  // repeated .fv.tb.protos.TBProtos.Transceiver transceiver = 2;
  inline int transceiver_size() const;
  inline void clear_transceiver();
  static const int kTransceiverFieldNumber = 2;
  inline const ::fv::tb::protos::TBProtos::Transceiver& transceiver(int index) const;
  inline ::fv::tb::protos::TBProtos::Transceiver* mutable_transceiver(int index);
  inline ::fv::tb::protos::TBProtos::Transceiver* add_transceiver();
  inline const ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Transceiver >&
      transceiver() const;
  inline ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Transceiver >*
      mutable_transceiver();

  // optional string guid = 3;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 3;
  inline const ::std::string& guid() const;
  inline void set_guid(const ::std::string& value);
  inline void set_guid(const char* value);
  inline void set_guid(const char* value, size_t size);
  inline ::std::string* mutable_guid();
  inline ::std::string* release_guid();
  inline void set_allocated_guid(::std::string* guid);

  // optional int32 priority = 4;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 4;
  inline ::google::protobuf::int32 priority() const;
  inline void set_priority(::google::protobuf::int32 value);

  // optional bool enabled = 5;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 5;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.EWSDRCommand)
 private:
  inline void set_has_guid();
  inline void clear_has_guid();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_enabled();
  inline void clear_has_enabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Aperture > aperture_;
  ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Transceiver > transceiver_;
  ::std::string* guid_;
  ::google::protobuf::int32 priority_;
  bool enabled_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static EWSDRCommand* default_instance_;
};
// -------------------------------------------------------------------

class Aperture : public ::google::protobuf::Message {
 public:
  Aperture();
  virtual ~Aperture();

  Aperture(const Aperture& from);

  inline Aperture& operator=(const Aperture& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Aperture& default_instance();

  void Swap(Aperture* other);

  // implements Message ----------------------------------------------

  Aperture* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Aperture& from);
  void MergeFrom(const Aperture& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 antenna = 1;
  inline bool has_antenna() const;
  inline void clear_antenna();
  static const int kAntennaFieldNumber = 1;
  inline ::google::protobuf::int32 antenna() const;
  inline void set_antenna(::google::protobuf::int32 value);

  // optional float azimuth = 2;
  inline bool has_azimuth() const;
  inline void clear_azimuth();
  static const int kAzimuthFieldNumber = 2;
  inline float azimuth() const;
  inline void set_azimuth(float value);

  // optional float elevation = 3;
  inline bool has_elevation() const;
  inline void clear_elevation();
  static const int kElevationFieldNumber = 3;
  inline float elevation() const;
  inline void set_elevation(float value);

  // optional int32 polarization = 4;
  inline bool has_polarization() const;
  inline void clear_polarization();
  static const int kPolarizationFieldNumber = 4;
  inline ::google::protobuf::int32 polarization() const;
  inline void set_polarization(::google::protobuf::int32 value);

  // optional int32 priority = 5 [default = 100];
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 5;
  inline ::google::protobuf::int32 priority() const;
  inline void set_priority(::google::protobuf::int32 value);

  // optional string guid = 6 [default = "UNSPECIFIED"];
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 6;
  inline const ::std::string& guid() const;
  inline void set_guid(const ::std::string& value);
  inline void set_guid(const char* value);
  inline void set_guid(const char* value, size_t size);
  inline ::std::string* mutable_guid();
  inline ::std::string* release_guid();
  inline void set_allocated_guid(::std::string* guid);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.Aperture)
 private:
  inline void set_has_antenna();
  inline void clear_has_antenna();
  inline void set_has_azimuth();
  inline void clear_has_azimuth();
  inline void set_has_elevation();
  inline void clear_has_elevation();
  inline void set_has_polarization();
  inline void clear_has_polarization();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_guid();
  inline void clear_has_guid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 antenna_;
  float azimuth_;
  float elevation_;
  ::google::protobuf::int32 polarization_;
  ::std::string* guid_;
  static ::std::string* _default_guid_;
  ::google::protobuf::int32 priority_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static Aperture* default_instance_;
};
// -------------------------------------------------------------------

class Transceiver : public ::google::protobuf::Message {
 public:
  Transceiver();
  virtual ~Transceiver();

  Transceiver(const Transceiver& from);

  inline Transceiver& operator=(const Transceiver& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Transceiver& default_instance();

  void Swap(Transceiver* other);

  // implements Message ----------------------------------------------

  Transceiver* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Transceiver& from);
  void MergeFrom(const Transceiver& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 transceiver = 1;
  inline bool has_transceiver() const;
  inline void clear_transceiver();
  static const int kTransceiverFieldNumber = 1;
  inline ::google::protobuf::int32 transceiver() const;
  inline void set_transceiver(::google::protobuf::int32 value);

  // optional int32 channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional float freqMHz = 3;
  inline bool has_freqmhz() const;
  inline void clear_freqmhz();
  static const int kFreqMHzFieldNumber = 3;
  inline float freqmhz() const;
  inline void set_freqmhz(float value);

  // optional int32 gainDB = 4;
  inline bool has_gaindb() const;
  inline void clear_gaindb();
  static const int kGainDBFieldNumber = 4;
  inline ::google::protobuf::int32 gaindb() const;
  inline void set_gaindb(::google::protobuf::int32 value);

  // optional int32 priority = 5 [default = 100];
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 5;
  inline ::google::protobuf::int32 priority() const;
  inline void set_priority(::google::protobuf::int32 value);

  // optional string guid = 6 [default = "UNSPECIFIED"];
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 6;
  inline const ::std::string& guid() const;
  inline void set_guid(const ::std::string& value);
  inline void set_guid(const char* value);
  inline void set_guid(const char* value, size_t size);
  inline ::std::string* mutable_guid();
  inline ::std::string* release_guid();
  inline void set_allocated_guid(::std::string* guid);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.Transceiver)
 private:
  inline void set_has_transceiver();
  inline void clear_has_transceiver();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_freqmhz();
  inline void clear_has_freqmhz();
  inline void set_has_gaindb();
  inline void clear_has_gaindb();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_guid();
  inline void clear_has_guid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 transceiver_;
  ::google::protobuf::int32 channel_;
  float freqmhz_;
  ::google::protobuf::int32 gaindb_;
  ::std::string* guid_;
  static ::std::string* _default_guid_;
  ::google::protobuf::int32 priority_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static Transceiver* default_instance_;
};
// -------------------------------------------------------------------

class ThreatStatus : public ::google::protobuf::Message {
 public:
  ThreatStatus();
  virtual ~ThreatStatus();

  ThreatStatus(const ThreatStatus& from);

  inline ThreatStatus& operator=(const ThreatStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ThreatStatus& default_instance();

  void Swap(ThreatStatus* other);

  // implements Message ----------------------------------------------

  ThreatStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ThreatStatus& from);
  void MergeFrom(const ThreatStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .falcon_common_msg.KeyValuePair kvps = 1;
  inline int kvps_size() const;
  inline void clear_kvps();
  static const int kKvpsFieldNumber = 1;
  inline const ::falcon_common_msg::KeyValuePair& kvps(int index) const;
  inline ::falcon_common_msg::KeyValuePair* mutable_kvps(int index);
  inline ::falcon_common_msg::KeyValuePair* add_kvps();
  inline const ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::KeyValuePair >&
      kvps() const;
  inline ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::KeyValuePair >*
      mutable_kvps();

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.ThreatStatus)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::KeyValuePair > kvps_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static ThreatStatus* default_instance_;
};
// -------------------------------------------------------------------

class EWSDRStatus : public ::google::protobuf::Message {
 public:
  EWSDRStatus();
  virtual ~EWSDRStatus();

  EWSDRStatus(const EWSDRStatus& from);

  inline EWSDRStatus& operator=(const EWSDRStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EWSDRStatus& default_instance();

  void Swap(EWSDRStatus* other);

  // implements Message ----------------------------------------------

  EWSDRStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EWSDRStatus& from);
  void MergeFrom(const EWSDRStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fv.tb.protos.TBProtos.Aperture apertures = 1;
  inline int apertures_size() const;
  inline void clear_apertures();
  static const int kAperturesFieldNumber = 1;
  inline const ::fv::tb::protos::TBProtos::Aperture& apertures(int index) const;
  inline ::fv::tb::protos::TBProtos::Aperture* mutable_apertures(int index);
  inline ::fv::tb::protos::TBProtos::Aperture* add_apertures();
  inline const ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Aperture >&
      apertures() const;
  inline ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Aperture >*
      mutable_apertures();

  // repeated .fv.tb.protos.TBProtos.Transceiver transceivers = 2;
  inline int transceivers_size() const;
  inline void clear_transceivers();
  static const int kTransceiversFieldNumber = 2;
  inline const ::fv::tb::protos::TBProtos::Transceiver& transceivers(int index) const;
  inline ::fv::tb::protos::TBProtos::Transceiver* mutable_transceivers(int index);
  inline ::fv::tb::protos::TBProtos::Transceiver* add_transceivers();
  inline const ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Transceiver >&
      transceivers() const;
  inline ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Transceiver >*
      mutable_transceivers();

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.EWSDRStatus)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Aperture > apertures_;
  ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Transceiver > transceivers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static EWSDRStatus* default_instance_;
};
// -------------------------------------------------------------------

class SetAppParameters : public ::google::protobuf::Message {
 public:
  SetAppParameters();
  virtual ~SetAppParameters();

  SetAppParameters(const SetAppParameters& from);

  inline SetAppParameters& operator=(const SetAppParameters& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetAppParameters& default_instance();

  void Swap(SetAppParameters* other);

  // implements Message ----------------------------------------------

  SetAppParameters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetAppParameters& from);
  void MergeFrom(const SetAppParameters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string eltex = 1;
  inline bool has_eltex() const;
  inline void clear_eltex();
  static const int kEltexFieldNumber = 1;
  inline const ::std::string& eltex() const;
  inline void set_eltex(const ::std::string& value);
  inline void set_eltex(const char* value);
  inline void set_eltex(const char* value, size_t size);
  inline ::std::string* mutable_eltex();
  inline ::std::string* release_eltex();
  inline void set_allocated_eltex(::std::string* eltex);

  // optional string soiNum = 2;
  inline bool has_soinum() const;
  inline void clear_soinum();
  static const int kSoiNumFieldNumber = 2;
  inline const ::std::string& soinum() const;
  inline void set_soinum(const ::std::string& value);
  inline void set_soinum(const char* value);
  inline void set_soinum(const char* value, size_t size);
  inline ::std::string* mutable_soinum();
  inline ::std::string* release_soinum();
  inline void set_allocated_soinum(::std::string* soinum);

  // optional string globalID = 3;
  inline bool has_globalid() const;
  inline void clear_globalid();
  static const int kGlobalIDFieldNumber = 3;
  inline const ::std::string& globalid() const;
  inline void set_globalid(const ::std::string& value);
  inline void set_globalid(const char* value);
  inline void set_globalid(const char* value, size_t size);
  inline ::std::string* mutable_globalid();
  inline ::std::string* release_globalid();
  inline void set_allocated_globalid(::std::string* globalid);

  // optional int32 appID = 4;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 4;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional string sensorName = 5;
  inline bool has_sensorname() const;
  inline void clear_sensorname();
  static const int kSensorNameFieldNumber = 5;
  inline const ::std::string& sensorname() const;
  inline void set_sensorname(const ::std::string& value);
  inline void set_sensorname(const char* value);
  inline void set_sensorname(const char* value, size_t size);
  inline ::std::string* mutable_sensorname();
  inline ::std::string* release_sensorname();
  inline void set_allocated_sensorname(::std::string* sensorname);

  // optional int32 superPriority = 6;
  inline bool has_superpriority() const;
  inline void clear_superpriority();
  static const int kSuperPriorityFieldNumber = 6;
  inline ::google::protobuf::int32 superpriority() const;
  inline void set_superpriority(::google::protobuf::int32 value);

  // repeated .fv.tb.protos.TBProtos.Aperture aperture = 7;
  inline int aperture_size() const;
  inline void clear_aperture();
  static const int kApertureFieldNumber = 7;
  inline const ::fv::tb::protos::TBProtos::Aperture& aperture(int index) const;
  inline ::fv::tb::protos::TBProtos::Aperture* mutable_aperture(int index);
  inline ::fv::tb::protos::TBProtos::Aperture* add_aperture();
  inline const ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Aperture >&
      aperture() const;
  inline ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Aperture >*
      mutable_aperture();

  // repeated .fv.tb.protos.TBProtos.Transceiver transceiver = 8;
  inline int transceiver_size() const;
  inline void clear_transceiver();
  static const int kTransceiverFieldNumber = 8;
  inline const ::fv::tb::protos::TBProtos::Transceiver& transceiver(int index) const;
  inline ::fv::tb::protos::TBProtos::Transceiver* mutable_transceiver(int index);
  inline ::fv::tb::protos::TBProtos::Transceiver* add_transceiver();
  inline const ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Transceiver >&
      transceiver() const;
  inline ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Transceiver >*
      mutable_transceiver();

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.SetAppParameters)
 private:
  inline void set_has_eltex();
  inline void clear_has_eltex();
  inline void set_has_soinum();
  inline void clear_has_soinum();
  inline void set_has_globalid();
  inline void clear_has_globalid();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_sensorname();
  inline void clear_has_sensorname();
  inline void set_has_superpriority();
  inline void clear_has_superpriority();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* eltex_;
  ::std::string* soinum_;
  ::std::string* globalid_;
  ::std::string* sensorname_;
  ::google::protobuf::int32 appid_;
  ::google::protobuf::int32 superpriority_;
  ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Aperture > aperture_;
  ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Transceiver > transceiver_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static SetAppParameters* default_instance_;
};
// -------------------------------------------------------------------

class MissionMode : public ::google::protobuf::Message {
 public:
  MissionMode();
  virtual ~MissionMode();

  MissionMode(const MissionMode& from);

  inline MissionMode& operator=(const MissionMode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MissionMode& default_instance();

  void Swap(MissionMode* other);

  // implements Message ----------------------------------------------

  MissionMode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MissionMode& from);
  void MergeFrom(const MissionMode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MissionMode_Mode Mode;
  static const Mode SEARCH = MissionMode_Mode_SEARCH;
  static const Mode AUTO = MissionMode_Mode_AUTO;
  static const Mode TRACE = MissionMode_Mode_TRACE;
  static inline bool Mode_IsValid(int value) {
    return MissionMode_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    MissionMode_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    MissionMode_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    MissionMode_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Mode_descriptor() {
    return MissionMode_Mode_descriptor();
  }
  static inline const ::std::string& Mode_Name(Mode value) {
    return MissionMode_Mode_Name(value);
  }
  static inline bool Mode_Parse(const ::std::string& name,
      Mode* value) {
    return MissionMode_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .fv.tb.protos.TBProtos.MissionMode.Mode mode = 1;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline ::fv::tb::protos::TBProtos::MissionMode_Mode mode() const;
  inline void set_mode(::fv::tb::protos::TBProtos::MissionMode_Mode value);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.MissionMode)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static MissionMode* default_instance_;
};
// -------------------------------------------------------------------

class SignalEvent : public ::google::protobuf::Message {
 public:
  SignalEvent();
  virtual ~SignalEvent();

  SignalEvent(const SignalEvent& from);

  inline SignalEvent& operator=(const SignalEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignalEvent& default_instance();

  void Swap(SignalEvent* other);

  // implements Message ----------------------------------------------

  SignalEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignalEvent& from);
  void MergeFrom(const SignalEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SignalEvent_Type Type;
  static const Type SIGDET = SignalEvent_Type_SIGDET;
  static const Type SIGUP = SignalEvent_Type_SIGUP;
  static const Type SIGDOWN = SignalEvent_Type_SIGDOWN;
  static const Type SIGTIMEOUT = SignalEvent_Type_SIGTIMEOUT;
  static inline bool Type_IsValid(int value) {
    return SignalEvent_Type_IsValid(value);
  }
  static const Type Type_MIN =
    SignalEvent_Type_Type_MIN;
  static const Type Type_MAX =
    SignalEvent_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    SignalEvent_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return SignalEvent_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return SignalEvent_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return SignalEvent_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SIGNAL_EVENT"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional .fv.tb.protos.TBProtos.SignalEvent.Type eventType = 3;
  inline bool has_eventtype() const;
  inline void clear_eventtype();
  static const int kEventTypeFieldNumber = 3;
  inline ::fv::tb::protos::TBProtos::SignalEvent_Type eventtype() const;
  inline void set_eventtype(::fv::tb::protos::TBProtos::SignalEvent_Type value);

  // optional string eventID = 4;
  inline bool has_eventid() const;
  inline void clear_eventid();
  static const int kEventIDFieldNumber = 4;
  inline const ::std::string& eventid() const;
  inline void set_eventid(const ::std::string& value);
  inline void set_eventid(const char* value);
  inline void set_eventid(const char* value, size_t size);
  inline ::std::string* mutable_eventid();
  inline ::std::string* release_eventid();
  inline void set_allocated_eventid(::std::string* eventid);

  // optional string timestamp = 5;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  inline void set_allocated_timestamp(::std::string* timestamp);

  // optional string soiNum = 6;
  inline bool has_soinum() const;
  inline void clear_soinum();
  static const int kSoiNumFieldNumber = 6;
  inline const ::std::string& soinum() const;
  inline void set_soinum(const ::std::string& value);
  inline void set_soinum(const char* value);
  inline void set_soinum(const char* value, size_t size);
  inline ::std::string* mutable_soinum();
  inline ::std::string* release_soinum();
  inline void set_allocated_soinum(::std::string* soinum);

  // optional float rfMHz = 7;
  inline bool has_rfmhz() const;
  inline void clear_rfmhz();
  static const int kRfMHzFieldNumber = 7;
  inline float rfmhz() const;
  inline void set_rfmhz(float value);

  // optional float subcarMHz = 8;
  inline bool has_subcarmhz() const;
  inline void clear_subcarmhz();
  static const int kSubcarMHzFieldNumber = 8;
  inline float subcarmhz() const;
  inline void set_subcarmhz(float value);

  // optional float excurKHz = 9;
  inline bool has_excurkhz() const;
  inline void clear_excurkhz();
  static const int kExcurKHzFieldNumber = 9;
  inline float excurkhz() const;
  inline void set_excurkhz(float value);

  // optional int32 appID = 10;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 10;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional int32 antNum = 11;
  inline bool has_antnum() const;
  inline void clear_antnum();
  static const int kAntNumFieldNumber = 11;
  inline ::google::protobuf::int32 antnum() const;
  inline void set_antnum(::google::protobuf::int32 value);

  // optional float antAz = 12 [default = 0];
  inline bool has_antaz() const;
  inline void clear_antaz();
  static const int kAntAzFieldNumber = 12;
  inline float antaz() const;
  inline void set_antaz(float value);

  // optional float antEl = 13 [default = 0];
  inline bool has_antel() const;
  inline void clear_antel();
  static const int kAntElFieldNumber = 13;
  inline float antel() const;
  inline void set_antel(float value);

  // optional string globalID = 14;
  inline bool has_globalid() const;
  inline void clear_globalid();
  static const int kGlobalIDFieldNumber = 14;
  inline const ::std::string& globalid() const;
  inline void set_globalid(const ::std::string& value);
  inline void set_globalid(const char* value);
  inline void set_globalid(const char* value, size_t size);
  inline ::std::string* mutable_globalid();
  inline ::std::string* release_globalid();
  inline void set_allocated_globalid(::std::string* globalid);

  // optional string scrypt = 15;
  inline bool has_scrypt() const;
  inline void clear_scrypt();
  static const int kScryptFieldNumber = 15;
  inline const ::std::string& scrypt() const;
  inline void set_scrypt(const ::std::string& value);
  inline void set_scrypt(const char* value);
  inline void set_scrypt(const char* value, size_t size);
  inline ::std::string* mutable_scrypt();
  inline ::std::string* release_scrypt();
  inline void set_allocated_scrypt(::std::string* scrypt);

  // optional int32 exportPort = 16;
  inline bool has_exportport() const;
  inline void clear_exportport();
  static const int kExportPortFieldNumber = 16;
  inline ::google::protobuf::int32 exportport() const;
  inline void set_exportport(::google::protobuf::int32 value);

  // optional string eltex = 17;
  inline bool has_eltex() const;
  inline void clear_eltex();
  static const int kEltexFieldNumber = 17;
  inline const ::std::string& eltex() const;
  inline void set_eltex(const ::std::string& value);
  inline void set_eltex(const char* value);
  inline void set_eltex(const char* value, size_t size);
  inline ::std::string* mutable_eltex();
  inline ::std::string* release_eltex();
  inline void set_allocated_eltex(::std::string* eltex);

  // optional float bwMHz = 18;
  inline bool has_bwmhz() const;
  inline void clear_bwmhz();
  static const int kBwMHzFieldNumber = 18;
  inline float bwmhz() const;
  inline void set_bwmhz(float value);

  // optional string sensorName = 19 [default = ""];
  inline bool has_sensorname() const;
  inline void clear_sensorname();
  static const int kSensorNameFieldNumber = 19;
  inline const ::std::string& sensorname() const;
  inline void set_sensorname(const ::std::string& value);
  inline void set_sensorname(const char* value);
  inline void set_sensorname(const char* value, size_t size);
  inline ::std::string* mutable_sensorname();
  inline ::std::string* release_sensorname();
  inline void set_allocated_sensorname(::std::string* sensorname);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.SignalEvent)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_eventtype();
  inline void clear_has_eventtype();
  inline void set_has_eventid();
  inline void clear_has_eventid();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_soinum();
  inline void clear_has_soinum();
  inline void set_has_rfmhz();
  inline void clear_has_rfmhz();
  inline void set_has_subcarmhz();
  inline void clear_has_subcarmhz();
  inline void set_has_excurkhz();
  inline void clear_has_excurkhz();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_antnum();
  inline void clear_has_antnum();
  inline void set_has_antaz();
  inline void clear_has_antaz();
  inline void set_has_antel();
  inline void clear_has_antel();
  inline void set_has_globalid();
  inline void clear_has_globalid();
  inline void set_has_scrypt();
  inline void clear_has_scrypt();
  inline void set_has_exportport();
  inline void clear_has_exportport();
  inline void set_has_eltex();
  inline void clear_has_eltex();
  inline void set_has_bwmhz();
  inline void clear_has_bwmhz();
  inline void set_has_sensorname();
  inline void clear_has_sensorname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 channel_;
  int eventtype_;
  ::std::string* eventid_;
  ::std::string* timestamp_;
  ::std::string* soinum_;
  float rfmhz_;
  float subcarmhz_;
  float excurkhz_;
  ::google::protobuf::int32 appid_;
  ::google::protobuf::int32 antnum_;
  float antaz_;
  ::std::string* globalid_;
  float antel_;
  ::google::protobuf::int32 exportport_;
  ::std::string* scrypt_;
  ::std::string* eltex_;
  ::std::string* sensorname_;
  float bwmhz_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static SignalEvent* default_instance_;
};
// -------------------------------------------------------------------

class TxSignalParams : public ::google::protobuf::Message {
 public:
  TxSignalParams();
  virtual ~TxSignalParams();

  TxSignalParams(const TxSignalParams& from);

  inline TxSignalParams& operator=(const TxSignalParams& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxSignalParams& default_instance();

  void Swap(TxSignalParams* other);

  // implements Message ----------------------------------------------

  TxSignalParams* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxSignalParams& from);
  void MergeFrom(const TxSignalParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "TX_SIGNAL_PARAMS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string sigName = 2;
  inline bool has_signame() const;
  inline void clear_signame();
  static const int kSigNameFieldNumber = 2;
  inline const ::std::string& signame() const;
  inline void set_signame(const ::std::string& value);
  inline void set_signame(const char* value);
  inline void set_signame(const char* value, size_t size);
  inline ::std::string* mutable_signame();
  inline ::std::string* release_signame();
  inline void set_allocated_signame(::std::string* signame);

  // optional string fileName = 3;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 3;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional float sampleRateMHz = 4 [default = 25];
  inline bool has_sampleratemhz() const;
  inline void clear_sampleratemhz();
  static const int kSampleRateMHzFieldNumber = 4;
  inline float sampleratemhz() const;
  inline void set_sampleratemhz(float value);

  // optional double centerFreq = 5 [default = 915];
  inline bool has_centerfreq() const;
  inline void clear_centerfreq();
  static const int kCenterFreqFieldNumber = 5;
  inline double centerfreq() const;
  inline void set_centerfreq(double value);

  // optional string config = 6 [default = "CONFIG"];
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 6;
  inline const ::std::string& config() const;
  inline void set_config(const ::std::string& value);
  inline void set_config(const char* value);
  inline void set_config(const char* value, size_t size);
  inline ::std::string* mutable_config();
  inline ::std::string* release_config();
  inline void set_allocated_config(::std::string* config);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.TxSignalParams)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_signame();
  inline void clear_has_signame();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_sampleratemhz();
  inline void clear_has_sampleratemhz();
  inline void set_has_centerfreq();
  inline void clear_has_centerfreq();
  inline void set_has_config();
  inline void clear_has_config();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* signame_;
  ::std::string* filename_;
  double centerfreq_;
  ::std::string* config_;
  static ::std::string* _default_config_;
  float sampleratemhz_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static TxSignalParams* default_instance_;
};
// -------------------------------------------------------------------

class TxFileStatus : public ::google::protobuf::Message {
 public:
  TxFileStatus();
  virtual ~TxFileStatus();

  TxFileStatus(const TxFileStatus& from);

  inline TxFileStatus& operator=(const TxFileStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxFileStatus& default_instance();

  void Swap(TxFileStatus* other);

  // implements Message ----------------------------------------------

  TxFileStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxFileStatus& from);
  void MergeFrom(const TxFileStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "TX_FILE_STATUS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string sigName = 2;
  inline bool has_signame() const;
  inline void clear_signame();
  static const int kSigNameFieldNumber = 2;
  inline const ::std::string& signame() const;
  inline void set_signame(const ::std::string& value);
  inline void set_signame(const char* value);
  inline void set_signame(const char* value, size_t size);
  inline ::std::string* mutable_signame();
  inline ::std::string* release_signame();
  inline void set_allocated_signame(::std::string* signame);

  // optional string fileName = 3;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 3;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional string config = 4 [default = "CONFIG"];
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 4;
  inline const ::std::string& config() const;
  inline void set_config(const ::std::string& value);
  inline void set_config(const char* value);
  inline void set_config(const char* value, size_t size);
  inline ::std::string* mutable_config();
  inline ::std::string* release_config();
  inline void set_allocated_config(::std::string* config);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.TxFileStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_signame();
  inline void clear_has_signame();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_config();
  inline void clear_has_config();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* signame_;
  ::std::string* filename_;
  ::std::string* config_;
  static ::std::string* _default_config_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static TxFileStatus* default_instance_;
};
// -------------------------------------------------------------------

class CalibrationTimingResult : public ::google::protobuf::Message {
 public:
  CalibrationTimingResult();
  virtual ~CalibrationTimingResult();

  CalibrationTimingResult(const CalibrationTimingResult& from);

  inline CalibrationTimingResult& operator=(const CalibrationTimingResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CalibrationTimingResult& default_instance();

  void Swap(CalibrationTimingResult* other);

  // implements Message ----------------------------------------------

  CalibrationTimingResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CalibrationTimingResult& from);
  void MergeFrom(const CalibrationTimingResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "CALIBRATIONTIMINGRESULT"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional double wholeSeconds = 2 [default = 0];
  inline bool has_wholeseconds() const;
  inline void clear_wholeseconds();
  static const int kWholeSecondsFieldNumber = 2;
  inline double wholeseconds() const;
  inline void set_wholeseconds(double value);

  // optional double fracSeconds = 3 [default = 0];
  inline bool has_fracseconds() const;
  inline void clear_fracseconds();
  static const int kFracSecondsFieldNumber = 3;
  inline double fracseconds() const;
  inline void set_fracseconds(double value);

  // optional int32 transmittedByChannel = 4;
  inline bool has_transmittedbychannel() const;
  inline void clear_transmittedbychannel();
  static const int kTransmittedByChannelFieldNumber = 4;
  inline ::google::protobuf::int32 transmittedbychannel() const;
  inline void set_transmittedbychannel(::google::protobuf::int32 value);

  // optional int32 receivedByChannel = 5;
  inline bool has_receivedbychannel() const;
  inline void clear_receivedbychannel();
  static const int kReceivedByChannelFieldNumber = 5;
  inline ::google::protobuf::int32 receivedbychannel() const;
  inline void set_receivedbychannel(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fv.tb.protos.TBProtos.CalibrationTimingResult)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_wholeseconds();
  inline void clear_has_wholeseconds();
  inline void set_has_fracseconds();
  inline void clear_has_fracseconds();
  inline void set_has_transmittedbychannel();
  inline void clear_has_transmittedbychannel();
  inline void set_has_receivedbychannel();
  inline void clear_has_receivedbychannel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  double wholeseconds_;
  double fracseconds_;
  ::google::protobuf::int32 transmittedbychannel_;
  ::google::protobuf::int32 receivedbychannel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_AssignDesc_ThunderbirdMessages_2eproto();
  friend void protobuf_ShutdownFile_ThunderbirdMessages_2eproto();

  void InitAsDefaultInstance();
  static CalibrationTimingResult* default_instance_;
};
// ===================================================================


// ===================================================================

// CloseSelf

// optional string msgName = 1 [default = "CLOSESELF"];
inline bool CloseSelf::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CloseSelf::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CloseSelf::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CloseSelf::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& CloseSelf::msgname() const {
  return *msgname_;
}
inline void CloseSelf::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void CloseSelf::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void CloseSelf::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CloseSelf::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* CloseSelf::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void CloseSelf::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string uniqueWord = 2;
inline bool CloseSelf::has_uniqueword() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CloseSelf::set_has_uniqueword() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CloseSelf::clear_has_uniqueword() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CloseSelf::clear_uniqueword() {
  if (uniqueword_ != &::google::protobuf::internal::kEmptyString) {
    uniqueword_->clear();
  }
  clear_has_uniqueword();
}
inline const ::std::string& CloseSelf::uniqueword() const {
  return *uniqueword_;
}
inline void CloseSelf::set_uniqueword(const ::std::string& value) {
  set_has_uniqueword();
  if (uniqueword_ == &::google::protobuf::internal::kEmptyString) {
    uniqueword_ = new ::std::string;
  }
  uniqueword_->assign(value);
}
inline void CloseSelf::set_uniqueword(const char* value) {
  set_has_uniqueword();
  if (uniqueword_ == &::google::protobuf::internal::kEmptyString) {
    uniqueword_ = new ::std::string;
  }
  uniqueword_->assign(value);
}
inline void CloseSelf::set_uniqueword(const char* value, size_t size) {
  set_has_uniqueword();
  if (uniqueword_ == &::google::protobuf::internal::kEmptyString) {
    uniqueword_ = new ::std::string;
  }
  uniqueword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CloseSelf::mutable_uniqueword() {
  set_has_uniqueword();
  if (uniqueword_ == &::google::protobuf::internal::kEmptyString) {
    uniqueword_ = new ::std::string;
  }
  return uniqueword_;
}
inline ::std::string* CloseSelf::release_uniqueword() {
  clear_has_uniqueword();
  if (uniqueword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uniqueword_;
    uniqueword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CloseSelf::set_allocated_uniqueword(::std::string* uniqueword) {
  if (uniqueword_ != &::google::protobuf::internal::kEmptyString) {
    delete uniqueword_;
  }
  if (uniqueword) {
    set_has_uniqueword();
    uniqueword_ = uniqueword;
  } else {
    clear_has_uniqueword();
    uniqueword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EWCommandRequest

// optional string msgName = 1 [default = "EW_COMMAND_REQUEST"];
inline bool EWCommandRequest::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EWCommandRequest::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EWCommandRequest::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EWCommandRequest::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& EWCommandRequest::msgname() const {
  return *msgname_;
}
inline void EWCommandRequest::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWCommandRequest::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWCommandRequest::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWCommandRequest::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* EWCommandRequest::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void EWCommandRequest::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional .fv.tb.protos.TBProtos.EWCapability ewcap = 2;
inline bool EWCommandRequest::has_ewcap() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EWCommandRequest::set_has_ewcap() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EWCommandRequest::clear_has_ewcap() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EWCommandRequest::clear_ewcap() {
  if (ewcap_ != NULL) ewcap_->::fv::tb::protos::TBProtos::EWCapability::Clear();
  clear_has_ewcap();
}
inline const ::fv::tb::protos::TBProtos::EWCapability& EWCommandRequest::ewcap() const {
  return ewcap_ != NULL ? *ewcap_ : *default_instance_->ewcap_;
}
inline ::fv::tb::protos::TBProtos::EWCapability* EWCommandRequest::mutable_ewcap() {
  set_has_ewcap();
  if (ewcap_ == NULL) ewcap_ = new ::fv::tb::protos::TBProtos::EWCapability;
  return ewcap_;
}
inline ::fv::tb::protos::TBProtos::EWCapability* EWCommandRequest::release_ewcap() {
  clear_has_ewcap();
  ::fv::tb::protos::TBProtos::EWCapability* temp = ewcap_;
  ewcap_ = NULL;
  return temp;
}
inline void EWCommandRequest::set_allocated_ewcap(::fv::tb::protos::TBProtos::EWCapability* ewcap) {
  delete ewcap_;
  ewcap_ = ewcap;
  if (ewcap) {
    set_has_ewcap();
  } else {
    clear_has_ewcap();
  }
}

// optional bool active = 3;
inline bool EWCommandRequest::has_active() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EWCommandRequest::set_has_active() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EWCommandRequest::clear_has_active() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EWCommandRequest::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool EWCommandRequest::active() const {
  return active_;
}
inline void EWCommandRequest::set_active(bool value) {
  set_has_active();
  active_ = value;
}

// optional string sensorName = 4 [default = ""];
inline bool EWCommandRequest::has_sensorname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EWCommandRequest::set_has_sensorname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EWCommandRequest::clear_has_sensorname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EWCommandRequest::clear_sensorname() {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    sensorname_->clear();
  }
  clear_has_sensorname();
}
inline const ::std::string& EWCommandRequest::sensorname() const {
  return *sensorname_;
}
inline void EWCommandRequest::set_sensorname(const ::std::string& value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void EWCommandRequest::set_sensorname(const char* value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void EWCommandRequest::set_sensorname(const char* value, size_t size) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWCommandRequest::mutable_sensorname() {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  return sensorname_;
}
inline ::std::string* EWCommandRequest::release_sensorname() {
  clear_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sensorname_;
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EWCommandRequest::set_allocated_sensorname(::std::string* sensorname) {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    delete sensorname_;
  }
  if (sensorname) {
    set_has_sensorname();
    sensorname_ = sensorname;
  } else {
    clear_has_sensorname();
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Parameters

// optional string msgName = 1 [default = "EW_PARAMETER"];
inline bool Parameters::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Parameters::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Parameters::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Parameters::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& Parameters::msgname() const {
  return *msgname_;
}
inline void Parameters::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void Parameters::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void Parameters::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Parameters::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* Parameters::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void Parameters::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional float jamCFMHz = 10;
inline bool Parameters::has_jamcfmhz() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Parameters::set_has_jamcfmhz() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Parameters::clear_has_jamcfmhz() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Parameters::clear_jamcfmhz() {
  jamcfmhz_ = 0;
  clear_has_jamcfmhz();
}
inline float Parameters::jamcfmhz() const {
  return jamcfmhz_;
}
inline void Parameters::set_jamcfmhz(float value) {
  set_has_jamcfmhz();
  jamcfmhz_ = value;
}

// optional float tuneCFMHz = 11;
inline bool Parameters::has_tunecfmhz() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Parameters::set_has_tunecfmhz() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Parameters::clear_has_tunecfmhz() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Parameters::clear_tunecfmhz() {
  tunecfmhz_ = 0;
  clear_has_tunecfmhz();
}
inline float Parameters::tunecfmhz() const {
  return tunecfmhz_;
}
inline void Parameters::set_tunecfmhz(float value) {
  set_has_tunecfmhz();
  tunecfmhz_ = value;
}

// optional float jamBWMHz = 12;
inline bool Parameters::has_jambwmhz() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Parameters::set_has_jambwmhz() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Parameters::clear_has_jambwmhz() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Parameters::clear_jambwmhz() {
  jambwmhz_ = 0;
  clear_has_jambwmhz();
}
inline float Parameters::jambwmhz() const {
  return jambwmhz_;
}
inline void Parameters::set_jambwmhz(float value) {
  set_has_jambwmhz();
  jambwmhz_ = value;
}

// optional float jamBaudrate = 13;
inline bool Parameters::has_jambaudrate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Parameters::set_has_jambaudrate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Parameters::clear_has_jambaudrate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Parameters::clear_jambaudrate() {
  jambaudrate_ = 0;
  clear_has_jambaudrate();
}
inline float Parameters::jambaudrate() const {
  return jambaudrate_;
}
inline void Parameters::set_jambaudrate(float value) {
  set_has_jambaudrate();
  jambaudrate_ = value;
}

// optional float jamDeviation = 14;
inline bool Parameters::has_jamdeviation() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Parameters::set_has_jamdeviation() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Parameters::clear_has_jamdeviation() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Parameters::clear_jamdeviation() {
  jamdeviation_ = 0;
  clear_has_jamdeviation();
}
inline float Parameters::jamdeviation() const {
  return jamdeviation_;
}
inline void Parameters::set_jamdeviation(float value) {
  set_has_jamdeviation();
  jamdeviation_ = value;
}

// optional float onCycle = 15;
inline bool Parameters::has_oncycle() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Parameters::set_has_oncycle() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Parameters::clear_has_oncycle() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Parameters::clear_oncycle() {
  oncycle_ = 0;
  clear_has_oncycle();
}
inline float Parameters::oncycle() const {
  return oncycle_;
}
inline void Parameters::set_oncycle(float value) {
  set_has_oncycle();
  oncycle_ = value;
}

// optional float totalCycle = 16;
inline bool Parameters::has_totalcycle() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Parameters::set_has_totalcycle() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Parameters::clear_has_totalcycle() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Parameters::clear_totalcycle() {
  totalcycle_ = 0;
  clear_has_totalcycle();
}
inline float Parameters::totalcycle() const {
  return totalcycle_;
}
inline void Parameters::set_totalcycle(float value) {
  set_has_totalcycle();
  totalcycle_ = value;
}

// optional int32 modeID = 17;
inline bool Parameters::has_modeid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Parameters::set_has_modeid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Parameters::clear_has_modeid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Parameters::clear_modeid() {
  modeid_ = 0;
  clear_has_modeid();
}
inline ::google::protobuf::int32 Parameters::modeid() const {
  return modeid_;
}
inline void Parameters::set_modeid(::google::protobuf::int32 value) {
  set_has_modeid();
  modeid_ = value;
}

// optional int32 sourceID = 18;
inline bool Parameters::has_sourceid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Parameters::set_has_sourceid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Parameters::clear_has_sourceid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Parameters::clear_sourceid() {
  sourceid_ = 0;
  clear_has_sourceid();
}
inline ::google::protobuf::int32 Parameters::sourceid() const {
  return sourceid_;
}
inline void Parameters::set_sourceid(::google::protobuf::int32 value) {
  set_has_sourceid();
  sourceid_ = value;
}

// optional int32 destinationID = 19;
inline bool Parameters::has_destinationid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Parameters::set_has_destinationid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Parameters::clear_has_destinationid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Parameters::clear_destinationid() {
  destinationid_ = 0;
  clear_has_destinationid();
}
inline ::google::protobuf::int32 Parameters::destinationid() const {
  return destinationid_;
}
inline void Parameters::set_destinationid(::google::protobuf::int32 value) {
  set_has_destinationid();
  destinationid_ = value;
}

// optional int32 frameFormat = 20;
inline bool Parameters::has_frameformat() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Parameters::set_has_frameformat() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Parameters::clear_has_frameformat() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Parameters::clear_frameformat() {
  frameformat_ = 0;
  clear_has_frameformat();
}
inline ::google::protobuf::int32 Parameters::frameformat() const {
  return frameformat_;
}
inline void Parameters::set_frameformat(::google::protobuf::int32 value) {
  set_has_frameformat();
  frameformat_ = value;
}

// optional string textMessage = 21;
inline bool Parameters::has_textmessage() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Parameters::set_has_textmessage() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Parameters::clear_has_textmessage() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Parameters::clear_textmessage() {
  if (textmessage_ != &::google::protobuf::internal::kEmptyString) {
    textmessage_->clear();
  }
  clear_has_textmessage();
}
inline const ::std::string& Parameters::textmessage() const {
  return *textmessage_;
}
inline void Parameters::set_textmessage(const ::std::string& value) {
  set_has_textmessage();
  if (textmessage_ == &::google::protobuf::internal::kEmptyString) {
    textmessage_ = new ::std::string;
  }
  textmessage_->assign(value);
}
inline void Parameters::set_textmessage(const char* value) {
  set_has_textmessage();
  if (textmessage_ == &::google::protobuf::internal::kEmptyString) {
    textmessage_ = new ::std::string;
  }
  textmessage_->assign(value);
}
inline void Parameters::set_textmessage(const char* value, size_t size) {
  set_has_textmessage();
  if (textmessage_ == &::google::protobuf::internal::kEmptyString) {
    textmessage_ = new ::std::string;
  }
  textmessage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Parameters::mutable_textmessage() {
  set_has_textmessage();
  if (textmessage_ == &::google::protobuf::internal::kEmptyString) {
    textmessage_ = new ::std::string;
  }
  return textmessage_;
}
inline ::std::string* Parameters::release_textmessage() {
  clear_has_textmessage();
  if (textmessage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = textmessage_;
    textmessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Parameters::set_allocated_textmessage(::std::string* textmessage) {
  if (textmessage_ != &::google::protobuf::internal::kEmptyString) {
    delete textmessage_;
  }
  if (textmessage) {
    set_has_textmessage();
    textmessage_ = textmessage;
  } else {
    clear_has_textmessage();
    textmessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double lat = 22;
inline bool Parameters::has_lat() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Parameters::set_has_lat() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Parameters::clear_has_lat() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Parameters::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline double Parameters::lat() const {
  return lat_;
}
inline void Parameters::set_lat(double value) {
  set_has_lat();
  lat_ = value;
}

// optional double lon = 23;
inline bool Parameters::has_lon() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Parameters::set_has_lon() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Parameters::clear_has_lon() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Parameters::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline double Parameters::lon() const {
  return lon_;
}
inline void Parameters::set_lon(double value) {
  set_has_lon();
  lon_ = value;
}

// optional int32 numTargets = 24;
inline bool Parameters::has_numtargets() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Parameters::set_has_numtargets() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Parameters::clear_has_numtargets() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Parameters::clear_numtargets() {
  numtargets_ = 0;
  clear_has_numtargets();
}
inline ::google::protobuf::int32 Parameters::numtargets() const {
  return numtargets_;
}
inline void Parameters::set_numtargets(::google::protobuf::int32 value) {
  set_has_numtargets();
  numtargets_ = value;
}

// repeated .falcon_common_msg.KeyValuePair kvps = 25;
inline int Parameters::kvps_size() const {
  return kvps_.size();
}
inline void Parameters::clear_kvps() {
  kvps_.Clear();
}
inline const ::falcon_common_msg::KeyValuePair& Parameters::kvps(int index) const {
  return kvps_.Get(index);
}
inline ::falcon_common_msg::KeyValuePair* Parameters::mutable_kvps(int index) {
  return kvps_.Mutable(index);
}
inline ::falcon_common_msg::KeyValuePair* Parameters::add_kvps() {
  return kvps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::KeyValuePair >&
Parameters::kvps() const {
  return kvps_;
}
inline ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::KeyValuePair >*
Parameters::mutable_kvps() {
  return &kvps_;
}

// optional double jamIFMHz = 26 [default = 0];
inline bool Parameters::has_jamifmhz() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Parameters::set_has_jamifmhz() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Parameters::clear_has_jamifmhz() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Parameters::clear_jamifmhz() {
  jamifmhz_ = 0;
  clear_has_jamifmhz();
}
inline double Parameters::jamifmhz() const {
  return jamifmhz_;
}
inline void Parameters::set_jamifmhz(double value) {
  set_has_jamifmhz();
  jamifmhz_ = value;
}

// -------------------------------------------------------------------

// EWStatus

// optional string msgName = 1 [default = "EW_STATUS"];
inline bool EWStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EWStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EWStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EWStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& EWStatus::msgname() const {
  return *msgname_;
}
inline void EWStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* EWStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void EWStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// repeated .fv.tb.protos.TBProtos.OutputChannelStatus outputChannelStatus = 2;
inline int EWStatus::outputchannelstatus_size() const {
  return outputchannelstatus_.size();
}
inline void EWStatus::clear_outputchannelstatus() {
  outputchannelstatus_.Clear();
}
inline const ::fv::tb::protos::TBProtos::OutputChannelStatus& EWStatus::outputchannelstatus(int index) const {
  return outputchannelstatus_.Get(index);
}
inline ::fv::tb::protos::TBProtos::OutputChannelStatus* EWStatus::mutable_outputchannelstatus(int index) {
  return outputchannelstatus_.Mutable(index);
}
inline ::fv::tb::protos::TBProtos::OutputChannelStatus* EWStatus::add_outputchannelstatus() {
  return outputchannelstatus_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::OutputChannelStatus >&
EWStatus::outputchannelstatus() const {
  return outputchannelstatus_;
}
inline ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::OutputChannelStatus >*
EWStatus::mutable_outputchannelstatus() {
  return &outputchannelstatus_;
}

// -------------------------------------------------------------------

// OutputChannelStatus

// optional string msgName = 1 [default = "EW_OUTPUT_CHANNEL_STATUS"];
inline bool OutputChannelStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OutputChannelStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OutputChannelStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OutputChannelStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& OutputChannelStatus::msgname() const {
  return *msgname_;
}
inline void OutputChannelStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void OutputChannelStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void OutputChannelStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OutputChannelStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* OutputChannelStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void OutputChannelStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string effect = 2;
inline bool OutputChannelStatus::has_effect() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OutputChannelStatus::set_has_effect() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OutputChannelStatus::clear_has_effect() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OutputChannelStatus::clear_effect() {
  if (effect_ != &::google::protobuf::internal::kEmptyString) {
    effect_->clear();
  }
  clear_has_effect();
}
inline const ::std::string& OutputChannelStatus::effect() const {
  return *effect_;
}
inline void OutputChannelStatus::set_effect(const ::std::string& value) {
  set_has_effect();
  if (effect_ == &::google::protobuf::internal::kEmptyString) {
    effect_ = new ::std::string;
  }
  effect_->assign(value);
}
inline void OutputChannelStatus::set_effect(const char* value) {
  set_has_effect();
  if (effect_ == &::google::protobuf::internal::kEmptyString) {
    effect_ = new ::std::string;
  }
  effect_->assign(value);
}
inline void OutputChannelStatus::set_effect(const char* value, size_t size) {
  set_has_effect();
  if (effect_ == &::google::protobuf::internal::kEmptyString) {
    effect_ = new ::std::string;
  }
  effect_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OutputChannelStatus::mutable_effect() {
  set_has_effect();
  if (effect_ == &::google::protobuf::internal::kEmptyString) {
    effect_ = new ::std::string;
  }
  return effect_;
}
inline ::std::string* OutputChannelStatus::release_effect() {
  clear_has_effect();
  if (effect_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = effect_;
    effect_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OutputChannelStatus::set_allocated_effect(::std::string* effect) {
  if (effect_ != &::google::protobuf::internal::kEmptyString) {
    delete effect_;
  }
  if (effect) {
    set_has_effect();
    effect_ = effect;
  } else {
    clear_has_effect();
    effect_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double transmitFreq = 3;
inline bool OutputChannelStatus::has_transmitfreq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OutputChannelStatus::set_has_transmitfreq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OutputChannelStatus::clear_has_transmitfreq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OutputChannelStatus::clear_transmitfreq() {
  transmitfreq_ = 0;
  clear_has_transmitfreq();
}
inline double OutputChannelStatus::transmitfreq() const {
  return transmitfreq_;
}
inline void OutputChannelStatus::set_transmitfreq(double value) {
  set_has_transmitfreq();
  transmitfreq_ = value;
}

// optional string globalId = 4;
inline bool OutputChannelStatus::has_globalid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OutputChannelStatus::set_has_globalid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OutputChannelStatus::clear_has_globalid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OutputChannelStatus::clear_globalid() {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    globalid_->clear();
  }
  clear_has_globalid();
}
inline const ::std::string& OutputChannelStatus::globalid() const {
  return *globalid_;
}
inline void OutputChannelStatus::set_globalid(const ::std::string& value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void OutputChannelStatus::set_globalid(const char* value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void OutputChannelStatus::set_globalid(const char* value, size_t size) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OutputChannelStatus::mutable_globalid() {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  return globalid_;
}
inline ::std::string* OutputChannelStatus::release_globalid() {
  clear_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalid_;
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OutputChannelStatus::set_allocated_globalid(::std::string* globalid) {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    delete globalid_;
  }
  if (globalid) {
    set_has_globalid();
    globalid_ = globalid;
  } else {
    clear_has_globalid();
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string antenna = 5;
inline bool OutputChannelStatus::has_antenna() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OutputChannelStatus::set_has_antenna() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OutputChannelStatus::clear_has_antenna() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OutputChannelStatus::clear_antenna() {
  if (antenna_ != &::google::protobuf::internal::kEmptyString) {
    antenna_->clear();
  }
  clear_has_antenna();
}
inline const ::std::string& OutputChannelStatus::antenna() const {
  return *antenna_;
}
inline void OutputChannelStatus::set_antenna(const ::std::string& value) {
  set_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    antenna_ = new ::std::string;
  }
  antenna_->assign(value);
}
inline void OutputChannelStatus::set_antenna(const char* value) {
  set_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    antenna_ = new ::std::string;
  }
  antenna_->assign(value);
}
inline void OutputChannelStatus::set_antenna(const char* value, size_t size) {
  set_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    antenna_ = new ::std::string;
  }
  antenna_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OutputChannelStatus::mutable_antenna() {
  set_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    antenna_ = new ::std::string;
  }
  return antenna_;
}
inline ::std::string* OutputChannelStatus::release_antenna() {
  clear_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = antenna_;
    antenna_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OutputChannelStatus::set_allocated_antenna(::std::string* antenna) {
  if (antenna_ != &::google::protobuf::internal::kEmptyString) {
    delete antenna_;
  }
  if (antenna) {
    set_has_antenna();
    antenna_ = antenna;
  } else {
    clear_has_antenna();
    antenna_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .fv.tb.protos.TBProtos.OutputChannelStatus.TransmitState state = 6;
inline bool OutputChannelStatus::has_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OutputChannelStatus::set_has_state() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OutputChannelStatus::clear_has_state() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OutputChannelStatus::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::fv::tb::protos::TBProtos::OutputChannelStatus_TransmitState OutputChannelStatus::state() const {
  return static_cast< ::fv::tb::protos::TBProtos::OutputChannelStatus_TransmitState >(state_);
}
inline void OutputChannelStatus::set_state(::fv::tb::protos::TBProtos::OutputChannelStatus_TransmitState value) {
  assert(::fv::tb::protos::TBProtos::OutputChannelStatus_TransmitState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional double powerMeter = 7;
inline bool OutputChannelStatus::has_powermeter() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OutputChannelStatus::set_has_powermeter() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OutputChannelStatus::clear_has_powermeter() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OutputChannelStatus::clear_powermeter() {
  powermeter_ = 0;
  clear_has_powermeter();
}
inline double OutputChannelStatus::powermeter() const {
  return powermeter_;
}
inline void OutputChannelStatus::set_powermeter(double value) {
  set_has_powermeter();
  powermeter_ = value;
}

// optional string resID = 8;
inline bool OutputChannelStatus::has_resid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OutputChannelStatus::set_has_resid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OutputChannelStatus::clear_has_resid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OutputChannelStatus::clear_resid() {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    resid_->clear();
  }
  clear_has_resid();
}
inline const ::std::string& OutputChannelStatus::resid() const {
  return *resid_;
}
inline void OutputChannelStatus::set_resid(const ::std::string& value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void OutputChannelStatus::set_resid(const char* value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void OutputChannelStatus::set_resid(const char* value, size_t size) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OutputChannelStatus::mutable_resid() {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  return resid_;
}
inline ::std::string* OutputChannelStatus::release_resid() {
  clear_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resid_;
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OutputChannelStatus::set_allocated_resid(::std::string* resid) {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    delete resid_;
  }
  if (resid) {
    set_has_resid();
    resid_ = resid;
  } else {
    clear_has_resid();
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string signalName = 9;
inline bool OutputChannelStatus::has_signalname() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OutputChannelStatus::set_has_signalname() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OutputChannelStatus::clear_has_signalname() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OutputChannelStatus::clear_signalname() {
  if (signalname_ != &::google::protobuf::internal::kEmptyString) {
    signalname_->clear();
  }
  clear_has_signalname();
}
inline const ::std::string& OutputChannelStatus::signalname() const {
  return *signalname_;
}
inline void OutputChannelStatus::set_signalname(const ::std::string& value) {
  set_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    signalname_ = new ::std::string;
  }
  signalname_->assign(value);
}
inline void OutputChannelStatus::set_signalname(const char* value) {
  set_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    signalname_ = new ::std::string;
  }
  signalname_->assign(value);
}
inline void OutputChannelStatus::set_signalname(const char* value, size_t size) {
  set_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    signalname_ = new ::std::string;
  }
  signalname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OutputChannelStatus::mutable_signalname() {
  set_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    signalname_ = new ::std::string;
  }
  return signalname_;
}
inline ::std::string* OutputChannelStatus::release_signalname() {
  clear_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signalname_;
    signalname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OutputChannelStatus::set_allocated_signalname(::std::string* signalname) {
  if (signalname_ != &::google::protobuf::internal::kEmptyString) {
    delete signalname_;
  }
  if (signalname) {
    set_has_signalname();
    signalname_ = signalname;
  } else {
    clear_has_signalname();
    signalname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EWTransmittingRequest

// optional string msgName = 1 [default = "EW_TRANSMITTING_REQUEST"];
inline bool EWTransmittingRequest::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EWTransmittingRequest::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EWTransmittingRequest::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EWTransmittingRequest::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& EWTransmittingRequest::msgname() const {
  return *msgname_;
}
inline void EWTransmittingRequest::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWTransmittingRequest::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWTransmittingRequest::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWTransmittingRequest::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* EWTransmittingRequest::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void EWTransmittingRequest::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// -------------------------------------------------------------------

// EWCapabilityUnregister

// optional string msgName = 1 [default = "EW_CAPABILITY_UNREGISTER"];
inline bool EWCapabilityUnregister::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EWCapabilityUnregister::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EWCapabilityUnregister::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EWCapabilityUnregister::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& EWCapabilityUnregister::msgname() const {
  return *msgname_;
}
inline void EWCapabilityUnregister::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWCapabilityUnregister::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWCapabilityUnregister::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWCapabilityUnregister::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* EWCapabilityUnregister::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void EWCapabilityUnregister::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string capabilityId = 2;
inline bool EWCapabilityUnregister::has_capabilityid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EWCapabilityUnregister::set_has_capabilityid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EWCapabilityUnregister::clear_has_capabilityid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EWCapabilityUnregister::clear_capabilityid() {
  if (capabilityid_ != &::google::protobuf::internal::kEmptyString) {
    capabilityid_->clear();
  }
  clear_has_capabilityid();
}
inline const ::std::string& EWCapabilityUnregister::capabilityid() const {
  return *capabilityid_;
}
inline void EWCapabilityUnregister::set_capabilityid(const ::std::string& value) {
  set_has_capabilityid();
  if (capabilityid_ == &::google::protobuf::internal::kEmptyString) {
    capabilityid_ = new ::std::string;
  }
  capabilityid_->assign(value);
}
inline void EWCapabilityUnregister::set_capabilityid(const char* value) {
  set_has_capabilityid();
  if (capabilityid_ == &::google::protobuf::internal::kEmptyString) {
    capabilityid_ = new ::std::string;
  }
  capabilityid_->assign(value);
}
inline void EWCapabilityUnregister::set_capabilityid(const char* value, size_t size) {
  set_has_capabilityid();
  if (capabilityid_ == &::google::protobuf::internal::kEmptyString) {
    capabilityid_ = new ::std::string;
  }
  capabilityid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWCapabilityUnregister::mutable_capabilityid() {
  set_has_capabilityid();
  if (capabilityid_ == &::google::protobuf::internal::kEmptyString) {
    capabilityid_ = new ::std::string;
  }
  return capabilityid_;
}
inline ::std::string* EWCapabilityUnregister::release_capabilityid() {
  clear_has_capabilityid();
  if (capabilityid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = capabilityid_;
    capabilityid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EWCapabilityUnregister::set_allocated_capabilityid(::std::string* capabilityid) {
  if (capabilityid_ != &::google::protobuf::internal::kEmptyString) {
    delete capabilityid_;
  }
  if (capabilityid) {
    set_has_capabilityid();
    capabilityid_ = capabilityid;
  } else {
    clear_has_capabilityid();
    capabilityid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EWCapability

// optional string msgName = 1 [default = "EW_CAPABILITIY"];
inline bool EWCapability::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EWCapability::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EWCapability::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EWCapability::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& EWCapability::msgname() const {
  return *msgname_;
}
inline void EWCapability::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWCapability::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWCapability::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWCapability::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* EWCapability::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void EWCapability::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string signalName = 2;
inline bool EWCapability::has_signalname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EWCapability::set_has_signalname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EWCapability::clear_has_signalname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EWCapability::clear_signalname() {
  if (signalname_ != &::google::protobuf::internal::kEmptyString) {
    signalname_->clear();
  }
  clear_has_signalname();
}
inline const ::std::string& EWCapability::signalname() const {
  return *signalname_;
}
inline void EWCapability::set_signalname(const ::std::string& value) {
  set_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    signalname_ = new ::std::string;
  }
  signalname_->assign(value);
}
inline void EWCapability::set_signalname(const char* value) {
  set_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    signalname_ = new ::std::string;
  }
  signalname_->assign(value);
}
inline void EWCapability::set_signalname(const char* value, size_t size) {
  set_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    signalname_ = new ::std::string;
  }
  signalname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWCapability::mutable_signalname() {
  set_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    signalname_ = new ::std::string;
  }
  return signalname_;
}
inline ::std::string* EWCapability::release_signalname() {
  clear_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signalname_;
    signalname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EWCapability::set_allocated_signalname(::std::string* signalname) {
  if (signalname_ != &::google::protobuf::internal::kEmptyString) {
    delete signalname_;
  }
  if (signalname) {
    set_has_signalname();
    signalname_ = signalname;
  } else {
    clear_has_signalname();
    signalname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string effect = 3;
inline bool EWCapability::has_effect() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EWCapability::set_has_effect() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EWCapability::clear_has_effect() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EWCapability::clear_effect() {
  if (effect_ != &::google::protobuf::internal::kEmptyString) {
    effect_->clear();
  }
  clear_has_effect();
}
inline const ::std::string& EWCapability::effect() const {
  return *effect_;
}
inline void EWCapability::set_effect(const ::std::string& value) {
  set_has_effect();
  if (effect_ == &::google::protobuf::internal::kEmptyString) {
    effect_ = new ::std::string;
  }
  effect_->assign(value);
}
inline void EWCapability::set_effect(const char* value) {
  set_has_effect();
  if (effect_ == &::google::protobuf::internal::kEmptyString) {
    effect_ = new ::std::string;
  }
  effect_->assign(value);
}
inline void EWCapability::set_effect(const char* value, size_t size) {
  set_has_effect();
  if (effect_ == &::google::protobuf::internal::kEmptyString) {
    effect_ = new ::std::string;
  }
  effect_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWCapability::mutable_effect() {
  set_has_effect();
  if (effect_ == &::google::protobuf::internal::kEmptyString) {
    effect_ = new ::std::string;
  }
  return effect_;
}
inline ::std::string* EWCapability::release_effect() {
  clear_has_effect();
  if (effect_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = effect_;
    effect_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EWCapability::set_allocated_effect(::std::string* effect) {
  if (effect_ != &::google::protobuf::internal::kEmptyString) {
    delete effect_;
  }
  if (effect) {
    set_has_effect();
    effect_ = effect;
  } else {
    clear_has_effect();
    effect_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string capabilityId = 4;
inline bool EWCapability::has_capabilityid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EWCapability::set_has_capabilityid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EWCapability::clear_has_capabilityid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EWCapability::clear_capabilityid() {
  if (capabilityid_ != &::google::protobuf::internal::kEmptyString) {
    capabilityid_->clear();
  }
  clear_has_capabilityid();
}
inline const ::std::string& EWCapability::capabilityid() const {
  return *capabilityid_;
}
inline void EWCapability::set_capabilityid(const ::std::string& value) {
  set_has_capabilityid();
  if (capabilityid_ == &::google::protobuf::internal::kEmptyString) {
    capabilityid_ = new ::std::string;
  }
  capabilityid_->assign(value);
}
inline void EWCapability::set_capabilityid(const char* value) {
  set_has_capabilityid();
  if (capabilityid_ == &::google::protobuf::internal::kEmptyString) {
    capabilityid_ = new ::std::string;
  }
  capabilityid_->assign(value);
}
inline void EWCapability::set_capabilityid(const char* value, size_t size) {
  set_has_capabilityid();
  if (capabilityid_ == &::google::protobuf::internal::kEmptyString) {
    capabilityid_ = new ::std::string;
  }
  capabilityid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWCapability::mutable_capabilityid() {
  set_has_capabilityid();
  if (capabilityid_ == &::google::protobuf::internal::kEmptyString) {
    capabilityid_ = new ::std::string;
  }
  return capabilityid_;
}
inline ::std::string* EWCapability::release_capabilityid() {
  clear_has_capabilityid();
  if (capabilityid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = capabilityid_;
    capabilityid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EWCapability::set_allocated_capabilityid(::std::string* capabilityid) {
  if (capabilityid_ != &::google::protobuf::internal::kEmptyString) {
    delete capabilityid_;
  }
  if (capabilityid) {
    set_has_capabilityid();
    capabilityid_ = capabilityid;
  } else {
    clear_has_capabilityid();
    capabilityid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string globalID = 5;
inline bool EWCapability::has_globalid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EWCapability::set_has_globalid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EWCapability::clear_has_globalid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EWCapability::clear_globalid() {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    globalid_->clear();
  }
  clear_has_globalid();
}
inline const ::std::string& EWCapability::globalid() const {
  return *globalid_;
}
inline void EWCapability::set_globalid(const ::std::string& value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void EWCapability::set_globalid(const char* value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void EWCapability::set_globalid(const char* value, size_t size) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWCapability::mutable_globalid() {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  return globalid_;
}
inline ::std::string* EWCapability::release_globalid() {
  clear_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalid_;
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EWCapability::set_allocated_globalid(::std::string* globalid) {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    delete globalid_;
  }
  if (globalid) {
    set_has_globalid();
    globalid_ = globalid;
  } else {
    clear_has_globalid();
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float percentReady = 6 [default = 0];
inline bool EWCapability::has_percentready() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EWCapability::set_has_percentready() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EWCapability::clear_has_percentready() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EWCapability::clear_percentready() {
  percentready_ = 0;
  clear_has_percentready();
}
inline float EWCapability::percentready() const {
  return percentready_;
}
inline void EWCapability::set_percentready(float value) {
  set_has_percentready();
  percentready_ = value;
}

// optional .fv.tb.protos.TBProtos.Parameters parameters = 7;
inline bool EWCapability::has_parameters() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EWCapability::set_has_parameters() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EWCapability::clear_has_parameters() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EWCapability::clear_parameters() {
  if (parameters_ != NULL) parameters_->::fv::tb::protos::TBProtos::Parameters::Clear();
  clear_has_parameters();
}
inline const ::fv::tb::protos::TBProtos::Parameters& EWCapability::parameters() const {
  return parameters_ != NULL ? *parameters_ : *default_instance_->parameters_;
}
inline ::fv::tb::protos::TBProtos::Parameters* EWCapability::mutable_parameters() {
  set_has_parameters();
  if (parameters_ == NULL) parameters_ = new ::fv::tb::protos::TBProtos::Parameters;
  return parameters_;
}
inline ::fv::tb::protos::TBProtos::Parameters* EWCapability::release_parameters() {
  clear_has_parameters();
  ::fv::tb::protos::TBProtos::Parameters* temp = parameters_;
  parameters_ = NULL;
  return temp;
}
inline void EWCapability::set_allocated_parameters(::fv::tb::protos::TBProtos::Parameters* parameters) {
  delete parameters_;
  parameters_ = parameters;
  if (parameters) {
    set_has_parameters();
  } else {
    clear_has_parameters();
  }
}

// optional string tbUniqueID = 8;
inline bool EWCapability::has_tbuniqueid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EWCapability::set_has_tbuniqueid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EWCapability::clear_has_tbuniqueid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EWCapability::clear_tbuniqueid() {
  if (tbuniqueid_ != &::google::protobuf::internal::kEmptyString) {
    tbuniqueid_->clear();
  }
  clear_has_tbuniqueid();
}
inline const ::std::string& EWCapability::tbuniqueid() const {
  return *tbuniqueid_;
}
inline void EWCapability::set_tbuniqueid(const ::std::string& value) {
  set_has_tbuniqueid();
  if (tbuniqueid_ == &::google::protobuf::internal::kEmptyString) {
    tbuniqueid_ = new ::std::string;
  }
  tbuniqueid_->assign(value);
}
inline void EWCapability::set_tbuniqueid(const char* value) {
  set_has_tbuniqueid();
  if (tbuniqueid_ == &::google::protobuf::internal::kEmptyString) {
    tbuniqueid_ = new ::std::string;
  }
  tbuniqueid_->assign(value);
}
inline void EWCapability::set_tbuniqueid(const char* value, size_t size) {
  set_has_tbuniqueid();
  if (tbuniqueid_ == &::google::protobuf::internal::kEmptyString) {
    tbuniqueid_ = new ::std::string;
  }
  tbuniqueid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWCapability::mutable_tbuniqueid() {
  set_has_tbuniqueid();
  if (tbuniqueid_ == &::google::protobuf::internal::kEmptyString) {
    tbuniqueid_ = new ::std::string;
  }
  return tbuniqueid_;
}
inline ::std::string* EWCapability::release_tbuniqueid() {
  clear_has_tbuniqueid();
  if (tbuniqueid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tbuniqueid_;
    tbuniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EWCapability::set_allocated_tbuniqueid(::std::string* tbuniqueid) {
  if (tbuniqueid_ != &::google::protobuf::internal::kEmptyString) {
    delete tbuniqueid_;
  }
  if (tbuniqueid) {
    set_has_tbuniqueid();
    tbuniqueid_ = tbuniqueid;
  } else {
    clear_has_tbuniqueid();
    tbuniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EWCapabilities

// optional string msgName = 1 [default = "EWCAPABILITIES"];
inline bool EWCapabilities::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EWCapabilities::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EWCapabilities::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EWCapabilities::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& EWCapabilities::msgname() const {
  return *msgname_;
}
inline void EWCapabilities::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWCapabilities::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWCapabilities::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWCapabilities::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* EWCapabilities::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void EWCapabilities::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// repeated .fv.tb.protos.TBProtos.EWCapability ewcap = 2;
inline int EWCapabilities::ewcap_size() const {
  return ewcap_.size();
}
inline void EWCapabilities::clear_ewcap() {
  ewcap_.Clear();
}
inline const ::fv::tb::protos::TBProtos::EWCapability& EWCapabilities::ewcap(int index) const {
  return ewcap_.Get(index);
}
inline ::fv::tb::protos::TBProtos::EWCapability* EWCapabilities::mutable_ewcap(int index) {
  return ewcap_.Mutable(index);
}
inline ::fv::tb::protos::TBProtos::EWCapability* EWCapabilities::add_ewcap() {
  return ewcap_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::EWCapability >&
EWCapabilities::ewcap() const {
  return ewcap_;
}
inline ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::EWCapability >*
EWCapabilities::mutable_ewcap() {
  return &ewcap_;
}

// optional string sensorName = 3 [default = ""];
inline bool EWCapabilities::has_sensorname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EWCapabilities::set_has_sensorname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EWCapabilities::clear_has_sensorname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EWCapabilities::clear_sensorname() {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    sensorname_->clear();
  }
  clear_has_sensorname();
}
inline const ::std::string& EWCapabilities::sensorname() const {
  return *sensorname_;
}
inline void EWCapabilities::set_sensorname(const ::std::string& value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void EWCapabilities::set_sensorname(const char* value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void EWCapabilities::set_sensorname(const char* value, size_t size) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWCapabilities::mutable_sensorname() {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  return sensorname_;
}
inline ::std::string* EWCapabilities::release_sensorname() {
  clear_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sensorname_;
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EWCapabilities::set_allocated_sensorname(::std::string* sensorname) {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    delete sensorname_;
  }
  if (sensorname) {
    set_has_sensorname();
    sensorname_ = sensorname;
  } else {
    clear_has_sensorname();
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EWCapabilityTransmitting

// optional string msgName = 1 [default = "EW_CAPABILITY_TRANSMITTING"];
inline bool EWCapabilityTransmitting::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EWCapabilityTransmitting::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EWCapabilityTransmitting::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EWCapabilityTransmitting::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& EWCapabilityTransmitting::msgname() const {
  return *msgname_;
}
inline void EWCapabilityTransmitting::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWCapabilityTransmitting::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWCapabilityTransmitting::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWCapabilityTransmitting::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* EWCapabilityTransmitting::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void EWCapabilityTransmitting::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional .fv.tb.protos.TBProtos.EWCapability ewcap = 2;
inline bool EWCapabilityTransmitting::has_ewcap() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EWCapabilityTransmitting::set_has_ewcap() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EWCapabilityTransmitting::clear_has_ewcap() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EWCapabilityTransmitting::clear_ewcap() {
  if (ewcap_ != NULL) ewcap_->::fv::tb::protos::TBProtos::EWCapability::Clear();
  clear_has_ewcap();
}
inline const ::fv::tb::protos::TBProtos::EWCapability& EWCapabilityTransmitting::ewcap() const {
  return ewcap_ != NULL ? *ewcap_ : *default_instance_->ewcap_;
}
inline ::fv::tb::protos::TBProtos::EWCapability* EWCapabilityTransmitting::mutable_ewcap() {
  set_has_ewcap();
  if (ewcap_ == NULL) ewcap_ = new ::fv::tb::protos::TBProtos::EWCapability;
  return ewcap_;
}
inline ::fv::tb::protos::TBProtos::EWCapability* EWCapabilityTransmitting::release_ewcap() {
  clear_has_ewcap();
  ::fv::tb::protos::TBProtos::EWCapability* temp = ewcap_;
  ewcap_ = NULL;
  return temp;
}
inline void EWCapabilityTransmitting::set_allocated_ewcap(::fv::tb::protos::TBProtos::EWCapability* ewcap) {
  delete ewcap_;
  ewcap_ = ewcap;
  if (ewcap) {
    set_has_ewcap();
  } else {
    clear_has_ewcap();
  }
}

// optional bool active = 3 [default = false];
inline bool EWCapabilityTransmitting::has_active() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EWCapabilityTransmitting::set_has_active() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EWCapabilityTransmitting::clear_has_active() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EWCapabilityTransmitting::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool EWCapabilityTransmitting::active() const {
  return active_;
}
inline void EWCapabilityTransmitting::set_active(bool value) {
  set_has_active();
  active_ = value;
}

// -------------------------------------------------------------------

// EWTransmitting

// optional string msgName = 1 [default = "EW_TRANSMITTING"];
inline bool EWTransmitting::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EWTransmitting::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EWTransmitting::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EWTransmitting::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& EWTransmitting::msgname() const {
  return *msgname_;
}
inline void EWTransmitting::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWTransmitting::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWTransmitting::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWTransmitting::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* EWTransmitting::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void EWTransmitting::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// repeated .fv.tb.protos.TBProtos.EWCapability ewcap = 2;
inline int EWTransmitting::ewcap_size() const {
  return ewcap_.size();
}
inline void EWTransmitting::clear_ewcap() {
  ewcap_.Clear();
}
inline const ::fv::tb::protos::TBProtos::EWCapability& EWTransmitting::ewcap(int index) const {
  return ewcap_.Get(index);
}
inline ::fv::tb::protos::TBProtos::EWCapability* EWTransmitting::mutable_ewcap(int index) {
  return ewcap_.Mutable(index);
}
inline ::fv::tb::protos::TBProtos::EWCapability* EWTransmitting::add_ewcap() {
  return ewcap_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::EWCapability >&
EWTransmitting::ewcap() const {
  return ewcap_;
}
inline ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::EWCapability >*
EWTransmitting::mutable_ewcap() {
  return &ewcap_;
}

// optional string sensorName = 3;
inline bool EWTransmitting::has_sensorname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EWTransmitting::set_has_sensorname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EWTransmitting::clear_has_sensorname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EWTransmitting::clear_sensorname() {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    sensorname_->clear();
  }
  clear_has_sensorname();
}
inline const ::std::string& EWTransmitting::sensorname() const {
  return *sensorname_;
}
inline void EWTransmitting::set_sensorname(const ::std::string& value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void EWTransmitting::set_sensorname(const char* value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void EWTransmitting::set_sensorname(const char* value, size_t size) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWTransmitting::mutable_sensorname() {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  return sensorname_;
}
inline ::std::string* EWTransmitting::release_sensorname() {
  clear_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sensorname_;
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EWTransmitting::set_allocated_sensorname(::std::string* sensorname) {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    delete sensorname_;
  }
  if (sensorname) {
    set_has_sensorname();
    sensorname_ = sensorname;
  } else {
    clear_has_sensorname();
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EWTechniqueDescriptions

// optional string msgName = 1 [default = "EWTECHNIQUEDESCRIPTIONS"];
inline bool EWTechniqueDescriptions::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EWTechniqueDescriptions::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EWTechniqueDescriptions::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EWTechniqueDescriptions::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& EWTechniqueDescriptions::msgname() const {
  return *msgname_;
}
inline void EWTechniqueDescriptions::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWTechniqueDescriptions::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWTechniqueDescriptions::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWTechniqueDescriptions::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* EWTechniqueDescriptions::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void EWTechniqueDescriptions::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// repeated string techniqueDescription = 2;
inline int EWTechniqueDescriptions::techniquedescription_size() const {
  return techniquedescription_.size();
}
inline void EWTechniqueDescriptions::clear_techniquedescription() {
  techniquedescription_.Clear();
}
inline const ::std::string& EWTechniqueDescriptions::techniquedescription(int index) const {
  return techniquedescription_.Get(index);
}
inline ::std::string* EWTechniqueDescriptions::mutable_techniquedescription(int index) {
  return techniquedescription_.Mutable(index);
}
inline void EWTechniqueDescriptions::set_techniquedescription(int index, const ::std::string& value) {
  techniquedescription_.Mutable(index)->assign(value);
}
inline void EWTechniqueDescriptions::set_techniquedescription(int index, const char* value) {
  techniquedescription_.Mutable(index)->assign(value);
}
inline void EWTechniqueDescriptions::set_techniquedescription(int index, const char* value, size_t size) {
  techniquedescription_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWTechniqueDescriptions::add_techniquedescription() {
  return techniquedescription_.Add();
}
inline void EWTechniqueDescriptions::add_techniquedescription(const ::std::string& value) {
  techniquedescription_.Add()->assign(value);
}
inline void EWTechniqueDescriptions::add_techniquedescription(const char* value) {
  techniquedescription_.Add()->assign(value);
}
inline void EWTechniqueDescriptions::add_techniquedescription(const char* value, size_t size) {
  techniquedescription_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
EWTechniqueDescriptions::techniquedescription() const {
  return techniquedescription_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
EWTechniqueDescriptions::mutable_techniquedescription() {
  return &techniquedescription_;
}

// -------------------------------------------------------------------

// EWTechniqueDescriptionsRequest

// optional string msgName = 1 [default = "EWTECHNIQUEDESCRIPTIONSREQUEST"];
inline bool EWTechniqueDescriptionsRequest::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EWTechniqueDescriptionsRequest::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EWTechniqueDescriptionsRequest::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EWTechniqueDescriptionsRequest::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& EWTechniqueDescriptionsRequest::msgname() const {
  return *msgname_;
}
inline void EWTechniqueDescriptionsRequest::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWTechniqueDescriptionsRequest::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWTechniqueDescriptionsRequest::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWTechniqueDescriptionsRequest::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* EWTechniqueDescriptionsRequest::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void EWTechniqueDescriptionsRequest::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// -------------------------------------------------------------------

// EWOption

// optional string msgName = 1 [default = "EW_OPTION"];
inline bool EWOption::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EWOption::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EWOption::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EWOption::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& EWOption::msgname() const {
  return *msgname_;
}
inline void EWOption::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWOption::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWOption::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWOption::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* EWOption::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void EWOption::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string signalName = 2;
inline bool EWOption::has_signalname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EWOption::set_has_signalname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EWOption::clear_has_signalname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EWOption::clear_signalname() {
  if (signalname_ != &::google::protobuf::internal::kEmptyString) {
    signalname_->clear();
  }
  clear_has_signalname();
}
inline const ::std::string& EWOption::signalname() const {
  return *signalname_;
}
inline void EWOption::set_signalname(const ::std::string& value) {
  set_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    signalname_ = new ::std::string;
  }
  signalname_->assign(value);
}
inline void EWOption::set_signalname(const char* value) {
  set_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    signalname_ = new ::std::string;
  }
  signalname_->assign(value);
}
inline void EWOption::set_signalname(const char* value, size_t size) {
  set_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    signalname_ = new ::std::string;
  }
  signalname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWOption::mutable_signalname() {
  set_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    signalname_ = new ::std::string;
  }
  return signalname_;
}
inline ::std::string* EWOption::release_signalname() {
  clear_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signalname_;
    signalname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EWOption::set_allocated_signalname(::std::string* signalname) {
  if (signalname_ != &::google::protobuf::internal::kEmptyString) {
    delete signalname_;
  }
  if (signalname) {
    set_has_signalname();
    signalname_ = signalname;
  } else {
    clear_has_signalname();
    signalname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string effect = 3;
inline int EWOption::effect_size() const {
  return effect_.size();
}
inline void EWOption::clear_effect() {
  effect_.Clear();
}
inline const ::std::string& EWOption::effect(int index) const {
  return effect_.Get(index);
}
inline ::std::string* EWOption::mutable_effect(int index) {
  return effect_.Mutable(index);
}
inline void EWOption::set_effect(int index, const ::std::string& value) {
  effect_.Mutable(index)->assign(value);
}
inline void EWOption::set_effect(int index, const char* value) {
  effect_.Mutable(index)->assign(value);
}
inline void EWOption::set_effect(int index, const char* value, size_t size) {
  effect_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWOption::add_effect() {
  return effect_.Add();
}
inline void EWOption::add_effect(const ::std::string& value) {
  effect_.Add()->assign(value);
}
inline void EWOption::add_effect(const char* value) {
  effect_.Add()->assign(value);
}
inline void EWOption::add_effect(const char* value, size_t size) {
  effect_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
EWOption::effect() const {
  return effect_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
EWOption::mutable_effect() {
  return &effect_;
}

// optional .fv.tb.protos.TBProtos.EWOption.DetectionSource detectionSource = 4;
inline bool EWOption::has_detectionsource() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EWOption::set_has_detectionsource() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EWOption::clear_has_detectionsource() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EWOption::clear_detectionsource() {
  detectionsource_ = 0;
  clear_has_detectionsource();
}
inline ::fv::tb::protos::TBProtos::EWOption_DetectionSource EWOption::detectionsource() const {
  return static_cast< ::fv::tb::protos::TBProtos::EWOption_DetectionSource >(detectionsource_);
}
inline void EWOption::set_detectionsource(::fv::tb::protos::TBProtos::EWOption_DetectionSource value) {
  assert(::fv::tb::protos::TBProtos::EWOption_DetectionSource_IsValid(value));
  set_has_detectionsource();
  detectionsource_ = value;
}

// optional string globalId = 5;
inline bool EWOption::has_globalid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EWOption::set_has_globalid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EWOption::clear_has_globalid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EWOption::clear_globalid() {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    globalid_->clear();
  }
  clear_has_globalid();
}
inline const ::std::string& EWOption::globalid() const {
  return *globalid_;
}
inline void EWOption::set_globalid(const ::std::string& value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void EWOption::set_globalid(const char* value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void EWOption::set_globalid(const char* value, size_t size) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWOption::mutable_globalid() {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  return globalid_;
}
inline ::std::string* EWOption::release_globalid() {
  clear_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalid_;
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EWOption::set_allocated_globalid(::std::string* globalid) {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    delete globalid_;
  }
  if (globalid) {
    set_has_globalid();
    globalid_ = globalid;
  } else {
    clear_has_globalid();
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EWOptions

// optional string msgName = 1 [default = "EW_OPTIONS"];
inline bool EWOptions::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EWOptions::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EWOptions::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EWOptions::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& EWOptions::msgname() const {
  return *msgname_;
}
inline void EWOptions::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWOptions::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWOptions::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWOptions::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* EWOptions::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void EWOptions::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// repeated .fv.tb.protos.TBProtos.EWOption ewopt = 2;
inline int EWOptions::ewopt_size() const {
  return ewopt_.size();
}
inline void EWOptions::clear_ewopt() {
  ewopt_.Clear();
}
inline const ::fv::tb::protos::TBProtos::EWOption& EWOptions::ewopt(int index) const {
  return ewopt_.Get(index);
}
inline ::fv::tb::protos::TBProtos::EWOption* EWOptions::mutable_ewopt(int index) {
  return ewopt_.Mutable(index);
}
inline ::fv::tb::protos::TBProtos::EWOption* EWOptions::add_ewopt() {
  return ewopt_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::EWOption >&
EWOptions::ewopt() const {
  return ewopt_;
}
inline ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::EWOption >*
EWOptions::mutable_ewopt() {
  return &ewopt_;
}

// -------------------------------------------------------------------

// EWOptionsRequest

// optional string msgName = 1 [default = "EW_OPTIONS_REQUEST"];
inline bool EWOptionsRequest::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EWOptionsRequest::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EWOptionsRequest::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EWOptionsRequest::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& EWOptionsRequest::msgname() const {
  return *msgname_;
}
inline void EWOptionsRequest::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWOptionsRequest::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWOptionsRequest::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWOptionsRequest::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* EWOptionsRequest::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void EWOptionsRequest::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// -------------------------------------------------------------------

// EWStatusRequest

// optional string msgName = 1 [default = "EW_STATUS_REQUEST"];
inline bool EWStatusRequest::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EWStatusRequest::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EWStatusRequest::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EWStatusRequest::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& EWStatusRequest::msgname() const {
  return *msgname_;
}
inline void EWStatusRequest::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWStatusRequest::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWStatusRequest::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWStatusRequest::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* EWStatusRequest::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void EWStatusRequest::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// -------------------------------------------------------------------

// EWCapabilitiesRequest

// optional string msgName = 1 [default = "EW_CAPABILITIES_REQUEST"];
inline bool EWCapabilitiesRequest::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EWCapabilitiesRequest::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EWCapabilitiesRequest::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EWCapabilitiesRequest::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& EWCapabilitiesRequest::msgname() const {
  return *msgname_;
}
inline void EWCapabilitiesRequest::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWCapabilitiesRequest::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWCapabilitiesRequest::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWCapabilitiesRequest::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* EWCapabilitiesRequest::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void EWCapabilitiesRequest::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// -------------------------------------------------------------------

// EWOptionDelete

// optional string msgName = 1 [default = "EW_OPTION_DELETE"];
inline bool EWOptionDelete::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EWOptionDelete::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EWOptionDelete::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EWOptionDelete::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& EWOptionDelete::msgname() const {
  return *msgname_;
}
inline void EWOptionDelete::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWOptionDelete::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWOptionDelete::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWOptionDelete::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* EWOptionDelete::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void EWOptionDelete::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string globalId = 2;
inline bool EWOptionDelete::has_globalid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EWOptionDelete::set_has_globalid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EWOptionDelete::clear_has_globalid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EWOptionDelete::clear_globalid() {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    globalid_->clear();
  }
  clear_has_globalid();
}
inline const ::std::string& EWOptionDelete::globalid() const {
  return *globalid_;
}
inline void EWOptionDelete::set_globalid(const ::std::string& value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void EWOptionDelete::set_globalid(const char* value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void EWOptionDelete::set_globalid(const char* value, size_t size) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWOptionDelete::mutable_globalid() {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  return globalid_;
}
inline ::std::string* EWOptionDelete::release_globalid() {
  clear_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalid_;
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EWOptionDelete::set_allocated_globalid(::std::string* globalid) {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    delete globalid_;
  }
  if (globalid) {
    set_has_globalid();
    globalid_ = globalid;
  } else {
    clear_has_globalid();
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EWCeaseBuzzer

// optional string msgName = 1 [default = "EW_CEASE_BUZZER"];
inline bool EWCeaseBuzzer::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EWCeaseBuzzer::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EWCeaseBuzzer::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EWCeaseBuzzer::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& EWCeaseBuzzer::msgname() const {
  return *msgname_;
}
inline void EWCeaseBuzzer::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWCeaseBuzzer::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWCeaseBuzzer::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWCeaseBuzzer::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* EWCeaseBuzzer::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void EWCeaseBuzzer::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// -------------------------------------------------------------------

// TxAntennaConfig

// optional string msgName = 1 [default = "TX_ANTENNA_CONFIG"];
inline bool TxAntennaConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxAntennaConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxAntennaConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxAntennaConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& TxAntennaConfig::msgname() const {
  return *msgname_;
}
inline void TxAntennaConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void TxAntennaConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void TxAntennaConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxAntennaConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* TxAntennaConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void TxAntennaConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string antName = 2;
inline bool TxAntennaConfig::has_antname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxAntennaConfig::set_has_antname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxAntennaConfig::clear_has_antname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxAntennaConfig::clear_antname() {
  if (antname_ != &::google::protobuf::internal::kEmptyString) {
    antname_->clear();
  }
  clear_has_antname();
}
inline const ::std::string& TxAntennaConfig::antname() const {
  return *antname_;
}
inline void TxAntennaConfig::set_antname(const ::std::string& value) {
  set_has_antname();
  if (antname_ == &::google::protobuf::internal::kEmptyString) {
    antname_ = new ::std::string;
  }
  antname_->assign(value);
}
inline void TxAntennaConfig::set_antname(const char* value) {
  set_has_antname();
  if (antname_ == &::google::protobuf::internal::kEmptyString) {
    antname_ = new ::std::string;
  }
  antname_->assign(value);
}
inline void TxAntennaConfig::set_antname(const char* value, size_t size) {
  set_has_antname();
  if (antname_ == &::google::protobuf::internal::kEmptyString) {
    antname_ = new ::std::string;
  }
  antname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxAntennaConfig::mutable_antname() {
  set_has_antname();
  if (antname_ == &::google::protobuf::internal::kEmptyString) {
    antname_ = new ::std::string;
  }
  return antname_;
}
inline ::std::string* TxAntennaConfig::release_antname() {
  clear_has_antname();
  if (antname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = antname_;
    antname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TxAntennaConfig::set_allocated_antname(::std::string* antname) {
  if (antname_ != &::google::protobuf::internal::kEmptyString) {
    delete antname_;
  }
  if (antname) {
    set_has_antname();
    antname_ = antname;
  } else {
    clear_has_antname();
    antname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double minRF = 3;
inline bool TxAntennaConfig::has_minrf() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxAntennaConfig::set_has_minrf() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxAntennaConfig::clear_has_minrf() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxAntennaConfig::clear_minrf() {
  minrf_ = 0;
  clear_has_minrf();
}
inline double TxAntennaConfig::minrf() const {
  return minrf_;
}
inline void TxAntennaConfig::set_minrf(double value) {
  set_has_minrf();
  minrf_ = value;
}

// optional double maxRF = 4;
inline bool TxAntennaConfig::has_maxrf() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TxAntennaConfig::set_has_maxrf() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TxAntennaConfig::clear_has_maxrf() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TxAntennaConfig::clear_maxrf() {
  maxrf_ = 0;
  clear_has_maxrf();
}
inline double TxAntennaConfig::maxrf() const {
  return maxrf_;
}
inline void TxAntennaConfig::set_maxrf(double value) {
  set_has_maxrf();
  maxrf_ = value;
}

// optional float fixedAngle = 5 [default = -999];
inline bool TxAntennaConfig::has_fixedangle() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TxAntennaConfig::set_has_fixedangle() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TxAntennaConfig::clear_has_fixedangle() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TxAntennaConfig::clear_fixedangle() {
  fixedangle_ = -999;
  clear_has_fixedangle();
}
inline float TxAntennaConfig::fixedangle() const {
  return fixedangle_;
}
inline void TxAntennaConfig::set_fixedangle(float value) {
  set_has_fixedangle();
  fixedangle_ = value;
}

// optional float latitude = 6 [default = 0];
inline bool TxAntennaConfig::has_latitude() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TxAntennaConfig::set_has_latitude() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TxAntennaConfig::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TxAntennaConfig::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline float TxAntennaConfig::latitude() const {
  return latitude_;
}
inline void TxAntennaConfig::set_latitude(float value) {
  set_has_latitude();
  latitude_ = value;
}

// optional float longitude = 7 [default = 0];
inline bool TxAntennaConfig::has_longitude() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TxAntennaConfig::set_has_longitude() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TxAntennaConfig::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TxAntennaConfig::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline float TxAntennaConfig::longitude() const {
  return longitude_;
}
inline void TxAntennaConfig::set_longitude(float value) {
  set_has_longitude();
  longitude_ = value;
}

// optional float altitude = 8 [default = 0];
inline bool TxAntennaConfig::has_altitude() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TxAntennaConfig::set_has_altitude() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TxAntennaConfig::clear_has_altitude() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TxAntennaConfig::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline float TxAntennaConfig::altitude() const {
  return altitude_;
}
inline void TxAntennaConfig::set_altitude(float value) {
  set_has_altitude();
  altitude_ = value;
}

// optional float beamwidth = 9 [default = 0];
inline bool TxAntennaConfig::has_beamwidth() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TxAntennaConfig::set_has_beamwidth() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TxAntennaConfig::clear_has_beamwidth() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TxAntennaConfig::clear_beamwidth() {
  beamwidth_ = 0;
  clear_has_beamwidth();
}
inline float TxAntennaConfig::beamwidth() const {
  return beamwidth_;
}
inline void TxAntennaConfig::set_beamwidth(float value) {
  set_has_beamwidth();
  beamwidth_ = value;
}

// optional float dwncnvtLO = 10 [default = 0];
inline bool TxAntennaConfig::has_dwncnvtlo() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TxAntennaConfig::set_has_dwncnvtlo() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TxAntennaConfig::clear_has_dwncnvtlo() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TxAntennaConfig::clear_dwncnvtlo() {
  dwncnvtlo_ = 0;
  clear_has_dwncnvtlo();
}
inline float TxAntennaConfig::dwncnvtlo() const {
  return dwncnvtlo_;
}
inline void TxAntennaConfig::set_dwncnvtlo(float value) {
  set_has_dwncnvtlo();
  dwncnvtlo_ = value;
}

// optional int32 ssc = 11 [default = -1];
inline bool TxAntennaConfig::has_ssc() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TxAntennaConfig::set_has_ssc() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TxAntennaConfig::clear_has_ssc() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TxAntennaConfig::clear_ssc() {
  ssc_ = -1;
  clear_has_ssc();
}
inline ::google::protobuf::int32 TxAntennaConfig::ssc() const {
  return ssc_;
}
inline void TxAntennaConfig::set_ssc(::google::protobuf::int32 value) {
  set_has_ssc();
  ssc_ = value;
}

// optional string band = 12;
inline bool TxAntennaConfig::has_band() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TxAntennaConfig::set_has_band() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TxAntennaConfig::clear_has_band() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TxAntennaConfig::clear_band() {
  if (band_ != &::google::protobuf::internal::kEmptyString) {
    band_->clear();
  }
  clear_has_band();
}
inline const ::std::string& TxAntennaConfig::band() const {
  return *band_;
}
inline void TxAntennaConfig::set_band(const ::std::string& value) {
  set_has_band();
  if (band_ == &::google::protobuf::internal::kEmptyString) {
    band_ = new ::std::string;
  }
  band_->assign(value);
}
inline void TxAntennaConfig::set_band(const char* value) {
  set_has_band();
  if (band_ == &::google::protobuf::internal::kEmptyString) {
    band_ = new ::std::string;
  }
  band_->assign(value);
}
inline void TxAntennaConfig::set_band(const char* value, size_t size) {
  set_has_band();
  if (band_ == &::google::protobuf::internal::kEmptyString) {
    band_ = new ::std::string;
  }
  band_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxAntennaConfig::mutable_band() {
  set_has_band();
  if (band_ == &::google::protobuf::internal::kEmptyString) {
    band_ = new ::std::string;
  }
  return band_;
}
inline ::std::string* TxAntennaConfig::release_band() {
  clear_has_band();
  if (band_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = band_;
    band_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TxAntennaConfig::set_allocated_band(::std::string* band) {
  if (band_ != &::google::protobuf::internal::kEmptyString) {
    delete band_;
  }
  if (band) {
    set_has_band();
    band_ = band;
  } else {
    clear_has_band();
    band_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string polarization = 13;
inline bool TxAntennaConfig::has_polarization() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TxAntennaConfig::set_has_polarization() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TxAntennaConfig::clear_has_polarization() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TxAntennaConfig::clear_polarization() {
  if (polarization_ != &::google::protobuf::internal::kEmptyString) {
    polarization_->clear();
  }
  clear_has_polarization();
}
inline const ::std::string& TxAntennaConfig::polarization() const {
  return *polarization_;
}
inline void TxAntennaConfig::set_polarization(const ::std::string& value) {
  set_has_polarization();
  if (polarization_ == &::google::protobuf::internal::kEmptyString) {
    polarization_ = new ::std::string;
  }
  polarization_->assign(value);
}
inline void TxAntennaConfig::set_polarization(const char* value) {
  set_has_polarization();
  if (polarization_ == &::google::protobuf::internal::kEmptyString) {
    polarization_ = new ::std::string;
  }
  polarization_->assign(value);
}
inline void TxAntennaConfig::set_polarization(const char* value, size_t size) {
  set_has_polarization();
  if (polarization_ == &::google::protobuf::internal::kEmptyString) {
    polarization_ = new ::std::string;
  }
  polarization_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxAntennaConfig::mutable_polarization() {
  set_has_polarization();
  if (polarization_ == &::google::protobuf::internal::kEmptyString) {
    polarization_ = new ::std::string;
  }
  return polarization_;
}
inline ::std::string* TxAntennaConfig::release_polarization() {
  clear_has_polarization();
  if (polarization_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = polarization_;
    polarization_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TxAntennaConfig::set_allocated_polarization(::std::string* polarization) {
  if (polarization_ != &::google::protobuf::internal::kEmptyString) {
    delete polarization_;
  }
  if (polarization) {
    set_has_polarization();
    polarization_ = polarization;
  } else {
    clear_has_polarization();
    polarization_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 group = 14;
inline bool TxAntennaConfig::has_group() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TxAntennaConfig::set_has_group() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TxAntennaConfig::clear_has_group() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TxAntennaConfig::clear_group() {
  group_ = 0;
  clear_has_group();
}
inline ::google::protobuf::int32 TxAntennaConfig::group() const {
  return group_;
}
inline void TxAntennaConfig::set_group(::google::protobuf::int32 value) {
  set_has_group();
  group_ = value;
}

// optional float sightDistance = 15 [default = 500];
inline bool TxAntennaConfig::has_sightdistance() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TxAntennaConfig::set_has_sightdistance() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TxAntennaConfig::clear_has_sightdistance() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TxAntennaConfig::clear_sightdistance() {
  sightdistance_ = 500;
  clear_has_sightdistance();
}
inline float TxAntennaConfig::sightdistance() const {
  return sightdistance_;
}
inline void TxAntennaConfig::set_sightdistance(float value) {
  set_has_sightdistance();
  sightdistance_ = value;
}

// optional string noiseTest = 16 [default = "NO_TEST"];
inline bool TxAntennaConfig::has_noisetest() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TxAntennaConfig::set_has_noisetest() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TxAntennaConfig::clear_has_noisetest() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TxAntennaConfig::clear_noisetest() {
  if (noisetest_ != _default_noisetest_) {
    noisetest_->assign(*_default_noisetest_);
  }
  clear_has_noisetest();
}
inline const ::std::string& TxAntennaConfig::noisetest() const {
  return *noisetest_;
}
inline void TxAntennaConfig::set_noisetest(const ::std::string& value) {
  set_has_noisetest();
  if (noisetest_ == _default_noisetest_) {
    noisetest_ = new ::std::string;
  }
  noisetest_->assign(value);
}
inline void TxAntennaConfig::set_noisetest(const char* value) {
  set_has_noisetest();
  if (noisetest_ == _default_noisetest_) {
    noisetest_ = new ::std::string;
  }
  noisetest_->assign(value);
}
inline void TxAntennaConfig::set_noisetest(const char* value, size_t size) {
  set_has_noisetest();
  if (noisetest_ == _default_noisetest_) {
    noisetest_ = new ::std::string;
  }
  noisetest_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxAntennaConfig::mutable_noisetest() {
  set_has_noisetest();
  if (noisetest_ == _default_noisetest_) {
    noisetest_ = new ::std::string(*_default_noisetest_);
  }
  return noisetest_;
}
inline ::std::string* TxAntennaConfig::release_noisetest() {
  clear_has_noisetest();
  if (noisetest_ == _default_noisetest_) {
    return NULL;
  } else {
    ::std::string* temp = noisetest_;
    noisetest_ = const_cast< ::std::string*>(_default_noisetest_);
    return temp;
  }
}
inline void TxAntennaConfig::set_allocated_noisetest(::std::string* noisetest) {
  if (noisetest_ != _default_noisetest_) {
    delete noisetest_;
  }
  if (noisetest) {
    set_has_noisetest();
    noisetest_ = noisetest;
  } else {
    clear_has_noisetest();
    noisetest_ = const_cast< ::std::string*>(_default_noisetest_);
  }
}

// -------------------------------------------------------------------

// TxAmpConfig

// optional string msgName = 1 [default = "TX_AMP_CONFIG"];
inline bool TxAmpConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxAmpConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxAmpConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxAmpConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& TxAmpConfig::msgname() const {
  return *msgname_;
}
inline void TxAmpConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void TxAmpConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void TxAmpConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxAmpConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* TxAmpConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void TxAmpConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string ampName = 2;
inline bool TxAmpConfig::has_ampname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxAmpConfig::set_has_ampname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxAmpConfig::clear_has_ampname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxAmpConfig::clear_ampname() {
  if (ampname_ != &::google::protobuf::internal::kEmptyString) {
    ampname_->clear();
  }
  clear_has_ampname();
}
inline const ::std::string& TxAmpConfig::ampname() const {
  return *ampname_;
}
inline void TxAmpConfig::set_ampname(const ::std::string& value) {
  set_has_ampname();
  if (ampname_ == &::google::protobuf::internal::kEmptyString) {
    ampname_ = new ::std::string;
  }
  ampname_->assign(value);
}
inline void TxAmpConfig::set_ampname(const char* value) {
  set_has_ampname();
  if (ampname_ == &::google::protobuf::internal::kEmptyString) {
    ampname_ = new ::std::string;
  }
  ampname_->assign(value);
}
inline void TxAmpConfig::set_ampname(const char* value, size_t size) {
  set_has_ampname();
  if (ampname_ == &::google::protobuf::internal::kEmptyString) {
    ampname_ = new ::std::string;
  }
  ampname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxAmpConfig::mutable_ampname() {
  set_has_ampname();
  if (ampname_ == &::google::protobuf::internal::kEmptyString) {
    ampname_ = new ::std::string;
  }
  return ampname_;
}
inline ::std::string* TxAmpConfig::release_ampname() {
  clear_has_ampname();
  if (ampname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ampname_;
    ampname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TxAmpConfig::set_allocated_ampname(::std::string* ampname) {
  if (ampname_ != &::google::protobuf::internal::kEmptyString) {
    delete ampname_;
  }
  if (ampname) {
    set_has_ampname();
    ampname_ = ampname;
  } else {
    clear_has_ampname();
    ampname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string IP = 3 [default = "nportserver"];
inline bool TxAmpConfig::has_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxAmpConfig::set_has_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxAmpConfig::clear_has_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxAmpConfig::clear_ip() {
  if (ip_ != _default_ip_) {
    ip_->assign(*_default_ip_);
  }
  clear_has_ip();
}
inline const ::std::string& TxAmpConfig::ip() const {
  return *ip_;
}
inline void TxAmpConfig::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == _default_ip_) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void TxAmpConfig::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == _default_ip_) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void TxAmpConfig::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == _default_ip_) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxAmpConfig::mutable_ip() {
  set_has_ip();
  if (ip_ == _default_ip_) {
    ip_ = new ::std::string(*_default_ip_);
  }
  return ip_;
}
inline ::std::string* TxAmpConfig::release_ip() {
  clear_has_ip();
  if (ip_ == _default_ip_) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(_default_ip_);
    return temp;
  }
}
inline void TxAmpConfig::set_allocated_ip(::std::string* ip) {
  if (ip_ != _default_ip_) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(_default_ip_);
  }
}

// optional int32 port = 4 [default = 4012];
inline bool TxAmpConfig::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TxAmpConfig::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TxAmpConfig::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TxAmpConfig::clear_port() {
  port_ = 4012;
  clear_has_port();
}
inline ::google::protobuf::int32 TxAmpConfig::port() const {
  return port_;
}
inline void TxAmpConfig::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// optional bool hardware = 5;
inline bool TxAmpConfig::has_hardware() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TxAmpConfig::set_has_hardware() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TxAmpConfig::clear_has_hardware() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TxAmpConfig::clear_hardware() {
  hardware_ = false;
  clear_has_hardware();
}
inline bool TxAmpConfig::hardware() const {
  return hardware_;
}
inline void TxAmpConfig::set_hardware(bool value) {
  set_has_hardware();
  hardware_ = value;
}

// -------------------------------------------------------------------

// TransmitterConfig

// optional string msgName = 1 [default = "TRANSMITTER_CONFIG"];
inline bool TransmitterConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransmitterConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransmitterConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransmitterConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& TransmitterConfig::msgname() const {
  return *msgname_;
}
inline void TransmitterConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void TransmitterConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void TransmitterConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransmitterConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* TransmitterConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void TransmitterConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string txName = 2;
inline bool TransmitterConfig::has_txname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransmitterConfig::set_has_txname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransmitterConfig::clear_has_txname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransmitterConfig::clear_txname() {
  if (txname_ != &::google::protobuf::internal::kEmptyString) {
    txname_->clear();
  }
  clear_has_txname();
}
inline const ::std::string& TransmitterConfig::txname() const {
  return *txname_;
}
inline void TransmitterConfig::set_txname(const ::std::string& value) {
  set_has_txname();
  if (txname_ == &::google::protobuf::internal::kEmptyString) {
    txname_ = new ::std::string;
  }
  txname_->assign(value);
}
inline void TransmitterConfig::set_txname(const char* value) {
  set_has_txname();
  if (txname_ == &::google::protobuf::internal::kEmptyString) {
    txname_ = new ::std::string;
  }
  txname_->assign(value);
}
inline void TransmitterConfig::set_txname(const char* value, size_t size) {
  set_has_txname();
  if (txname_ == &::google::protobuf::internal::kEmptyString) {
    txname_ = new ::std::string;
  }
  txname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransmitterConfig::mutable_txname() {
  set_has_txname();
  if (txname_ == &::google::protobuf::internal::kEmptyString) {
    txname_ = new ::std::string;
  }
  return txname_;
}
inline ::std::string* TransmitterConfig::release_txname() {
  clear_has_txname();
  if (txname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txname_;
    txname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransmitterConfig::set_allocated_txname(::std::string* txname) {
  if (txname_ != &::google::protobuf::internal::kEmptyString) {
    delete txname_;
  }
  if (txname) {
    set_has_txname();
    txname_ = txname;
  } else {
    clear_has_txname();
    txname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float clkFreq = 3 [default = 4e+08];
inline bool TransmitterConfig::has_clkfreq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransmitterConfig::set_has_clkfreq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransmitterConfig::clear_has_clkfreq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransmitterConfig::clear_clkfreq() {
  clkfreq_ = 4e+08f;
  clear_has_clkfreq();
}
inline float TransmitterConfig::clkfreq() const {
  return clkfreq_;
}
inline void TransmitterConfig::set_clkfreq(float value) {
  set_has_clkfreq();
  clkfreq_ = value;
}

// optional int32 dacInterp = 4 [default = 16];
inline bool TransmitterConfig::has_dacinterp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransmitterConfig::set_has_dacinterp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransmitterConfig::clear_has_dacinterp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransmitterConfig::clear_dacinterp() {
  dacinterp_ = 16;
  clear_has_dacinterp();
}
inline ::google::protobuf::int32 TransmitterConfig::dacinterp() const {
  return dacinterp_;
}
inline void TransmitterConfig::set_dacinterp(::google::protobuf::int32 value) {
  set_has_dacinterp();
  dacinterp_ = value;
}

// optional int32 coreInterp = 5 [default = 1];
inline bool TransmitterConfig::has_coreinterp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TransmitterConfig::set_has_coreinterp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TransmitterConfig::clear_has_coreinterp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TransmitterConfig::clear_coreinterp() {
  coreinterp_ = 1;
  clear_has_coreinterp();
}
inline ::google::protobuf::int32 TransmitterConfig::coreinterp() const {
  return coreinterp_;
}
inline void TransmitterConfig::set_coreinterp(::google::protobuf::int32 value) {
  set_has_coreinterp();
  coreinterp_ = value;
}

// optional int32 baseChan = 6 [default = 1];
inline bool TransmitterConfig::has_basechan() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TransmitterConfig::set_has_basechan() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TransmitterConfig::clear_has_basechan() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TransmitterConfig::clear_basechan() {
  basechan_ = 1;
  clear_has_basechan();
}
inline ::google::protobuf::int32 TransmitterConfig::basechan() const {
  return basechan_;
}
inline void TransmitterConfig::set_basechan(::google::protobuf::int32 value) {
  set_has_basechan();
  basechan_ = value;
}

// optional int32 numBuffers = 7 [default = 2];
inline bool TransmitterConfig::has_numbuffers() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TransmitterConfig::set_has_numbuffers() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TransmitterConfig::clear_has_numbuffers() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TransmitterConfig::clear_numbuffers() {
  numbuffers_ = 2;
  clear_has_numbuffers();
}
inline ::google::protobuf::int32 TransmitterConfig::numbuffers() const {
  return numbuffers_;
}
inline void TransmitterConfig::set_numbuffers(::google::protobuf::int32 value) {
  set_has_numbuffers();
  numbuffers_ = value;
}

// optional float freqShift = 8 [default = 0];
inline bool TransmitterConfig::has_freqshift() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TransmitterConfig::set_has_freqshift() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TransmitterConfig::clear_has_freqshift() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TransmitterConfig::clear_freqshift() {
  freqshift_ = 0;
  clear_has_freqshift();
}
inline float TransmitterConfig::freqshift() const {
  return freqshift_;
}
inline void TransmitterConfig::set_freqshift(float value) {
  set_has_freqshift();
  freqshift_ = value;
}

// optional string siggenIP = 9;
inline bool TransmitterConfig::has_siggenip() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TransmitterConfig::set_has_siggenip() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TransmitterConfig::clear_has_siggenip() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TransmitterConfig::clear_siggenip() {
  if (siggenip_ != &::google::protobuf::internal::kEmptyString) {
    siggenip_->clear();
  }
  clear_has_siggenip();
}
inline const ::std::string& TransmitterConfig::siggenip() const {
  return *siggenip_;
}
inline void TransmitterConfig::set_siggenip(const ::std::string& value) {
  set_has_siggenip();
  if (siggenip_ == &::google::protobuf::internal::kEmptyString) {
    siggenip_ = new ::std::string;
  }
  siggenip_->assign(value);
}
inline void TransmitterConfig::set_siggenip(const char* value) {
  set_has_siggenip();
  if (siggenip_ == &::google::protobuf::internal::kEmptyString) {
    siggenip_ = new ::std::string;
  }
  siggenip_->assign(value);
}
inline void TransmitterConfig::set_siggenip(const char* value, size_t size) {
  set_has_siggenip();
  if (siggenip_ == &::google::protobuf::internal::kEmptyString) {
    siggenip_ = new ::std::string;
  }
  siggenip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransmitterConfig::mutable_siggenip() {
  set_has_siggenip();
  if (siggenip_ == &::google::protobuf::internal::kEmptyString) {
    siggenip_ = new ::std::string;
  }
  return siggenip_;
}
inline ::std::string* TransmitterConfig::release_siggenip() {
  clear_has_siggenip();
  if (siggenip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = siggenip_;
    siggenip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransmitterConfig::set_allocated_siggenip(::std::string* siggenip) {
  if (siggenip_ != &::google::protobuf::internal::kEmptyString) {
    delete siggenip_;
  }
  if (siggenip) {
    set_has_siggenip();
    siggenip_ = siggenip;
  } else {
    clear_has_siggenip();
    siggenip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .fv.tb.protos.TBProtos.TransmitterConfig.SiggenType siggenType = 10 [default = ROHDE_SCHWARZ];
inline bool TransmitterConfig::has_siggentype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TransmitterConfig::set_has_siggentype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TransmitterConfig::clear_has_siggentype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TransmitterConfig::clear_siggentype() {
  siggentype_ = 0;
  clear_has_siggentype();
}
inline ::fv::tb::protos::TBProtos::TransmitterConfig_SiggenType TransmitterConfig::siggentype() const {
  return static_cast< ::fv::tb::protos::TBProtos::TransmitterConfig_SiggenType >(siggentype_);
}
inline void TransmitterConfig::set_siggentype(::fv::tb::protos::TBProtos::TransmitterConfig_SiggenType value) {
  assert(::fv::tb::protos::TBProtos::TransmitterConfig_SiggenType_IsValid(value));
  set_has_siggentype();
  siggentype_ = value;
}

// -------------------------------------------------------------------

// techniqueCommand

// optional string msgName = 1 [default = "TECHNIQUECOMMAND"];
inline bool techniqueCommand::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void techniqueCommand::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void techniqueCommand::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void techniqueCommand::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& techniqueCommand::msgname() const {
  return *msgname_;
}
inline void techniqueCommand::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void techniqueCommand::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void techniqueCommand::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* techniqueCommand::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* techniqueCommand::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void techniqueCommand::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional .fv.tb.protos.TBProtos.techniqueCommand.CommandType command = 2;
inline bool techniqueCommand::has_command() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void techniqueCommand::set_has_command() {
  _has_bits_[0] |= 0x00000002u;
}
inline void techniqueCommand::clear_has_command() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void techniqueCommand::clear_command() {
  command_ = 0;
  clear_has_command();
}
inline ::fv::tb::protos::TBProtos::techniqueCommand_CommandType techniqueCommand::command() const {
  return static_cast< ::fv::tb::protos::TBProtos::techniqueCommand_CommandType >(command_);
}
inline void techniqueCommand::set_command(::fv::tb::protos::TBProtos::techniqueCommand_CommandType value) {
  assert(::fv::tb::protos::TBProtos::techniqueCommand_CommandType_IsValid(value));
  set_has_command();
  command_ = value;
}

// optional .fv.tb.protos.TBProtos.EWCapability ewcap = 3;
inline bool techniqueCommand::has_ewcap() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void techniqueCommand::set_has_ewcap() {
  _has_bits_[0] |= 0x00000004u;
}
inline void techniqueCommand::clear_has_ewcap() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void techniqueCommand::clear_ewcap() {
  if (ewcap_ != NULL) ewcap_->::fv::tb::protos::TBProtos::EWCapability::Clear();
  clear_has_ewcap();
}
inline const ::fv::tb::protos::TBProtos::EWCapability& techniqueCommand::ewcap() const {
  return ewcap_ != NULL ? *ewcap_ : *default_instance_->ewcap_;
}
inline ::fv::tb::protos::TBProtos::EWCapability* techniqueCommand::mutable_ewcap() {
  set_has_ewcap();
  if (ewcap_ == NULL) ewcap_ = new ::fv::tb::protos::TBProtos::EWCapability;
  return ewcap_;
}
inline ::fv::tb::protos::TBProtos::EWCapability* techniqueCommand::release_ewcap() {
  clear_has_ewcap();
  ::fv::tb::protos::TBProtos::EWCapability* temp = ewcap_;
  ewcap_ = NULL;
  return temp;
}
inline void techniqueCommand::set_allocated_ewcap(::fv::tb::protos::TBProtos::EWCapability* ewcap) {
  delete ewcap_;
  ewcap_ = ewcap;
  if (ewcap) {
    set_has_ewcap();
  } else {
    clear_has_ewcap();
  }
}

// -------------------------------------------------------------------

// newSignalFrame

// optional string msgName = 1 [default = "NEWSIGNALFRAME"];
inline bool newSignalFrame::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void newSignalFrame::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void newSignalFrame::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void newSignalFrame::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& newSignalFrame::msgname() const {
  return *msgname_;
}
inline void newSignalFrame::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void newSignalFrame::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void newSignalFrame::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* newSignalFrame::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* newSignalFrame::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void newSignalFrame::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string radioName = 2;
inline bool newSignalFrame::has_radioname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void newSignalFrame::set_has_radioname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void newSignalFrame::clear_has_radioname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void newSignalFrame::clear_radioname() {
  if (radioname_ != &::google::protobuf::internal::kEmptyString) {
    radioname_->clear();
  }
  clear_has_radioname();
}
inline const ::std::string& newSignalFrame::radioname() const {
  return *radioname_;
}
inline void newSignalFrame::set_radioname(const ::std::string& value) {
  set_has_radioname();
  if (radioname_ == &::google::protobuf::internal::kEmptyString) {
    radioname_ = new ::std::string;
  }
  radioname_->assign(value);
}
inline void newSignalFrame::set_radioname(const char* value) {
  set_has_radioname();
  if (radioname_ == &::google::protobuf::internal::kEmptyString) {
    radioname_ = new ::std::string;
  }
  radioname_->assign(value);
}
inline void newSignalFrame::set_radioname(const char* value, size_t size) {
  set_has_radioname();
  if (radioname_ == &::google::protobuf::internal::kEmptyString) {
    radioname_ = new ::std::string;
  }
  radioname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* newSignalFrame::mutable_radioname() {
  set_has_radioname();
  if (radioname_ == &::google::protobuf::internal::kEmptyString) {
    radioname_ = new ::std::string;
  }
  return radioname_;
}
inline ::std::string* newSignalFrame::release_radioname() {
  clear_has_radioname();
  if (radioname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = radioname_;
    radioname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void newSignalFrame::set_allocated_radioname(::std::string* radioname) {
  if (radioname_ != &::google::protobuf::internal::kEmptyString) {
    delete radioname_;
  }
  if (radioname) {
    set_has_radioname();
    radioname_ = radioname;
  } else {
    clear_has_radioname();
    radioname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 frameID = 3;
inline bool newSignalFrame::has_frameid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void newSignalFrame::set_has_frameid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void newSignalFrame::clear_has_frameid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void newSignalFrame::clear_frameid() {
  frameid_ = 0;
  clear_has_frameid();
}
inline ::google::protobuf::int32 newSignalFrame::frameid() const {
  return frameid_;
}
inline void newSignalFrame::set_frameid(::google::protobuf::int32 value) {
  set_has_frameid();
  frameid_ = value;
}

// -------------------------------------------------------------------

// RegisterQuery

// optional string msgName = 1 [default = "REGISTERQUERY"];
inline bool RegisterQuery::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterQuery::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterQuery::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterQuery::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& RegisterQuery::msgname() const {
  return *msgname_;
}
inline void RegisterQuery::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RegisterQuery::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RegisterQuery::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterQuery::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* RegisterQuery::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void RegisterQuery::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string sensorName = 2;
inline bool RegisterQuery::has_sensorname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterQuery::set_has_sensorname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterQuery::clear_has_sensorname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterQuery::clear_sensorname() {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    sensorname_->clear();
  }
  clear_has_sensorname();
}
inline const ::std::string& RegisterQuery::sensorname() const {
  return *sensorname_;
}
inline void RegisterQuery::set_sensorname(const ::std::string& value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void RegisterQuery::set_sensorname(const char* value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void RegisterQuery::set_sensorname(const char* value, size_t size) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterQuery::mutable_sensorname() {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  return sensorname_;
}
inline ::std::string* RegisterQuery::release_sensorname() {
  clear_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sensorname_;
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterQuery::set_allocated_sensorname(::std::string* sensorname) {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    delete sensorname_;
  }
  if (sensorname) {
    set_has_sensorname();
    sensorname_ = sensorname;
  } else {
    clear_has_sensorname();
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RegisterRequest

// optional string msgName = 1 [default = "REGISTERREQUEST"];
inline bool RegisterRequest::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterRequest::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterRequest::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterRequest::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& RegisterRequest::msgname() const {
  return *msgname_;
}
inline void RegisterRequest::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RegisterRequest::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RegisterRequest::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterRequest::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* RegisterRequest::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void RegisterRequest::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string platformName = 2;
inline bool RegisterRequest::has_platformname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterRequest::set_has_platformname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterRequest::clear_has_platformname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterRequest::clear_platformname() {
  if (platformname_ != &::google::protobuf::internal::kEmptyString) {
    platformname_->clear();
  }
  clear_has_platformname();
}
inline const ::std::string& RegisterRequest::platformname() const {
  return *platformname_;
}
inline void RegisterRequest::set_platformname(const ::std::string& value) {
  set_has_platformname();
  if (platformname_ == &::google::protobuf::internal::kEmptyString) {
    platformname_ = new ::std::string;
  }
  platformname_->assign(value);
}
inline void RegisterRequest::set_platformname(const char* value) {
  set_has_platformname();
  if (platformname_ == &::google::protobuf::internal::kEmptyString) {
    platformname_ = new ::std::string;
  }
  platformname_->assign(value);
}
inline void RegisterRequest::set_platformname(const char* value, size_t size) {
  set_has_platformname();
  if (platformname_ == &::google::protobuf::internal::kEmptyString) {
    platformname_ = new ::std::string;
  }
  platformname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterRequest::mutable_platformname() {
  set_has_platformname();
  if (platformname_ == &::google::protobuf::internal::kEmptyString) {
    platformname_ = new ::std::string;
  }
  return platformname_;
}
inline ::std::string* RegisterRequest::release_platformname() {
  clear_has_platformname();
  if (platformname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = platformname_;
    platformname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterRequest::set_allocated_platformname(::std::string* platformname) {
  if (platformname_ != &::google::protobuf::internal::kEmptyString) {
    delete platformname_;
  }
  if (platformname) {
    set_has_platformname();
    platformname_ = platformname;
  } else {
    clear_has_platformname();
    platformname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string techniqueName = 3;
inline bool RegisterRequest::has_techniquename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterRequest::set_has_techniquename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterRequest::clear_has_techniquename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterRequest::clear_techniquename() {
  if (techniquename_ != &::google::protobuf::internal::kEmptyString) {
    techniquename_->clear();
  }
  clear_has_techniquename();
}
inline const ::std::string& RegisterRequest::techniquename() const {
  return *techniquename_;
}
inline void RegisterRequest::set_techniquename(const ::std::string& value) {
  set_has_techniquename();
  if (techniquename_ == &::google::protobuf::internal::kEmptyString) {
    techniquename_ = new ::std::string;
  }
  techniquename_->assign(value);
}
inline void RegisterRequest::set_techniquename(const char* value) {
  set_has_techniquename();
  if (techniquename_ == &::google::protobuf::internal::kEmptyString) {
    techniquename_ = new ::std::string;
  }
  techniquename_->assign(value);
}
inline void RegisterRequest::set_techniquename(const char* value, size_t size) {
  set_has_techniquename();
  if (techniquename_ == &::google::protobuf::internal::kEmptyString) {
    techniquename_ = new ::std::string;
  }
  techniquename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterRequest::mutable_techniquename() {
  set_has_techniquename();
  if (techniquename_ == &::google::protobuf::internal::kEmptyString) {
    techniquename_ = new ::std::string;
  }
  return techniquename_;
}
inline ::std::string* RegisterRequest::release_techniquename() {
  clear_has_techniquename();
  if (techniquename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = techniquename_;
    techniquename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterRequest::set_allocated_techniquename(::std::string* techniquename) {
  if (techniquename_ != &::google::protobuf::internal::kEmptyString) {
    delete techniquename_;
  }
  if (techniquename) {
    set_has_techniquename();
    techniquename_ = techniquename;
  } else {
    clear_has_techniquename();
    techniquename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string tbUniqueID = 4;
inline bool RegisterRequest::has_tbuniqueid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegisterRequest::set_has_tbuniqueid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegisterRequest::clear_has_tbuniqueid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegisterRequest::clear_tbuniqueid() {
  if (tbuniqueid_ != &::google::protobuf::internal::kEmptyString) {
    tbuniqueid_->clear();
  }
  clear_has_tbuniqueid();
}
inline const ::std::string& RegisterRequest::tbuniqueid() const {
  return *tbuniqueid_;
}
inline void RegisterRequest::set_tbuniqueid(const ::std::string& value) {
  set_has_tbuniqueid();
  if (tbuniqueid_ == &::google::protobuf::internal::kEmptyString) {
    tbuniqueid_ = new ::std::string;
  }
  tbuniqueid_->assign(value);
}
inline void RegisterRequest::set_tbuniqueid(const char* value) {
  set_has_tbuniqueid();
  if (tbuniqueid_ == &::google::protobuf::internal::kEmptyString) {
    tbuniqueid_ = new ::std::string;
  }
  tbuniqueid_->assign(value);
}
inline void RegisterRequest::set_tbuniqueid(const char* value, size_t size) {
  set_has_tbuniqueid();
  if (tbuniqueid_ == &::google::protobuf::internal::kEmptyString) {
    tbuniqueid_ = new ::std::string;
  }
  tbuniqueid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterRequest::mutable_tbuniqueid() {
  set_has_tbuniqueid();
  if (tbuniqueid_ == &::google::protobuf::internal::kEmptyString) {
    tbuniqueid_ = new ::std::string;
  }
  return tbuniqueid_;
}
inline ::std::string* RegisterRequest::release_tbuniqueid() {
  clear_has_tbuniqueid();
  if (tbuniqueid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tbuniqueid_;
    tbuniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterRequest::set_allocated_tbuniqueid(::std::string* tbuniqueid) {
  if (tbuniqueid_ != &::google::protobuf::internal::kEmptyString) {
    delete tbuniqueid_;
  }
  if (tbuniqueid) {
    set_has_tbuniqueid();
    tbuniqueid_ = tbuniqueid;
  } else {
    clear_has_tbuniqueid();
    tbuniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dataPipeName = 5;
inline bool RegisterRequest::has_datapipename() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegisterRequest::set_has_datapipename() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RegisterRequest::clear_has_datapipename() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RegisterRequest::clear_datapipename() {
  if (datapipename_ != &::google::protobuf::internal::kEmptyString) {
    datapipename_->clear();
  }
  clear_has_datapipename();
}
inline const ::std::string& RegisterRequest::datapipename() const {
  return *datapipename_;
}
inline void RegisterRequest::set_datapipename(const ::std::string& value) {
  set_has_datapipename();
  if (datapipename_ == &::google::protobuf::internal::kEmptyString) {
    datapipename_ = new ::std::string;
  }
  datapipename_->assign(value);
}
inline void RegisterRequest::set_datapipename(const char* value) {
  set_has_datapipename();
  if (datapipename_ == &::google::protobuf::internal::kEmptyString) {
    datapipename_ = new ::std::string;
  }
  datapipename_->assign(value);
}
inline void RegisterRequest::set_datapipename(const char* value, size_t size) {
  set_has_datapipename();
  if (datapipename_ == &::google::protobuf::internal::kEmptyString) {
    datapipename_ = new ::std::string;
  }
  datapipename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterRequest::mutable_datapipename() {
  set_has_datapipename();
  if (datapipename_ == &::google::protobuf::internal::kEmptyString) {
    datapipename_ = new ::std::string;
  }
  return datapipename_;
}
inline ::std::string* RegisterRequest::release_datapipename() {
  clear_has_datapipename();
  if (datapipename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = datapipename_;
    datapipename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterRequest::set_allocated_datapipename(::std::string* datapipename) {
  if (datapipename_ != &::google::protobuf::internal::kEmptyString) {
    delete datapipename_;
  }
  if (datapipename) {
    set_has_datapipename();
    datapipename_ = datapipename;
  } else {
    clear_has_datapipename();
    datapipename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string metaPipeName = 6;
inline bool RegisterRequest::has_metapipename() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RegisterRequest::set_has_metapipename() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RegisterRequest::clear_has_metapipename() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RegisterRequest::clear_metapipename() {
  if (metapipename_ != &::google::protobuf::internal::kEmptyString) {
    metapipename_->clear();
  }
  clear_has_metapipename();
}
inline const ::std::string& RegisterRequest::metapipename() const {
  return *metapipename_;
}
inline void RegisterRequest::set_metapipename(const ::std::string& value) {
  set_has_metapipename();
  if (metapipename_ == &::google::protobuf::internal::kEmptyString) {
    metapipename_ = new ::std::string;
  }
  metapipename_->assign(value);
}
inline void RegisterRequest::set_metapipename(const char* value) {
  set_has_metapipename();
  if (metapipename_ == &::google::protobuf::internal::kEmptyString) {
    metapipename_ = new ::std::string;
  }
  metapipename_->assign(value);
}
inline void RegisterRequest::set_metapipename(const char* value, size_t size) {
  set_has_metapipename();
  if (metapipename_ == &::google::protobuf::internal::kEmptyString) {
    metapipename_ = new ::std::string;
  }
  metapipename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterRequest::mutable_metapipename() {
  set_has_metapipename();
  if (metapipename_ == &::google::protobuf::internal::kEmptyString) {
    metapipename_ = new ::std::string;
  }
  return metapipename_;
}
inline ::std::string* RegisterRequest::release_metapipename() {
  clear_has_metapipename();
  if (metapipename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = metapipename_;
    metapipename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterRequest::set_allocated_metapipename(::std::string* metapipename) {
  if (metapipename_ != &::google::protobuf::internal::kEmptyString) {
    delete metapipename_;
  }
  if (metapipename) {
    set_has_metapipename();
    metapipename_ = metapipename;
  } else {
    clear_has_metapipename();
    metapipename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string techniqueDescription = 7;
inline bool RegisterRequest::has_techniquedescription() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RegisterRequest::set_has_techniquedescription() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RegisterRequest::clear_has_techniquedescription() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RegisterRequest::clear_techniquedescription() {
  if (techniquedescription_ != &::google::protobuf::internal::kEmptyString) {
    techniquedescription_->clear();
  }
  clear_has_techniquedescription();
}
inline const ::std::string& RegisterRequest::techniquedescription() const {
  return *techniquedescription_;
}
inline void RegisterRequest::set_techniquedescription(const ::std::string& value) {
  set_has_techniquedescription();
  if (techniquedescription_ == &::google::protobuf::internal::kEmptyString) {
    techniquedescription_ = new ::std::string;
  }
  techniquedescription_->assign(value);
}
inline void RegisterRequest::set_techniquedescription(const char* value) {
  set_has_techniquedescription();
  if (techniquedescription_ == &::google::protobuf::internal::kEmptyString) {
    techniquedescription_ = new ::std::string;
  }
  techniquedescription_->assign(value);
}
inline void RegisterRequest::set_techniquedescription(const char* value, size_t size) {
  set_has_techniquedescription();
  if (techniquedescription_ == &::google::protobuf::internal::kEmptyString) {
    techniquedescription_ = new ::std::string;
  }
  techniquedescription_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterRequest::mutable_techniquedescription() {
  set_has_techniquedescription();
  if (techniquedescription_ == &::google::protobuf::internal::kEmptyString) {
    techniquedescription_ = new ::std::string;
  }
  return techniquedescription_;
}
inline ::std::string* RegisterRequest::release_techniquedescription() {
  clear_has_techniquedescription();
  if (techniquedescription_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = techniquedescription_;
    techniquedescription_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterRequest::set_allocated_techniquedescription(::std::string* techniquedescription) {
  if (techniquedescription_ != &::google::protobuf::internal::kEmptyString) {
    delete techniquedescription_;
  }
  if (techniquedescription) {
    set_has_techniquedescription();
    techniquedescription_ = techniquedescription;
  } else {
    clear_has_techniquedescription();
    techniquedescription_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 numberOfZPipePorts = 8 [default = 1];
inline bool RegisterRequest::has_numberofzpipeports() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RegisterRequest::set_has_numberofzpipeports() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RegisterRequest::clear_has_numberofzpipeports() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RegisterRequest::clear_numberofzpipeports() {
  numberofzpipeports_ = 1;
  clear_has_numberofzpipeports();
}
inline ::google::protobuf::int32 RegisterRequest::numberofzpipeports() const {
  return numberofzpipeports_;
}
inline void RegisterRequest::set_numberofzpipeports(::google::protobuf::int32 value) {
  set_has_numberofzpipeports();
  numberofzpipeports_ = value;
}

// optional string sensorName = 9;
inline bool RegisterRequest::has_sensorname() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RegisterRequest::set_has_sensorname() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RegisterRequest::clear_has_sensorname() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RegisterRequest::clear_sensorname() {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    sensorname_->clear();
  }
  clear_has_sensorname();
}
inline const ::std::string& RegisterRequest::sensorname() const {
  return *sensorname_;
}
inline void RegisterRequest::set_sensorname(const ::std::string& value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void RegisterRequest::set_sensorname(const char* value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void RegisterRequest::set_sensorname(const char* value, size_t size) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterRequest::mutable_sensorname() {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  return sensorname_;
}
inline ::std::string* RegisterRequest::release_sensorname() {
  clear_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sensorname_;
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterRequest::set_allocated_sensorname(::std::string* sensorname) {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    delete sensorname_;
  }
  if (sensorname) {
    set_has_sensorname();
    sensorname_ = sensorname;
  } else {
    clear_has_sensorname();
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float estimatedCenterFreqMHz = 10;
inline bool RegisterRequest::has_estimatedcenterfreqmhz() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RegisterRequest::set_has_estimatedcenterfreqmhz() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RegisterRequest::clear_has_estimatedcenterfreqmhz() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RegisterRequest::clear_estimatedcenterfreqmhz() {
  estimatedcenterfreqmhz_ = 0;
  clear_has_estimatedcenterfreqmhz();
}
inline float RegisterRequest::estimatedcenterfreqmhz() const {
  return estimatedcenterfreqmhz_;
}
inline void RegisterRequest::set_estimatedcenterfreqmhz(float value) {
  set_has_estimatedcenterfreqmhz();
  estimatedcenterfreqmhz_ = value;
}

// optional int32 overrideChannel = 11 [default = -1];
inline bool RegisterRequest::has_overridechannel() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RegisterRequest::set_has_overridechannel() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RegisterRequest::clear_has_overridechannel() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RegisterRequest::clear_overridechannel() {
  overridechannel_ = -1;
  clear_has_overridechannel();
}
inline ::google::protobuf::int32 RegisterRequest::overridechannel() const {
  return overridechannel_;
}
inline void RegisterRequest::set_overridechannel(::google::protobuf::int32 value) {
  set_has_overridechannel();
  overridechannel_ = value;
}

// -------------------------------------------------------------------

// UnregisterRequest

// optional string msgName = 1 [default = "UNREGISTERREQUEST"];
inline bool UnregisterRequest::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnregisterRequest::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnregisterRequest::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnregisterRequest::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& UnregisterRequest::msgname() const {
  return *msgname_;
}
inline void UnregisterRequest::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UnregisterRequest::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UnregisterRequest::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnregisterRequest::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* UnregisterRequest::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void UnregisterRequest::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string tbUniqueID = 2;
inline bool UnregisterRequest::has_tbuniqueid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnregisterRequest::set_has_tbuniqueid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnregisterRequest::clear_has_tbuniqueid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnregisterRequest::clear_tbuniqueid() {
  if (tbuniqueid_ != &::google::protobuf::internal::kEmptyString) {
    tbuniqueid_->clear();
  }
  clear_has_tbuniqueid();
}
inline const ::std::string& UnregisterRequest::tbuniqueid() const {
  return *tbuniqueid_;
}
inline void UnregisterRequest::set_tbuniqueid(const ::std::string& value) {
  set_has_tbuniqueid();
  if (tbuniqueid_ == &::google::protobuf::internal::kEmptyString) {
    tbuniqueid_ = new ::std::string;
  }
  tbuniqueid_->assign(value);
}
inline void UnregisterRequest::set_tbuniqueid(const char* value) {
  set_has_tbuniqueid();
  if (tbuniqueid_ == &::google::protobuf::internal::kEmptyString) {
    tbuniqueid_ = new ::std::string;
  }
  tbuniqueid_->assign(value);
}
inline void UnregisterRequest::set_tbuniqueid(const char* value, size_t size) {
  set_has_tbuniqueid();
  if (tbuniqueid_ == &::google::protobuf::internal::kEmptyString) {
    tbuniqueid_ = new ::std::string;
  }
  tbuniqueid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnregisterRequest::mutable_tbuniqueid() {
  set_has_tbuniqueid();
  if (tbuniqueid_ == &::google::protobuf::internal::kEmptyString) {
    tbuniqueid_ = new ::std::string;
  }
  return tbuniqueid_;
}
inline ::std::string* UnregisterRequest::release_tbuniqueid() {
  clear_has_tbuniqueid();
  if (tbuniqueid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tbuniqueid_;
    tbuniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnregisterRequest::set_allocated_tbuniqueid(::std::string* tbuniqueid) {
  if (tbuniqueid_ != &::google::protobuf::internal::kEmptyString) {
    delete tbuniqueid_;
  }
  if (tbuniqueid) {
    set_has_tbuniqueid();
    tbuniqueid_ = tbuniqueid;
  } else {
    clear_has_tbuniqueid();
    tbuniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RegisterResponse

// optional string msgName = 1 [default = "REGISTERRESPONSE"];
inline bool RegisterResponse::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterResponse::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterResponse::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterResponse::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& RegisterResponse::msgname() const {
  return *msgname_;
}
inline void RegisterResponse::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RegisterResponse::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RegisterResponse::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterResponse::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* RegisterResponse::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void RegisterResponse::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string idNum = 2;
inline bool RegisterResponse::has_idnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterResponse::set_has_idnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterResponse::clear_has_idnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterResponse::clear_idnum() {
  if (idnum_ != &::google::protobuf::internal::kEmptyString) {
    idnum_->clear();
  }
  clear_has_idnum();
}
inline const ::std::string& RegisterResponse::idnum() const {
  return *idnum_;
}
inline void RegisterResponse::set_idnum(const ::std::string& value) {
  set_has_idnum();
  if (idnum_ == &::google::protobuf::internal::kEmptyString) {
    idnum_ = new ::std::string;
  }
  idnum_->assign(value);
}
inline void RegisterResponse::set_idnum(const char* value) {
  set_has_idnum();
  if (idnum_ == &::google::protobuf::internal::kEmptyString) {
    idnum_ = new ::std::string;
  }
  idnum_->assign(value);
}
inline void RegisterResponse::set_idnum(const char* value, size_t size) {
  set_has_idnum();
  if (idnum_ == &::google::protobuf::internal::kEmptyString) {
    idnum_ = new ::std::string;
  }
  idnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterResponse::mutable_idnum() {
  set_has_idnum();
  if (idnum_ == &::google::protobuf::internal::kEmptyString) {
    idnum_ = new ::std::string;
  }
  return idnum_;
}
inline ::std::string* RegisterResponse::release_idnum() {
  clear_has_idnum();
  if (idnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = idnum_;
    idnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterResponse::set_allocated_idnum(::std::string* idnum) {
  if (idnum_ != &::google::protobuf::internal::kEmptyString) {
    delete idnum_;
  }
  if (idnum) {
    set_has_idnum();
    idnum_ = idnum;
  } else {
    clear_has_idnum();
    idnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated int32 ports = 3;
inline int RegisterResponse::ports_size() const {
  return ports_.size();
}
inline void RegisterResponse::clear_ports() {
  ports_.Clear();
}
inline ::google::protobuf::int32 RegisterResponse::ports(int index) const {
  return ports_.Get(index);
}
inline void RegisterResponse::set_ports(int index, ::google::protobuf::int32 value) {
  ports_.Set(index, value);
}
inline void RegisterResponse::add_ports(::google::protobuf::int32 value) {
  ports_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RegisterResponse::ports() const {
  return ports_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RegisterResponse::mutable_ports() {
  return &ports_;
}

// optional float sampleRateSps = 4;
inline bool RegisterResponse::has_sampleratesps() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegisterResponse::set_has_sampleratesps() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegisterResponse::clear_has_sampleratesps() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegisterResponse::clear_sampleratesps() {
  sampleratesps_ = 0;
  clear_has_sampleratesps();
}
inline float RegisterResponse::sampleratesps() const {
  return sampleratesps_;
}
inline void RegisterResponse::set_sampleratesps(float value) {
  set_has_sampleratesps();
  sampleratesps_ = value;
}

// optional float minFreqMHz = 5 [default = 20];
inline bool RegisterResponse::has_minfreqmhz() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegisterResponse::set_has_minfreqmhz() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RegisterResponse::clear_has_minfreqmhz() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RegisterResponse::clear_minfreqmhz() {
  minfreqmhz_ = 20;
  clear_has_minfreqmhz();
}
inline float RegisterResponse::minfreqmhz() const {
  return minfreqmhz_;
}
inline void RegisterResponse::set_minfreqmhz(float value) {
  set_has_minfreqmhz();
  minfreqmhz_ = value;
}

// optional float maxFreqMHz = 6 [default = 6000];
inline bool RegisterResponse::has_maxfreqmhz() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RegisterResponse::set_has_maxfreqmhz() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RegisterResponse::clear_has_maxfreqmhz() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RegisterResponse::clear_maxfreqmhz() {
  maxfreqmhz_ = 6000;
  clear_has_maxfreqmhz();
}
inline float RegisterResponse::maxfreqmhz() const {
  return maxfreqmhz_;
}
inline void RegisterResponse::set_maxfreqmhz(float value) {
  set_has_maxfreqmhz();
  maxfreqmhz_ = value;
}

// optional int32 assignedChannel = 7;
inline bool RegisterResponse::has_assignedchannel() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RegisterResponse::set_has_assignedchannel() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RegisterResponse::clear_has_assignedchannel() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RegisterResponse::clear_assignedchannel() {
  assignedchannel_ = 0;
  clear_has_assignedchannel();
}
inline ::google::protobuf::int32 RegisterResponse::assignedchannel() const {
  return assignedchannel_;
}
inline void RegisterResponse::set_assignedchannel(::google::protobuf::int32 value) {
  set_has_assignedchannel();
  assignedchannel_ = value;
}

// optional string sensorName = 9;
inline bool RegisterResponse::has_sensorname() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RegisterResponse::set_has_sensorname() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RegisterResponse::clear_has_sensorname() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RegisterResponse::clear_sensorname() {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    sensorname_->clear();
  }
  clear_has_sensorname();
}
inline const ::std::string& RegisterResponse::sensorname() const {
  return *sensorname_;
}
inline void RegisterResponse::set_sensorname(const ::std::string& value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void RegisterResponse::set_sensorname(const char* value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void RegisterResponse::set_sensorname(const char* value, size_t size) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterResponse::mutable_sensorname() {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  return sensorname_;
}
inline ::std::string* RegisterResponse::release_sensorname() {
  clear_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sensorname_;
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterResponse::set_allocated_sensorname(::std::string* sensorname) {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    delete sensorname_;
  }
  if (sensorname) {
    set_has_sensorname();
    sensorname_ = sensorname;
  } else {
    clear_has_sensorname();
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// HopAttackStatus

// optional string msgName = 1 [default = "HOPATTACKSTATUS"];
inline bool HopAttackStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HopAttackStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HopAttackStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HopAttackStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& HopAttackStatus::msgname() const {
  return *msgname_;
}
inline void HopAttackStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void HopAttackStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void HopAttackStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HopAttackStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* HopAttackStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void HopAttackStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string platform = 2;
inline bool HopAttackStatus::has_platform() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HopAttackStatus::set_has_platform() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HopAttackStatus::clear_has_platform() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HopAttackStatus::clear_platform() {
  if (platform_ != &::google::protobuf::internal::kEmptyString) {
    platform_->clear();
  }
  clear_has_platform();
}
inline const ::std::string& HopAttackStatus::platform() const {
  return *platform_;
}
inline void HopAttackStatus::set_platform(const ::std::string& value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void HopAttackStatus::set_platform(const char* value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void HopAttackStatus::set_platform(const char* value, size_t size) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HopAttackStatus::mutable_platform() {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  return platform_;
}
inline ::std::string* HopAttackStatus::release_platform() {
  clear_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = platform_;
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HopAttackStatus::set_allocated_platform(::std::string* platform) {
  if (platform_ != &::google::protobuf::internal::kEmptyString) {
    delete platform_;
  }
  if (platform) {
    set_has_platform();
    platform_ = platform;
  } else {
    clear_has_platform();
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 totalhops = 3;
inline bool HopAttackStatus::has_totalhops() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HopAttackStatus::set_has_totalhops() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HopAttackStatus::clear_has_totalhops() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HopAttackStatus::clear_totalhops() {
  totalhops_ = 0;
  clear_has_totalhops();
}
inline ::google::protobuf::int32 HopAttackStatus::totalhops() const {
  return totalhops_;
}
inline void HopAttackStatus::set_totalhops(::google::protobuf::int32 value) {
  set_has_totalhops();
  totalhops_ = value;
}

// optional int32 goodhops = 4;
inline bool HopAttackStatus::has_goodhops() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HopAttackStatus::set_has_goodhops() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HopAttackStatus::clear_has_goodhops() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HopAttackStatus::clear_goodhops() {
  goodhops_ = 0;
  clear_has_goodhops();
}
inline ::google::protobuf::int32 HopAttackStatus::goodhops() const {
  return goodhops_;
}
inline void HopAttackStatus::set_goodhops(::google::protobuf::int32 value) {
  set_has_goodhops();
  goodhops_ = value;
}

// optional float percentage = 5;
inline bool HopAttackStatus::has_percentage() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HopAttackStatus::set_has_percentage() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HopAttackStatus::clear_has_percentage() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HopAttackStatus::clear_percentage() {
  percentage_ = 0;
  clear_has_percentage();
}
inline float HopAttackStatus::percentage() const {
  return percentage_;
}
inline void HopAttackStatus::set_percentage(float value) {
  set_has_percentage();
  percentage_ = value;
}

// -------------------------------------------------------------------

// TxFreqRequest

// optional string msgName = 1 [default = "TXFREQREQUEST"];
inline bool TxFreqRequest::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxFreqRequest::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxFreqRequest::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxFreqRequest::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& TxFreqRequest::msgname() const {
  return *msgname_;
}
inline void TxFreqRequest::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void TxFreqRequest::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void TxFreqRequest::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxFreqRequest::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* TxFreqRequest::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void TxFreqRequest::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional float freqHz = 2;
inline bool TxFreqRequest::has_freqhz() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxFreqRequest::set_has_freqhz() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxFreqRequest::clear_has_freqhz() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxFreqRequest::clear_freqhz() {
  freqhz_ = 0;
  clear_has_freqhz();
}
inline float TxFreqRequest::freqhz() const {
  return freqhz_;
}
inline void TxFreqRequest::set_freqhz(float value) {
  set_has_freqhz();
  freqhz_ = value;
}

// optional string globalID = 3;
inline bool TxFreqRequest::has_globalid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxFreqRequest::set_has_globalid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxFreqRequest::clear_has_globalid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxFreqRequest::clear_globalid() {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    globalid_->clear();
  }
  clear_has_globalid();
}
inline const ::std::string& TxFreqRequest::globalid() const {
  return *globalid_;
}
inline void TxFreqRequest::set_globalid(const ::std::string& value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void TxFreqRequest::set_globalid(const char* value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void TxFreqRequest::set_globalid(const char* value, size_t size) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxFreqRequest::mutable_globalid() {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  return globalid_;
}
inline ::std::string* TxFreqRequest::release_globalid() {
  clear_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalid_;
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TxFreqRequest::set_allocated_globalid(::std::string* globalid) {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    delete globalid_;
  }
  if (globalid) {
    set_has_globalid();
    globalid_ = globalid;
  } else {
    clear_has_globalid();
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EmergencyJam

// optional string msgName = 1 [default = "EMERGENCYJAM"];
inline bool EmergencyJam::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmergencyJam::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmergencyJam::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmergencyJam::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& EmergencyJam::msgname() const {
  return *msgname_;
}
inline void EmergencyJam::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EmergencyJam::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EmergencyJam::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmergencyJam::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* EmergencyJam::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void EmergencyJam::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional double centerFreq = 2 [default = 2440];
inline bool EmergencyJam::has_centerfreq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmergencyJam::set_has_centerfreq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmergencyJam::clear_has_centerfreq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmergencyJam::clear_centerfreq() {
  centerfreq_ = 2440;
  clear_has_centerfreq();
}
inline double EmergencyJam::centerfreq() const {
  return centerfreq_;
}
inline void EmergencyJam::set_centerfreq(double value) {
  set_has_centerfreq();
  centerfreq_ = value;
}

// optional double bandwidth = 3 [default = 84];
inline bool EmergencyJam::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EmergencyJam::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EmergencyJam::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EmergencyJam::clear_bandwidth() {
  bandwidth_ = 84;
  clear_has_bandwidth();
}
inline double EmergencyJam::bandwidth() const {
  return bandwidth_;
}
inline void EmergencyJam::set_bandwidth(double value) {
  set_has_bandwidth();
  bandwidth_ = value;
}

// optional int32 targetID = 4 [default = -1];
inline bool EmergencyJam::has_targetid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EmergencyJam::set_has_targetid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EmergencyJam::clear_has_targetid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EmergencyJam::clear_targetid() {
  targetid_ = -1;
  clear_has_targetid();
}
inline ::google::protobuf::int32 EmergencyJam::targetid() const {
  return targetid_;
}
inline void EmergencyJam::set_targetid(::google::protobuf::int32 value) {
  set_has_targetid();
  targetid_ = value;
}

// -------------------------------------------------------------------

// JamOff

// optional string msgName = 1 [default = "JAMOFF"];
inline bool JamOff::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JamOff::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JamOff::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JamOff::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& JamOff::msgname() const {
  return *msgname_;
}
inline void JamOff::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void JamOff::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void JamOff::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JamOff::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* JamOff::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void JamOff::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 targetID = 4 [default = -1];
inline bool JamOff::has_targetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JamOff::set_has_targetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JamOff::clear_has_targetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JamOff::clear_targetid() {
  targetid_ = -1;
  clear_has_targetid();
}
inline ::google::protobuf::int32 JamOff::targetid() const {
  return targetid_;
}
inline void JamOff::set_targetid(::google::protobuf::int32 value) {
  set_has_targetid();
  targetid_ = value;
}

// -------------------------------------------------------------------

// EWSDRRequest

// repeated .fv.tb.protos.TBProtos.Aperture aperture = 1;
inline int EWSDRRequest::aperture_size() const {
  return aperture_.size();
}
inline void EWSDRRequest::clear_aperture() {
  aperture_.Clear();
}
inline const ::fv::tb::protos::TBProtos::Aperture& EWSDRRequest::aperture(int index) const {
  return aperture_.Get(index);
}
inline ::fv::tb::protos::TBProtos::Aperture* EWSDRRequest::mutable_aperture(int index) {
  return aperture_.Mutable(index);
}
inline ::fv::tb::protos::TBProtos::Aperture* EWSDRRequest::add_aperture() {
  return aperture_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Aperture >&
EWSDRRequest::aperture() const {
  return aperture_;
}
inline ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Aperture >*
EWSDRRequest::mutable_aperture() {
  return &aperture_;
}

// repeated .fv.tb.protos.TBProtos.Transceiver transceiver = 2;
inline int EWSDRRequest::transceiver_size() const {
  return transceiver_.size();
}
inline void EWSDRRequest::clear_transceiver() {
  transceiver_.Clear();
}
inline const ::fv::tb::protos::TBProtos::Transceiver& EWSDRRequest::transceiver(int index) const {
  return transceiver_.Get(index);
}
inline ::fv::tb::protos::TBProtos::Transceiver* EWSDRRequest::mutable_transceiver(int index) {
  return transceiver_.Mutable(index);
}
inline ::fv::tb::protos::TBProtos::Transceiver* EWSDRRequest::add_transceiver() {
  return transceiver_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Transceiver >&
EWSDRRequest::transceiver() const {
  return transceiver_;
}
inline ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Transceiver >*
EWSDRRequest::mutable_transceiver() {
  return &transceiver_;
}

// optional string guid = 3;
inline bool EWSDRRequest::has_guid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EWSDRRequest::set_has_guid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EWSDRRequest::clear_has_guid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EWSDRRequest::clear_guid() {
  if (guid_ != &::google::protobuf::internal::kEmptyString) {
    guid_->clear();
  }
  clear_has_guid();
}
inline const ::std::string& EWSDRRequest::guid() const {
  return *guid_;
}
inline void EWSDRRequest::set_guid(const ::std::string& value) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
}
inline void EWSDRRequest::set_guid(const char* value) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
}
inline void EWSDRRequest::set_guid(const char* value, size_t size) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWSDRRequest::mutable_guid() {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  return guid_;
}
inline ::std::string* EWSDRRequest::release_guid() {
  clear_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guid_;
    guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EWSDRRequest::set_allocated_guid(::std::string* guid) {
  if (guid_ != &::google::protobuf::internal::kEmptyString) {
    delete guid_;
  }
  if (guid) {
    set_has_guid();
    guid_ = guid;
  } else {
    clear_has_guid();
    guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 priority = 4;
inline bool EWSDRRequest::has_priority() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EWSDRRequest::set_has_priority() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EWSDRRequest::clear_has_priority() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EWSDRRequest::clear_priority() {
  priority_ = 0;
  clear_has_priority();
}
inline ::google::protobuf::int32 EWSDRRequest::priority() const {
  return priority_;
}
inline void EWSDRRequest::set_priority(::google::protobuf::int32 value) {
  set_has_priority();
  priority_ = value;
}

// optional bool enabled = 5;
inline bool EWSDRRequest::has_enabled() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EWSDRRequest::set_has_enabled() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EWSDRRequest::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EWSDRRequest::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool EWSDRRequest::enabled() const {
  return enabled_;
}
inline void EWSDRRequest::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
}

// -------------------------------------------------------------------

// EWSDRCommand

// repeated .fv.tb.protos.TBProtos.Aperture aperture = 1;
inline int EWSDRCommand::aperture_size() const {
  return aperture_.size();
}
inline void EWSDRCommand::clear_aperture() {
  aperture_.Clear();
}
inline const ::fv::tb::protos::TBProtos::Aperture& EWSDRCommand::aperture(int index) const {
  return aperture_.Get(index);
}
inline ::fv::tb::protos::TBProtos::Aperture* EWSDRCommand::mutable_aperture(int index) {
  return aperture_.Mutable(index);
}
inline ::fv::tb::protos::TBProtos::Aperture* EWSDRCommand::add_aperture() {
  return aperture_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Aperture >&
EWSDRCommand::aperture() const {
  return aperture_;
}
inline ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Aperture >*
EWSDRCommand::mutable_aperture() {
  return &aperture_;
}

// repeated .fv.tb.protos.TBProtos.Transceiver transceiver = 2;
inline int EWSDRCommand::transceiver_size() const {
  return transceiver_.size();
}
inline void EWSDRCommand::clear_transceiver() {
  transceiver_.Clear();
}
inline const ::fv::tb::protos::TBProtos::Transceiver& EWSDRCommand::transceiver(int index) const {
  return transceiver_.Get(index);
}
inline ::fv::tb::protos::TBProtos::Transceiver* EWSDRCommand::mutable_transceiver(int index) {
  return transceiver_.Mutable(index);
}
inline ::fv::tb::protos::TBProtos::Transceiver* EWSDRCommand::add_transceiver() {
  return transceiver_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Transceiver >&
EWSDRCommand::transceiver() const {
  return transceiver_;
}
inline ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Transceiver >*
EWSDRCommand::mutable_transceiver() {
  return &transceiver_;
}

// optional string guid = 3;
inline bool EWSDRCommand::has_guid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EWSDRCommand::set_has_guid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EWSDRCommand::clear_has_guid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EWSDRCommand::clear_guid() {
  if (guid_ != &::google::protobuf::internal::kEmptyString) {
    guid_->clear();
  }
  clear_has_guid();
}
inline const ::std::string& EWSDRCommand::guid() const {
  return *guid_;
}
inline void EWSDRCommand::set_guid(const ::std::string& value) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
}
inline void EWSDRCommand::set_guid(const char* value) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
}
inline void EWSDRCommand::set_guid(const char* value, size_t size) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWSDRCommand::mutable_guid() {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  return guid_;
}
inline ::std::string* EWSDRCommand::release_guid() {
  clear_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guid_;
    guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EWSDRCommand::set_allocated_guid(::std::string* guid) {
  if (guid_ != &::google::protobuf::internal::kEmptyString) {
    delete guid_;
  }
  if (guid) {
    set_has_guid();
    guid_ = guid;
  } else {
    clear_has_guid();
    guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 priority = 4;
inline bool EWSDRCommand::has_priority() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EWSDRCommand::set_has_priority() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EWSDRCommand::clear_has_priority() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EWSDRCommand::clear_priority() {
  priority_ = 0;
  clear_has_priority();
}
inline ::google::protobuf::int32 EWSDRCommand::priority() const {
  return priority_;
}
inline void EWSDRCommand::set_priority(::google::protobuf::int32 value) {
  set_has_priority();
  priority_ = value;
}

// optional bool enabled = 5;
inline bool EWSDRCommand::has_enabled() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EWSDRCommand::set_has_enabled() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EWSDRCommand::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EWSDRCommand::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool EWSDRCommand::enabled() const {
  return enabled_;
}
inline void EWSDRCommand::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
}

// -------------------------------------------------------------------

// Aperture

// optional int32 antenna = 1;
inline bool Aperture::has_antenna() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Aperture::set_has_antenna() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Aperture::clear_has_antenna() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Aperture::clear_antenna() {
  antenna_ = 0;
  clear_has_antenna();
}
inline ::google::protobuf::int32 Aperture::antenna() const {
  return antenna_;
}
inline void Aperture::set_antenna(::google::protobuf::int32 value) {
  set_has_antenna();
  antenna_ = value;
}

// optional float azimuth = 2;
inline bool Aperture::has_azimuth() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Aperture::set_has_azimuth() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Aperture::clear_has_azimuth() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Aperture::clear_azimuth() {
  azimuth_ = 0;
  clear_has_azimuth();
}
inline float Aperture::azimuth() const {
  return azimuth_;
}
inline void Aperture::set_azimuth(float value) {
  set_has_azimuth();
  azimuth_ = value;
}

// optional float elevation = 3;
inline bool Aperture::has_elevation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Aperture::set_has_elevation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Aperture::clear_has_elevation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Aperture::clear_elevation() {
  elevation_ = 0;
  clear_has_elevation();
}
inline float Aperture::elevation() const {
  return elevation_;
}
inline void Aperture::set_elevation(float value) {
  set_has_elevation();
  elevation_ = value;
}

// optional int32 polarization = 4;
inline bool Aperture::has_polarization() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Aperture::set_has_polarization() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Aperture::clear_has_polarization() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Aperture::clear_polarization() {
  polarization_ = 0;
  clear_has_polarization();
}
inline ::google::protobuf::int32 Aperture::polarization() const {
  return polarization_;
}
inline void Aperture::set_polarization(::google::protobuf::int32 value) {
  set_has_polarization();
  polarization_ = value;
}

// optional int32 priority = 5 [default = 100];
inline bool Aperture::has_priority() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Aperture::set_has_priority() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Aperture::clear_has_priority() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Aperture::clear_priority() {
  priority_ = 100;
  clear_has_priority();
}
inline ::google::protobuf::int32 Aperture::priority() const {
  return priority_;
}
inline void Aperture::set_priority(::google::protobuf::int32 value) {
  set_has_priority();
  priority_ = value;
}

// optional string guid = 6 [default = "UNSPECIFIED"];
inline bool Aperture::has_guid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Aperture::set_has_guid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Aperture::clear_has_guid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Aperture::clear_guid() {
  if (guid_ != _default_guid_) {
    guid_->assign(*_default_guid_);
  }
  clear_has_guid();
}
inline const ::std::string& Aperture::guid() const {
  return *guid_;
}
inline void Aperture::set_guid(const ::std::string& value) {
  set_has_guid();
  if (guid_ == _default_guid_) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
}
inline void Aperture::set_guid(const char* value) {
  set_has_guid();
  if (guid_ == _default_guid_) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
}
inline void Aperture::set_guid(const char* value, size_t size) {
  set_has_guid();
  if (guid_ == _default_guid_) {
    guid_ = new ::std::string;
  }
  guid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Aperture::mutable_guid() {
  set_has_guid();
  if (guid_ == _default_guid_) {
    guid_ = new ::std::string(*_default_guid_);
  }
  return guid_;
}
inline ::std::string* Aperture::release_guid() {
  clear_has_guid();
  if (guid_ == _default_guid_) {
    return NULL;
  } else {
    ::std::string* temp = guid_;
    guid_ = const_cast< ::std::string*>(_default_guid_);
    return temp;
  }
}
inline void Aperture::set_allocated_guid(::std::string* guid) {
  if (guid_ != _default_guid_) {
    delete guid_;
  }
  if (guid) {
    set_has_guid();
    guid_ = guid;
  } else {
    clear_has_guid();
    guid_ = const_cast< ::std::string*>(_default_guid_);
  }
}

// -------------------------------------------------------------------

// Transceiver

// optional int32 transceiver = 1;
inline bool Transceiver::has_transceiver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Transceiver::set_has_transceiver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Transceiver::clear_has_transceiver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Transceiver::clear_transceiver() {
  transceiver_ = 0;
  clear_has_transceiver();
}
inline ::google::protobuf::int32 Transceiver::transceiver() const {
  return transceiver_;
}
inline void Transceiver::set_transceiver(::google::protobuf::int32 value) {
  set_has_transceiver();
  transceiver_ = value;
}

// optional int32 channel = 2;
inline bool Transceiver::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Transceiver::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Transceiver::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Transceiver::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 Transceiver::channel() const {
  return channel_;
}
inline void Transceiver::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// optional float freqMHz = 3;
inline bool Transceiver::has_freqmhz() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Transceiver::set_has_freqmhz() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Transceiver::clear_has_freqmhz() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Transceiver::clear_freqmhz() {
  freqmhz_ = 0;
  clear_has_freqmhz();
}
inline float Transceiver::freqmhz() const {
  return freqmhz_;
}
inline void Transceiver::set_freqmhz(float value) {
  set_has_freqmhz();
  freqmhz_ = value;
}

// optional int32 gainDB = 4;
inline bool Transceiver::has_gaindb() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Transceiver::set_has_gaindb() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Transceiver::clear_has_gaindb() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Transceiver::clear_gaindb() {
  gaindb_ = 0;
  clear_has_gaindb();
}
inline ::google::protobuf::int32 Transceiver::gaindb() const {
  return gaindb_;
}
inline void Transceiver::set_gaindb(::google::protobuf::int32 value) {
  set_has_gaindb();
  gaindb_ = value;
}

// optional int32 priority = 5 [default = 100];
inline bool Transceiver::has_priority() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Transceiver::set_has_priority() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Transceiver::clear_has_priority() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Transceiver::clear_priority() {
  priority_ = 100;
  clear_has_priority();
}
inline ::google::protobuf::int32 Transceiver::priority() const {
  return priority_;
}
inline void Transceiver::set_priority(::google::protobuf::int32 value) {
  set_has_priority();
  priority_ = value;
}

// optional string guid = 6 [default = "UNSPECIFIED"];
inline bool Transceiver::has_guid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Transceiver::set_has_guid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Transceiver::clear_has_guid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Transceiver::clear_guid() {
  if (guid_ != _default_guid_) {
    guid_->assign(*_default_guid_);
  }
  clear_has_guid();
}
inline const ::std::string& Transceiver::guid() const {
  return *guid_;
}
inline void Transceiver::set_guid(const ::std::string& value) {
  set_has_guid();
  if (guid_ == _default_guid_) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
}
inline void Transceiver::set_guid(const char* value) {
  set_has_guid();
  if (guid_ == _default_guid_) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
}
inline void Transceiver::set_guid(const char* value, size_t size) {
  set_has_guid();
  if (guid_ == _default_guid_) {
    guid_ = new ::std::string;
  }
  guid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Transceiver::mutable_guid() {
  set_has_guid();
  if (guid_ == _default_guid_) {
    guid_ = new ::std::string(*_default_guid_);
  }
  return guid_;
}
inline ::std::string* Transceiver::release_guid() {
  clear_has_guid();
  if (guid_ == _default_guid_) {
    return NULL;
  } else {
    ::std::string* temp = guid_;
    guid_ = const_cast< ::std::string*>(_default_guid_);
    return temp;
  }
}
inline void Transceiver::set_allocated_guid(::std::string* guid) {
  if (guid_ != _default_guid_) {
    delete guid_;
  }
  if (guid) {
    set_has_guid();
    guid_ = guid;
  } else {
    clear_has_guid();
    guid_ = const_cast< ::std::string*>(_default_guid_);
  }
}

// -------------------------------------------------------------------

// ThreatStatus

// repeated .falcon_common_msg.KeyValuePair kvps = 1;
inline int ThreatStatus::kvps_size() const {
  return kvps_.size();
}
inline void ThreatStatus::clear_kvps() {
  kvps_.Clear();
}
inline const ::falcon_common_msg::KeyValuePair& ThreatStatus::kvps(int index) const {
  return kvps_.Get(index);
}
inline ::falcon_common_msg::KeyValuePair* ThreatStatus::mutable_kvps(int index) {
  return kvps_.Mutable(index);
}
inline ::falcon_common_msg::KeyValuePair* ThreatStatus::add_kvps() {
  return kvps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::KeyValuePair >&
ThreatStatus::kvps() const {
  return kvps_;
}
inline ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::KeyValuePair >*
ThreatStatus::mutable_kvps() {
  return &kvps_;
}

// -------------------------------------------------------------------

// EWSDRStatus

// repeated .fv.tb.protos.TBProtos.Aperture apertures = 1;
inline int EWSDRStatus::apertures_size() const {
  return apertures_.size();
}
inline void EWSDRStatus::clear_apertures() {
  apertures_.Clear();
}
inline const ::fv::tb::protos::TBProtos::Aperture& EWSDRStatus::apertures(int index) const {
  return apertures_.Get(index);
}
inline ::fv::tb::protos::TBProtos::Aperture* EWSDRStatus::mutable_apertures(int index) {
  return apertures_.Mutable(index);
}
inline ::fv::tb::protos::TBProtos::Aperture* EWSDRStatus::add_apertures() {
  return apertures_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Aperture >&
EWSDRStatus::apertures() const {
  return apertures_;
}
inline ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Aperture >*
EWSDRStatus::mutable_apertures() {
  return &apertures_;
}

// repeated .fv.tb.protos.TBProtos.Transceiver transceivers = 2;
inline int EWSDRStatus::transceivers_size() const {
  return transceivers_.size();
}
inline void EWSDRStatus::clear_transceivers() {
  transceivers_.Clear();
}
inline const ::fv::tb::protos::TBProtos::Transceiver& EWSDRStatus::transceivers(int index) const {
  return transceivers_.Get(index);
}
inline ::fv::tb::protos::TBProtos::Transceiver* EWSDRStatus::mutable_transceivers(int index) {
  return transceivers_.Mutable(index);
}
inline ::fv::tb::protos::TBProtos::Transceiver* EWSDRStatus::add_transceivers() {
  return transceivers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Transceiver >&
EWSDRStatus::transceivers() const {
  return transceivers_;
}
inline ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Transceiver >*
EWSDRStatus::mutable_transceivers() {
  return &transceivers_;
}

// -------------------------------------------------------------------

// SetAppParameters

// optional string eltex = 1;
inline bool SetAppParameters::has_eltex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetAppParameters::set_has_eltex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetAppParameters::clear_has_eltex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetAppParameters::clear_eltex() {
  if (eltex_ != &::google::protobuf::internal::kEmptyString) {
    eltex_->clear();
  }
  clear_has_eltex();
}
inline const ::std::string& SetAppParameters::eltex() const {
  return *eltex_;
}
inline void SetAppParameters::set_eltex(const ::std::string& value) {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  eltex_->assign(value);
}
inline void SetAppParameters::set_eltex(const char* value) {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  eltex_->assign(value);
}
inline void SetAppParameters::set_eltex(const char* value, size_t size) {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  eltex_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SetAppParameters::mutable_eltex() {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  return eltex_;
}
inline ::std::string* SetAppParameters::release_eltex() {
  clear_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eltex_;
    eltex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SetAppParameters::set_allocated_eltex(::std::string* eltex) {
  if (eltex_ != &::google::protobuf::internal::kEmptyString) {
    delete eltex_;
  }
  if (eltex) {
    set_has_eltex();
    eltex_ = eltex;
  } else {
    clear_has_eltex();
    eltex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string soiNum = 2;
inline bool SetAppParameters::has_soinum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetAppParameters::set_has_soinum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetAppParameters::clear_has_soinum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetAppParameters::clear_soinum() {
  if (soinum_ != &::google::protobuf::internal::kEmptyString) {
    soinum_->clear();
  }
  clear_has_soinum();
}
inline const ::std::string& SetAppParameters::soinum() const {
  return *soinum_;
}
inline void SetAppParameters::set_soinum(const ::std::string& value) {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  soinum_->assign(value);
}
inline void SetAppParameters::set_soinum(const char* value) {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  soinum_->assign(value);
}
inline void SetAppParameters::set_soinum(const char* value, size_t size) {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  soinum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SetAppParameters::mutable_soinum() {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  return soinum_;
}
inline ::std::string* SetAppParameters::release_soinum() {
  clear_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = soinum_;
    soinum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SetAppParameters::set_allocated_soinum(::std::string* soinum) {
  if (soinum_ != &::google::protobuf::internal::kEmptyString) {
    delete soinum_;
  }
  if (soinum) {
    set_has_soinum();
    soinum_ = soinum;
  } else {
    clear_has_soinum();
    soinum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string globalID = 3;
inline bool SetAppParameters::has_globalid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetAppParameters::set_has_globalid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetAppParameters::clear_has_globalid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetAppParameters::clear_globalid() {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    globalid_->clear();
  }
  clear_has_globalid();
}
inline const ::std::string& SetAppParameters::globalid() const {
  return *globalid_;
}
inline void SetAppParameters::set_globalid(const ::std::string& value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void SetAppParameters::set_globalid(const char* value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void SetAppParameters::set_globalid(const char* value, size_t size) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SetAppParameters::mutable_globalid() {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  return globalid_;
}
inline ::std::string* SetAppParameters::release_globalid() {
  clear_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalid_;
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SetAppParameters::set_allocated_globalid(::std::string* globalid) {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    delete globalid_;
  }
  if (globalid) {
    set_has_globalid();
    globalid_ = globalid;
  } else {
    clear_has_globalid();
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 appID = 4;
inline bool SetAppParameters::has_appid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SetAppParameters::set_has_appid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SetAppParameters::clear_has_appid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SetAppParameters::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 SetAppParameters::appid() const {
  return appid_;
}
inline void SetAppParameters::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional string sensorName = 5;
inline bool SetAppParameters::has_sensorname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SetAppParameters::set_has_sensorname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SetAppParameters::clear_has_sensorname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SetAppParameters::clear_sensorname() {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    sensorname_->clear();
  }
  clear_has_sensorname();
}
inline const ::std::string& SetAppParameters::sensorname() const {
  return *sensorname_;
}
inline void SetAppParameters::set_sensorname(const ::std::string& value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void SetAppParameters::set_sensorname(const char* value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void SetAppParameters::set_sensorname(const char* value, size_t size) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SetAppParameters::mutable_sensorname() {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  return sensorname_;
}
inline ::std::string* SetAppParameters::release_sensorname() {
  clear_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sensorname_;
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SetAppParameters::set_allocated_sensorname(::std::string* sensorname) {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    delete sensorname_;
  }
  if (sensorname) {
    set_has_sensorname();
    sensorname_ = sensorname;
  } else {
    clear_has_sensorname();
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 superPriority = 6;
inline bool SetAppParameters::has_superpriority() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SetAppParameters::set_has_superpriority() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SetAppParameters::clear_has_superpriority() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SetAppParameters::clear_superpriority() {
  superpriority_ = 0;
  clear_has_superpriority();
}
inline ::google::protobuf::int32 SetAppParameters::superpriority() const {
  return superpriority_;
}
inline void SetAppParameters::set_superpriority(::google::protobuf::int32 value) {
  set_has_superpriority();
  superpriority_ = value;
}

// repeated .fv.tb.protos.TBProtos.Aperture aperture = 7;
inline int SetAppParameters::aperture_size() const {
  return aperture_.size();
}
inline void SetAppParameters::clear_aperture() {
  aperture_.Clear();
}
inline const ::fv::tb::protos::TBProtos::Aperture& SetAppParameters::aperture(int index) const {
  return aperture_.Get(index);
}
inline ::fv::tb::protos::TBProtos::Aperture* SetAppParameters::mutable_aperture(int index) {
  return aperture_.Mutable(index);
}
inline ::fv::tb::protos::TBProtos::Aperture* SetAppParameters::add_aperture() {
  return aperture_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Aperture >&
SetAppParameters::aperture() const {
  return aperture_;
}
inline ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Aperture >*
SetAppParameters::mutable_aperture() {
  return &aperture_;
}

// repeated .fv.tb.protos.TBProtos.Transceiver transceiver = 8;
inline int SetAppParameters::transceiver_size() const {
  return transceiver_.size();
}
inline void SetAppParameters::clear_transceiver() {
  transceiver_.Clear();
}
inline const ::fv::tb::protos::TBProtos::Transceiver& SetAppParameters::transceiver(int index) const {
  return transceiver_.Get(index);
}
inline ::fv::tb::protos::TBProtos::Transceiver* SetAppParameters::mutable_transceiver(int index) {
  return transceiver_.Mutable(index);
}
inline ::fv::tb::protos::TBProtos::Transceiver* SetAppParameters::add_transceiver() {
  return transceiver_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Transceiver >&
SetAppParameters::transceiver() const {
  return transceiver_;
}
inline ::google::protobuf::RepeatedPtrField< ::fv::tb::protos::TBProtos::Transceiver >*
SetAppParameters::mutable_transceiver() {
  return &transceiver_;
}

// -------------------------------------------------------------------

// MissionMode

// optional .fv.tb.protos.TBProtos.MissionMode.Mode mode = 1;
inline bool MissionMode::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MissionMode::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MissionMode::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MissionMode::clear_mode() {
  mode_ = 1;
  clear_has_mode();
}
inline ::fv::tb::protos::TBProtos::MissionMode_Mode MissionMode::mode() const {
  return static_cast< ::fv::tb::protos::TBProtos::MissionMode_Mode >(mode_);
}
inline void MissionMode::set_mode(::fv::tb::protos::TBProtos::MissionMode_Mode value) {
  assert(::fv::tb::protos::TBProtos::MissionMode_Mode_IsValid(value));
  set_has_mode();
  mode_ = value;
}

// -------------------------------------------------------------------

// SignalEvent

// optional string msgName = 1 [default = "SIGNAL_EVENT"];
inline bool SignalEvent::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignalEvent::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignalEvent::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignalEvent::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SignalEvent::msgname() const {
  return *msgname_;
}
inline void SignalEvent::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SignalEvent::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SignalEvent::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalEvent::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SignalEvent::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SignalEvent::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 channel = 2;
inline bool SignalEvent::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignalEvent::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignalEvent::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignalEvent::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 SignalEvent::channel() const {
  return channel_;
}
inline void SignalEvent::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// optional .fv.tb.protos.TBProtos.SignalEvent.Type eventType = 3;
inline bool SignalEvent::has_eventtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignalEvent::set_has_eventtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignalEvent::clear_has_eventtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignalEvent::clear_eventtype() {
  eventtype_ = 0;
  clear_has_eventtype();
}
inline ::fv::tb::protos::TBProtos::SignalEvent_Type SignalEvent::eventtype() const {
  return static_cast< ::fv::tb::protos::TBProtos::SignalEvent_Type >(eventtype_);
}
inline void SignalEvent::set_eventtype(::fv::tb::protos::TBProtos::SignalEvent_Type value) {
  assert(::fv::tb::protos::TBProtos::SignalEvent_Type_IsValid(value));
  set_has_eventtype();
  eventtype_ = value;
}

// optional string eventID = 4;
inline bool SignalEvent::has_eventid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignalEvent::set_has_eventid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignalEvent::clear_has_eventid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignalEvent::clear_eventid() {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    eventid_->clear();
  }
  clear_has_eventid();
}
inline const ::std::string& SignalEvent::eventid() const {
  return *eventid_;
}
inline void SignalEvent::set_eventid(const ::std::string& value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void SignalEvent::set_eventid(const char* value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void SignalEvent::set_eventid(const char* value, size_t size) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalEvent::mutable_eventid() {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  return eventid_;
}
inline ::std::string* SignalEvent::release_eventid() {
  clear_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventid_;
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignalEvent::set_allocated_eventid(::std::string* eventid) {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    delete eventid_;
  }
  if (eventid) {
    set_has_eventid();
    eventid_ = eventid;
  } else {
    clear_has_eventid();
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string timestamp = 5;
inline bool SignalEvent::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SignalEvent::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SignalEvent::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SignalEvent::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& SignalEvent::timestamp() const {
  return *timestamp_;
}
inline void SignalEvent::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void SignalEvent::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void SignalEvent::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalEvent::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* SignalEvent::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignalEvent::set_allocated_timestamp(::std::string* timestamp) {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    delete timestamp_;
  }
  if (timestamp) {
    set_has_timestamp();
    timestamp_ = timestamp;
  } else {
    clear_has_timestamp();
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string soiNum = 6;
inline bool SignalEvent::has_soinum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SignalEvent::set_has_soinum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SignalEvent::clear_has_soinum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SignalEvent::clear_soinum() {
  if (soinum_ != &::google::protobuf::internal::kEmptyString) {
    soinum_->clear();
  }
  clear_has_soinum();
}
inline const ::std::string& SignalEvent::soinum() const {
  return *soinum_;
}
inline void SignalEvent::set_soinum(const ::std::string& value) {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  soinum_->assign(value);
}
inline void SignalEvent::set_soinum(const char* value) {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  soinum_->assign(value);
}
inline void SignalEvent::set_soinum(const char* value, size_t size) {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  soinum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalEvent::mutable_soinum() {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  return soinum_;
}
inline ::std::string* SignalEvent::release_soinum() {
  clear_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = soinum_;
    soinum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignalEvent::set_allocated_soinum(::std::string* soinum) {
  if (soinum_ != &::google::protobuf::internal::kEmptyString) {
    delete soinum_;
  }
  if (soinum) {
    set_has_soinum();
    soinum_ = soinum;
  } else {
    clear_has_soinum();
    soinum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float rfMHz = 7;
inline bool SignalEvent::has_rfmhz() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SignalEvent::set_has_rfmhz() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SignalEvent::clear_has_rfmhz() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SignalEvent::clear_rfmhz() {
  rfmhz_ = 0;
  clear_has_rfmhz();
}
inline float SignalEvent::rfmhz() const {
  return rfmhz_;
}
inline void SignalEvent::set_rfmhz(float value) {
  set_has_rfmhz();
  rfmhz_ = value;
}

// optional float subcarMHz = 8;
inline bool SignalEvent::has_subcarmhz() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SignalEvent::set_has_subcarmhz() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SignalEvent::clear_has_subcarmhz() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SignalEvent::clear_subcarmhz() {
  subcarmhz_ = 0;
  clear_has_subcarmhz();
}
inline float SignalEvent::subcarmhz() const {
  return subcarmhz_;
}
inline void SignalEvent::set_subcarmhz(float value) {
  set_has_subcarmhz();
  subcarmhz_ = value;
}

// optional float excurKHz = 9;
inline bool SignalEvent::has_excurkhz() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SignalEvent::set_has_excurkhz() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SignalEvent::clear_has_excurkhz() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SignalEvent::clear_excurkhz() {
  excurkhz_ = 0;
  clear_has_excurkhz();
}
inline float SignalEvent::excurkhz() const {
  return excurkhz_;
}
inline void SignalEvent::set_excurkhz(float value) {
  set_has_excurkhz();
  excurkhz_ = value;
}

// optional int32 appID = 10;
inline bool SignalEvent::has_appid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SignalEvent::set_has_appid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SignalEvent::clear_has_appid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SignalEvent::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 SignalEvent::appid() const {
  return appid_;
}
inline void SignalEvent::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional int32 antNum = 11;
inline bool SignalEvent::has_antnum() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SignalEvent::set_has_antnum() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SignalEvent::clear_has_antnum() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SignalEvent::clear_antnum() {
  antnum_ = 0;
  clear_has_antnum();
}
inline ::google::protobuf::int32 SignalEvent::antnum() const {
  return antnum_;
}
inline void SignalEvent::set_antnum(::google::protobuf::int32 value) {
  set_has_antnum();
  antnum_ = value;
}

// optional float antAz = 12 [default = 0];
inline bool SignalEvent::has_antaz() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SignalEvent::set_has_antaz() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SignalEvent::clear_has_antaz() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SignalEvent::clear_antaz() {
  antaz_ = 0;
  clear_has_antaz();
}
inline float SignalEvent::antaz() const {
  return antaz_;
}
inline void SignalEvent::set_antaz(float value) {
  set_has_antaz();
  antaz_ = value;
}

// optional float antEl = 13 [default = 0];
inline bool SignalEvent::has_antel() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SignalEvent::set_has_antel() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SignalEvent::clear_has_antel() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SignalEvent::clear_antel() {
  antel_ = 0;
  clear_has_antel();
}
inline float SignalEvent::antel() const {
  return antel_;
}
inline void SignalEvent::set_antel(float value) {
  set_has_antel();
  antel_ = value;
}

// optional string globalID = 14;
inline bool SignalEvent::has_globalid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SignalEvent::set_has_globalid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SignalEvent::clear_has_globalid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SignalEvent::clear_globalid() {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    globalid_->clear();
  }
  clear_has_globalid();
}
inline const ::std::string& SignalEvent::globalid() const {
  return *globalid_;
}
inline void SignalEvent::set_globalid(const ::std::string& value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void SignalEvent::set_globalid(const char* value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void SignalEvent::set_globalid(const char* value, size_t size) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalEvent::mutable_globalid() {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  return globalid_;
}
inline ::std::string* SignalEvent::release_globalid() {
  clear_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalid_;
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignalEvent::set_allocated_globalid(::std::string* globalid) {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    delete globalid_;
  }
  if (globalid) {
    set_has_globalid();
    globalid_ = globalid;
  } else {
    clear_has_globalid();
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string scrypt = 15;
inline bool SignalEvent::has_scrypt() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SignalEvent::set_has_scrypt() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SignalEvent::clear_has_scrypt() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SignalEvent::clear_scrypt() {
  if (scrypt_ != &::google::protobuf::internal::kEmptyString) {
    scrypt_->clear();
  }
  clear_has_scrypt();
}
inline const ::std::string& SignalEvent::scrypt() const {
  return *scrypt_;
}
inline void SignalEvent::set_scrypt(const ::std::string& value) {
  set_has_scrypt();
  if (scrypt_ == &::google::protobuf::internal::kEmptyString) {
    scrypt_ = new ::std::string;
  }
  scrypt_->assign(value);
}
inline void SignalEvent::set_scrypt(const char* value) {
  set_has_scrypt();
  if (scrypt_ == &::google::protobuf::internal::kEmptyString) {
    scrypt_ = new ::std::string;
  }
  scrypt_->assign(value);
}
inline void SignalEvent::set_scrypt(const char* value, size_t size) {
  set_has_scrypt();
  if (scrypt_ == &::google::protobuf::internal::kEmptyString) {
    scrypt_ = new ::std::string;
  }
  scrypt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalEvent::mutable_scrypt() {
  set_has_scrypt();
  if (scrypt_ == &::google::protobuf::internal::kEmptyString) {
    scrypt_ = new ::std::string;
  }
  return scrypt_;
}
inline ::std::string* SignalEvent::release_scrypt() {
  clear_has_scrypt();
  if (scrypt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = scrypt_;
    scrypt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignalEvent::set_allocated_scrypt(::std::string* scrypt) {
  if (scrypt_ != &::google::protobuf::internal::kEmptyString) {
    delete scrypt_;
  }
  if (scrypt) {
    set_has_scrypt();
    scrypt_ = scrypt;
  } else {
    clear_has_scrypt();
    scrypt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 exportPort = 16;
inline bool SignalEvent::has_exportport() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SignalEvent::set_has_exportport() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SignalEvent::clear_has_exportport() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SignalEvent::clear_exportport() {
  exportport_ = 0;
  clear_has_exportport();
}
inline ::google::protobuf::int32 SignalEvent::exportport() const {
  return exportport_;
}
inline void SignalEvent::set_exportport(::google::protobuf::int32 value) {
  set_has_exportport();
  exportport_ = value;
}

// optional string eltex = 17;
inline bool SignalEvent::has_eltex() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SignalEvent::set_has_eltex() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SignalEvent::clear_has_eltex() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SignalEvent::clear_eltex() {
  if (eltex_ != &::google::protobuf::internal::kEmptyString) {
    eltex_->clear();
  }
  clear_has_eltex();
}
inline const ::std::string& SignalEvent::eltex() const {
  return *eltex_;
}
inline void SignalEvent::set_eltex(const ::std::string& value) {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  eltex_->assign(value);
}
inline void SignalEvent::set_eltex(const char* value) {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  eltex_->assign(value);
}
inline void SignalEvent::set_eltex(const char* value, size_t size) {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  eltex_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalEvent::mutable_eltex() {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  return eltex_;
}
inline ::std::string* SignalEvent::release_eltex() {
  clear_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eltex_;
    eltex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignalEvent::set_allocated_eltex(::std::string* eltex) {
  if (eltex_ != &::google::protobuf::internal::kEmptyString) {
    delete eltex_;
  }
  if (eltex) {
    set_has_eltex();
    eltex_ = eltex;
  } else {
    clear_has_eltex();
    eltex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float bwMHz = 18;
inline bool SignalEvent::has_bwmhz() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SignalEvent::set_has_bwmhz() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SignalEvent::clear_has_bwmhz() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SignalEvent::clear_bwmhz() {
  bwmhz_ = 0;
  clear_has_bwmhz();
}
inline float SignalEvent::bwmhz() const {
  return bwmhz_;
}
inline void SignalEvent::set_bwmhz(float value) {
  set_has_bwmhz();
  bwmhz_ = value;
}

// optional string sensorName = 19 [default = ""];
inline bool SignalEvent::has_sensorname() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SignalEvent::set_has_sensorname() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SignalEvent::clear_has_sensorname() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SignalEvent::clear_sensorname() {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    sensorname_->clear();
  }
  clear_has_sensorname();
}
inline const ::std::string& SignalEvent::sensorname() const {
  return *sensorname_;
}
inline void SignalEvent::set_sensorname(const ::std::string& value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void SignalEvent::set_sensorname(const char* value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void SignalEvent::set_sensorname(const char* value, size_t size) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalEvent::mutable_sensorname() {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  return sensorname_;
}
inline ::std::string* SignalEvent::release_sensorname() {
  clear_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sensorname_;
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignalEvent::set_allocated_sensorname(::std::string* sensorname) {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    delete sensorname_;
  }
  if (sensorname) {
    set_has_sensorname();
    sensorname_ = sensorname;
  } else {
    clear_has_sensorname();
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TxSignalParams

// optional string msgName = 1 [default = "TX_SIGNAL_PARAMS"];
inline bool TxSignalParams::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxSignalParams::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxSignalParams::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxSignalParams::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& TxSignalParams::msgname() const {
  return *msgname_;
}
inline void TxSignalParams::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void TxSignalParams::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void TxSignalParams::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxSignalParams::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* TxSignalParams::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void TxSignalParams::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string sigName = 2;
inline bool TxSignalParams::has_signame() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxSignalParams::set_has_signame() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxSignalParams::clear_has_signame() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxSignalParams::clear_signame() {
  if (signame_ != &::google::protobuf::internal::kEmptyString) {
    signame_->clear();
  }
  clear_has_signame();
}
inline const ::std::string& TxSignalParams::signame() const {
  return *signame_;
}
inline void TxSignalParams::set_signame(const ::std::string& value) {
  set_has_signame();
  if (signame_ == &::google::protobuf::internal::kEmptyString) {
    signame_ = new ::std::string;
  }
  signame_->assign(value);
}
inline void TxSignalParams::set_signame(const char* value) {
  set_has_signame();
  if (signame_ == &::google::protobuf::internal::kEmptyString) {
    signame_ = new ::std::string;
  }
  signame_->assign(value);
}
inline void TxSignalParams::set_signame(const char* value, size_t size) {
  set_has_signame();
  if (signame_ == &::google::protobuf::internal::kEmptyString) {
    signame_ = new ::std::string;
  }
  signame_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxSignalParams::mutable_signame() {
  set_has_signame();
  if (signame_ == &::google::protobuf::internal::kEmptyString) {
    signame_ = new ::std::string;
  }
  return signame_;
}
inline ::std::string* TxSignalParams::release_signame() {
  clear_has_signame();
  if (signame_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signame_;
    signame_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TxSignalParams::set_allocated_signame(::std::string* signame) {
  if (signame_ != &::google::protobuf::internal::kEmptyString) {
    delete signame_;
  }
  if (signame) {
    set_has_signame();
    signame_ = signame;
  } else {
    clear_has_signame();
    signame_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string fileName = 3;
inline bool TxSignalParams::has_filename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxSignalParams::set_has_filename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxSignalParams::clear_has_filename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxSignalParams::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& TxSignalParams::filename() const {
  return *filename_;
}
inline void TxSignalParams::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void TxSignalParams::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void TxSignalParams::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxSignalParams::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* TxSignalParams::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TxSignalParams::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float sampleRateMHz = 4 [default = 25];
inline bool TxSignalParams::has_sampleratemhz() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TxSignalParams::set_has_sampleratemhz() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TxSignalParams::clear_has_sampleratemhz() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TxSignalParams::clear_sampleratemhz() {
  sampleratemhz_ = 25;
  clear_has_sampleratemhz();
}
inline float TxSignalParams::sampleratemhz() const {
  return sampleratemhz_;
}
inline void TxSignalParams::set_sampleratemhz(float value) {
  set_has_sampleratemhz();
  sampleratemhz_ = value;
}

// optional double centerFreq = 5 [default = 915];
inline bool TxSignalParams::has_centerfreq() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TxSignalParams::set_has_centerfreq() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TxSignalParams::clear_has_centerfreq() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TxSignalParams::clear_centerfreq() {
  centerfreq_ = 915;
  clear_has_centerfreq();
}
inline double TxSignalParams::centerfreq() const {
  return centerfreq_;
}
inline void TxSignalParams::set_centerfreq(double value) {
  set_has_centerfreq();
  centerfreq_ = value;
}

// optional string config = 6 [default = "CONFIG"];
inline bool TxSignalParams::has_config() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TxSignalParams::set_has_config() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TxSignalParams::clear_has_config() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TxSignalParams::clear_config() {
  if (config_ != _default_config_) {
    config_->assign(*_default_config_);
  }
  clear_has_config();
}
inline const ::std::string& TxSignalParams::config() const {
  return *config_;
}
inline void TxSignalParams::set_config(const ::std::string& value) {
  set_has_config();
  if (config_ == _default_config_) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void TxSignalParams::set_config(const char* value) {
  set_has_config();
  if (config_ == _default_config_) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void TxSignalParams::set_config(const char* value, size_t size) {
  set_has_config();
  if (config_ == _default_config_) {
    config_ = new ::std::string;
  }
  config_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxSignalParams::mutable_config() {
  set_has_config();
  if (config_ == _default_config_) {
    config_ = new ::std::string(*_default_config_);
  }
  return config_;
}
inline ::std::string* TxSignalParams::release_config() {
  clear_has_config();
  if (config_ == _default_config_) {
    return NULL;
  } else {
    ::std::string* temp = config_;
    config_ = const_cast< ::std::string*>(_default_config_);
    return temp;
  }
}
inline void TxSignalParams::set_allocated_config(::std::string* config) {
  if (config_ != _default_config_) {
    delete config_;
  }
  if (config) {
    set_has_config();
    config_ = config;
  } else {
    clear_has_config();
    config_ = const_cast< ::std::string*>(_default_config_);
  }
}

// -------------------------------------------------------------------

// TxFileStatus

// optional string msgName = 1 [default = "TX_FILE_STATUS"];
inline bool TxFileStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxFileStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxFileStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxFileStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& TxFileStatus::msgname() const {
  return *msgname_;
}
inline void TxFileStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void TxFileStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void TxFileStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxFileStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* TxFileStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void TxFileStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string sigName = 2;
inline bool TxFileStatus::has_signame() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxFileStatus::set_has_signame() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxFileStatus::clear_has_signame() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxFileStatus::clear_signame() {
  if (signame_ != &::google::protobuf::internal::kEmptyString) {
    signame_->clear();
  }
  clear_has_signame();
}
inline const ::std::string& TxFileStatus::signame() const {
  return *signame_;
}
inline void TxFileStatus::set_signame(const ::std::string& value) {
  set_has_signame();
  if (signame_ == &::google::protobuf::internal::kEmptyString) {
    signame_ = new ::std::string;
  }
  signame_->assign(value);
}
inline void TxFileStatus::set_signame(const char* value) {
  set_has_signame();
  if (signame_ == &::google::protobuf::internal::kEmptyString) {
    signame_ = new ::std::string;
  }
  signame_->assign(value);
}
inline void TxFileStatus::set_signame(const char* value, size_t size) {
  set_has_signame();
  if (signame_ == &::google::protobuf::internal::kEmptyString) {
    signame_ = new ::std::string;
  }
  signame_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxFileStatus::mutable_signame() {
  set_has_signame();
  if (signame_ == &::google::protobuf::internal::kEmptyString) {
    signame_ = new ::std::string;
  }
  return signame_;
}
inline ::std::string* TxFileStatus::release_signame() {
  clear_has_signame();
  if (signame_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signame_;
    signame_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TxFileStatus::set_allocated_signame(::std::string* signame) {
  if (signame_ != &::google::protobuf::internal::kEmptyString) {
    delete signame_;
  }
  if (signame) {
    set_has_signame();
    signame_ = signame;
  } else {
    clear_has_signame();
    signame_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string fileName = 3;
inline bool TxFileStatus::has_filename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxFileStatus::set_has_filename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxFileStatus::clear_has_filename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxFileStatus::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& TxFileStatus::filename() const {
  return *filename_;
}
inline void TxFileStatus::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void TxFileStatus::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void TxFileStatus::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxFileStatus::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* TxFileStatus::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TxFileStatus::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string config = 4 [default = "CONFIG"];
inline bool TxFileStatus::has_config() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TxFileStatus::set_has_config() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TxFileStatus::clear_has_config() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TxFileStatus::clear_config() {
  if (config_ != _default_config_) {
    config_->assign(*_default_config_);
  }
  clear_has_config();
}
inline const ::std::string& TxFileStatus::config() const {
  return *config_;
}
inline void TxFileStatus::set_config(const ::std::string& value) {
  set_has_config();
  if (config_ == _default_config_) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void TxFileStatus::set_config(const char* value) {
  set_has_config();
  if (config_ == _default_config_) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void TxFileStatus::set_config(const char* value, size_t size) {
  set_has_config();
  if (config_ == _default_config_) {
    config_ = new ::std::string;
  }
  config_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxFileStatus::mutable_config() {
  set_has_config();
  if (config_ == _default_config_) {
    config_ = new ::std::string(*_default_config_);
  }
  return config_;
}
inline ::std::string* TxFileStatus::release_config() {
  clear_has_config();
  if (config_ == _default_config_) {
    return NULL;
  } else {
    ::std::string* temp = config_;
    config_ = const_cast< ::std::string*>(_default_config_);
    return temp;
  }
}
inline void TxFileStatus::set_allocated_config(::std::string* config) {
  if (config_ != _default_config_) {
    delete config_;
  }
  if (config) {
    set_has_config();
    config_ = config;
  } else {
    clear_has_config();
    config_ = const_cast< ::std::string*>(_default_config_);
  }
}

// -------------------------------------------------------------------

// CalibrationTimingResult

// optional string msgName = 1 [default = "CALIBRATIONTIMINGRESULT"];
inline bool CalibrationTimingResult::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CalibrationTimingResult::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CalibrationTimingResult::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CalibrationTimingResult::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& CalibrationTimingResult::msgname() const {
  return *msgname_;
}
inline void CalibrationTimingResult::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void CalibrationTimingResult::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void CalibrationTimingResult::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CalibrationTimingResult::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* CalibrationTimingResult::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void CalibrationTimingResult::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional double wholeSeconds = 2 [default = 0];
inline bool CalibrationTimingResult::has_wholeseconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CalibrationTimingResult::set_has_wholeseconds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CalibrationTimingResult::clear_has_wholeseconds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CalibrationTimingResult::clear_wholeseconds() {
  wholeseconds_ = 0;
  clear_has_wholeseconds();
}
inline double CalibrationTimingResult::wholeseconds() const {
  return wholeseconds_;
}
inline void CalibrationTimingResult::set_wholeseconds(double value) {
  set_has_wholeseconds();
  wholeseconds_ = value;
}

// optional double fracSeconds = 3 [default = 0];
inline bool CalibrationTimingResult::has_fracseconds() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CalibrationTimingResult::set_has_fracseconds() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CalibrationTimingResult::clear_has_fracseconds() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CalibrationTimingResult::clear_fracseconds() {
  fracseconds_ = 0;
  clear_has_fracseconds();
}
inline double CalibrationTimingResult::fracseconds() const {
  return fracseconds_;
}
inline void CalibrationTimingResult::set_fracseconds(double value) {
  set_has_fracseconds();
  fracseconds_ = value;
}

// optional int32 transmittedByChannel = 4;
inline bool CalibrationTimingResult::has_transmittedbychannel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CalibrationTimingResult::set_has_transmittedbychannel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CalibrationTimingResult::clear_has_transmittedbychannel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CalibrationTimingResult::clear_transmittedbychannel() {
  transmittedbychannel_ = 0;
  clear_has_transmittedbychannel();
}
inline ::google::protobuf::int32 CalibrationTimingResult::transmittedbychannel() const {
  return transmittedbychannel_;
}
inline void CalibrationTimingResult::set_transmittedbychannel(::google::protobuf::int32 value) {
  set_has_transmittedbychannel();
  transmittedbychannel_ = value;
}

// optional int32 receivedByChannel = 5;
inline bool CalibrationTimingResult::has_receivedbychannel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CalibrationTimingResult::set_has_receivedbychannel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CalibrationTimingResult::clear_has_receivedbychannel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CalibrationTimingResult::clear_receivedbychannel() {
  receivedbychannel_ = 0;
  clear_has_receivedbychannel();
}
inline ::google::protobuf::int32 CalibrationTimingResult::receivedbychannel() const {
  return receivedbychannel_;
}
inline void CalibrationTimingResult::set_receivedbychannel(::google::protobuf::int32 value) {
  set_has_receivedbychannel();
  receivedbychannel_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace TBProtos
}  // namespace protos
}  // namespace tb
}  // namespace fv

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fv::tb::protos::TBProtos::OutputChannelStatus_TransmitState>() {
  return ::fv::tb::protos::TBProtos::OutputChannelStatus_TransmitState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fv::tb::protos::TBProtos::EWCapability_DetectionSource>() {
  return ::fv::tb::protos::TBProtos::EWCapability_DetectionSource_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fv::tb::protos::TBProtos::EWOption_DetectionSource>() {
  return ::fv::tb::protos::TBProtos::EWOption_DetectionSource_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fv::tb::protos::TBProtos::TransmitterConfig_SiggenType>() {
  return ::fv::tb::protos::TBProtos::TransmitterConfig_SiggenType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fv::tb::protos::TBProtos::techniqueCommand_CommandType>() {
  return ::fv::tb::protos::TBProtos::techniqueCommand_CommandType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fv::tb::protos::TBProtos::MissionMode_Mode>() {
  return ::fv::tb::protos::TBProtos::MissionMode_Mode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fv::tb::protos::TBProtos::SignalEvent_Type>() {
  return ::fv::tb::protos::TBProtos::SignalEvent_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ThunderbirdMessages_2eproto__INCLUDED
