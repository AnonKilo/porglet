// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FalconGeoMessages.proto

#ifndef PROTOBUF_FalconGeoMessages_2eproto__INCLUDED
#define PROTOBUF_FalconGeoMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "FalconCommonMessages.pb.h"
// @@protoc_insertion_point(includes)

namespace falcon_geo_msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_FalconGeoMessages_2eproto();
void protobuf_AssignDesc_FalconGeoMessages_2eproto();
void protobuf_ShutdownFile_FalconGeoMessages_2eproto();

class CSNAP;
class GeoSnapResponse;
class GeoSnapDone;
class CSNAPQ;
class GeoSnapQuitResponse;
class GeoBurstDone;
class GSNAP;
class GeoProcessDone;
class GEO_EXIT;
class GEO_RESET;
class WifiTest;

// ===================================================================

class CSNAP : public ::google::protobuf::Message {
 public:
  CSNAP();
  virtual ~CSNAP();

  CSNAP(const CSNAP& from);

  inline CSNAP& operator=(const CSNAP& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSNAP& default_instance();

  void Swap(CSNAP* other);

  // implements Message ----------------------------------------------

  CSNAP* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSNAP& from);
  void MergeFrom(const CSNAP& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "CSNAP"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional double start_sec = 2;
  inline bool has_start_sec() const;
  inline void clear_start_sec();
  static const int kStartSecFieldNumber = 2;
  inline double start_sec() const;
  inline void set_start_sec(double value);

  // optional double start_fsec = 3;
  inline bool has_start_fsec() const;
  inline void clear_start_fsec();
  static const int kStartFsecFieldNumber = 3;
  inline double start_fsec() const;
  inline void set_start_fsec(double value);

  // optional float cf = 4;
  inline bool has_cf() const;
  inline void clear_cf();
  static const int kCfFieldNumber = 4;
  inline float cf() const;
  inline void set_cf(float value);

  // optional float duration = 5;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 5;
  inline float duration() const;
  inline void set_duration(float value);

  // optional int32 az = 6;
  inline bool has_az() const;
  inline void clear_az();
  static const int kAzFieldNumber = 6;
  inline ::google::protobuf::int32 az() const;
  inline void set_az(::google::protobuf::int32 value);

  // optional float lat = 7;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 7;
  inline float lat() const;
  inline void set_lat(float value);

  // optional float lon = 8;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 8;
  inline float lon() const;
  inline void set_lon(float value);

  // optional string soi = 9;
  inline bool has_soi() const;
  inline void clear_soi();
  static const int kSoiFieldNumber = 9;
  inline const ::std::string& soi() const;
  inline void set_soi(const ::std::string& value);
  inline void set_soi(const char* value);
  inline void set_soi(const char* value, size_t size);
  inline ::std::string* mutable_soi();
  inline ::std::string* release_soi();
  inline void set_allocated_soi(::std::string* soi);

  // optional string unit_id = 10;
  inline bool has_unit_id() const;
  inline void clear_unit_id();
  static const int kUnitIdFieldNumber = 10;
  inline const ::std::string& unit_id() const;
  inline void set_unit_id(const ::std::string& value);
  inline void set_unit_id(const char* value);
  inline void set_unit_id(const char* value, size_t size);
  inline ::std::string* mutable_unit_id();
  inline ::std::string* release_unit_id();
  inline void set_allocated_unit_id(::std::string* unit_id);

  // optional double message_id = 11;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 11;
  inline double message_id() const;
  inline void set_message_id(double value);

  // @@protoc_insertion_point(class_scope:falcon_geo_msg.CSNAP)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_start_sec();
  inline void clear_has_start_sec();
  inline void set_has_start_fsec();
  inline void clear_has_start_fsec();
  inline void set_has_cf();
  inline void clear_has_cf();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_az();
  inline void clear_has_az();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_soi();
  inline void clear_has_soi();
  inline void set_has_unit_id();
  inline void clear_has_unit_id();
  inline void set_has_message_id();
  inline void clear_has_message_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  double start_sec_;
  double start_fsec_;
  float cf_;
  float duration_;
  ::google::protobuf::int32 az_;
  float lat_;
  ::std::string* soi_;
  ::std::string* unit_id_;
  double message_id_;
  float lon_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_FalconGeoMessages_2eproto();
  friend void protobuf_AssignDesc_FalconGeoMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconGeoMessages_2eproto();

  void InitAsDefaultInstance();
  static CSNAP* default_instance_;
};
// -------------------------------------------------------------------

class GeoSnapResponse : public ::google::protobuf::Message {
 public:
  GeoSnapResponse();
  virtual ~GeoSnapResponse();

  GeoSnapResponse(const GeoSnapResponse& from);

  inline GeoSnapResponse& operator=(const GeoSnapResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GeoSnapResponse& default_instance();

  void Swap(GeoSnapResponse* other);

  // implements Message ----------------------------------------------

  GeoSnapResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GeoSnapResponse& from);
  void MergeFrom(const GeoSnapResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "GEO_SNAP_RESPONSE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 ack = 2;
  inline bool has_ack() const;
  inline void clear_ack();
  static const int kAckFieldNumber = 2;
  inline ::google::protobuf::int32 ack() const;
  inline void set_ack(::google::protobuf::int32 value);

  // optional double message_id = 3;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 3;
  inline double message_id() const;
  inline void set_message_id(double value);

  // @@protoc_insertion_point(class_scope:falcon_geo_msg.GeoSnapResponse)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_ack();
  inline void clear_has_ack();
  inline void set_has_message_id();
  inline void clear_has_message_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  double message_id_;
  ::google::protobuf::int32 ack_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconGeoMessages_2eproto();
  friend void protobuf_AssignDesc_FalconGeoMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconGeoMessages_2eproto();

  void InitAsDefaultInstance();
  static GeoSnapResponse* default_instance_;
};
// -------------------------------------------------------------------

class GeoSnapDone : public ::google::protobuf::Message {
 public:
  GeoSnapDone();
  virtual ~GeoSnapDone();

  GeoSnapDone(const GeoSnapDone& from);

  inline GeoSnapDone& operator=(const GeoSnapDone& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GeoSnapDone& default_instance();

  void Swap(GeoSnapDone* other);

  // implements Message ----------------------------------------------

  GeoSnapDone* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GeoSnapDone& from);
  void MergeFrom(const GeoSnapDone& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "GEO_SNAP_DONE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional double start_sec = 2;
  inline bool has_start_sec() const;
  inline void clear_start_sec();
  static const int kStartSecFieldNumber = 2;
  inline double start_sec() const;
  inline void set_start_sec(double value);

  // optional double start_fsec = 3;
  inline bool has_start_fsec() const;
  inline void clear_start_fsec();
  static const int kStartFsecFieldNumber = 3;
  inline double start_fsec() const;
  inline void set_start_fsec(double value);

  // optional float duration = 4;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 4;
  inline float duration() const;
  inline void set_duration(float value);

  // optional int32 chan = 5;
  inline bool has_chan() const;
  inline void clear_chan();
  static const int kChanFieldNumber = 5;
  inline ::google::protobuf::int32 chan() const;
  inline void set_chan(::google::protobuf::int32 value);

  // optional float cf = 6;
  inline bool has_cf() const;
  inline void clear_cf();
  static const int kCfFieldNumber = 6;
  inline float cf() const;
  inline void set_cf(float value);

  // optional string soi = 7;
  inline bool has_soi() const;
  inline void clear_soi();
  static const int kSoiFieldNumber = 7;
  inline const ::std::string& soi() const;
  inline void set_soi(const ::std::string& value);
  inline void set_soi(const char* value);
  inline void set_soi(const char* value, size_t size);
  inline ::std::string* mutable_soi();
  inline ::std::string* release_soi();
  inline void set_allocated_soi(::std::string* soi);

  // optional string unit_id = 8;
  inline bool has_unit_id() const;
  inline void clear_unit_id();
  static const int kUnitIdFieldNumber = 8;
  inline const ::std::string& unit_id() const;
  inline void set_unit_id(const ::std::string& value);
  inline void set_unit_id(const char* value);
  inline void set_unit_id(const char* value, size_t size);
  inline ::std::string* mutable_unit_id();
  inline ::std::string* release_unit_id();
  inline void set_allocated_unit_id(::std::string* unit_id);

  // optional string filename = 9;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 9;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional string meta_filename = 10;
  inline bool has_meta_filename() const;
  inline void clear_meta_filename();
  static const int kMetaFilenameFieldNumber = 10;
  inline const ::std::string& meta_filename() const;
  inline void set_meta_filename(const ::std::string& value);
  inline void set_meta_filename(const char* value);
  inline void set_meta_filename(const char* value, size_t size);
  inline ::std::string* mutable_meta_filename();
  inline ::std::string* release_meta_filename();
  inline void set_allocated_meta_filename(::std::string* meta_filename);

  // optional double message_id = 11;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 11;
  inline double message_id() const;
  inline void set_message_id(double value);

  // @@protoc_insertion_point(class_scope:falcon_geo_msg.GeoSnapDone)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_start_sec();
  inline void clear_has_start_sec();
  inline void set_has_start_fsec();
  inline void clear_has_start_fsec();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_chan();
  inline void clear_has_chan();
  inline void set_has_cf();
  inline void clear_has_cf();
  inline void set_has_soi();
  inline void clear_has_soi();
  inline void set_has_unit_id();
  inline void clear_has_unit_id();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_meta_filename();
  inline void clear_has_meta_filename();
  inline void set_has_message_id();
  inline void clear_has_message_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  double start_sec_;
  double start_fsec_;
  float duration_;
  ::google::protobuf::int32 chan_;
  ::std::string* soi_;
  ::std::string* unit_id_;
  ::std::string* filename_;
  ::std::string* meta_filename_;
  double message_id_;
  float cf_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_FalconGeoMessages_2eproto();
  friend void protobuf_AssignDesc_FalconGeoMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconGeoMessages_2eproto();

  void InitAsDefaultInstance();
  static GeoSnapDone* default_instance_;
};
// -------------------------------------------------------------------

class CSNAPQ : public ::google::protobuf::Message {
 public:
  CSNAPQ();
  virtual ~CSNAPQ();

  CSNAPQ(const CSNAPQ& from);

  inline CSNAPQ& operator=(const CSNAPQ& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSNAPQ& default_instance();

  void Swap(CSNAPQ* other);

  // implements Message ----------------------------------------------

  CSNAPQ* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSNAPQ& from);
  void MergeFrom(const CSNAPQ& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "CSNAPQ"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 chan = 2;
  inline bool has_chan() const;
  inline void clear_chan();
  static const int kChanFieldNumber = 2;
  inline ::google::protobuf::int32 chan() const;
  inline void set_chan(::google::protobuf::int32 value);

  // optional double message_id = 3;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 3;
  inline double message_id() const;
  inline void set_message_id(double value);

  // @@protoc_insertion_point(class_scope:falcon_geo_msg.CSNAPQ)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_chan();
  inline void clear_has_chan();
  inline void set_has_message_id();
  inline void clear_has_message_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  double message_id_;
  ::google::protobuf::int32 chan_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconGeoMessages_2eproto();
  friend void protobuf_AssignDesc_FalconGeoMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconGeoMessages_2eproto();

  void InitAsDefaultInstance();
  static CSNAPQ* default_instance_;
};
// -------------------------------------------------------------------

class GeoSnapQuitResponse : public ::google::protobuf::Message {
 public:
  GeoSnapQuitResponse();
  virtual ~GeoSnapQuitResponse();

  GeoSnapQuitResponse(const GeoSnapQuitResponse& from);

  inline GeoSnapQuitResponse& operator=(const GeoSnapQuitResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GeoSnapQuitResponse& default_instance();

  void Swap(GeoSnapQuitResponse* other);

  // implements Message ----------------------------------------------

  GeoSnapQuitResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GeoSnapQuitResponse& from);
  void MergeFrom(const GeoSnapQuitResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "GEO_SNAP_QUIT_RESPONSE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 ack = 2;
  inline bool has_ack() const;
  inline void clear_ack();
  static const int kAckFieldNumber = 2;
  inline ::google::protobuf::int32 ack() const;
  inline void set_ack(::google::protobuf::int32 value);

  // optional int32 chan = 3;
  inline bool has_chan() const;
  inline void clear_chan();
  static const int kChanFieldNumber = 3;
  inline ::google::protobuf::int32 chan() const;
  inline void set_chan(::google::protobuf::int32 value);

  // optional double message_id = 4;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 4;
  inline double message_id() const;
  inline void set_message_id(double value);

  // @@protoc_insertion_point(class_scope:falcon_geo_msg.GeoSnapQuitResponse)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_ack();
  inline void clear_has_ack();
  inline void set_has_chan();
  inline void clear_has_chan();
  inline void set_has_message_id();
  inline void clear_has_message_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 ack_;
  ::google::protobuf::int32 chan_;
  double message_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_FalconGeoMessages_2eproto();
  friend void protobuf_AssignDesc_FalconGeoMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconGeoMessages_2eproto();

  void InitAsDefaultInstance();
  static GeoSnapQuitResponse* default_instance_;
};
// -------------------------------------------------------------------

class GeoBurstDone : public ::google::protobuf::Message {
 public:
  GeoBurstDone();
  virtual ~GeoBurstDone();

  GeoBurstDone(const GeoBurstDone& from);

  inline GeoBurstDone& operator=(const GeoBurstDone& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GeoBurstDone& default_instance();

  void Swap(GeoBurstDone* other);

  // implements Message ----------------------------------------------

  GeoBurstDone* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GeoBurstDone& from);
  void MergeFrom(const GeoBurstDone& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "GEO_BURST_DONE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string meta_filename = 2;
  inline bool has_meta_filename() const;
  inline void clear_meta_filename();
  static const int kMetaFilenameFieldNumber = 2;
  inline const ::std::string& meta_filename() const;
  inline void set_meta_filename(const ::std::string& value);
  inline void set_meta_filename(const char* value);
  inline void set_meta_filename(const char* value, size_t size);
  inline ::std::string* mutable_meta_filename();
  inline ::std::string* release_meta_filename();
  inline void set_allocated_meta_filename(::std::string* meta_filename);

  // optional int32 message_id = 3;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 3;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // optional string chan = 4;
  inline bool has_chan() const;
  inline void clear_chan();
  static const int kChanFieldNumber = 4;
  inline const ::std::string& chan() const;
  inline void set_chan(const ::std::string& value);
  inline void set_chan(const char* value);
  inline void set_chan(const char* value, size_t size);
  inline ::std::string* mutable_chan();
  inline ::std::string* release_chan();
  inline void set_allocated_chan(::std::string* chan);

  // @@protoc_insertion_point(class_scope:falcon_geo_msg.GeoBurstDone)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_meta_filename();
  inline void clear_has_meta_filename();
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_chan();
  inline void clear_has_chan();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* meta_filename_;
  ::std::string* chan_;
  ::google::protobuf::int32 message_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_FalconGeoMessages_2eproto();
  friend void protobuf_AssignDesc_FalconGeoMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconGeoMessages_2eproto();

  void InitAsDefaultInstance();
  static GeoBurstDone* default_instance_;
};
// -------------------------------------------------------------------

class GSNAP : public ::google::protobuf::Message {
 public:
  GSNAP();
  virtual ~GSNAP();

  GSNAP(const GSNAP& from);

  inline GSNAP& operator=(const GSNAP& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GSNAP& default_instance();

  void Swap(GSNAP* other);

  // implements Message ----------------------------------------------

  GSNAP* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GSNAP& from);
  void MergeFrom(const GSNAP& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "GSNAP"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 chan = 3;
  inline bool has_chan() const;
  inline void clear_chan();
  static const int kChanFieldNumber = 3;
  inline ::google::protobuf::int32 chan() const;
  inline void set_chan(::google::protobuf::int32 value);

  // optional double start_sec = 4;
  inline bool has_start_sec() const;
  inline void clear_start_sec();
  static const int kStartSecFieldNumber = 4;
  inline double start_sec() const;
  inline void set_start_sec(double value);

  // optional double start_fsec = 5;
  inline bool has_start_fsec() const;
  inline void clear_start_fsec();
  static const int kStartFsecFieldNumber = 5;
  inline double start_fsec() const;
  inline void set_start_fsec(double value);

  // optional int32 duration = 6;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 6;
  inline ::google::protobuf::int32 duration() const;
  inline void set_duration(::google::protobuf::int32 value);

  // optional float freq = 7;
  inline bool has_freq() const;
  inline void clear_freq();
  static const int kFreqFieldNumber = 7;
  inline float freq() const;
  inline void set_freq(float value);

  // optional float sample_rate = 8;
  inline bool has_sample_rate() const;
  inline void clear_sample_rate();
  static const int kSampleRateFieldNumber = 8;
  inline float sample_rate() const;
  inline void set_sample_rate(float value);

  // optional int32 track_number = 9;
  inline bool has_track_number() const;
  inline void clear_track_number();
  static const int kTrackNumberFieldNumber = 9;
  inline ::google::protobuf::int32 track_number() const;
  inline void set_track_number(::google::protobuf::int32 value);

  // optional string soi = 10;
  inline bool has_soi() const;
  inline void clear_soi();
  static const int kSoiFieldNumber = 10;
  inline const ::std::string& soi() const;
  inline void set_soi(const ::std::string& value);
  inline void set_soi(const char* value);
  inline void set_soi(const char* value, size_t size);
  inline ::std::string* mutable_soi();
  inline ::std::string* release_soi();
  inline void set_allocated_soi(::std::string* soi);

  // optional double message_id = 11;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 11;
  inline double message_id() const;
  inline void set_message_id(double value);

  // @@protoc_insertion_point(class_scope:falcon_geo_msg.GSNAP)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_chan();
  inline void clear_has_chan();
  inline void set_has_start_sec();
  inline void clear_has_start_sec();
  inline void set_has_start_fsec();
  inline void clear_has_start_fsec();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_freq();
  inline void clear_has_freq();
  inline void set_has_sample_rate();
  inline void clear_has_sample_rate();
  inline void set_has_track_number();
  inline void clear_has_track_number();
  inline void set_has_soi();
  inline void clear_has_soi();
  inline void set_has_message_id();
  inline void clear_has_message_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  double start_sec_;
  ::google::protobuf::int32 chan_;
  ::google::protobuf::int32 duration_;
  double start_fsec_;
  float freq_;
  float sample_rate_;
  ::std::string* soi_;
  double message_id_;
  ::google::protobuf::int32 track_number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_FalconGeoMessages_2eproto();
  friend void protobuf_AssignDesc_FalconGeoMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconGeoMessages_2eproto();

  void InitAsDefaultInstance();
  static GSNAP* default_instance_;
};
// -------------------------------------------------------------------

class GeoProcessDone : public ::google::protobuf::Message {
 public:
  GeoProcessDone();
  virtual ~GeoProcessDone();

  GeoProcessDone(const GeoProcessDone& from);

  inline GeoProcessDone& operator=(const GeoProcessDone& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GeoProcessDone& default_instance();

  void Swap(GeoProcessDone* other);

  // implements Message ----------------------------------------------

  GeoProcessDone* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GeoProcessDone& from);
  void MergeFrom(const GeoProcessDone& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "GEO_PROCESS_DONE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 success = 3;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 3;
  inline ::google::protobuf::int32 success() const;
  inline void set_success(::google::protobuf::int32 value);

  // optional string filename = 4;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 4;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional double message_id = 5;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 5;
  inline double message_id() const;
  inline void set_message_id(double value);

  // @@protoc_insertion_point(class_scope:falcon_geo_msg.GeoProcessDone)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_message_id();
  inline void clear_has_message_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* filename_;
  double message_id_;
  ::google::protobuf::int32 success_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_FalconGeoMessages_2eproto();
  friend void protobuf_AssignDesc_FalconGeoMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconGeoMessages_2eproto();

  void InitAsDefaultInstance();
  static GeoProcessDone* default_instance_;
};
// -------------------------------------------------------------------

class GEO_EXIT : public ::google::protobuf::Message {
 public:
  GEO_EXIT();
  virtual ~GEO_EXIT();

  GEO_EXIT(const GEO_EXIT& from);

  inline GEO_EXIT& operator=(const GEO_EXIT& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GEO_EXIT& default_instance();

  void Swap(GEO_EXIT* other);

  // implements Message ----------------------------------------------

  GEO_EXIT* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GEO_EXIT& from);
  void MergeFrom(const GEO_EXIT& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "GEO_EXIT"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // @@protoc_insertion_point(class_scope:falcon_geo_msg.GEO_EXIT)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_FalconGeoMessages_2eproto();
  friend void protobuf_AssignDesc_FalconGeoMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconGeoMessages_2eproto();

  void InitAsDefaultInstance();
  static GEO_EXIT* default_instance_;
};
// -------------------------------------------------------------------

class GEO_RESET : public ::google::protobuf::Message {
 public:
  GEO_RESET();
  virtual ~GEO_RESET();

  GEO_RESET(const GEO_RESET& from);

  inline GEO_RESET& operator=(const GEO_RESET& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GEO_RESET& default_instance();

  void Swap(GEO_RESET* other);

  // implements Message ----------------------------------------------

  GEO_RESET* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GEO_RESET& from);
  void MergeFrom(const GEO_RESET& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "GEO_RESET"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // @@protoc_insertion_point(class_scope:falcon_geo_msg.GEO_RESET)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_FalconGeoMessages_2eproto();
  friend void protobuf_AssignDesc_FalconGeoMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconGeoMessages_2eproto();

  void InitAsDefaultInstance();
  static GEO_RESET* default_instance_;
};
// -------------------------------------------------------------------

class WifiTest : public ::google::protobuf::Message {
 public:
  WifiTest();
  virtual ~WifiTest();

  WifiTest(const WifiTest& from);

  inline WifiTest& operator=(const WifiTest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WifiTest& default_instance();

  void Swap(WifiTest* other);

  // implements Message ----------------------------------------------

  WifiTest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WifiTest& from);
  void MergeFrom(const WifiTest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "WIFI_TEST"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // @@protoc_insertion_point(class_scope:falcon_geo_msg.WifiTest)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_FalconGeoMessages_2eproto();
  friend void protobuf_AssignDesc_FalconGeoMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconGeoMessages_2eproto();

  void InitAsDefaultInstance();
  static WifiTest* default_instance_;
};
// ===================================================================


// ===================================================================

// CSNAP

// optional string msgName = 1 [default = "CSNAP"];
inline bool CSNAP::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSNAP::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSNAP::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSNAP::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& CSNAP::msgname() const {
  return *msgname_;
}
inline void CSNAP::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void CSNAP::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void CSNAP::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSNAP::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* CSNAP::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void CSNAP::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional double start_sec = 2;
inline bool CSNAP::has_start_sec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSNAP::set_has_start_sec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSNAP::clear_has_start_sec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSNAP::clear_start_sec() {
  start_sec_ = 0;
  clear_has_start_sec();
}
inline double CSNAP::start_sec() const {
  return start_sec_;
}
inline void CSNAP::set_start_sec(double value) {
  set_has_start_sec();
  start_sec_ = value;
}

// optional double start_fsec = 3;
inline bool CSNAP::has_start_fsec() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSNAP::set_has_start_fsec() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSNAP::clear_has_start_fsec() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSNAP::clear_start_fsec() {
  start_fsec_ = 0;
  clear_has_start_fsec();
}
inline double CSNAP::start_fsec() const {
  return start_fsec_;
}
inline void CSNAP::set_start_fsec(double value) {
  set_has_start_fsec();
  start_fsec_ = value;
}

// optional float cf = 4;
inline bool CSNAP::has_cf() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSNAP::set_has_cf() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSNAP::clear_has_cf() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSNAP::clear_cf() {
  cf_ = 0;
  clear_has_cf();
}
inline float CSNAP::cf() const {
  return cf_;
}
inline void CSNAP::set_cf(float value) {
  set_has_cf();
  cf_ = value;
}

// optional float duration = 5;
inline bool CSNAP::has_duration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSNAP::set_has_duration() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSNAP::clear_has_duration() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSNAP::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline float CSNAP::duration() const {
  return duration_;
}
inline void CSNAP::set_duration(float value) {
  set_has_duration();
  duration_ = value;
}

// optional int32 az = 6;
inline bool CSNAP::has_az() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSNAP::set_has_az() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSNAP::clear_has_az() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSNAP::clear_az() {
  az_ = 0;
  clear_has_az();
}
inline ::google::protobuf::int32 CSNAP::az() const {
  return az_;
}
inline void CSNAP::set_az(::google::protobuf::int32 value) {
  set_has_az();
  az_ = value;
}

// optional float lat = 7;
inline bool CSNAP::has_lat() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSNAP::set_has_lat() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSNAP::clear_has_lat() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSNAP::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline float CSNAP::lat() const {
  return lat_;
}
inline void CSNAP::set_lat(float value) {
  set_has_lat();
  lat_ = value;
}

// optional float lon = 8;
inline bool CSNAP::has_lon() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSNAP::set_has_lon() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSNAP::clear_has_lon() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSNAP::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline float CSNAP::lon() const {
  return lon_;
}
inline void CSNAP::set_lon(float value) {
  set_has_lon();
  lon_ = value;
}

// optional string soi = 9;
inline bool CSNAP::has_soi() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CSNAP::set_has_soi() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CSNAP::clear_has_soi() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CSNAP::clear_soi() {
  if (soi_ != &::google::protobuf::internal::kEmptyString) {
    soi_->clear();
  }
  clear_has_soi();
}
inline const ::std::string& CSNAP::soi() const {
  return *soi_;
}
inline void CSNAP::set_soi(const ::std::string& value) {
  set_has_soi();
  if (soi_ == &::google::protobuf::internal::kEmptyString) {
    soi_ = new ::std::string;
  }
  soi_->assign(value);
}
inline void CSNAP::set_soi(const char* value) {
  set_has_soi();
  if (soi_ == &::google::protobuf::internal::kEmptyString) {
    soi_ = new ::std::string;
  }
  soi_->assign(value);
}
inline void CSNAP::set_soi(const char* value, size_t size) {
  set_has_soi();
  if (soi_ == &::google::protobuf::internal::kEmptyString) {
    soi_ = new ::std::string;
  }
  soi_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSNAP::mutable_soi() {
  set_has_soi();
  if (soi_ == &::google::protobuf::internal::kEmptyString) {
    soi_ = new ::std::string;
  }
  return soi_;
}
inline ::std::string* CSNAP::release_soi() {
  clear_has_soi();
  if (soi_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = soi_;
    soi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSNAP::set_allocated_soi(::std::string* soi) {
  if (soi_ != &::google::protobuf::internal::kEmptyString) {
    delete soi_;
  }
  if (soi) {
    set_has_soi();
    soi_ = soi;
  } else {
    clear_has_soi();
    soi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string unit_id = 10;
inline bool CSNAP::has_unit_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CSNAP::set_has_unit_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CSNAP::clear_has_unit_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CSNAP::clear_unit_id() {
  if (unit_id_ != &::google::protobuf::internal::kEmptyString) {
    unit_id_->clear();
  }
  clear_has_unit_id();
}
inline const ::std::string& CSNAP::unit_id() const {
  return *unit_id_;
}
inline void CSNAP::set_unit_id(const ::std::string& value) {
  set_has_unit_id();
  if (unit_id_ == &::google::protobuf::internal::kEmptyString) {
    unit_id_ = new ::std::string;
  }
  unit_id_->assign(value);
}
inline void CSNAP::set_unit_id(const char* value) {
  set_has_unit_id();
  if (unit_id_ == &::google::protobuf::internal::kEmptyString) {
    unit_id_ = new ::std::string;
  }
  unit_id_->assign(value);
}
inline void CSNAP::set_unit_id(const char* value, size_t size) {
  set_has_unit_id();
  if (unit_id_ == &::google::protobuf::internal::kEmptyString) {
    unit_id_ = new ::std::string;
  }
  unit_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSNAP::mutable_unit_id() {
  set_has_unit_id();
  if (unit_id_ == &::google::protobuf::internal::kEmptyString) {
    unit_id_ = new ::std::string;
  }
  return unit_id_;
}
inline ::std::string* CSNAP::release_unit_id() {
  clear_has_unit_id();
  if (unit_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = unit_id_;
    unit_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSNAP::set_allocated_unit_id(::std::string* unit_id) {
  if (unit_id_ != &::google::protobuf::internal::kEmptyString) {
    delete unit_id_;
  }
  if (unit_id) {
    set_has_unit_id();
    unit_id_ = unit_id;
  } else {
    clear_has_unit_id();
    unit_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double message_id = 11;
inline bool CSNAP::has_message_id() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CSNAP::set_has_message_id() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CSNAP::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CSNAP::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline double CSNAP::message_id() const {
  return message_id_;
}
inline void CSNAP::set_message_id(double value) {
  set_has_message_id();
  message_id_ = value;
}

// -------------------------------------------------------------------

// GeoSnapResponse

// optional string msgName = 1 [default = "GEO_SNAP_RESPONSE"];
inline bool GeoSnapResponse::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GeoSnapResponse::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GeoSnapResponse::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GeoSnapResponse::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& GeoSnapResponse::msgname() const {
  return *msgname_;
}
inline void GeoSnapResponse::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GeoSnapResponse::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GeoSnapResponse::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoSnapResponse::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* GeoSnapResponse::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void GeoSnapResponse::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 ack = 2;
inline bool GeoSnapResponse::has_ack() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GeoSnapResponse::set_has_ack() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GeoSnapResponse::clear_has_ack() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GeoSnapResponse::clear_ack() {
  ack_ = 0;
  clear_has_ack();
}
inline ::google::protobuf::int32 GeoSnapResponse::ack() const {
  return ack_;
}
inline void GeoSnapResponse::set_ack(::google::protobuf::int32 value) {
  set_has_ack();
  ack_ = value;
}

// optional double message_id = 3;
inline bool GeoSnapResponse::has_message_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GeoSnapResponse::set_has_message_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GeoSnapResponse::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GeoSnapResponse::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline double GeoSnapResponse::message_id() const {
  return message_id_;
}
inline void GeoSnapResponse::set_message_id(double value) {
  set_has_message_id();
  message_id_ = value;
}

// -------------------------------------------------------------------

// GeoSnapDone

// optional string msgName = 1 [default = "GEO_SNAP_DONE"];
inline bool GeoSnapDone::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GeoSnapDone::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GeoSnapDone::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GeoSnapDone::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& GeoSnapDone::msgname() const {
  return *msgname_;
}
inline void GeoSnapDone::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GeoSnapDone::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GeoSnapDone::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoSnapDone::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* GeoSnapDone::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void GeoSnapDone::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional double start_sec = 2;
inline bool GeoSnapDone::has_start_sec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GeoSnapDone::set_has_start_sec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GeoSnapDone::clear_has_start_sec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GeoSnapDone::clear_start_sec() {
  start_sec_ = 0;
  clear_has_start_sec();
}
inline double GeoSnapDone::start_sec() const {
  return start_sec_;
}
inline void GeoSnapDone::set_start_sec(double value) {
  set_has_start_sec();
  start_sec_ = value;
}

// optional double start_fsec = 3;
inline bool GeoSnapDone::has_start_fsec() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GeoSnapDone::set_has_start_fsec() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GeoSnapDone::clear_has_start_fsec() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GeoSnapDone::clear_start_fsec() {
  start_fsec_ = 0;
  clear_has_start_fsec();
}
inline double GeoSnapDone::start_fsec() const {
  return start_fsec_;
}
inline void GeoSnapDone::set_start_fsec(double value) {
  set_has_start_fsec();
  start_fsec_ = value;
}

// optional float duration = 4;
inline bool GeoSnapDone::has_duration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GeoSnapDone::set_has_duration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GeoSnapDone::clear_has_duration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GeoSnapDone::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline float GeoSnapDone::duration() const {
  return duration_;
}
inline void GeoSnapDone::set_duration(float value) {
  set_has_duration();
  duration_ = value;
}

// optional int32 chan = 5;
inline bool GeoSnapDone::has_chan() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GeoSnapDone::set_has_chan() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GeoSnapDone::clear_has_chan() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GeoSnapDone::clear_chan() {
  chan_ = 0;
  clear_has_chan();
}
inline ::google::protobuf::int32 GeoSnapDone::chan() const {
  return chan_;
}
inline void GeoSnapDone::set_chan(::google::protobuf::int32 value) {
  set_has_chan();
  chan_ = value;
}

// optional float cf = 6;
inline bool GeoSnapDone::has_cf() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GeoSnapDone::set_has_cf() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GeoSnapDone::clear_has_cf() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GeoSnapDone::clear_cf() {
  cf_ = 0;
  clear_has_cf();
}
inline float GeoSnapDone::cf() const {
  return cf_;
}
inline void GeoSnapDone::set_cf(float value) {
  set_has_cf();
  cf_ = value;
}

// optional string soi = 7;
inline bool GeoSnapDone::has_soi() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GeoSnapDone::set_has_soi() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GeoSnapDone::clear_has_soi() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GeoSnapDone::clear_soi() {
  if (soi_ != &::google::protobuf::internal::kEmptyString) {
    soi_->clear();
  }
  clear_has_soi();
}
inline const ::std::string& GeoSnapDone::soi() const {
  return *soi_;
}
inline void GeoSnapDone::set_soi(const ::std::string& value) {
  set_has_soi();
  if (soi_ == &::google::protobuf::internal::kEmptyString) {
    soi_ = new ::std::string;
  }
  soi_->assign(value);
}
inline void GeoSnapDone::set_soi(const char* value) {
  set_has_soi();
  if (soi_ == &::google::protobuf::internal::kEmptyString) {
    soi_ = new ::std::string;
  }
  soi_->assign(value);
}
inline void GeoSnapDone::set_soi(const char* value, size_t size) {
  set_has_soi();
  if (soi_ == &::google::protobuf::internal::kEmptyString) {
    soi_ = new ::std::string;
  }
  soi_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoSnapDone::mutable_soi() {
  set_has_soi();
  if (soi_ == &::google::protobuf::internal::kEmptyString) {
    soi_ = new ::std::string;
  }
  return soi_;
}
inline ::std::string* GeoSnapDone::release_soi() {
  clear_has_soi();
  if (soi_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = soi_;
    soi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeoSnapDone::set_allocated_soi(::std::string* soi) {
  if (soi_ != &::google::protobuf::internal::kEmptyString) {
    delete soi_;
  }
  if (soi) {
    set_has_soi();
    soi_ = soi;
  } else {
    clear_has_soi();
    soi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string unit_id = 8;
inline bool GeoSnapDone::has_unit_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GeoSnapDone::set_has_unit_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GeoSnapDone::clear_has_unit_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GeoSnapDone::clear_unit_id() {
  if (unit_id_ != &::google::protobuf::internal::kEmptyString) {
    unit_id_->clear();
  }
  clear_has_unit_id();
}
inline const ::std::string& GeoSnapDone::unit_id() const {
  return *unit_id_;
}
inline void GeoSnapDone::set_unit_id(const ::std::string& value) {
  set_has_unit_id();
  if (unit_id_ == &::google::protobuf::internal::kEmptyString) {
    unit_id_ = new ::std::string;
  }
  unit_id_->assign(value);
}
inline void GeoSnapDone::set_unit_id(const char* value) {
  set_has_unit_id();
  if (unit_id_ == &::google::protobuf::internal::kEmptyString) {
    unit_id_ = new ::std::string;
  }
  unit_id_->assign(value);
}
inline void GeoSnapDone::set_unit_id(const char* value, size_t size) {
  set_has_unit_id();
  if (unit_id_ == &::google::protobuf::internal::kEmptyString) {
    unit_id_ = new ::std::string;
  }
  unit_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoSnapDone::mutable_unit_id() {
  set_has_unit_id();
  if (unit_id_ == &::google::protobuf::internal::kEmptyString) {
    unit_id_ = new ::std::string;
  }
  return unit_id_;
}
inline ::std::string* GeoSnapDone::release_unit_id() {
  clear_has_unit_id();
  if (unit_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = unit_id_;
    unit_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeoSnapDone::set_allocated_unit_id(::std::string* unit_id) {
  if (unit_id_ != &::google::protobuf::internal::kEmptyString) {
    delete unit_id_;
  }
  if (unit_id) {
    set_has_unit_id();
    unit_id_ = unit_id;
  } else {
    clear_has_unit_id();
    unit_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string filename = 9;
inline bool GeoSnapDone::has_filename() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GeoSnapDone::set_has_filename() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GeoSnapDone::clear_has_filename() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GeoSnapDone::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& GeoSnapDone::filename() const {
  return *filename_;
}
inline void GeoSnapDone::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void GeoSnapDone::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void GeoSnapDone::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoSnapDone::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* GeoSnapDone::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeoSnapDone::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string meta_filename = 10;
inline bool GeoSnapDone::has_meta_filename() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GeoSnapDone::set_has_meta_filename() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GeoSnapDone::clear_has_meta_filename() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GeoSnapDone::clear_meta_filename() {
  if (meta_filename_ != &::google::protobuf::internal::kEmptyString) {
    meta_filename_->clear();
  }
  clear_has_meta_filename();
}
inline const ::std::string& GeoSnapDone::meta_filename() const {
  return *meta_filename_;
}
inline void GeoSnapDone::set_meta_filename(const ::std::string& value) {
  set_has_meta_filename();
  if (meta_filename_ == &::google::protobuf::internal::kEmptyString) {
    meta_filename_ = new ::std::string;
  }
  meta_filename_->assign(value);
}
inline void GeoSnapDone::set_meta_filename(const char* value) {
  set_has_meta_filename();
  if (meta_filename_ == &::google::protobuf::internal::kEmptyString) {
    meta_filename_ = new ::std::string;
  }
  meta_filename_->assign(value);
}
inline void GeoSnapDone::set_meta_filename(const char* value, size_t size) {
  set_has_meta_filename();
  if (meta_filename_ == &::google::protobuf::internal::kEmptyString) {
    meta_filename_ = new ::std::string;
  }
  meta_filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoSnapDone::mutable_meta_filename() {
  set_has_meta_filename();
  if (meta_filename_ == &::google::protobuf::internal::kEmptyString) {
    meta_filename_ = new ::std::string;
  }
  return meta_filename_;
}
inline ::std::string* GeoSnapDone::release_meta_filename() {
  clear_has_meta_filename();
  if (meta_filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = meta_filename_;
    meta_filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeoSnapDone::set_allocated_meta_filename(::std::string* meta_filename) {
  if (meta_filename_ != &::google::protobuf::internal::kEmptyString) {
    delete meta_filename_;
  }
  if (meta_filename) {
    set_has_meta_filename();
    meta_filename_ = meta_filename;
  } else {
    clear_has_meta_filename();
    meta_filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double message_id = 11;
inline bool GeoSnapDone::has_message_id() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GeoSnapDone::set_has_message_id() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GeoSnapDone::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GeoSnapDone::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline double GeoSnapDone::message_id() const {
  return message_id_;
}
inline void GeoSnapDone::set_message_id(double value) {
  set_has_message_id();
  message_id_ = value;
}

// -------------------------------------------------------------------

// CSNAPQ

// optional string msgName = 1 [default = "CSNAPQ"];
inline bool CSNAPQ::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSNAPQ::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSNAPQ::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSNAPQ::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& CSNAPQ::msgname() const {
  return *msgname_;
}
inline void CSNAPQ::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void CSNAPQ::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void CSNAPQ::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSNAPQ::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* CSNAPQ::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void CSNAPQ::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 chan = 2;
inline bool CSNAPQ::has_chan() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSNAPQ::set_has_chan() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSNAPQ::clear_has_chan() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSNAPQ::clear_chan() {
  chan_ = 0;
  clear_has_chan();
}
inline ::google::protobuf::int32 CSNAPQ::chan() const {
  return chan_;
}
inline void CSNAPQ::set_chan(::google::protobuf::int32 value) {
  set_has_chan();
  chan_ = value;
}

// optional double message_id = 3;
inline bool CSNAPQ::has_message_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSNAPQ::set_has_message_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSNAPQ::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSNAPQ::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline double CSNAPQ::message_id() const {
  return message_id_;
}
inline void CSNAPQ::set_message_id(double value) {
  set_has_message_id();
  message_id_ = value;
}

// -------------------------------------------------------------------

// GeoSnapQuitResponse

// optional string msgName = 1 [default = "GEO_SNAP_QUIT_RESPONSE"];
inline bool GeoSnapQuitResponse::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GeoSnapQuitResponse::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GeoSnapQuitResponse::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GeoSnapQuitResponse::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& GeoSnapQuitResponse::msgname() const {
  return *msgname_;
}
inline void GeoSnapQuitResponse::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GeoSnapQuitResponse::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GeoSnapQuitResponse::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoSnapQuitResponse::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* GeoSnapQuitResponse::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void GeoSnapQuitResponse::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 ack = 2;
inline bool GeoSnapQuitResponse::has_ack() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GeoSnapQuitResponse::set_has_ack() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GeoSnapQuitResponse::clear_has_ack() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GeoSnapQuitResponse::clear_ack() {
  ack_ = 0;
  clear_has_ack();
}
inline ::google::protobuf::int32 GeoSnapQuitResponse::ack() const {
  return ack_;
}
inline void GeoSnapQuitResponse::set_ack(::google::protobuf::int32 value) {
  set_has_ack();
  ack_ = value;
}

// optional int32 chan = 3;
inline bool GeoSnapQuitResponse::has_chan() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GeoSnapQuitResponse::set_has_chan() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GeoSnapQuitResponse::clear_has_chan() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GeoSnapQuitResponse::clear_chan() {
  chan_ = 0;
  clear_has_chan();
}
inline ::google::protobuf::int32 GeoSnapQuitResponse::chan() const {
  return chan_;
}
inline void GeoSnapQuitResponse::set_chan(::google::protobuf::int32 value) {
  set_has_chan();
  chan_ = value;
}

// optional double message_id = 4;
inline bool GeoSnapQuitResponse::has_message_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GeoSnapQuitResponse::set_has_message_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GeoSnapQuitResponse::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GeoSnapQuitResponse::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline double GeoSnapQuitResponse::message_id() const {
  return message_id_;
}
inline void GeoSnapQuitResponse::set_message_id(double value) {
  set_has_message_id();
  message_id_ = value;
}

// -------------------------------------------------------------------

// GeoBurstDone

// optional string msgName = 1 [default = "GEO_BURST_DONE"];
inline bool GeoBurstDone::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GeoBurstDone::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GeoBurstDone::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GeoBurstDone::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& GeoBurstDone::msgname() const {
  return *msgname_;
}
inline void GeoBurstDone::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GeoBurstDone::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GeoBurstDone::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoBurstDone::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* GeoBurstDone::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void GeoBurstDone::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string meta_filename = 2;
inline bool GeoBurstDone::has_meta_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GeoBurstDone::set_has_meta_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GeoBurstDone::clear_has_meta_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GeoBurstDone::clear_meta_filename() {
  if (meta_filename_ != &::google::protobuf::internal::kEmptyString) {
    meta_filename_->clear();
  }
  clear_has_meta_filename();
}
inline const ::std::string& GeoBurstDone::meta_filename() const {
  return *meta_filename_;
}
inline void GeoBurstDone::set_meta_filename(const ::std::string& value) {
  set_has_meta_filename();
  if (meta_filename_ == &::google::protobuf::internal::kEmptyString) {
    meta_filename_ = new ::std::string;
  }
  meta_filename_->assign(value);
}
inline void GeoBurstDone::set_meta_filename(const char* value) {
  set_has_meta_filename();
  if (meta_filename_ == &::google::protobuf::internal::kEmptyString) {
    meta_filename_ = new ::std::string;
  }
  meta_filename_->assign(value);
}
inline void GeoBurstDone::set_meta_filename(const char* value, size_t size) {
  set_has_meta_filename();
  if (meta_filename_ == &::google::protobuf::internal::kEmptyString) {
    meta_filename_ = new ::std::string;
  }
  meta_filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoBurstDone::mutable_meta_filename() {
  set_has_meta_filename();
  if (meta_filename_ == &::google::protobuf::internal::kEmptyString) {
    meta_filename_ = new ::std::string;
  }
  return meta_filename_;
}
inline ::std::string* GeoBurstDone::release_meta_filename() {
  clear_has_meta_filename();
  if (meta_filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = meta_filename_;
    meta_filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeoBurstDone::set_allocated_meta_filename(::std::string* meta_filename) {
  if (meta_filename_ != &::google::protobuf::internal::kEmptyString) {
    delete meta_filename_;
  }
  if (meta_filename) {
    set_has_meta_filename();
    meta_filename_ = meta_filename;
  } else {
    clear_has_meta_filename();
    meta_filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 message_id = 3;
inline bool GeoBurstDone::has_message_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GeoBurstDone::set_has_message_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GeoBurstDone::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GeoBurstDone::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 GeoBurstDone::message_id() const {
  return message_id_;
}
inline void GeoBurstDone::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// optional string chan = 4;
inline bool GeoBurstDone::has_chan() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GeoBurstDone::set_has_chan() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GeoBurstDone::clear_has_chan() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GeoBurstDone::clear_chan() {
  if (chan_ != &::google::protobuf::internal::kEmptyString) {
    chan_->clear();
  }
  clear_has_chan();
}
inline const ::std::string& GeoBurstDone::chan() const {
  return *chan_;
}
inline void GeoBurstDone::set_chan(const ::std::string& value) {
  set_has_chan();
  if (chan_ == &::google::protobuf::internal::kEmptyString) {
    chan_ = new ::std::string;
  }
  chan_->assign(value);
}
inline void GeoBurstDone::set_chan(const char* value) {
  set_has_chan();
  if (chan_ == &::google::protobuf::internal::kEmptyString) {
    chan_ = new ::std::string;
  }
  chan_->assign(value);
}
inline void GeoBurstDone::set_chan(const char* value, size_t size) {
  set_has_chan();
  if (chan_ == &::google::protobuf::internal::kEmptyString) {
    chan_ = new ::std::string;
  }
  chan_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoBurstDone::mutable_chan() {
  set_has_chan();
  if (chan_ == &::google::protobuf::internal::kEmptyString) {
    chan_ = new ::std::string;
  }
  return chan_;
}
inline ::std::string* GeoBurstDone::release_chan() {
  clear_has_chan();
  if (chan_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chan_;
    chan_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeoBurstDone::set_allocated_chan(::std::string* chan) {
  if (chan_ != &::google::protobuf::internal::kEmptyString) {
    delete chan_;
  }
  if (chan) {
    set_has_chan();
    chan_ = chan;
  } else {
    clear_has_chan();
    chan_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GSNAP

// optional string msgName = 1 [default = "GSNAP"];
inline bool GSNAP::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GSNAP::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GSNAP::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GSNAP::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& GSNAP::msgname() const {
  return *msgname_;
}
inline void GSNAP::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GSNAP::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GSNAP::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GSNAP::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* GSNAP::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void GSNAP::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 chan = 3;
inline bool GSNAP::has_chan() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GSNAP::set_has_chan() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GSNAP::clear_has_chan() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GSNAP::clear_chan() {
  chan_ = 0;
  clear_has_chan();
}
inline ::google::protobuf::int32 GSNAP::chan() const {
  return chan_;
}
inline void GSNAP::set_chan(::google::protobuf::int32 value) {
  set_has_chan();
  chan_ = value;
}

// optional double start_sec = 4;
inline bool GSNAP::has_start_sec() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GSNAP::set_has_start_sec() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GSNAP::clear_has_start_sec() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GSNAP::clear_start_sec() {
  start_sec_ = 0;
  clear_has_start_sec();
}
inline double GSNAP::start_sec() const {
  return start_sec_;
}
inline void GSNAP::set_start_sec(double value) {
  set_has_start_sec();
  start_sec_ = value;
}

// optional double start_fsec = 5;
inline bool GSNAP::has_start_fsec() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GSNAP::set_has_start_fsec() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GSNAP::clear_has_start_fsec() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GSNAP::clear_start_fsec() {
  start_fsec_ = 0;
  clear_has_start_fsec();
}
inline double GSNAP::start_fsec() const {
  return start_fsec_;
}
inline void GSNAP::set_start_fsec(double value) {
  set_has_start_fsec();
  start_fsec_ = value;
}

// optional int32 duration = 6;
inline bool GSNAP::has_duration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GSNAP::set_has_duration() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GSNAP::clear_has_duration() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GSNAP::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline ::google::protobuf::int32 GSNAP::duration() const {
  return duration_;
}
inline void GSNAP::set_duration(::google::protobuf::int32 value) {
  set_has_duration();
  duration_ = value;
}

// optional float freq = 7;
inline bool GSNAP::has_freq() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GSNAP::set_has_freq() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GSNAP::clear_has_freq() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GSNAP::clear_freq() {
  freq_ = 0;
  clear_has_freq();
}
inline float GSNAP::freq() const {
  return freq_;
}
inline void GSNAP::set_freq(float value) {
  set_has_freq();
  freq_ = value;
}

// optional float sample_rate = 8;
inline bool GSNAP::has_sample_rate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GSNAP::set_has_sample_rate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GSNAP::clear_has_sample_rate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GSNAP::clear_sample_rate() {
  sample_rate_ = 0;
  clear_has_sample_rate();
}
inline float GSNAP::sample_rate() const {
  return sample_rate_;
}
inline void GSNAP::set_sample_rate(float value) {
  set_has_sample_rate();
  sample_rate_ = value;
}

// optional int32 track_number = 9;
inline bool GSNAP::has_track_number() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GSNAP::set_has_track_number() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GSNAP::clear_has_track_number() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GSNAP::clear_track_number() {
  track_number_ = 0;
  clear_has_track_number();
}
inline ::google::protobuf::int32 GSNAP::track_number() const {
  return track_number_;
}
inline void GSNAP::set_track_number(::google::protobuf::int32 value) {
  set_has_track_number();
  track_number_ = value;
}

// optional string soi = 10;
inline bool GSNAP::has_soi() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GSNAP::set_has_soi() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GSNAP::clear_has_soi() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GSNAP::clear_soi() {
  if (soi_ != &::google::protobuf::internal::kEmptyString) {
    soi_->clear();
  }
  clear_has_soi();
}
inline const ::std::string& GSNAP::soi() const {
  return *soi_;
}
inline void GSNAP::set_soi(const ::std::string& value) {
  set_has_soi();
  if (soi_ == &::google::protobuf::internal::kEmptyString) {
    soi_ = new ::std::string;
  }
  soi_->assign(value);
}
inline void GSNAP::set_soi(const char* value) {
  set_has_soi();
  if (soi_ == &::google::protobuf::internal::kEmptyString) {
    soi_ = new ::std::string;
  }
  soi_->assign(value);
}
inline void GSNAP::set_soi(const char* value, size_t size) {
  set_has_soi();
  if (soi_ == &::google::protobuf::internal::kEmptyString) {
    soi_ = new ::std::string;
  }
  soi_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GSNAP::mutable_soi() {
  set_has_soi();
  if (soi_ == &::google::protobuf::internal::kEmptyString) {
    soi_ = new ::std::string;
  }
  return soi_;
}
inline ::std::string* GSNAP::release_soi() {
  clear_has_soi();
  if (soi_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = soi_;
    soi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GSNAP::set_allocated_soi(::std::string* soi) {
  if (soi_ != &::google::protobuf::internal::kEmptyString) {
    delete soi_;
  }
  if (soi) {
    set_has_soi();
    soi_ = soi;
  } else {
    clear_has_soi();
    soi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double message_id = 11;
inline bool GSNAP::has_message_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GSNAP::set_has_message_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GSNAP::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GSNAP::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline double GSNAP::message_id() const {
  return message_id_;
}
inline void GSNAP::set_message_id(double value) {
  set_has_message_id();
  message_id_ = value;
}

// -------------------------------------------------------------------

// GeoProcessDone

// optional string msgName = 1 [default = "GEO_PROCESS_DONE"];
inline bool GeoProcessDone::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GeoProcessDone::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GeoProcessDone::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GeoProcessDone::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& GeoProcessDone::msgname() const {
  return *msgname_;
}
inline void GeoProcessDone::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GeoProcessDone::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GeoProcessDone::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoProcessDone::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* GeoProcessDone::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void GeoProcessDone::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 success = 3;
inline bool GeoProcessDone::has_success() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GeoProcessDone::set_has_success() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GeoProcessDone::clear_has_success() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GeoProcessDone::clear_success() {
  success_ = 0;
  clear_has_success();
}
inline ::google::protobuf::int32 GeoProcessDone::success() const {
  return success_;
}
inline void GeoProcessDone::set_success(::google::protobuf::int32 value) {
  set_has_success();
  success_ = value;
}

// optional string filename = 4;
inline bool GeoProcessDone::has_filename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GeoProcessDone::set_has_filename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GeoProcessDone::clear_has_filename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GeoProcessDone::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& GeoProcessDone::filename() const {
  return *filename_;
}
inline void GeoProcessDone::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void GeoProcessDone::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void GeoProcessDone::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoProcessDone::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* GeoProcessDone::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeoProcessDone::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double message_id = 5;
inline bool GeoProcessDone::has_message_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GeoProcessDone::set_has_message_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GeoProcessDone::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GeoProcessDone::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline double GeoProcessDone::message_id() const {
  return message_id_;
}
inline void GeoProcessDone::set_message_id(double value) {
  set_has_message_id();
  message_id_ = value;
}

// -------------------------------------------------------------------

// GEO_EXIT

// optional string msgName = 1 [default = "GEO_EXIT"];
inline bool GEO_EXIT::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GEO_EXIT::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GEO_EXIT::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GEO_EXIT::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& GEO_EXIT::msgname() const {
  return *msgname_;
}
inline void GEO_EXIT::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GEO_EXIT::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GEO_EXIT::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GEO_EXIT::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* GEO_EXIT::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void GEO_EXIT::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// -------------------------------------------------------------------

// GEO_RESET

// optional string msgName = 1 [default = "GEO_RESET"];
inline bool GEO_RESET::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GEO_RESET::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GEO_RESET::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GEO_RESET::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& GEO_RESET::msgname() const {
  return *msgname_;
}
inline void GEO_RESET::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GEO_RESET::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GEO_RESET::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GEO_RESET::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* GEO_RESET::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void GEO_RESET::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// -------------------------------------------------------------------

// WifiTest

// optional string msgName = 1 [default = "WIFI_TEST"];
inline bool WifiTest::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WifiTest::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WifiTest::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WifiTest::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& WifiTest::msgname() const {
  return *msgname_;
}
inline void WifiTest::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void WifiTest::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void WifiTest::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WifiTest::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* WifiTest::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void WifiTest::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace falcon_geo_msg

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_FalconGeoMessages_2eproto__INCLUDED
