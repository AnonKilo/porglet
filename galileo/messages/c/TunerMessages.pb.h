// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TunerMessages.proto

#ifndef PROTOBUF_TunerMessages_2eproto__INCLUDED
#define PROTOBUF_TunerMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace tuner_msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_TunerMessages_2eproto();
void protobuf_AssignDesc_TunerMessages_2eproto();
void protobuf_ShutdownFile_TunerMessages_2eproto();

class AdjustScan;
class ManArch;
class TArch;
class IQHeaderInfo;
class IQMetaData;
class SnapInfo;
class ChangeTuneRange;
class TuneRange;
class ReceiverStatus;
class QueryReceiverStatus;
class TimingCheck;
class DwellScan;
class TxTune;
class ReactiveJam;
class diskSnapAvailable;
class SnapBroadcast;
class ReceiverRequest;
class ReceiverRelease;
class ReceiverAcquired;
class ReceiverReleased;
class ChangeRXTxConfig;

enum ReceiverStatus_Status {
  ReceiverStatus_Status_SCANNING = 1,
  ReceiverStatus_Status_DWELLING = 2,
  ReceiverStatus_Status_OFF = 3
};
bool ReceiverStatus_Status_IsValid(int value);
const ReceiverStatus_Status ReceiverStatus_Status_Status_MIN = ReceiverStatus_Status_SCANNING;
const ReceiverStatus_Status ReceiverStatus_Status_Status_MAX = ReceiverStatus_Status_OFF;
const int ReceiverStatus_Status_Status_ARRAYSIZE = ReceiverStatus_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReceiverStatus_Status_descriptor();
inline const ::std::string& ReceiverStatus_Status_Name(ReceiverStatus_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReceiverStatus_Status_descriptor(), value);
}
inline bool ReceiverStatus_Status_Parse(
    const ::std::string& name, ReceiverStatus_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReceiverStatus_Status>(
    ReceiverStatus_Status_descriptor(), name, value);
}
enum DwellScan_State {
  DwellScan_State_START = 0,
  DwellScan_State_DWELL = 1,
  DwellScan_State_STOP = 2
};
bool DwellScan_State_IsValid(int value);
const DwellScan_State DwellScan_State_State_MIN = DwellScan_State_START;
const DwellScan_State DwellScan_State_State_MAX = DwellScan_State_STOP;
const int DwellScan_State_State_ARRAYSIZE = DwellScan_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* DwellScan_State_descriptor();
inline const ::std::string& DwellScan_State_Name(DwellScan_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    DwellScan_State_descriptor(), value);
}
inline bool DwellScan_State_Parse(
    const ::std::string& name, DwellScan_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DwellScan_State>(
    DwellScan_State_descriptor(), name, value);
}
enum DwellScan_GainMode {
  DwellScan_GainMode_AGC = 0,
  DwellScan_GainMode_MANUAL = 1
};
bool DwellScan_GainMode_IsValid(int value);
const DwellScan_GainMode DwellScan_GainMode_GainMode_MIN = DwellScan_GainMode_AGC;
const DwellScan_GainMode DwellScan_GainMode_GainMode_MAX = DwellScan_GainMode_MANUAL;
const int DwellScan_GainMode_GainMode_ARRAYSIZE = DwellScan_GainMode_GainMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* DwellScan_GainMode_descriptor();
inline const ::std::string& DwellScan_GainMode_Name(DwellScan_GainMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    DwellScan_GainMode_descriptor(), value);
}
inline bool DwellScan_GainMode_Parse(
    const ::std::string& name, DwellScan_GainMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DwellScan_GainMode>(
    DwellScan_GainMode_descriptor(), name, value);
}
enum SnapBroadcast_State {
  SnapBroadcast_State_START = 0,
  SnapBroadcast_State_STOP = 1
};
bool SnapBroadcast_State_IsValid(int value);
const SnapBroadcast_State SnapBroadcast_State_State_MIN = SnapBroadcast_State_START;
const SnapBroadcast_State SnapBroadcast_State_State_MAX = SnapBroadcast_State_STOP;
const int SnapBroadcast_State_State_ARRAYSIZE = SnapBroadcast_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* SnapBroadcast_State_descriptor();
inline const ::std::string& SnapBroadcast_State_Name(SnapBroadcast_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    SnapBroadcast_State_descriptor(), value);
}
inline bool SnapBroadcast_State_Parse(
    const ::std::string& name, SnapBroadcast_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SnapBroadcast_State>(
    SnapBroadcast_State_descriptor(), name, value);
}
// ===================================================================

class AdjustScan : public ::google::protobuf::Message {
 public:
  AdjustScan();
  virtual ~AdjustScan();

  AdjustScan(const AdjustScan& from);

  inline AdjustScan& operator=(const AdjustScan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdjustScan& default_instance();

  void Swap(AdjustScan* other);

  // implements Message ----------------------------------------------

  AdjustScan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdjustScan& from);
  void MergeFrom(const AdjustScan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ADJUSTSCAN"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional double dwtime = 2;
  inline bool has_dwtime() const;
  inline void clear_dwtime();
  static const int kDwtimeFieldNumber = 2;
  inline double dwtime() const;
  inline void set_dwtime(double value);

  // optional int32 ftupdate = 3;
  inline bool has_ftupdate() const;
  inline void clear_ftupdate();
  static const int kFtupdateFieldNumber = 3;
  inline ::google::protobuf::int32 ftupdate() const;
  inline void set_ftupdate(::google::protobuf::int32 value);

  // optional int32 mode = 4;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 4;
  inline ::google::protobuf::int32 mode() const;
  inline void set_mode(::google::protobuf::int32 value);

  // optional int32 revid = 5;
  inline bool has_revid() const;
  inline void clear_revid();
  static const int kRevidFieldNumber = 5;
  inline ::google::protobuf::int32 revid() const;
  inline void set_revid(::google::protobuf::int32 value);

  // optional string feed = 6;
  inline bool has_feed() const;
  inline void clear_feed();
  static const int kFeedFieldNumber = 6;
  inline const ::std::string& feed() const;
  inline void set_feed(const ::std::string& value);
  inline void set_feed(const char* value);
  inline void set_feed(const char* value, size_t size);
  inline ::std::string* mutable_feed();
  inline ::std::string* release_feed();
  inline void set_allocated_feed(::std::string* feed);

  // optional double az = 7;
  inline bool has_az() const;
  inline void clear_az();
  static const int kAzFieldNumber = 7;
  inline double az() const;
  inline void set_az(double value);

  // optional double foffset = 8;
  inline bool has_foffset() const;
  inline void clear_foffset();
  static const int kFoffsetFieldNumber = 8;
  inline double foffset() const;
  inline void set_foffset(double value);

  // optional int32 snapreset = 9;
  inline bool has_snapreset() const;
  inline void clear_snapreset();
  static const int kSnapresetFieldNumber = 9;
  inline ::google::protobuf::int32 snapreset() const;
  inline void set_snapreset(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tuner_msg.AdjustScan)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_dwtime();
  inline void clear_has_dwtime();
  inline void set_has_ftupdate();
  inline void clear_has_ftupdate();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_revid();
  inline void clear_has_revid();
  inline void set_has_feed();
  inline void clear_has_feed();
  inline void set_has_az();
  inline void clear_has_az();
  inline void set_has_foffset();
  inline void clear_has_foffset();
  inline void set_has_snapreset();
  inline void clear_has_snapreset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  double dwtime_;
  ::google::protobuf::int32 ftupdate_;
  ::google::protobuf::int32 mode_;
  ::std::string* feed_;
  double az_;
  ::google::protobuf::int32 revid_;
  ::google::protobuf::int32 snapreset_;
  double foffset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_TunerMessages_2eproto();
  friend void protobuf_AssignDesc_TunerMessages_2eproto();
  friend void protobuf_ShutdownFile_TunerMessages_2eproto();

  void InitAsDefaultInstance();
  static AdjustScan* default_instance_;
};
// -------------------------------------------------------------------

class ManArch : public ::google::protobuf::Message {
 public:
  ManArch();
  virtual ~ManArch();

  ManArch(const ManArch& from);

  inline ManArch& operator=(const ManArch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ManArch& default_instance();

  void Swap(ManArch* other);

  // implements Message ----------------------------------------------

  ManArch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ManArch& from);
  void MergeFrom(const ManArch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "MANARCH"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional double freq = 2;
  inline bool has_freq() const;
  inline void clear_freq();
  static const int kFreqFieldNumber = 2;
  inline double freq() const;
  inline void set_freq(double value);

  // optional double duration = 3;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 3;
  inline double duration() const;
  inline void set_duration(double value);

  // optional string filename = 4;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 4;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // @@protoc_insertion_point(class_scope:tuner_msg.ManArch)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_freq();
  inline void clear_has_freq();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_filename();
  inline void clear_has_filename();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  double freq_;
  double duration_;
  ::std::string* filename_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TunerMessages_2eproto();
  friend void protobuf_AssignDesc_TunerMessages_2eproto();
  friend void protobuf_ShutdownFile_TunerMessages_2eproto();

  void InitAsDefaultInstance();
  static ManArch* default_instance_;
};
// -------------------------------------------------------------------

class TArch : public ::google::protobuf::Message {
 public:
  TArch();
  virtual ~TArch();

  TArch(const TArch& from);

  inline TArch& operator=(const TArch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TArch& default_instance();

  void Swap(TArch* other);

  // implements Message ----------------------------------------------

  TArch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TArch& from);
  void MergeFrom(const TArch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "TARCH"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional double duration = 2;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 2;
  inline double duration() const;
  inline void set_duration(double value);

  // optional double frequency = 3;
  inline bool has_frequency() const;
  inline void clear_frequency();
  static const int kFrequencyFieldNumber = 3;
  inline double frequency() const;
  inline void set_frequency(double value);

  // optional double start = 4;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 4;
  inline double start() const;
  inline void set_start(double value);

  // optional double startf = 5;
  inline bool has_startf() const;
  inline void clear_startf();
  static const int kStartfFieldNumber = 5;
  inline double startf() const;
  inline void set_startf(double value);

  // optional double tasknum = 6;
  inline bool has_tasknum() const;
  inline void clear_tasknum();
  static const int kTasknumFieldNumber = 6;
  inline double tasknum() const;
  inline void set_tasknum(double value);

  // optional int32 revid = 7;
  inline bool has_revid() const;
  inline void clear_revid();
  static const int kRevidFieldNumber = 7;
  inline ::google::protobuf::int32 revid() const;
  inline void set_revid(::google::protobuf::int32 value);

  // optional double foffset = 8;
  inline bool has_foffset() const;
  inline void clear_foffset();
  static const int kFoffsetFieldNumber = 8;
  inline double foffset() const;
  inline void set_foffset(double value);

  // @@protoc_insertion_point(class_scope:tuner_msg.TArch)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_frequency();
  inline void clear_has_frequency();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_startf();
  inline void clear_has_startf();
  inline void set_has_tasknum();
  inline void clear_has_tasknum();
  inline void set_has_revid();
  inline void clear_has_revid();
  inline void set_has_foffset();
  inline void clear_has_foffset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  double duration_;
  double frequency_;
  double start_;
  double startf_;
  double tasknum_;
  double foffset_;
  ::google::protobuf::int32 revid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_TunerMessages_2eproto();
  friend void protobuf_AssignDesc_TunerMessages_2eproto();
  friend void protobuf_ShutdownFile_TunerMessages_2eproto();

  void InitAsDefaultInstance();
  static TArch* default_instance_;
};
// -------------------------------------------------------------------

class IQHeaderInfo : public ::google::protobuf::Message {
 public:
  IQHeaderInfo();
  virtual ~IQHeaderInfo();

  IQHeaderInfo(const IQHeaderInfo& from);

  inline IQHeaderInfo& operator=(const IQHeaderInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IQHeaderInfo& default_instance();

  void Swap(IQHeaderInfo* other);

  // implements Message ----------------------------------------------

  IQHeaderInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IQHeaderInfo& from);
  void MergeFrom(const IQHeaderInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "IQHEADERINFO"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional double freqRF = 2;
  inline bool has_freqrf() const;
  inline void clear_freqrf();
  static const int kFreqRFFieldNumber = 2;
  inline double freqrf() const;
  inline void set_freqrf(double value);

  // optional string snapid = 3;
  inline bool has_snapid() const;
  inline void clear_snapid();
  static const int kSnapidFieldNumber = 3;
  inline const ::std::string& snapid() const;
  inline void set_snapid(const ::std::string& value);
  inline void set_snapid(const char* value);
  inline void set_snapid(const char* value, size_t size);
  inline ::std::string* mutable_snapid();
  inline ::std::string* release_snapid();
  inline void set_allocated_snapid(::std::string* snapid);

  // optional int32 revid = 4;
  inline bool has_revid() const;
  inline void clear_revid();
  static const int kRevidFieldNumber = 4;
  inline ::google::protobuf::int32 revid() const;
  inline void set_revid(::google::protobuf::int32 value);

  // optional int32 tasknum = 5;
  inline bool has_tasknum() const;
  inline void clear_tasknum();
  static const int kTasknumFieldNumber = 5;
  inline ::google::protobuf::int32 tasknum() const;
  inline void set_tasknum(::google::protobuf::int32 value);

  // optional int32 channel = 6;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 6;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional string filename = 7;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 7;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional string feedid = 8;
  inline bool has_feedid() const;
  inline void clear_feedid();
  static const int kFeedidFieldNumber = 8;
  inline const ::std::string& feedid() const;
  inline void set_feedid(const ::std::string& value);
  inline void set_feedid(const char* value);
  inline void set_feedid(const char* value, size_t size);
  inline ::std::string* mutable_feedid();
  inline ::std::string* release_feedid();
  inline void set_allocated_feedid(::std::string* feedid);

  // optional string rcvrid = 9;
  inline bool has_rcvrid() const;
  inline void clear_rcvrid();
  static const int kRcvridFieldNumber = 9;
  inline const ::std::string& rcvrid() const;
  inline void set_rcvrid(const ::std::string& value);
  inline void set_rcvrid(const char* value);
  inline void set_rcvrid(const char* value, size_t size);
  inline ::std::string* mutable_rcvrid();
  inline ::std::string* release_rcvrid();
  inline void set_allocated_rcvrid(::std::string* rcvrid);

  // optional double sample_rate = 10;
  inline bool has_sample_rate() const;
  inline void clear_sample_rate();
  static const int kSampleRateFieldNumber = 10;
  inline double sample_rate() const;
  inline void set_sample_rate(double value);

  // optional double duration = 11;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 11;
  inline double duration() const;
  inline void set_duration(double value);

  // optional string ramsnap_time = 12;
  inline bool has_ramsnap_time() const;
  inline void clear_ramsnap_time();
  static const int kRamsnapTimeFieldNumber = 12;
  inline const ::std::string& ramsnap_time() const;
  inline void set_ramsnap_time(const ::std::string& value);
  inline void set_ramsnap_time(const char* value);
  inline void set_ramsnap_time(const char* value, size_t size);
  inline ::std::string* mutable_ramsnap_time();
  inline ::std::string* release_ramsnap_time();
  inline void set_allocated_ramsnap_time(::std::string* ramsnap_time);

  // optional string hostname = 13 [default = "None"];
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 13;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional double bandwidth = 14;
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandwidthFieldNumber = 14;
  inline double bandwidth() const;
  inline void set_bandwidth(double value);

  // optional bool derived = 15 [default = false];
  inline bool has_derived() const;
  inline void clear_derived();
  static const int kDerivedFieldNumber = 15;
  inline bool derived() const;
  inline void set_derived(bool value);

  // optional string parentSnapID = 16;
  inline bool has_parentsnapid() const;
  inline void clear_parentsnapid();
  static const int kParentSnapIDFieldNumber = 16;
  inline const ::std::string& parentsnapid() const;
  inline void set_parentsnapid(const ::std::string& value);
  inline void set_parentsnapid(const char* value);
  inline void set_parentsnapid(const char* value, size_t size);
  inline ::std::string* mutable_parentsnapid();
  inline ::std::string* release_parentsnapid();
  inline void set_allocated_parentsnapid(::std::string* parentsnapid);

  // optional string basePath = 17 [default = "/var/lib/kepler/snapshots/"];
  inline bool has_basepath() const;
  inline void clear_basepath();
  static const int kBasePathFieldNumber = 17;
  inline const ::std::string& basepath() const;
  inline void set_basepath(const ::std::string& value);
  inline void set_basepath(const char* value);
  inline void set_basepath(const char* value, size_t size);
  inline ::std::string* mutable_basepath();
  inline ::std::string* release_basepath();
  inline void set_allocated_basepath(::std::string* basepath);

  // optional string fileExtension = 18 [default = ".tmp"];
  inline bool has_fileextension() const;
  inline void clear_fileextension();
  static const int kFileExtensionFieldNumber = 18;
  inline const ::std::string& fileextension() const;
  inline void set_fileextension(const ::std::string& value);
  inline void set_fileextension(const char* value);
  inline void set_fileextension(const char* value, size_t size);
  inline ::std::string* mutable_fileextension();
  inline ::std::string* release_fileextension();
  inline void set_allocated_fileextension(::std::string* fileextension);

  // optional uint64 fileDataOffset = 51;
  inline bool has_filedataoffset() const;
  inline void clear_filedataoffset();
  static const int kFileDataOffsetFieldNumber = 51;
  inline ::google::protobuf::uint64 filedataoffset() const;
  inline void set_filedataoffset(::google::protobuf::uint64 value);

  // optional uint64 fileDataSize = 52;
  inline bool has_filedatasize() const;
  inline void clear_filedatasize();
  static const int kFileDataSizeFieldNumber = 52;
  inline ::google::protobuf::uint64 filedatasize() const;
  inline void set_filedatasize(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:tuner_msg.IQHeaderInfo)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_freqrf();
  inline void clear_has_freqrf();
  inline void set_has_snapid();
  inline void clear_has_snapid();
  inline void set_has_revid();
  inline void clear_has_revid();
  inline void set_has_tasknum();
  inline void clear_has_tasknum();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_feedid();
  inline void clear_has_feedid();
  inline void set_has_rcvrid();
  inline void clear_has_rcvrid();
  inline void set_has_sample_rate();
  inline void clear_has_sample_rate();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_ramsnap_time();
  inline void clear_has_ramsnap_time();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();
  inline void set_has_derived();
  inline void clear_has_derived();
  inline void set_has_parentsnapid();
  inline void clear_has_parentsnapid();
  inline void set_has_basepath();
  inline void clear_has_basepath();
  inline void set_has_fileextension();
  inline void clear_has_fileextension();
  inline void set_has_filedataoffset();
  inline void clear_has_filedataoffset();
  inline void set_has_filedatasize();
  inline void clear_has_filedatasize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  double freqrf_;
  ::std::string* snapid_;
  ::google::protobuf::int32 revid_;
  ::google::protobuf::int32 tasknum_;
  ::std::string* filename_;
  ::std::string* feedid_;
  ::std::string* rcvrid_;
  double sample_rate_;
  ::google::protobuf::int32 channel_;
  bool derived_;
  double duration_;
  ::std::string* ramsnap_time_;
  ::std::string* hostname_;
  static ::std::string* _default_hostname_;
  double bandwidth_;
  ::std::string* parentsnapid_;
  ::std::string* basepath_;
  static ::std::string* _default_basepath_;
  ::std::string* fileextension_;
  static ::std::string* _default_fileextension_;
  ::google::protobuf::uint64 filedataoffset_;
  ::google::protobuf::uint64 filedatasize_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(20 + 31) / 32];

  friend void  protobuf_AddDesc_TunerMessages_2eproto();
  friend void protobuf_AssignDesc_TunerMessages_2eproto();
  friend void protobuf_ShutdownFile_TunerMessages_2eproto();

  void InitAsDefaultInstance();
  static IQHeaderInfo* default_instance_;
};
// -------------------------------------------------------------------

class IQMetaData : public ::google::protobuf::Message {
 public:
  IQMetaData();
  virtual ~IQMetaData();

  IQMetaData(const IQMetaData& from);

  inline IQMetaData& operator=(const IQMetaData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IQMetaData& default_instance();

  void Swap(IQMetaData* other);

  // implements Message ----------------------------------------------

  IQMetaData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IQMetaData& from);
  void MergeFrom(const IQMetaData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double freqCf = 1;
  inline bool has_freqcf() const;
  inline void clear_freqcf();
  static const int kFreqCfFieldNumber = 1;
  inline double freqcf() const;
  inline void set_freqcf(double value);

  // optional double freqMin = 2;
  inline bool has_freqmin() const;
  inline void clear_freqmin();
  static const int kFreqMinFieldNumber = 2;
  inline double freqmin() const;
  inline void set_freqmin(double value);

  // optional double freqMax = 3;
  inline bool has_freqmax() const;
  inline void clear_freqmax();
  static const int kFreqMaxFieldNumber = 3;
  inline double freqmax() const;
  inline void set_freqmax(double value);

  // optional double duration = 4;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 4;
  inline double duration() const;
  inline void set_duration(double value);

  // optional string ramsnapTime = 5;
  inline bool has_ramsnaptime() const;
  inline void clear_ramsnaptime();
  static const int kRamsnapTimeFieldNumber = 5;
  inline const ::std::string& ramsnaptime() const;
  inline void set_ramsnaptime(const ::std::string& value);
  inline void set_ramsnaptime(const char* value);
  inline void set_ramsnaptime(const char* value, size_t size);
  inline ::std::string* mutable_ramsnaptime();
  inline ::std::string* release_ramsnaptime();
  inline void set_allocated_ramsnaptime(::std::string* ramsnaptime);

  // optional string hostname = 6;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 6;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional string feedId = 7;
  inline bool has_feedid() const;
  inline void clear_feedid();
  static const int kFeedIdFieldNumber = 7;
  inline const ::std::string& feedid() const;
  inline void set_feedid(const ::std::string& value);
  inline void set_feedid(const char* value);
  inline void set_feedid(const char* value, size_t size);
  inline ::std::string* mutable_feedid();
  inline ::std::string* release_feedid();
  inline void set_allocated_feedid(::std::string* feedid);

  // optional string rcvrId = 8;
  inline bool has_rcvrid() const;
  inline void clear_rcvrid();
  static const int kRcvrIdFieldNumber = 8;
  inline const ::std::string& rcvrid() const;
  inline void set_rcvrid(const ::std::string& value);
  inline void set_rcvrid(const char* value);
  inline void set_rcvrid(const char* value, size_t size);
  inline ::std::string* mutable_rcvrid();
  inline ::std::string* release_rcvrid();
  inline void set_allocated_rcvrid(::std::string* rcvrid);

  // @@protoc_insertion_point(class_scope:tuner_msg.IQMetaData)
 private:
  inline void set_has_freqcf();
  inline void clear_has_freqcf();
  inline void set_has_freqmin();
  inline void clear_has_freqmin();
  inline void set_has_freqmax();
  inline void clear_has_freqmax();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_ramsnaptime();
  inline void clear_has_ramsnaptime();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_feedid();
  inline void clear_has_feedid();
  inline void set_has_rcvrid();
  inline void clear_has_rcvrid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double freqcf_;
  double freqmin_;
  double freqmax_;
  double duration_;
  ::std::string* ramsnaptime_;
  ::std::string* hostname_;
  ::std::string* feedid_;
  ::std::string* rcvrid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_TunerMessages_2eproto();
  friend void protobuf_AssignDesc_TunerMessages_2eproto();
  friend void protobuf_ShutdownFile_TunerMessages_2eproto();

  void InitAsDefaultInstance();
  static IQMetaData* default_instance_;
};
// -------------------------------------------------------------------

class SnapInfo : public ::google::protobuf::Message {
 public:
  SnapInfo();
  virtual ~SnapInfo();

  SnapInfo(const SnapInfo& from);

  inline SnapInfo& operator=(const SnapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SnapInfo& default_instance();

  void Swap(SnapInfo* other);

  // implements Message ----------------------------------------------

  SnapInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SnapInfo& from);
  void MergeFrom(const SnapInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SNAPINFO"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional .tuner_msg.IQHeaderInfo IQHeader = 2;
  inline bool has_iqheader() const;
  inline void clear_iqheader();
  static const int kIQHeaderFieldNumber = 2;
  inline const ::tuner_msg::IQHeaderInfo& iqheader() const;
  inline ::tuner_msg::IQHeaderInfo* mutable_iqheader();
  inline ::tuner_msg::IQHeaderInfo* release_iqheader();
  inline void set_allocated_iqheader(::tuner_msg::IQHeaderInfo* iqheader);

  // repeated .tuner_msg.IQHeaderInfo iqHeaders = 3;
  inline int iqheaders_size() const;
  inline void clear_iqheaders();
  static const int kIqHeadersFieldNumber = 3;
  inline const ::tuner_msg::IQHeaderInfo& iqheaders(int index) const;
  inline ::tuner_msg::IQHeaderInfo* mutable_iqheaders(int index);
  inline ::tuner_msg::IQHeaderInfo* add_iqheaders();
  inline const ::google::protobuf::RepeatedPtrField< ::tuner_msg::IQHeaderInfo >&
      iqheaders() const;
  inline ::google::protobuf::RepeatedPtrField< ::tuner_msg::IQHeaderInfo >*
      mutable_iqheaders();

  // optional .tuner_msg.IQMetaData iqMetaData = 4;
  inline bool has_iqmetadata() const;
  inline void clear_iqmetadata();
  static const int kIqMetaDataFieldNumber = 4;
  inline const ::tuner_msg::IQMetaData& iqmetadata() const;
  inline ::tuner_msg::IQMetaData* mutable_iqmetadata();
  inline ::tuner_msg::IQMetaData* release_iqmetadata();
  inline void set_allocated_iqmetadata(::tuner_msg::IQMetaData* iqmetadata);

  // @@protoc_insertion_point(class_scope:tuner_msg.SnapInfo)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_iqheader();
  inline void clear_has_iqheader();
  inline void set_has_iqmetadata();
  inline void clear_has_iqmetadata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::tuner_msg::IQHeaderInfo* iqheader_;
  ::google::protobuf::RepeatedPtrField< ::tuner_msg::IQHeaderInfo > iqheaders_;
  ::tuner_msg::IQMetaData* iqmetadata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TunerMessages_2eproto();
  friend void protobuf_AssignDesc_TunerMessages_2eproto();
  friend void protobuf_ShutdownFile_TunerMessages_2eproto();

  void InitAsDefaultInstance();
  static SnapInfo* default_instance_;
};
// -------------------------------------------------------------------

class ChangeTuneRange : public ::google::protobuf::Message {
 public:
  ChangeTuneRange();
  virtual ~ChangeTuneRange();

  ChangeTuneRange(const ChangeTuneRange& from);

  inline ChangeTuneRange& operator=(const ChangeTuneRange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeTuneRange& default_instance();

  void Swap(ChangeTuneRange* other);

  // implements Message ----------------------------------------------

  ChangeTuneRange* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeTuneRange& from);
  void MergeFrom(const ChangeTuneRange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "CHANGE_TUNE_RANGE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 channel = 2 [default = -1];
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional int32 appID = 3;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 3;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // repeated .tuner_msg.TuneRange tunePlan = 4;
  inline int tuneplan_size() const;
  inline void clear_tuneplan();
  static const int kTunePlanFieldNumber = 4;
  inline const ::tuner_msg::TuneRange& tuneplan(int index) const;
  inline ::tuner_msg::TuneRange* mutable_tuneplan(int index);
  inline ::tuner_msg::TuneRange* add_tuneplan();
  inline const ::google::protobuf::RepeatedPtrField< ::tuner_msg::TuneRange >&
      tuneplan() const;
  inline ::google::protobuf::RepeatedPtrField< ::tuner_msg::TuneRange >*
      mutable_tuneplan();

  // optional bool allowOverlap = 5 [default = true];
  inline bool has_allowoverlap() const;
  inline void clear_allowoverlap();
  static const int kAllowOverlapFieldNumber = 5;
  inline bool allowoverlap() const;
  inline void set_allowoverlap(bool value);

  // @@protoc_insertion_point(class_scope:tuner_msg.ChangeTuneRange)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_allowoverlap();
  inline void clear_has_allowoverlap();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 channel_;
  ::google::protobuf::int32 appid_;
  ::google::protobuf::RepeatedPtrField< ::tuner_msg::TuneRange > tuneplan_;
  bool allowoverlap_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TunerMessages_2eproto();
  friend void protobuf_AssignDesc_TunerMessages_2eproto();
  friend void protobuf_ShutdownFile_TunerMessages_2eproto();

  void InitAsDefaultInstance();
  static ChangeTuneRange* default_instance_;
};
// -------------------------------------------------------------------

class TuneRange : public ::google::protobuf::Message {
 public:
  TuneRange();
  virtual ~TuneRange();

  TuneRange(const TuneRange& from);

  inline TuneRange& operator=(const TuneRange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TuneRange& default_instance();

  void Swap(TuneRange* other);

  // implements Message ----------------------------------------------

  TuneRange* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TuneRange& from);
  void MergeFrom(const TuneRange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "TUNE_RANGE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional double startRf = 2;
  inline bool has_startrf() const;
  inline void clear_startrf();
  static const int kStartRfFieldNumber = 2;
  inline double startrf() const;
  inline void set_startrf(double value);

  // optional double endRf = 3;
  inline bool has_endrf() const;
  inline void clear_endrf();
  static const int kEndRfFieldNumber = 3;
  inline double endrf() const;
  inline void set_endrf(double value);

  // optional double step = 4;
  inline bool has_step() const;
  inline void clear_step();
  static const int kStepFieldNumber = 4;
  inline double step() const;
  inline void set_step(double value);

  // optional double duration = 5;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 5;
  inline double duration() const;
  inline void set_duration(double value);

  // optional double gain = 6;
  inline bool has_gain() const;
  inline void clear_gain();
  static const int kGainFieldNumber = 6;
  inline double gain() const;
  inline void set_gain(double value);

  // optional int32 atten = 7;
  inline bool has_atten() const;
  inline void clear_atten();
  static const int kAttenFieldNumber = 7;
  inline ::google::protobuf::int32 atten() const;
  inline void set_atten(::google::protobuf::int32 value);

  // optional float bwMHz = 8 [default = 20];
  inline bool has_bwmhz() const;
  inline void clear_bwmhz();
  static const int kBwMHzFieldNumber = 8;
  inline float bwmhz() const;
  inline void set_bwmhz(float value);

  // repeated int32 appID = 9;
  inline int appid_size() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 9;
  inline ::google::protobuf::int32 appid(int index) const;
  inline void set_appid(int index, ::google::protobuf::int32 value);
  inline void add_appid(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      appid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_appid();

  // @@protoc_insertion_point(class_scope:tuner_msg.TuneRange)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_startrf();
  inline void clear_has_startrf();
  inline void set_has_endrf();
  inline void clear_has_endrf();
  inline void set_has_step();
  inline void clear_has_step();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_gain();
  inline void clear_has_gain();
  inline void set_has_atten();
  inline void clear_has_atten();
  inline void set_has_bwmhz();
  inline void clear_has_bwmhz();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  double startrf_;
  double endrf_;
  double step_;
  double duration_;
  double gain_;
  ::google::protobuf::int32 atten_;
  float bwmhz_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > appid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_TunerMessages_2eproto();
  friend void protobuf_AssignDesc_TunerMessages_2eproto();
  friend void protobuf_ShutdownFile_TunerMessages_2eproto();

  void InitAsDefaultInstance();
  static TuneRange* default_instance_;
};
// -------------------------------------------------------------------

class ReceiverStatus : public ::google::protobuf::Message {
 public:
  ReceiverStatus();
  virtual ~ReceiverStatus();

  ReceiverStatus(const ReceiverStatus& from);

  inline ReceiverStatus& operator=(const ReceiverStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiverStatus& default_instance();

  void Swap(ReceiverStatus* other);

  // implements Message ----------------------------------------------

  ReceiverStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReceiverStatus& from);
  void MergeFrom(const ReceiverStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ReceiverStatus_Status Status;
  static const Status SCANNING = ReceiverStatus_Status_SCANNING;
  static const Status DWELLING = ReceiverStatus_Status_DWELLING;
  static const Status OFF = ReceiverStatus_Status_OFF;
  static inline bool Status_IsValid(int value) {
    return ReceiverStatus_Status_IsValid(value);
  }
  static const Status Status_MIN =
    ReceiverStatus_Status_Status_MIN;
  static const Status Status_MAX =
    ReceiverStatus_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    ReceiverStatus_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return ReceiverStatus_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return ReceiverStatus_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return ReceiverStatus_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "RECEIVERSTATUS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // repeated .tuner_msg.TuneRange tunePlan = 3;
  inline int tuneplan_size() const;
  inline void clear_tuneplan();
  static const int kTunePlanFieldNumber = 3;
  inline const ::tuner_msg::TuneRange& tuneplan(int index) const;
  inline ::tuner_msg::TuneRange* mutable_tuneplan(int index);
  inline ::tuner_msg::TuneRange* add_tuneplan();
  inline const ::google::protobuf::RepeatedPtrField< ::tuner_msg::TuneRange >&
      tuneplan() const;
  inline ::google::protobuf::RepeatedPtrField< ::tuner_msg::TuneRange >*
      mutable_tuneplan();

  // optional double currentFrequency = 4;
  inline bool has_currentfrequency() const;
  inline void clear_currentfrequency();
  static const int kCurrentFrequencyFieldNumber = 4;
  inline double currentfrequency() const;
  inline void set_currentfrequency(double value);

  // optional .tuner_msg.ReceiverStatus.Status status = 5 [default = OFF];
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 5;
  inline ::tuner_msg::ReceiverStatus_Status status() const;
  inline void set_status(::tuner_msg::ReceiverStatus_Status value);

  // @@protoc_insertion_point(class_scope:tuner_msg.ReceiverStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_currentfrequency();
  inline void clear_has_currentfrequency();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::RepeatedPtrField< ::tuner_msg::TuneRange > tuneplan_;
  ::google::protobuf::int32 channel_;
  int status_;
  double currentfrequency_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TunerMessages_2eproto();
  friend void protobuf_AssignDesc_TunerMessages_2eproto();
  friend void protobuf_ShutdownFile_TunerMessages_2eproto();

  void InitAsDefaultInstance();
  static ReceiverStatus* default_instance_;
};
// -------------------------------------------------------------------

class QueryReceiverStatus : public ::google::protobuf::Message {
 public:
  QueryReceiverStatus();
  virtual ~QueryReceiverStatus();

  QueryReceiverStatus(const QueryReceiverStatus& from);

  inline QueryReceiverStatus& operator=(const QueryReceiverStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryReceiverStatus& default_instance();

  void Swap(QueryReceiverStatus* other);

  // implements Message ----------------------------------------------

  QueryReceiverStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryReceiverStatus& from);
  void MergeFrom(const QueryReceiverStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "QUERYRECEIVERSTATUS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tuner_msg.QueryReceiverStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_channel();
  inline void clear_has_channel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 channel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TunerMessages_2eproto();
  friend void protobuf_AssignDesc_TunerMessages_2eproto();
  friend void protobuf_ShutdownFile_TunerMessages_2eproto();

  void InitAsDefaultInstance();
  static QueryReceiverStatus* default_instance_;
};
// -------------------------------------------------------------------

class TimingCheck : public ::google::protobuf::Message {
 public:
  TimingCheck();
  virtual ~TimingCheck();

  TimingCheck(const TimingCheck& from);

  inline TimingCheck& operator=(const TimingCheck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimingCheck& default_instance();

  void Swap(TimingCheck* other);

  // implements Message ----------------------------------------------

  TimingCheck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimingCheck& from);
  void MergeFrom(const TimingCheck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "TIMINGCHECK"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional string timing = 3;
  inline bool has_timing() const;
  inline void clear_timing();
  static const int kTimingFieldNumber = 3;
  inline const ::std::string& timing() const;
  inline void set_timing(const ::std::string& value);
  inline void set_timing(const char* value);
  inline void set_timing(const char* value, size_t size);
  inline ::std::string* mutable_timing();
  inline ::std::string* release_timing();
  inline void set_allocated_timing(::std::string* timing);

  // @@protoc_insertion_point(class_scope:tuner_msg.TimingCheck)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_timing();
  inline void clear_has_timing();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* timing_;
  ::google::protobuf::int32 channel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TunerMessages_2eproto();
  friend void protobuf_AssignDesc_TunerMessages_2eproto();
  friend void protobuf_ShutdownFile_TunerMessages_2eproto();

  void InitAsDefaultInstance();
  static TimingCheck* default_instance_;
};
// -------------------------------------------------------------------

class DwellScan : public ::google::protobuf::Message {
 public:
  DwellScan();
  virtual ~DwellScan();

  DwellScan(const DwellScan& from);

  inline DwellScan& operator=(const DwellScan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DwellScan& default_instance();

  void Swap(DwellScan* other);

  // implements Message ----------------------------------------------

  DwellScan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DwellScan& from);
  void MergeFrom(const DwellScan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DwellScan_State State;
  static const State START = DwellScan_State_START;
  static const State DWELL = DwellScan_State_DWELL;
  static const State STOP = DwellScan_State_STOP;
  static inline bool State_IsValid(int value) {
    return DwellScan_State_IsValid(value);
  }
  static const State State_MIN =
    DwellScan_State_State_MIN;
  static const State State_MAX =
    DwellScan_State_State_MAX;
  static const int State_ARRAYSIZE =
    DwellScan_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return DwellScan_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return DwellScan_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return DwellScan_State_Parse(name, value);
  }

  typedef DwellScan_GainMode GainMode;
  static const GainMode AGC = DwellScan_GainMode_AGC;
  static const GainMode MANUAL = DwellScan_GainMode_MANUAL;
  static inline bool GainMode_IsValid(int value) {
    return DwellScan_GainMode_IsValid(value);
  }
  static const GainMode GainMode_MIN =
    DwellScan_GainMode_GainMode_MIN;
  static const GainMode GainMode_MAX =
    DwellScan_GainMode_GainMode_MAX;
  static const int GainMode_ARRAYSIZE =
    DwellScan_GainMode_GainMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GainMode_descriptor() {
    return DwellScan_GainMode_descriptor();
  }
  static inline const ::std::string& GainMode_Name(GainMode value) {
    return DwellScan_GainMode_Name(value);
  }
  static inline bool GainMode_Parse(const ::std::string& name,
      GainMode* value) {
    return DwellScan_GainMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "DWELLSCAN"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional float freqMHz = 3;
  inline bool has_freqmhz() const;
  inline void clear_freqmhz();
  static const int kFreqMHzFieldNumber = 3;
  inline float freqmhz() const;
  inline void set_freqmhz(float value);

  // optional float gaindB = 4;
  inline bool has_gaindb() const;
  inline void clear_gaindb();
  static const int kGaindBFieldNumber = 4;
  inline float gaindb() const;
  inline void set_gaindb(float value);

  // optional float bwMHz = 5 [default = 20];
  inline bool has_bwmhz() const;
  inline void clear_bwmhz();
  static const int kBwMHzFieldNumber = 5;
  inline float bwmhz() const;
  inline void set_bwmhz(float value);

  // optional float duration = 6 [default = -1];
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 6;
  inline float duration() const;
  inline void set_duration(float value);

  // optional .tuner_msg.DwellScan.State state = 7 [default = DWELL];
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 7;
  inline ::tuner_msg::DwellScan_State state() const;
  inline void set_state(::tuner_msg::DwellScan_State value);

  // optional int32 appID = 8;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 8;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional bool mergeFile = 9 [default = false];
  inline bool has_mergefile() const;
  inline void clear_mergefile();
  static const int kMergeFileFieldNumber = 9;
  inline bool mergefile() const;
  inline void set_mergefile(bool value);

  // optional .tuner_msg.DwellScan.GainMode gainMode = 10 [default = AGC];
  inline bool has_gainmode() const;
  inline void clear_gainmode();
  static const int kGainModeFieldNumber = 10;
  inline ::tuner_msg::DwellScan_GainMode gainmode() const;
  inline void set_gainmode(::tuner_msg::DwellScan_GainMode value);

  // optional string hostname = 11 [default = "None"];
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 11;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // @@protoc_insertion_point(class_scope:tuner_msg.DwellScan)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_freqmhz();
  inline void clear_has_freqmhz();
  inline void set_has_gaindb();
  inline void clear_has_gaindb();
  inline void set_has_bwmhz();
  inline void clear_has_bwmhz();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_mergefile();
  inline void clear_has_mergefile();
  inline void set_has_gainmode();
  inline void clear_has_gainmode();
  inline void set_has_hostname();
  inline void clear_has_hostname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 channel_;
  float freqmhz_;
  float gaindb_;
  float bwmhz_;
  float duration_;
  int state_;
  ::google::protobuf::int32 appid_;
  bool mergefile_;
  ::std::string* hostname_;
  static ::std::string* _default_hostname_;
  int gainmode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_TunerMessages_2eproto();
  friend void protobuf_AssignDesc_TunerMessages_2eproto();
  friend void protobuf_ShutdownFile_TunerMessages_2eproto();

  void InitAsDefaultInstance();
  static DwellScan* default_instance_;
};
// -------------------------------------------------------------------

class TxTune : public ::google::protobuf::Message {
 public:
  TxTune();
  virtual ~TxTune();

  TxTune(const TxTune& from);

  inline TxTune& operator=(const TxTune& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxTune& default_instance();

  void Swap(TxTune* other);

  // implements Message ----------------------------------------------

  TxTune* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxTune& from);
  void MergeFrom(const TxTune& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "TXTUNE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional bool state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline bool state() const;
  inline void set_state(bool value);

  // optional int32 channel = 3;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 3;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional float freqMHz = 4;
  inline bool has_freqmhz() const;
  inline void clear_freqmhz();
  static const int kFreqMHzFieldNumber = 4;
  inline float freqmhz() const;
  inline void set_freqmhz(float value);

  // optional float gaindB = 5;
  inline bool has_gaindb() const;
  inline void clear_gaindb();
  static const int kGaindBFieldNumber = 5;
  inline float gaindb() const;
  inline void set_gaindb(float value);

  // optional float sampleRate = 6;
  inline bool has_samplerate() const;
  inline void clear_samplerate();
  static const int kSampleRateFieldNumber = 6;
  inline float samplerate() const;
  inline void set_samplerate(float value);

  // optional string config = 7;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 7;
  inline const ::std::string& config() const;
  inline void set_config(const ::std::string& value);
  inline void set_config(const char* value);
  inline void set_config(const char* value, size_t size);
  inline ::std::string* mutable_config();
  inline ::std::string* release_config();
  inline void set_allocated_config(::std::string* config);

  // optional bool capeState = 8;
  inline bool has_capestate() const;
  inline void clear_capestate();
  static const int kCapeStateFieldNumber = 8;
  inline bool capestate() const;
  inline void set_capestate(bool value);

  // @@protoc_insertion_point(class_scope:tuner_msg.TxTune)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_freqmhz();
  inline void clear_has_freqmhz();
  inline void set_has_gaindb();
  inline void clear_has_gaindb();
  inline void set_has_samplerate();
  inline void clear_has_samplerate();
  inline void set_has_config();
  inline void clear_has_config();
  inline void set_has_capestate();
  inline void clear_has_capestate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 channel_;
  float freqmhz_;
  float gaindb_;
  bool state_;
  bool capestate_;
  ::std::string* config_;
  float samplerate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_TunerMessages_2eproto();
  friend void protobuf_AssignDesc_TunerMessages_2eproto();
  friend void protobuf_ShutdownFile_TunerMessages_2eproto();

  void InitAsDefaultInstance();
  static TxTune* default_instance_;
};
// -------------------------------------------------------------------

class ReactiveJam : public ::google::protobuf::Message {
 public:
  ReactiveJam();
  virtual ~ReactiveJam();

  ReactiveJam(const ReactiveJam& from);

  inline ReactiveJam& operator=(const ReactiveJam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReactiveJam& default_instance();

  void Swap(ReactiveJam* other);

  // implements Message ----------------------------------------------

  ReactiveJam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReactiveJam& from);
  void MergeFrom(const ReactiveJam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "REACTIVEJAM"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional bool state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline bool state() const;
  inline void set_state(bool value);

  // @@protoc_insertion_point(class_scope:tuner_msg.ReactiveJam)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  bool state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TunerMessages_2eproto();
  friend void protobuf_AssignDesc_TunerMessages_2eproto();
  friend void protobuf_ShutdownFile_TunerMessages_2eproto();

  void InitAsDefaultInstance();
  static ReactiveJam* default_instance_;
};
// -------------------------------------------------------------------

class diskSnapAvailable : public ::google::protobuf::Message {
 public:
  diskSnapAvailable();
  virtual ~diskSnapAvailable();

  diskSnapAvailable(const diskSnapAvailable& from);

  inline diskSnapAvailable& operator=(const diskSnapAvailable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const diskSnapAvailable& default_instance();

  void Swap(diskSnapAvailable* other);

  // implements Message ----------------------------------------------

  diskSnapAvailable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const diskSnapAvailable& from);
  void MergeFrom(const diskSnapAvailable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "DISKSNAPAVAILABLE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string diskSnapID = 2;
  inline bool has_disksnapid() const;
  inline void clear_disksnapid();
  static const int kDiskSnapIDFieldNumber = 2;
  inline const ::std::string& disksnapid() const;
  inline void set_disksnapid(const ::std::string& value);
  inline void set_disksnapid(const char* value);
  inline void set_disksnapid(const char* value, size_t size);
  inline ::std::string* mutable_disksnapid();
  inline ::std::string* release_disksnapid();
  inline void set_allocated_disksnapid(::std::string* disksnapid);

  // optional string filename = 3;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 3;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional string hostname = 4;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 4;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // @@protoc_insertion_point(class_scope:tuner_msg.diskSnapAvailable)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_disksnapid();
  inline void clear_has_disksnapid();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_hostname();
  inline void clear_has_hostname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* disksnapid_;
  ::std::string* filename_;
  ::std::string* hostname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TunerMessages_2eproto();
  friend void protobuf_AssignDesc_TunerMessages_2eproto();
  friend void protobuf_ShutdownFile_TunerMessages_2eproto();

  void InitAsDefaultInstance();
  static diskSnapAvailable* default_instance_;
};
// -------------------------------------------------------------------

class SnapBroadcast : public ::google::protobuf::Message {
 public:
  SnapBroadcast();
  virtual ~SnapBroadcast();

  SnapBroadcast(const SnapBroadcast& from);

  inline SnapBroadcast& operator=(const SnapBroadcast& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SnapBroadcast& default_instance();

  void Swap(SnapBroadcast* other);

  // implements Message ----------------------------------------------

  SnapBroadcast* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SnapBroadcast& from);
  void MergeFrom(const SnapBroadcast& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SnapBroadcast_State State;
  static const State START = SnapBroadcast_State_START;
  static const State STOP = SnapBroadcast_State_STOP;
  static inline bool State_IsValid(int value) {
    return SnapBroadcast_State_IsValid(value);
  }
  static const State State_MIN =
    SnapBroadcast_State_State_MIN;
  static const State State_MAX =
    SnapBroadcast_State_State_MAX;
  static const int State_ARRAYSIZE =
    SnapBroadcast_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return SnapBroadcast_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return SnapBroadcast_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return SnapBroadcast_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SNAPBROADCAST"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional float freqMHz = 2;
  inline bool has_freqmhz() const;
  inline void clear_freqmhz();
  static const int kFreqMHzFieldNumber = 2;
  inline float freqmhz() const;
  inline void set_freqmhz(float value);

  // optional .tuner_msg.SnapBroadcast.State state = 3 [default = STOP];
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 3;
  inline ::tuner_msg::SnapBroadcast_State state() const;
  inline void set_state(::tuner_msg::SnapBroadcast_State value);

  // @@protoc_insertion_point(class_scope:tuner_msg.SnapBroadcast)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_freqmhz();
  inline void clear_has_freqmhz();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  float freqmhz_;
  int state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TunerMessages_2eproto();
  friend void protobuf_AssignDesc_TunerMessages_2eproto();
  friend void protobuf_ShutdownFile_TunerMessages_2eproto();

  void InitAsDefaultInstance();
  static SnapBroadcast* default_instance_;
};
// -------------------------------------------------------------------

class ReceiverRequest : public ::google::protobuf::Message {
 public:
  ReceiverRequest();
  virtual ~ReceiverRequest();

  ReceiverRequest(const ReceiverRequest& from);

  inline ReceiverRequest& operator=(const ReceiverRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiverRequest& default_instance();

  void Swap(ReceiverRequest* other);

  // implements Message ----------------------------------------------

  ReceiverRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReceiverRequest& from);
  void MergeFrom(const ReceiverRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 appID = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 1;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tuner_msg.ReceiverRequest)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 appid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TunerMessages_2eproto();
  friend void protobuf_AssignDesc_TunerMessages_2eproto();
  friend void protobuf_ShutdownFile_TunerMessages_2eproto();

  void InitAsDefaultInstance();
  static ReceiverRequest* default_instance_;
};
// -------------------------------------------------------------------

class ReceiverRelease : public ::google::protobuf::Message {
 public:
  ReceiverRelease();
  virtual ~ReceiverRelease();

  ReceiverRelease(const ReceiverRelease& from);

  inline ReceiverRelease& operator=(const ReceiverRelease& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiverRelease& default_instance();

  void Swap(ReceiverRelease* other);

  // implements Message ----------------------------------------------

  ReceiverRelease* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReceiverRelease& from);
  void MergeFrom(const ReceiverRelease& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 appID = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 1;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional int32 channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tuner_msg.ReceiverRelease)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_channel();
  inline void clear_has_channel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 appid_;
  ::google::protobuf::int32 channel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TunerMessages_2eproto();
  friend void protobuf_AssignDesc_TunerMessages_2eproto();
  friend void protobuf_ShutdownFile_TunerMessages_2eproto();

  void InitAsDefaultInstance();
  static ReceiverRelease* default_instance_;
};
// -------------------------------------------------------------------

class ReceiverAcquired : public ::google::protobuf::Message {
 public:
  ReceiverAcquired();
  virtual ~ReceiverAcquired();

  ReceiverAcquired(const ReceiverAcquired& from);

  inline ReceiverAcquired& operator=(const ReceiverAcquired& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiverAcquired& default_instance();

  void Swap(ReceiverAcquired* other);

  // implements Message ----------------------------------------------

  ReceiverAcquired* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReceiverAcquired& from);
  void MergeFrom(const ReceiverAcquired& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 appID = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 1;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional int32 channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tuner_msg.ReceiverAcquired)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_channel();
  inline void clear_has_channel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 appid_;
  ::google::protobuf::int32 channel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TunerMessages_2eproto();
  friend void protobuf_AssignDesc_TunerMessages_2eproto();
  friend void protobuf_ShutdownFile_TunerMessages_2eproto();

  void InitAsDefaultInstance();
  static ReceiverAcquired* default_instance_;
};
// -------------------------------------------------------------------

class ReceiverReleased : public ::google::protobuf::Message {
 public:
  ReceiverReleased();
  virtual ~ReceiverReleased();

  ReceiverReleased(const ReceiverReleased& from);

  inline ReceiverReleased& operator=(const ReceiverReleased& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiverReleased& default_instance();

  void Swap(ReceiverReleased* other);

  // implements Message ----------------------------------------------

  ReceiverReleased* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReceiverReleased& from);
  void MergeFrom(const ReceiverReleased& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 appID = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 1;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional int32 channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tuner_msg.ReceiverReleased)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_channel();
  inline void clear_has_channel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 appid_;
  ::google::protobuf::int32 channel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TunerMessages_2eproto();
  friend void protobuf_AssignDesc_TunerMessages_2eproto();
  friend void protobuf_ShutdownFile_TunerMessages_2eproto();

  void InitAsDefaultInstance();
  static ReceiverReleased* default_instance_;
};
// -------------------------------------------------------------------

class ChangeRXTxConfig : public ::google::protobuf::Message {
 public:
  ChangeRXTxConfig();
  virtual ~ChangeRXTxConfig();

  ChangeRXTxConfig(const ChangeRXTxConfig& from);

  inline ChangeRXTxConfig& operator=(const ChangeRXTxConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeRXTxConfig& default_instance();

  void Swap(ChangeRXTxConfig* other);

  // implements Message ----------------------------------------------

  ChangeRXTxConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeRXTxConfig& from);
  void MergeFrom(const ChangeRXTxConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ChangeRXTxConfig"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string config = 2 [default = "RCH3"];
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 2;
  inline const ::std::string& config() const;
  inline void set_config(const ::std::string& value);
  inline void set_config(const char* value);
  inline void set_config(const char* value, size_t size);
  inline ::std::string* mutable_config();
  inline ::std::string* release_config();
  inline void set_allocated_config(::std::string* config);

  // @@protoc_insertion_point(class_scope:tuner_msg.ChangeRXTxConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_config();
  inline void clear_has_config();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* config_;
  static ::std::string* _default_config_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TunerMessages_2eproto();
  friend void protobuf_AssignDesc_TunerMessages_2eproto();
  friend void protobuf_ShutdownFile_TunerMessages_2eproto();

  void InitAsDefaultInstance();
  static ChangeRXTxConfig* default_instance_;
};
// ===================================================================


// ===================================================================

// AdjustScan

// optional string msgName = 1 [default = "ADJUSTSCAN"];
inline bool AdjustScan::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdjustScan::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdjustScan::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdjustScan::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& AdjustScan::msgname() const {
  return *msgname_;
}
inline void AdjustScan::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AdjustScan::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AdjustScan::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AdjustScan::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* AdjustScan::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void AdjustScan::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional double dwtime = 2;
inline bool AdjustScan::has_dwtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdjustScan::set_has_dwtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdjustScan::clear_has_dwtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdjustScan::clear_dwtime() {
  dwtime_ = 0;
  clear_has_dwtime();
}
inline double AdjustScan::dwtime() const {
  return dwtime_;
}
inline void AdjustScan::set_dwtime(double value) {
  set_has_dwtime();
  dwtime_ = value;
}

// optional int32 ftupdate = 3;
inline bool AdjustScan::has_ftupdate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AdjustScan::set_has_ftupdate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AdjustScan::clear_has_ftupdate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AdjustScan::clear_ftupdate() {
  ftupdate_ = 0;
  clear_has_ftupdate();
}
inline ::google::protobuf::int32 AdjustScan::ftupdate() const {
  return ftupdate_;
}
inline void AdjustScan::set_ftupdate(::google::protobuf::int32 value) {
  set_has_ftupdate();
  ftupdate_ = value;
}

// optional int32 mode = 4;
inline bool AdjustScan::has_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AdjustScan::set_has_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AdjustScan::clear_has_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AdjustScan::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::google::protobuf::int32 AdjustScan::mode() const {
  return mode_;
}
inline void AdjustScan::set_mode(::google::protobuf::int32 value) {
  set_has_mode();
  mode_ = value;
}

// optional int32 revid = 5;
inline bool AdjustScan::has_revid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AdjustScan::set_has_revid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AdjustScan::clear_has_revid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AdjustScan::clear_revid() {
  revid_ = 0;
  clear_has_revid();
}
inline ::google::protobuf::int32 AdjustScan::revid() const {
  return revid_;
}
inline void AdjustScan::set_revid(::google::protobuf::int32 value) {
  set_has_revid();
  revid_ = value;
}

// optional string feed = 6;
inline bool AdjustScan::has_feed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AdjustScan::set_has_feed() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AdjustScan::clear_has_feed() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AdjustScan::clear_feed() {
  if (feed_ != &::google::protobuf::internal::kEmptyString) {
    feed_->clear();
  }
  clear_has_feed();
}
inline const ::std::string& AdjustScan::feed() const {
  return *feed_;
}
inline void AdjustScan::set_feed(const ::std::string& value) {
  set_has_feed();
  if (feed_ == &::google::protobuf::internal::kEmptyString) {
    feed_ = new ::std::string;
  }
  feed_->assign(value);
}
inline void AdjustScan::set_feed(const char* value) {
  set_has_feed();
  if (feed_ == &::google::protobuf::internal::kEmptyString) {
    feed_ = new ::std::string;
  }
  feed_->assign(value);
}
inline void AdjustScan::set_feed(const char* value, size_t size) {
  set_has_feed();
  if (feed_ == &::google::protobuf::internal::kEmptyString) {
    feed_ = new ::std::string;
  }
  feed_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AdjustScan::mutable_feed() {
  set_has_feed();
  if (feed_ == &::google::protobuf::internal::kEmptyString) {
    feed_ = new ::std::string;
  }
  return feed_;
}
inline ::std::string* AdjustScan::release_feed() {
  clear_has_feed();
  if (feed_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = feed_;
    feed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AdjustScan::set_allocated_feed(::std::string* feed) {
  if (feed_ != &::google::protobuf::internal::kEmptyString) {
    delete feed_;
  }
  if (feed) {
    set_has_feed();
    feed_ = feed;
  } else {
    clear_has_feed();
    feed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double az = 7;
inline bool AdjustScan::has_az() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AdjustScan::set_has_az() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AdjustScan::clear_has_az() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AdjustScan::clear_az() {
  az_ = 0;
  clear_has_az();
}
inline double AdjustScan::az() const {
  return az_;
}
inline void AdjustScan::set_az(double value) {
  set_has_az();
  az_ = value;
}

// optional double foffset = 8;
inline bool AdjustScan::has_foffset() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AdjustScan::set_has_foffset() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AdjustScan::clear_has_foffset() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AdjustScan::clear_foffset() {
  foffset_ = 0;
  clear_has_foffset();
}
inline double AdjustScan::foffset() const {
  return foffset_;
}
inline void AdjustScan::set_foffset(double value) {
  set_has_foffset();
  foffset_ = value;
}

// optional int32 snapreset = 9;
inline bool AdjustScan::has_snapreset() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AdjustScan::set_has_snapreset() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AdjustScan::clear_has_snapreset() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AdjustScan::clear_snapreset() {
  snapreset_ = 0;
  clear_has_snapreset();
}
inline ::google::protobuf::int32 AdjustScan::snapreset() const {
  return snapreset_;
}
inline void AdjustScan::set_snapreset(::google::protobuf::int32 value) {
  set_has_snapreset();
  snapreset_ = value;
}

// -------------------------------------------------------------------

// ManArch

// optional string msgName = 1 [default = "MANARCH"];
inline bool ManArch::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ManArch::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ManArch::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ManArch::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ManArch::msgname() const {
  return *msgname_;
}
inline void ManArch::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ManArch::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ManArch::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ManArch::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ManArch::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ManArch::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional double freq = 2;
inline bool ManArch::has_freq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ManArch::set_has_freq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ManArch::clear_has_freq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ManArch::clear_freq() {
  freq_ = 0;
  clear_has_freq();
}
inline double ManArch::freq() const {
  return freq_;
}
inline void ManArch::set_freq(double value) {
  set_has_freq();
  freq_ = value;
}

// optional double duration = 3;
inline bool ManArch::has_duration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ManArch::set_has_duration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ManArch::clear_has_duration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ManArch::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline double ManArch::duration() const {
  return duration_;
}
inline void ManArch::set_duration(double value) {
  set_has_duration();
  duration_ = value;
}

// optional string filename = 4;
inline bool ManArch::has_filename() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ManArch::set_has_filename() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ManArch::clear_has_filename() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ManArch::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& ManArch::filename() const {
  return *filename_;
}
inline void ManArch::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void ManArch::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void ManArch::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ManArch::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* ManArch::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ManArch::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TArch

// optional string msgName = 1 [default = "TARCH"];
inline bool TArch::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TArch::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TArch::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TArch::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& TArch::msgname() const {
  return *msgname_;
}
inline void TArch::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void TArch::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void TArch::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TArch::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* TArch::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void TArch::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional double duration = 2;
inline bool TArch::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TArch::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TArch::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TArch::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline double TArch::duration() const {
  return duration_;
}
inline void TArch::set_duration(double value) {
  set_has_duration();
  duration_ = value;
}

// optional double frequency = 3;
inline bool TArch::has_frequency() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TArch::set_has_frequency() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TArch::clear_has_frequency() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TArch::clear_frequency() {
  frequency_ = 0;
  clear_has_frequency();
}
inline double TArch::frequency() const {
  return frequency_;
}
inline void TArch::set_frequency(double value) {
  set_has_frequency();
  frequency_ = value;
}

// optional double start = 4;
inline bool TArch::has_start() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TArch::set_has_start() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TArch::clear_has_start() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TArch::clear_start() {
  start_ = 0;
  clear_has_start();
}
inline double TArch::start() const {
  return start_;
}
inline void TArch::set_start(double value) {
  set_has_start();
  start_ = value;
}

// optional double startf = 5;
inline bool TArch::has_startf() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TArch::set_has_startf() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TArch::clear_has_startf() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TArch::clear_startf() {
  startf_ = 0;
  clear_has_startf();
}
inline double TArch::startf() const {
  return startf_;
}
inline void TArch::set_startf(double value) {
  set_has_startf();
  startf_ = value;
}

// optional double tasknum = 6;
inline bool TArch::has_tasknum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TArch::set_has_tasknum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TArch::clear_has_tasknum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TArch::clear_tasknum() {
  tasknum_ = 0;
  clear_has_tasknum();
}
inline double TArch::tasknum() const {
  return tasknum_;
}
inline void TArch::set_tasknum(double value) {
  set_has_tasknum();
  tasknum_ = value;
}

// optional int32 revid = 7;
inline bool TArch::has_revid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TArch::set_has_revid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TArch::clear_has_revid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TArch::clear_revid() {
  revid_ = 0;
  clear_has_revid();
}
inline ::google::protobuf::int32 TArch::revid() const {
  return revid_;
}
inline void TArch::set_revid(::google::protobuf::int32 value) {
  set_has_revid();
  revid_ = value;
}

// optional double foffset = 8;
inline bool TArch::has_foffset() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TArch::set_has_foffset() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TArch::clear_has_foffset() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TArch::clear_foffset() {
  foffset_ = 0;
  clear_has_foffset();
}
inline double TArch::foffset() const {
  return foffset_;
}
inline void TArch::set_foffset(double value) {
  set_has_foffset();
  foffset_ = value;
}

// -------------------------------------------------------------------

// IQHeaderInfo

// optional string msgName = 1 [default = "IQHEADERINFO"];
inline bool IQHeaderInfo::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IQHeaderInfo::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IQHeaderInfo::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IQHeaderInfo::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& IQHeaderInfo::msgname() const {
  return *msgname_;
}
inline void IQHeaderInfo::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void IQHeaderInfo::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void IQHeaderInfo::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IQHeaderInfo::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* IQHeaderInfo::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void IQHeaderInfo::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional double freqRF = 2;
inline bool IQHeaderInfo::has_freqrf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IQHeaderInfo::set_has_freqrf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IQHeaderInfo::clear_has_freqrf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IQHeaderInfo::clear_freqrf() {
  freqrf_ = 0;
  clear_has_freqrf();
}
inline double IQHeaderInfo::freqrf() const {
  return freqrf_;
}
inline void IQHeaderInfo::set_freqrf(double value) {
  set_has_freqrf();
  freqrf_ = value;
}

// optional string snapid = 3;
inline bool IQHeaderInfo::has_snapid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IQHeaderInfo::set_has_snapid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IQHeaderInfo::clear_has_snapid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IQHeaderInfo::clear_snapid() {
  if (snapid_ != &::google::protobuf::internal::kEmptyString) {
    snapid_->clear();
  }
  clear_has_snapid();
}
inline const ::std::string& IQHeaderInfo::snapid() const {
  return *snapid_;
}
inline void IQHeaderInfo::set_snapid(const ::std::string& value) {
  set_has_snapid();
  if (snapid_ == &::google::protobuf::internal::kEmptyString) {
    snapid_ = new ::std::string;
  }
  snapid_->assign(value);
}
inline void IQHeaderInfo::set_snapid(const char* value) {
  set_has_snapid();
  if (snapid_ == &::google::protobuf::internal::kEmptyString) {
    snapid_ = new ::std::string;
  }
  snapid_->assign(value);
}
inline void IQHeaderInfo::set_snapid(const char* value, size_t size) {
  set_has_snapid();
  if (snapid_ == &::google::protobuf::internal::kEmptyString) {
    snapid_ = new ::std::string;
  }
  snapid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IQHeaderInfo::mutable_snapid() {
  set_has_snapid();
  if (snapid_ == &::google::protobuf::internal::kEmptyString) {
    snapid_ = new ::std::string;
  }
  return snapid_;
}
inline ::std::string* IQHeaderInfo::release_snapid() {
  clear_has_snapid();
  if (snapid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = snapid_;
    snapid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IQHeaderInfo::set_allocated_snapid(::std::string* snapid) {
  if (snapid_ != &::google::protobuf::internal::kEmptyString) {
    delete snapid_;
  }
  if (snapid) {
    set_has_snapid();
    snapid_ = snapid;
  } else {
    clear_has_snapid();
    snapid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 revid = 4;
inline bool IQHeaderInfo::has_revid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IQHeaderInfo::set_has_revid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IQHeaderInfo::clear_has_revid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IQHeaderInfo::clear_revid() {
  revid_ = 0;
  clear_has_revid();
}
inline ::google::protobuf::int32 IQHeaderInfo::revid() const {
  return revid_;
}
inline void IQHeaderInfo::set_revid(::google::protobuf::int32 value) {
  set_has_revid();
  revid_ = value;
}

// optional int32 tasknum = 5;
inline bool IQHeaderInfo::has_tasknum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IQHeaderInfo::set_has_tasknum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IQHeaderInfo::clear_has_tasknum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IQHeaderInfo::clear_tasknum() {
  tasknum_ = 0;
  clear_has_tasknum();
}
inline ::google::protobuf::int32 IQHeaderInfo::tasknum() const {
  return tasknum_;
}
inline void IQHeaderInfo::set_tasknum(::google::protobuf::int32 value) {
  set_has_tasknum();
  tasknum_ = value;
}

// optional int32 channel = 6;
inline bool IQHeaderInfo::has_channel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IQHeaderInfo::set_has_channel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IQHeaderInfo::clear_has_channel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IQHeaderInfo::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 IQHeaderInfo::channel() const {
  return channel_;
}
inline void IQHeaderInfo::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// optional string filename = 7;
inline bool IQHeaderInfo::has_filename() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IQHeaderInfo::set_has_filename() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IQHeaderInfo::clear_has_filename() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IQHeaderInfo::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& IQHeaderInfo::filename() const {
  return *filename_;
}
inline void IQHeaderInfo::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void IQHeaderInfo::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void IQHeaderInfo::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IQHeaderInfo::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* IQHeaderInfo::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IQHeaderInfo::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string feedid = 8;
inline bool IQHeaderInfo::has_feedid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IQHeaderInfo::set_has_feedid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IQHeaderInfo::clear_has_feedid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IQHeaderInfo::clear_feedid() {
  if (feedid_ != &::google::protobuf::internal::kEmptyString) {
    feedid_->clear();
  }
  clear_has_feedid();
}
inline const ::std::string& IQHeaderInfo::feedid() const {
  return *feedid_;
}
inline void IQHeaderInfo::set_feedid(const ::std::string& value) {
  set_has_feedid();
  if (feedid_ == &::google::protobuf::internal::kEmptyString) {
    feedid_ = new ::std::string;
  }
  feedid_->assign(value);
}
inline void IQHeaderInfo::set_feedid(const char* value) {
  set_has_feedid();
  if (feedid_ == &::google::protobuf::internal::kEmptyString) {
    feedid_ = new ::std::string;
  }
  feedid_->assign(value);
}
inline void IQHeaderInfo::set_feedid(const char* value, size_t size) {
  set_has_feedid();
  if (feedid_ == &::google::protobuf::internal::kEmptyString) {
    feedid_ = new ::std::string;
  }
  feedid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IQHeaderInfo::mutable_feedid() {
  set_has_feedid();
  if (feedid_ == &::google::protobuf::internal::kEmptyString) {
    feedid_ = new ::std::string;
  }
  return feedid_;
}
inline ::std::string* IQHeaderInfo::release_feedid() {
  clear_has_feedid();
  if (feedid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = feedid_;
    feedid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IQHeaderInfo::set_allocated_feedid(::std::string* feedid) {
  if (feedid_ != &::google::protobuf::internal::kEmptyString) {
    delete feedid_;
  }
  if (feedid) {
    set_has_feedid();
    feedid_ = feedid;
  } else {
    clear_has_feedid();
    feedid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string rcvrid = 9;
inline bool IQHeaderInfo::has_rcvrid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void IQHeaderInfo::set_has_rcvrid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void IQHeaderInfo::clear_has_rcvrid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void IQHeaderInfo::clear_rcvrid() {
  if (rcvrid_ != &::google::protobuf::internal::kEmptyString) {
    rcvrid_->clear();
  }
  clear_has_rcvrid();
}
inline const ::std::string& IQHeaderInfo::rcvrid() const {
  return *rcvrid_;
}
inline void IQHeaderInfo::set_rcvrid(const ::std::string& value) {
  set_has_rcvrid();
  if (rcvrid_ == &::google::protobuf::internal::kEmptyString) {
    rcvrid_ = new ::std::string;
  }
  rcvrid_->assign(value);
}
inline void IQHeaderInfo::set_rcvrid(const char* value) {
  set_has_rcvrid();
  if (rcvrid_ == &::google::protobuf::internal::kEmptyString) {
    rcvrid_ = new ::std::string;
  }
  rcvrid_->assign(value);
}
inline void IQHeaderInfo::set_rcvrid(const char* value, size_t size) {
  set_has_rcvrid();
  if (rcvrid_ == &::google::protobuf::internal::kEmptyString) {
    rcvrid_ = new ::std::string;
  }
  rcvrid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IQHeaderInfo::mutable_rcvrid() {
  set_has_rcvrid();
  if (rcvrid_ == &::google::protobuf::internal::kEmptyString) {
    rcvrid_ = new ::std::string;
  }
  return rcvrid_;
}
inline ::std::string* IQHeaderInfo::release_rcvrid() {
  clear_has_rcvrid();
  if (rcvrid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rcvrid_;
    rcvrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IQHeaderInfo::set_allocated_rcvrid(::std::string* rcvrid) {
  if (rcvrid_ != &::google::protobuf::internal::kEmptyString) {
    delete rcvrid_;
  }
  if (rcvrid) {
    set_has_rcvrid();
    rcvrid_ = rcvrid;
  } else {
    clear_has_rcvrid();
    rcvrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double sample_rate = 10;
inline bool IQHeaderInfo::has_sample_rate() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void IQHeaderInfo::set_has_sample_rate() {
  _has_bits_[0] |= 0x00000200u;
}
inline void IQHeaderInfo::clear_has_sample_rate() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void IQHeaderInfo::clear_sample_rate() {
  sample_rate_ = 0;
  clear_has_sample_rate();
}
inline double IQHeaderInfo::sample_rate() const {
  return sample_rate_;
}
inline void IQHeaderInfo::set_sample_rate(double value) {
  set_has_sample_rate();
  sample_rate_ = value;
}

// optional double duration = 11;
inline bool IQHeaderInfo::has_duration() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void IQHeaderInfo::set_has_duration() {
  _has_bits_[0] |= 0x00000400u;
}
inline void IQHeaderInfo::clear_has_duration() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void IQHeaderInfo::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline double IQHeaderInfo::duration() const {
  return duration_;
}
inline void IQHeaderInfo::set_duration(double value) {
  set_has_duration();
  duration_ = value;
}

// optional string ramsnap_time = 12;
inline bool IQHeaderInfo::has_ramsnap_time() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void IQHeaderInfo::set_has_ramsnap_time() {
  _has_bits_[0] |= 0x00000800u;
}
inline void IQHeaderInfo::clear_has_ramsnap_time() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void IQHeaderInfo::clear_ramsnap_time() {
  if (ramsnap_time_ != &::google::protobuf::internal::kEmptyString) {
    ramsnap_time_->clear();
  }
  clear_has_ramsnap_time();
}
inline const ::std::string& IQHeaderInfo::ramsnap_time() const {
  return *ramsnap_time_;
}
inline void IQHeaderInfo::set_ramsnap_time(const ::std::string& value) {
  set_has_ramsnap_time();
  if (ramsnap_time_ == &::google::protobuf::internal::kEmptyString) {
    ramsnap_time_ = new ::std::string;
  }
  ramsnap_time_->assign(value);
}
inline void IQHeaderInfo::set_ramsnap_time(const char* value) {
  set_has_ramsnap_time();
  if (ramsnap_time_ == &::google::protobuf::internal::kEmptyString) {
    ramsnap_time_ = new ::std::string;
  }
  ramsnap_time_->assign(value);
}
inline void IQHeaderInfo::set_ramsnap_time(const char* value, size_t size) {
  set_has_ramsnap_time();
  if (ramsnap_time_ == &::google::protobuf::internal::kEmptyString) {
    ramsnap_time_ = new ::std::string;
  }
  ramsnap_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IQHeaderInfo::mutable_ramsnap_time() {
  set_has_ramsnap_time();
  if (ramsnap_time_ == &::google::protobuf::internal::kEmptyString) {
    ramsnap_time_ = new ::std::string;
  }
  return ramsnap_time_;
}
inline ::std::string* IQHeaderInfo::release_ramsnap_time() {
  clear_has_ramsnap_time();
  if (ramsnap_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ramsnap_time_;
    ramsnap_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IQHeaderInfo::set_allocated_ramsnap_time(::std::string* ramsnap_time) {
  if (ramsnap_time_ != &::google::protobuf::internal::kEmptyString) {
    delete ramsnap_time_;
  }
  if (ramsnap_time) {
    set_has_ramsnap_time();
    ramsnap_time_ = ramsnap_time;
  } else {
    clear_has_ramsnap_time();
    ramsnap_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string hostname = 13 [default = "None"];
inline bool IQHeaderInfo::has_hostname() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void IQHeaderInfo::set_has_hostname() {
  _has_bits_[0] |= 0x00001000u;
}
inline void IQHeaderInfo::clear_has_hostname() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void IQHeaderInfo::clear_hostname() {
  if (hostname_ != _default_hostname_) {
    hostname_->assign(*_default_hostname_);
  }
  clear_has_hostname();
}
inline const ::std::string& IQHeaderInfo::hostname() const {
  return *hostname_;
}
inline void IQHeaderInfo::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == _default_hostname_) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void IQHeaderInfo::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == _default_hostname_) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void IQHeaderInfo::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == _default_hostname_) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IQHeaderInfo::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == _default_hostname_) {
    hostname_ = new ::std::string(*_default_hostname_);
  }
  return hostname_;
}
inline ::std::string* IQHeaderInfo::release_hostname() {
  clear_has_hostname();
  if (hostname_ == _default_hostname_) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(_default_hostname_);
    return temp;
  }
}
inline void IQHeaderInfo::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != _default_hostname_) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(_default_hostname_);
  }
}

// optional double bandwidth = 14;
inline bool IQHeaderInfo::has_bandwidth() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void IQHeaderInfo::set_has_bandwidth() {
  _has_bits_[0] |= 0x00002000u;
}
inline void IQHeaderInfo::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void IQHeaderInfo::clear_bandwidth() {
  bandwidth_ = 0;
  clear_has_bandwidth();
}
inline double IQHeaderInfo::bandwidth() const {
  return bandwidth_;
}
inline void IQHeaderInfo::set_bandwidth(double value) {
  set_has_bandwidth();
  bandwidth_ = value;
}

// optional bool derived = 15 [default = false];
inline bool IQHeaderInfo::has_derived() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void IQHeaderInfo::set_has_derived() {
  _has_bits_[0] |= 0x00004000u;
}
inline void IQHeaderInfo::clear_has_derived() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void IQHeaderInfo::clear_derived() {
  derived_ = false;
  clear_has_derived();
}
inline bool IQHeaderInfo::derived() const {
  return derived_;
}
inline void IQHeaderInfo::set_derived(bool value) {
  set_has_derived();
  derived_ = value;
}

// optional string parentSnapID = 16;
inline bool IQHeaderInfo::has_parentsnapid() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void IQHeaderInfo::set_has_parentsnapid() {
  _has_bits_[0] |= 0x00008000u;
}
inline void IQHeaderInfo::clear_has_parentsnapid() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void IQHeaderInfo::clear_parentsnapid() {
  if (parentsnapid_ != &::google::protobuf::internal::kEmptyString) {
    parentsnapid_->clear();
  }
  clear_has_parentsnapid();
}
inline const ::std::string& IQHeaderInfo::parentsnapid() const {
  return *parentsnapid_;
}
inline void IQHeaderInfo::set_parentsnapid(const ::std::string& value) {
  set_has_parentsnapid();
  if (parentsnapid_ == &::google::protobuf::internal::kEmptyString) {
    parentsnapid_ = new ::std::string;
  }
  parentsnapid_->assign(value);
}
inline void IQHeaderInfo::set_parentsnapid(const char* value) {
  set_has_parentsnapid();
  if (parentsnapid_ == &::google::protobuf::internal::kEmptyString) {
    parentsnapid_ = new ::std::string;
  }
  parentsnapid_->assign(value);
}
inline void IQHeaderInfo::set_parentsnapid(const char* value, size_t size) {
  set_has_parentsnapid();
  if (parentsnapid_ == &::google::protobuf::internal::kEmptyString) {
    parentsnapid_ = new ::std::string;
  }
  parentsnapid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IQHeaderInfo::mutable_parentsnapid() {
  set_has_parentsnapid();
  if (parentsnapid_ == &::google::protobuf::internal::kEmptyString) {
    parentsnapid_ = new ::std::string;
  }
  return parentsnapid_;
}
inline ::std::string* IQHeaderInfo::release_parentsnapid() {
  clear_has_parentsnapid();
  if (parentsnapid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parentsnapid_;
    parentsnapid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IQHeaderInfo::set_allocated_parentsnapid(::std::string* parentsnapid) {
  if (parentsnapid_ != &::google::protobuf::internal::kEmptyString) {
    delete parentsnapid_;
  }
  if (parentsnapid) {
    set_has_parentsnapid();
    parentsnapid_ = parentsnapid;
  } else {
    clear_has_parentsnapid();
    parentsnapid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string basePath = 17 [default = "/var/lib/kepler/snapshots/"];
inline bool IQHeaderInfo::has_basepath() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void IQHeaderInfo::set_has_basepath() {
  _has_bits_[0] |= 0x00010000u;
}
inline void IQHeaderInfo::clear_has_basepath() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void IQHeaderInfo::clear_basepath() {
  if (basepath_ != _default_basepath_) {
    basepath_->assign(*_default_basepath_);
  }
  clear_has_basepath();
}
inline const ::std::string& IQHeaderInfo::basepath() const {
  return *basepath_;
}
inline void IQHeaderInfo::set_basepath(const ::std::string& value) {
  set_has_basepath();
  if (basepath_ == _default_basepath_) {
    basepath_ = new ::std::string;
  }
  basepath_->assign(value);
}
inline void IQHeaderInfo::set_basepath(const char* value) {
  set_has_basepath();
  if (basepath_ == _default_basepath_) {
    basepath_ = new ::std::string;
  }
  basepath_->assign(value);
}
inline void IQHeaderInfo::set_basepath(const char* value, size_t size) {
  set_has_basepath();
  if (basepath_ == _default_basepath_) {
    basepath_ = new ::std::string;
  }
  basepath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IQHeaderInfo::mutable_basepath() {
  set_has_basepath();
  if (basepath_ == _default_basepath_) {
    basepath_ = new ::std::string(*_default_basepath_);
  }
  return basepath_;
}
inline ::std::string* IQHeaderInfo::release_basepath() {
  clear_has_basepath();
  if (basepath_ == _default_basepath_) {
    return NULL;
  } else {
    ::std::string* temp = basepath_;
    basepath_ = const_cast< ::std::string*>(_default_basepath_);
    return temp;
  }
}
inline void IQHeaderInfo::set_allocated_basepath(::std::string* basepath) {
  if (basepath_ != _default_basepath_) {
    delete basepath_;
  }
  if (basepath) {
    set_has_basepath();
    basepath_ = basepath;
  } else {
    clear_has_basepath();
    basepath_ = const_cast< ::std::string*>(_default_basepath_);
  }
}

// optional string fileExtension = 18 [default = ".tmp"];
inline bool IQHeaderInfo::has_fileextension() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void IQHeaderInfo::set_has_fileextension() {
  _has_bits_[0] |= 0x00020000u;
}
inline void IQHeaderInfo::clear_has_fileextension() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void IQHeaderInfo::clear_fileextension() {
  if (fileextension_ != _default_fileextension_) {
    fileextension_->assign(*_default_fileextension_);
  }
  clear_has_fileextension();
}
inline const ::std::string& IQHeaderInfo::fileextension() const {
  return *fileextension_;
}
inline void IQHeaderInfo::set_fileextension(const ::std::string& value) {
  set_has_fileextension();
  if (fileextension_ == _default_fileextension_) {
    fileextension_ = new ::std::string;
  }
  fileextension_->assign(value);
}
inline void IQHeaderInfo::set_fileextension(const char* value) {
  set_has_fileextension();
  if (fileextension_ == _default_fileextension_) {
    fileextension_ = new ::std::string;
  }
  fileextension_->assign(value);
}
inline void IQHeaderInfo::set_fileextension(const char* value, size_t size) {
  set_has_fileextension();
  if (fileextension_ == _default_fileextension_) {
    fileextension_ = new ::std::string;
  }
  fileextension_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IQHeaderInfo::mutable_fileextension() {
  set_has_fileextension();
  if (fileextension_ == _default_fileextension_) {
    fileextension_ = new ::std::string(*_default_fileextension_);
  }
  return fileextension_;
}
inline ::std::string* IQHeaderInfo::release_fileextension() {
  clear_has_fileextension();
  if (fileextension_ == _default_fileextension_) {
    return NULL;
  } else {
    ::std::string* temp = fileextension_;
    fileextension_ = const_cast< ::std::string*>(_default_fileextension_);
    return temp;
  }
}
inline void IQHeaderInfo::set_allocated_fileextension(::std::string* fileextension) {
  if (fileextension_ != _default_fileextension_) {
    delete fileextension_;
  }
  if (fileextension) {
    set_has_fileextension();
    fileextension_ = fileextension;
  } else {
    clear_has_fileextension();
    fileextension_ = const_cast< ::std::string*>(_default_fileextension_);
  }
}

// optional uint64 fileDataOffset = 51;
inline bool IQHeaderInfo::has_filedataoffset() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void IQHeaderInfo::set_has_filedataoffset() {
  _has_bits_[0] |= 0x00040000u;
}
inline void IQHeaderInfo::clear_has_filedataoffset() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void IQHeaderInfo::clear_filedataoffset() {
  filedataoffset_ = GOOGLE_ULONGLONG(0);
  clear_has_filedataoffset();
}
inline ::google::protobuf::uint64 IQHeaderInfo::filedataoffset() const {
  return filedataoffset_;
}
inline void IQHeaderInfo::set_filedataoffset(::google::protobuf::uint64 value) {
  set_has_filedataoffset();
  filedataoffset_ = value;
}

// optional uint64 fileDataSize = 52;
inline bool IQHeaderInfo::has_filedatasize() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void IQHeaderInfo::set_has_filedatasize() {
  _has_bits_[0] |= 0x00080000u;
}
inline void IQHeaderInfo::clear_has_filedatasize() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void IQHeaderInfo::clear_filedatasize() {
  filedatasize_ = GOOGLE_ULONGLONG(0);
  clear_has_filedatasize();
}
inline ::google::protobuf::uint64 IQHeaderInfo::filedatasize() const {
  return filedatasize_;
}
inline void IQHeaderInfo::set_filedatasize(::google::protobuf::uint64 value) {
  set_has_filedatasize();
  filedatasize_ = value;
}

// -------------------------------------------------------------------

// IQMetaData

// optional double freqCf = 1;
inline bool IQMetaData::has_freqcf() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IQMetaData::set_has_freqcf() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IQMetaData::clear_has_freqcf() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IQMetaData::clear_freqcf() {
  freqcf_ = 0;
  clear_has_freqcf();
}
inline double IQMetaData::freqcf() const {
  return freqcf_;
}
inline void IQMetaData::set_freqcf(double value) {
  set_has_freqcf();
  freqcf_ = value;
}

// optional double freqMin = 2;
inline bool IQMetaData::has_freqmin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IQMetaData::set_has_freqmin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IQMetaData::clear_has_freqmin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IQMetaData::clear_freqmin() {
  freqmin_ = 0;
  clear_has_freqmin();
}
inline double IQMetaData::freqmin() const {
  return freqmin_;
}
inline void IQMetaData::set_freqmin(double value) {
  set_has_freqmin();
  freqmin_ = value;
}

// optional double freqMax = 3;
inline bool IQMetaData::has_freqmax() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IQMetaData::set_has_freqmax() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IQMetaData::clear_has_freqmax() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IQMetaData::clear_freqmax() {
  freqmax_ = 0;
  clear_has_freqmax();
}
inline double IQMetaData::freqmax() const {
  return freqmax_;
}
inline void IQMetaData::set_freqmax(double value) {
  set_has_freqmax();
  freqmax_ = value;
}

// optional double duration = 4;
inline bool IQMetaData::has_duration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IQMetaData::set_has_duration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IQMetaData::clear_has_duration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IQMetaData::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline double IQMetaData::duration() const {
  return duration_;
}
inline void IQMetaData::set_duration(double value) {
  set_has_duration();
  duration_ = value;
}

// optional string ramsnapTime = 5;
inline bool IQMetaData::has_ramsnaptime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IQMetaData::set_has_ramsnaptime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IQMetaData::clear_has_ramsnaptime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IQMetaData::clear_ramsnaptime() {
  if (ramsnaptime_ != &::google::protobuf::internal::kEmptyString) {
    ramsnaptime_->clear();
  }
  clear_has_ramsnaptime();
}
inline const ::std::string& IQMetaData::ramsnaptime() const {
  return *ramsnaptime_;
}
inline void IQMetaData::set_ramsnaptime(const ::std::string& value) {
  set_has_ramsnaptime();
  if (ramsnaptime_ == &::google::protobuf::internal::kEmptyString) {
    ramsnaptime_ = new ::std::string;
  }
  ramsnaptime_->assign(value);
}
inline void IQMetaData::set_ramsnaptime(const char* value) {
  set_has_ramsnaptime();
  if (ramsnaptime_ == &::google::protobuf::internal::kEmptyString) {
    ramsnaptime_ = new ::std::string;
  }
  ramsnaptime_->assign(value);
}
inline void IQMetaData::set_ramsnaptime(const char* value, size_t size) {
  set_has_ramsnaptime();
  if (ramsnaptime_ == &::google::protobuf::internal::kEmptyString) {
    ramsnaptime_ = new ::std::string;
  }
  ramsnaptime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IQMetaData::mutable_ramsnaptime() {
  set_has_ramsnaptime();
  if (ramsnaptime_ == &::google::protobuf::internal::kEmptyString) {
    ramsnaptime_ = new ::std::string;
  }
  return ramsnaptime_;
}
inline ::std::string* IQMetaData::release_ramsnaptime() {
  clear_has_ramsnaptime();
  if (ramsnaptime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ramsnaptime_;
    ramsnaptime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IQMetaData::set_allocated_ramsnaptime(::std::string* ramsnaptime) {
  if (ramsnaptime_ != &::google::protobuf::internal::kEmptyString) {
    delete ramsnaptime_;
  }
  if (ramsnaptime) {
    set_has_ramsnaptime();
    ramsnaptime_ = ramsnaptime;
  } else {
    clear_has_ramsnaptime();
    ramsnaptime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string hostname = 6;
inline bool IQMetaData::has_hostname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IQMetaData::set_has_hostname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IQMetaData::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IQMetaData::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& IQMetaData::hostname() const {
  return *hostname_;
}
inline void IQMetaData::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void IQMetaData::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void IQMetaData::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IQMetaData::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* IQMetaData::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IQMetaData::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string feedId = 7;
inline bool IQMetaData::has_feedid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IQMetaData::set_has_feedid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IQMetaData::clear_has_feedid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IQMetaData::clear_feedid() {
  if (feedid_ != &::google::protobuf::internal::kEmptyString) {
    feedid_->clear();
  }
  clear_has_feedid();
}
inline const ::std::string& IQMetaData::feedid() const {
  return *feedid_;
}
inline void IQMetaData::set_feedid(const ::std::string& value) {
  set_has_feedid();
  if (feedid_ == &::google::protobuf::internal::kEmptyString) {
    feedid_ = new ::std::string;
  }
  feedid_->assign(value);
}
inline void IQMetaData::set_feedid(const char* value) {
  set_has_feedid();
  if (feedid_ == &::google::protobuf::internal::kEmptyString) {
    feedid_ = new ::std::string;
  }
  feedid_->assign(value);
}
inline void IQMetaData::set_feedid(const char* value, size_t size) {
  set_has_feedid();
  if (feedid_ == &::google::protobuf::internal::kEmptyString) {
    feedid_ = new ::std::string;
  }
  feedid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IQMetaData::mutable_feedid() {
  set_has_feedid();
  if (feedid_ == &::google::protobuf::internal::kEmptyString) {
    feedid_ = new ::std::string;
  }
  return feedid_;
}
inline ::std::string* IQMetaData::release_feedid() {
  clear_has_feedid();
  if (feedid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = feedid_;
    feedid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IQMetaData::set_allocated_feedid(::std::string* feedid) {
  if (feedid_ != &::google::protobuf::internal::kEmptyString) {
    delete feedid_;
  }
  if (feedid) {
    set_has_feedid();
    feedid_ = feedid;
  } else {
    clear_has_feedid();
    feedid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string rcvrId = 8;
inline bool IQMetaData::has_rcvrid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IQMetaData::set_has_rcvrid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IQMetaData::clear_has_rcvrid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IQMetaData::clear_rcvrid() {
  if (rcvrid_ != &::google::protobuf::internal::kEmptyString) {
    rcvrid_->clear();
  }
  clear_has_rcvrid();
}
inline const ::std::string& IQMetaData::rcvrid() const {
  return *rcvrid_;
}
inline void IQMetaData::set_rcvrid(const ::std::string& value) {
  set_has_rcvrid();
  if (rcvrid_ == &::google::protobuf::internal::kEmptyString) {
    rcvrid_ = new ::std::string;
  }
  rcvrid_->assign(value);
}
inline void IQMetaData::set_rcvrid(const char* value) {
  set_has_rcvrid();
  if (rcvrid_ == &::google::protobuf::internal::kEmptyString) {
    rcvrid_ = new ::std::string;
  }
  rcvrid_->assign(value);
}
inline void IQMetaData::set_rcvrid(const char* value, size_t size) {
  set_has_rcvrid();
  if (rcvrid_ == &::google::protobuf::internal::kEmptyString) {
    rcvrid_ = new ::std::string;
  }
  rcvrid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IQMetaData::mutable_rcvrid() {
  set_has_rcvrid();
  if (rcvrid_ == &::google::protobuf::internal::kEmptyString) {
    rcvrid_ = new ::std::string;
  }
  return rcvrid_;
}
inline ::std::string* IQMetaData::release_rcvrid() {
  clear_has_rcvrid();
  if (rcvrid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rcvrid_;
    rcvrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IQMetaData::set_allocated_rcvrid(::std::string* rcvrid) {
  if (rcvrid_ != &::google::protobuf::internal::kEmptyString) {
    delete rcvrid_;
  }
  if (rcvrid) {
    set_has_rcvrid();
    rcvrid_ = rcvrid;
  } else {
    clear_has_rcvrid();
    rcvrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SnapInfo

// optional string msgName = 1 [default = "SNAPINFO"];
inline bool SnapInfo::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SnapInfo::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SnapInfo::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SnapInfo::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SnapInfo::msgname() const {
  return *msgname_;
}
inline void SnapInfo::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SnapInfo::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SnapInfo::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SnapInfo::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SnapInfo::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SnapInfo::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional .tuner_msg.IQHeaderInfo IQHeader = 2;
inline bool SnapInfo::has_iqheader() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SnapInfo::set_has_iqheader() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SnapInfo::clear_has_iqheader() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SnapInfo::clear_iqheader() {
  if (iqheader_ != NULL) iqheader_->::tuner_msg::IQHeaderInfo::Clear();
  clear_has_iqheader();
}
inline const ::tuner_msg::IQHeaderInfo& SnapInfo::iqheader() const {
  return iqheader_ != NULL ? *iqheader_ : *default_instance_->iqheader_;
}
inline ::tuner_msg::IQHeaderInfo* SnapInfo::mutable_iqheader() {
  set_has_iqheader();
  if (iqheader_ == NULL) iqheader_ = new ::tuner_msg::IQHeaderInfo;
  return iqheader_;
}
inline ::tuner_msg::IQHeaderInfo* SnapInfo::release_iqheader() {
  clear_has_iqheader();
  ::tuner_msg::IQHeaderInfo* temp = iqheader_;
  iqheader_ = NULL;
  return temp;
}
inline void SnapInfo::set_allocated_iqheader(::tuner_msg::IQHeaderInfo* iqheader) {
  delete iqheader_;
  iqheader_ = iqheader;
  if (iqheader) {
    set_has_iqheader();
  } else {
    clear_has_iqheader();
  }
}

// repeated .tuner_msg.IQHeaderInfo iqHeaders = 3;
inline int SnapInfo::iqheaders_size() const {
  return iqheaders_.size();
}
inline void SnapInfo::clear_iqheaders() {
  iqheaders_.Clear();
}
inline const ::tuner_msg::IQHeaderInfo& SnapInfo::iqheaders(int index) const {
  return iqheaders_.Get(index);
}
inline ::tuner_msg::IQHeaderInfo* SnapInfo::mutable_iqheaders(int index) {
  return iqheaders_.Mutable(index);
}
inline ::tuner_msg::IQHeaderInfo* SnapInfo::add_iqheaders() {
  return iqheaders_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tuner_msg::IQHeaderInfo >&
SnapInfo::iqheaders() const {
  return iqheaders_;
}
inline ::google::protobuf::RepeatedPtrField< ::tuner_msg::IQHeaderInfo >*
SnapInfo::mutable_iqheaders() {
  return &iqheaders_;
}

// optional .tuner_msg.IQMetaData iqMetaData = 4;
inline bool SnapInfo::has_iqmetadata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SnapInfo::set_has_iqmetadata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SnapInfo::clear_has_iqmetadata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SnapInfo::clear_iqmetadata() {
  if (iqmetadata_ != NULL) iqmetadata_->::tuner_msg::IQMetaData::Clear();
  clear_has_iqmetadata();
}
inline const ::tuner_msg::IQMetaData& SnapInfo::iqmetadata() const {
  return iqmetadata_ != NULL ? *iqmetadata_ : *default_instance_->iqmetadata_;
}
inline ::tuner_msg::IQMetaData* SnapInfo::mutable_iqmetadata() {
  set_has_iqmetadata();
  if (iqmetadata_ == NULL) iqmetadata_ = new ::tuner_msg::IQMetaData;
  return iqmetadata_;
}
inline ::tuner_msg::IQMetaData* SnapInfo::release_iqmetadata() {
  clear_has_iqmetadata();
  ::tuner_msg::IQMetaData* temp = iqmetadata_;
  iqmetadata_ = NULL;
  return temp;
}
inline void SnapInfo::set_allocated_iqmetadata(::tuner_msg::IQMetaData* iqmetadata) {
  delete iqmetadata_;
  iqmetadata_ = iqmetadata;
  if (iqmetadata) {
    set_has_iqmetadata();
  } else {
    clear_has_iqmetadata();
  }
}

// -------------------------------------------------------------------

// ChangeTuneRange

// optional string msgName = 1 [default = "CHANGE_TUNE_RANGE"];
inline bool ChangeTuneRange::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeTuneRange::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeTuneRange::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeTuneRange::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ChangeTuneRange::msgname() const {
  return *msgname_;
}
inline void ChangeTuneRange::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ChangeTuneRange::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ChangeTuneRange::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChangeTuneRange::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ChangeTuneRange::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ChangeTuneRange::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 channel = 2 [default = -1];
inline bool ChangeTuneRange::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeTuneRange::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeTuneRange::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeTuneRange::clear_channel() {
  channel_ = -1;
  clear_has_channel();
}
inline ::google::protobuf::int32 ChangeTuneRange::channel() const {
  return channel_;
}
inline void ChangeTuneRange::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// optional int32 appID = 3;
inline bool ChangeTuneRange::has_appid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChangeTuneRange::set_has_appid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChangeTuneRange::clear_has_appid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChangeTuneRange::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 ChangeTuneRange::appid() const {
  return appid_;
}
inline void ChangeTuneRange::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// repeated .tuner_msg.TuneRange tunePlan = 4;
inline int ChangeTuneRange::tuneplan_size() const {
  return tuneplan_.size();
}
inline void ChangeTuneRange::clear_tuneplan() {
  tuneplan_.Clear();
}
inline const ::tuner_msg::TuneRange& ChangeTuneRange::tuneplan(int index) const {
  return tuneplan_.Get(index);
}
inline ::tuner_msg::TuneRange* ChangeTuneRange::mutable_tuneplan(int index) {
  return tuneplan_.Mutable(index);
}
inline ::tuner_msg::TuneRange* ChangeTuneRange::add_tuneplan() {
  return tuneplan_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tuner_msg::TuneRange >&
ChangeTuneRange::tuneplan() const {
  return tuneplan_;
}
inline ::google::protobuf::RepeatedPtrField< ::tuner_msg::TuneRange >*
ChangeTuneRange::mutable_tuneplan() {
  return &tuneplan_;
}

// optional bool allowOverlap = 5 [default = true];
inline bool ChangeTuneRange::has_allowoverlap() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChangeTuneRange::set_has_allowoverlap() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChangeTuneRange::clear_has_allowoverlap() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChangeTuneRange::clear_allowoverlap() {
  allowoverlap_ = true;
  clear_has_allowoverlap();
}
inline bool ChangeTuneRange::allowoverlap() const {
  return allowoverlap_;
}
inline void ChangeTuneRange::set_allowoverlap(bool value) {
  set_has_allowoverlap();
  allowoverlap_ = value;
}

// -------------------------------------------------------------------

// TuneRange

// optional string msgName = 1 [default = "TUNE_RANGE"];
inline bool TuneRange::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TuneRange::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TuneRange::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TuneRange::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& TuneRange::msgname() const {
  return *msgname_;
}
inline void TuneRange::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void TuneRange::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void TuneRange::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TuneRange::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* TuneRange::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void TuneRange::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional double startRf = 2;
inline bool TuneRange::has_startrf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TuneRange::set_has_startrf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TuneRange::clear_has_startrf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TuneRange::clear_startrf() {
  startrf_ = 0;
  clear_has_startrf();
}
inline double TuneRange::startrf() const {
  return startrf_;
}
inline void TuneRange::set_startrf(double value) {
  set_has_startrf();
  startrf_ = value;
}

// optional double endRf = 3;
inline bool TuneRange::has_endrf() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TuneRange::set_has_endrf() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TuneRange::clear_has_endrf() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TuneRange::clear_endrf() {
  endrf_ = 0;
  clear_has_endrf();
}
inline double TuneRange::endrf() const {
  return endrf_;
}
inline void TuneRange::set_endrf(double value) {
  set_has_endrf();
  endrf_ = value;
}

// optional double step = 4;
inline bool TuneRange::has_step() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TuneRange::set_has_step() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TuneRange::clear_has_step() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TuneRange::clear_step() {
  step_ = 0;
  clear_has_step();
}
inline double TuneRange::step() const {
  return step_;
}
inline void TuneRange::set_step(double value) {
  set_has_step();
  step_ = value;
}

// optional double duration = 5;
inline bool TuneRange::has_duration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TuneRange::set_has_duration() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TuneRange::clear_has_duration() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TuneRange::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline double TuneRange::duration() const {
  return duration_;
}
inline void TuneRange::set_duration(double value) {
  set_has_duration();
  duration_ = value;
}

// optional double gain = 6;
inline bool TuneRange::has_gain() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TuneRange::set_has_gain() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TuneRange::clear_has_gain() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TuneRange::clear_gain() {
  gain_ = 0;
  clear_has_gain();
}
inline double TuneRange::gain() const {
  return gain_;
}
inline void TuneRange::set_gain(double value) {
  set_has_gain();
  gain_ = value;
}

// optional int32 atten = 7;
inline bool TuneRange::has_atten() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TuneRange::set_has_atten() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TuneRange::clear_has_atten() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TuneRange::clear_atten() {
  atten_ = 0;
  clear_has_atten();
}
inline ::google::protobuf::int32 TuneRange::atten() const {
  return atten_;
}
inline void TuneRange::set_atten(::google::protobuf::int32 value) {
  set_has_atten();
  atten_ = value;
}

// optional float bwMHz = 8 [default = 20];
inline bool TuneRange::has_bwmhz() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TuneRange::set_has_bwmhz() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TuneRange::clear_has_bwmhz() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TuneRange::clear_bwmhz() {
  bwmhz_ = 20;
  clear_has_bwmhz();
}
inline float TuneRange::bwmhz() const {
  return bwmhz_;
}
inline void TuneRange::set_bwmhz(float value) {
  set_has_bwmhz();
  bwmhz_ = value;
}

// repeated int32 appID = 9;
inline int TuneRange::appid_size() const {
  return appid_.size();
}
inline void TuneRange::clear_appid() {
  appid_.Clear();
}
inline ::google::protobuf::int32 TuneRange::appid(int index) const {
  return appid_.Get(index);
}
inline void TuneRange::set_appid(int index, ::google::protobuf::int32 value) {
  appid_.Set(index, value);
}
inline void TuneRange::add_appid(::google::protobuf::int32 value) {
  appid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TuneRange::appid() const {
  return appid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TuneRange::mutable_appid() {
  return &appid_;
}

// -------------------------------------------------------------------

// ReceiverStatus

// optional string msgName = 1 [default = "RECEIVERSTATUS"];
inline bool ReceiverStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReceiverStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReceiverStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReceiverStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ReceiverStatus::msgname() const {
  return *msgname_;
}
inline void ReceiverStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ReceiverStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ReceiverStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiverStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ReceiverStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ReceiverStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 channel = 2;
inline bool ReceiverStatus::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReceiverStatus::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReceiverStatus::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReceiverStatus::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 ReceiverStatus::channel() const {
  return channel_;
}
inline void ReceiverStatus::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// repeated .tuner_msg.TuneRange tunePlan = 3;
inline int ReceiverStatus::tuneplan_size() const {
  return tuneplan_.size();
}
inline void ReceiverStatus::clear_tuneplan() {
  tuneplan_.Clear();
}
inline const ::tuner_msg::TuneRange& ReceiverStatus::tuneplan(int index) const {
  return tuneplan_.Get(index);
}
inline ::tuner_msg::TuneRange* ReceiverStatus::mutable_tuneplan(int index) {
  return tuneplan_.Mutable(index);
}
inline ::tuner_msg::TuneRange* ReceiverStatus::add_tuneplan() {
  return tuneplan_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tuner_msg::TuneRange >&
ReceiverStatus::tuneplan() const {
  return tuneplan_;
}
inline ::google::protobuf::RepeatedPtrField< ::tuner_msg::TuneRange >*
ReceiverStatus::mutable_tuneplan() {
  return &tuneplan_;
}

// optional double currentFrequency = 4;
inline bool ReceiverStatus::has_currentfrequency() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReceiverStatus::set_has_currentfrequency() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReceiverStatus::clear_has_currentfrequency() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReceiverStatus::clear_currentfrequency() {
  currentfrequency_ = 0;
  clear_has_currentfrequency();
}
inline double ReceiverStatus::currentfrequency() const {
  return currentfrequency_;
}
inline void ReceiverStatus::set_currentfrequency(double value) {
  set_has_currentfrequency();
  currentfrequency_ = value;
}

// optional .tuner_msg.ReceiverStatus.Status status = 5 [default = OFF];
inline bool ReceiverStatus::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReceiverStatus::set_has_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReceiverStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReceiverStatus::clear_status() {
  status_ = 3;
  clear_has_status();
}
inline ::tuner_msg::ReceiverStatus_Status ReceiverStatus::status() const {
  return static_cast< ::tuner_msg::ReceiverStatus_Status >(status_);
}
inline void ReceiverStatus::set_status(::tuner_msg::ReceiverStatus_Status value) {
  assert(::tuner_msg::ReceiverStatus_Status_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// QueryReceiverStatus

// optional string msgName = 1 [default = "QUERYRECEIVERSTATUS"];
inline bool QueryReceiverStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryReceiverStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryReceiverStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryReceiverStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& QueryReceiverStatus::msgname() const {
  return *msgname_;
}
inline void QueryReceiverStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void QueryReceiverStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void QueryReceiverStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryReceiverStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* QueryReceiverStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void QueryReceiverStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 channel = 2;
inline bool QueryReceiverStatus::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryReceiverStatus::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryReceiverStatus::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryReceiverStatus::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 QueryReceiverStatus::channel() const {
  return channel_;
}
inline void QueryReceiverStatus::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// -------------------------------------------------------------------

// TimingCheck

// optional string msgName = 1 [default = "TIMINGCHECK"];
inline bool TimingCheck::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimingCheck::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimingCheck::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimingCheck::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& TimingCheck::msgname() const {
  return *msgname_;
}
inline void TimingCheck::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void TimingCheck::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void TimingCheck::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TimingCheck::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* TimingCheck::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void TimingCheck::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 channel = 2;
inline bool TimingCheck::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimingCheck::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimingCheck::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimingCheck::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 TimingCheck::channel() const {
  return channel_;
}
inline void TimingCheck::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// optional string timing = 3;
inline bool TimingCheck::has_timing() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TimingCheck::set_has_timing() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TimingCheck::clear_has_timing() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TimingCheck::clear_timing() {
  if (timing_ != &::google::protobuf::internal::kEmptyString) {
    timing_->clear();
  }
  clear_has_timing();
}
inline const ::std::string& TimingCheck::timing() const {
  return *timing_;
}
inline void TimingCheck::set_timing(const ::std::string& value) {
  set_has_timing();
  if (timing_ == &::google::protobuf::internal::kEmptyString) {
    timing_ = new ::std::string;
  }
  timing_->assign(value);
}
inline void TimingCheck::set_timing(const char* value) {
  set_has_timing();
  if (timing_ == &::google::protobuf::internal::kEmptyString) {
    timing_ = new ::std::string;
  }
  timing_->assign(value);
}
inline void TimingCheck::set_timing(const char* value, size_t size) {
  set_has_timing();
  if (timing_ == &::google::protobuf::internal::kEmptyString) {
    timing_ = new ::std::string;
  }
  timing_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TimingCheck::mutable_timing() {
  set_has_timing();
  if (timing_ == &::google::protobuf::internal::kEmptyString) {
    timing_ = new ::std::string;
  }
  return timing_;
}
inline ::std::string* TimingCheck::release_timing() {
  clear_has_timing();
  if (timing_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timing_;
    timing_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TimingCheck::set_allocated_timing(::std::string* timing) {
  if (timing_ != &::google::protobuf::internal::kEmptyString) {
    delete timing_;
  }
  if (timing) {
    set_has_timing();
    timing_ = timing;
  } else {
    clear_has_timing();
    timing_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DwellScan

// optional string msgName = 1 [default = "DWELLSCAN"];
inline bool DwellScan::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DwellScan::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DwellScan::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DwellScan::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& DwellScan::msgname() const {
  return *msgname_;
}
inline void DwellScan::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void DwellScan::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void DwellScan::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DwellScan::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* DwellScan::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void DwellScan::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 channel = 2;
inline bool DwellScan::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DwellScan::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DwellScan::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DwellScan::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 DwellScan::channel() const {
  return channel_;
}
inline void DwellScan::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// optional float freqMHz = 3;
inline bool DwellScan::has_freqmhz() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DwellScan::set_has_freqmhz() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DwellScan::clear_has_freqmhz() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DwellScan::clear_freqmhz() {
  freqmhz_ = 0;
  clear_has_freqmhz();
}
inline float DwellScan::freqmhz() const {
  return freqmhz_;
}
inline void DwellScan::set_freqmhz(float value) {
  set_has_freqmhz();
  freqmhz_ = value;
}

// optional float gaindB = 4;
inline bool DwellScan::has_gaindb() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DwellScan::set_has_gaindb() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DwellScan::clear_has_gaindb() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DwellScan::clear_gaindb() {
  gaindb_ = 0;
  clear_has_gaindb();
}
inline float DwellScan::gaindb() const {
  return gaindb_;
}
inline void DwellScan::set_gaindb(float value) {
  set_has_gaindb();
  gaindb_ = value;
}

// optional float bwMHz = 5 [default = 20];
inline bool DwellScan::has_bwmhz() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DwellScan::set_has_bwmhz() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DwellScan::clear_has_bwmhz() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DwellScan::clear_bwmhz() {
  bwmhz_ = 20;
  clear_has_bwmhz();
}
inline float DwellScan::bwmhz() const {
  return bwmhz_;
}
inline void DwellScan::set_bwmhz(float value) {
  set_has_bwmhz();
  bwmhz_ = value;
}

// optional float duration = 6 [default = -1];
inline bool DwellScan::has_duration() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DwellScan::set_has_duration() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DwellScan::clear_has_duration() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DwellScan::clear_duration() {
  duration_ = -1;
  clear_has_duration();
}
inline float DwellScan::duration() const {
  return duration_;
}
inline void DwellScan::set_duration(float value) {
  set_has_duration();
  duration_ = value;
}

// optional .tuner_msg.DwellScan.State state = 7 [default = DWELL];
inline bool DwellScan::has_state() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DwellScan::set_has_state() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DwellScan::clear_has_state() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DwellScan::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::tuner_msg::DwellScan_State DwellScan::state() const {
  return static_cast< ::tuner_msg::DwellScan_State >(state_);
}
inline void DwellScan::set_state(::tuner_msg::DwellScan_State value) {
  assert(::tuner_msg::DwellScan_State_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional int32 appID = 8;
inline bool DwellScan::has_appid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DwellScan::set_has_appid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DwellScan::clear_has_appid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DwellScan::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 DwellScan::appid() const {
  return appid_;
}
inline void DwellScan::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional bool mergeFile = 9 [default = false];
inline bool DwellScan::has_mergefile() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DwellScan::set_has_mergefile() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DwellScan::clear_has_mergefile() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DwellScan::clear_mergefile() {
  mergefile_ = false;
  clear_has_mergefile();
}
inline bool DwellScan::mergefile() const {
  return mergefile_;
}
inline void DwellScan::set_mergefile(bool value) {
  set_has_mergefile();
  mergefile_ = value;
}

// optional .tuner_msg.DwellScan.GainMode gainMode = 10 [default = AGC];
inline bool DwellScan::has_gainmode() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DwellScan::set_has_gainmode() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DwellScan::clear_has_gainmode() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DwellScan::clear_gainmode() {
  gainmode_ = 0;
  clear_has_gainmode();
}
inline ::tuner_msg::DwellScan_GainMode DwellScan::gainmode() const {
  return static_cast< ::tuner_msg::DwellScan_GainMode >(gainmode_);
}
inline void DwellScan::set_gainmode(::tuner_msg::DwellScan_GainMode value) {
  assert(::tuner_msg::DwellScan_GainMode_IsValid(value));
  set_has_gainmode();
  gainmode_ = value;
}

// optional string hostname = 11 [default = "None"];
inline bool DwellScan::has_hostname() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DwellScan::set_has_hostname() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DwellScan::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DwellScan::clear_hostname() {
  if (hostname_ != _default_hostname_) {
    hostname_->assign(*_default_hostname_);
  }
  clear_has_hostname();
}
inline const ::std::string& DwellScan::hostname() const {
  return *hostname_;
}
inline void DwellScan::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == _default_hostname_) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void DwellScan::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == _default_hostname_) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void DwellScan::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == _default_hostname_) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DwellScan::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == _default_hostname_) {
    hostname_ = new ::std::string(*_default_hostname_);
  }
  return hostname_;
}
inline ::std::string* DwellScan::release_hostname() {
  clear_has_hostname();
  if (hostname_ == _default_hostname_) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(_default_hostname_);
    return temp;
  }
}
inline void DwellScan::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != _default_hostname_) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(_default_hostname_);
  }
}

// -------------------------------------------------------------------

// TxTune

// optional string msgName = 1 [default = "TXTUNE"];
inline bool TxTune::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxTune::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxTune::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxTune::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& TxTune::msgname() const {
  return *msgname_;
}
inline void TxTune::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void TxTune::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void TxTune::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxTune::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* TxTune::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void TxTune::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional bool state = 2;
inline bool TxTune::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxTune::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxTune::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxTune::clear_state() {
  state_ = false;
  clear_has_state();
}
inline bool TxTune::state() const {
  return state_;
}
inline void TxTune::set_state(bool value) {
  set_has_state();
  state_ = value;
}

// optional int32 channel = 3;
inline bool TxTune::has_channel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxTune::set_has_channel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxTune::clear_has_channel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxTune::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 TxTune::channel() const {
  return channel_;
}
inline void TxTune::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// optional float freqMHz = 4;
inline bool TxTune::has_freqmhz() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TxTune::set_has_freqmhz() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TxTune::clear_has_freqmhz() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TxTune::clear_freqmhz() {
  freqmhz_ = 0;
  clear_has_freqmhz();
}
inline float TxTune::freqmhz() const {
  return freqmhz_;
}
inline void TxTune::set_freqmhz(float value) {
  set_has_freqmhz();
  freqmhz_ = value;
}

// optional float gaindB = 5;
inline bool TxTune::has_gaindb() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TxTune::set_has_gaindb() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TxTune::clear_has_gaindb() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TxTune::clear_gaindb() {
  gaindb_ = 0;
  clear_has_gaindb();
}
inline float TxTune::gaindb() const {
  return gaindb_;
}
inline void TxTune::set_gaindb(float value) {
  set_has_gaindb();
  gaindb_ = value;
}

// optional float sampleRate = 6;
inline bool TxTune::has_samplerate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TxTune::set_has_samplerate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TxTune::clear_has_samplerate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TxTune::clear_samplerate() {
  samplerate_ = 0;
  clear_has_samplerate();
}
inline float TxTune::samplerate() const {
  return samplerate_;
}
inline void TxTune::set_samplerate(float value) {
  set_has_samplerate();
  samplerate_ = value;
}

// optional string config = 7;
inline bool TxTune::has_config() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TxTune::set_has_config() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TxTune::clear_has_config() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TxTune::clear_config() {
  if (config_ != &::google::protobuf::internal::kEmptyString) {
    config_->clear();
  }
  clear_has_config();
}
inline const ::std::string& TxTune::config() const {
  return *config_;
}
inline void TxTune::set_config(const ::std::string& value) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void TxTune::set_config(const char* value) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void TxTune::set_config(const char* value, size_t size) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxTune::mutable_config() {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  return config_;
}
inline ::std::string* TxTune::release_config() {
  clear_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = config_;
    config_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TxTune::set_allocated_config(::std::string* config) {
  if (config_ != &::google::protobuf::internal::kEmptyString) {
    delete config_;
  }
  if (config) {
    set_has_config();
    config_ = config;
  } else {
    clear_has_config();
    config_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool capeState = 8;
inline bool TxTune::has_capestate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TxTune::set_has_capestate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TxTune::clear_has_capestate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TxTune::clear_capestate() {
  capestate_ = false;
  clear_has_capestate();
}
inline bool TxTune::capestate() const {
  return capestate_;
}
inline void TxTune::set_capestate(bool value) {
  set_has_capestate();
  capestate_ = value;
}

// -------------------------------------------------------------------

// ReactiveJam

// optional string msgName = 1 [default = "REACTIVEJAM"];
inline bool ReactiveJam::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReactiveJam::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReactiveJam::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReactiveJam::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ReactiveJam::msgname() const {
  return *msgname_;
}
inline void ReactiveJam::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ReactiveJam::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ReactiveJam::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReactiveJam::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ReactiveJam::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ReactiveJam::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional bool state = 2;
inline bool ReactiveJam::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReactiveJam::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReactiveJam::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReactiveJam::clear_state() {
  state_ = false;
  clear_has_state();
}
inline bool ReactiveJam::state() const {
  return state_;
}
inline void ReactiveJam::set_state(bool value) {
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// diskSnapAvailable

// optional string msgName = 1 [default = "DISKSNAPAVAILABLE"];
inline bool diskSnapAvailable::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void diskSnapAvailable::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void diskSnapAvailable::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void diskSnapAvailable::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& diskSnapAvailable::msgname() const {
  return *msgname_;
}
inline void diskSnapAvailable::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void diskSnapAvailable::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void diskSnapAvailable::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* diskSnapAvailable::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* diskSnapAvailable::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void diskSnapAvailable::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string diskSnapID = 2;
inline bool diskSnapAvailable::has_disksnapid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void diskSnapAvailable::set_has_disksnapid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void diskSnapAvailable::clear_has_disksnapid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void diskSnapAvailable::clear_disksnapid() {
  if (disksnapid_ != &::google::protobuf::internal::kEmptyString) {
    disksnapid_->clear();
  }
  clear_has_disksnapid();
}
inline const ::std::string& diskSnapAvailable::disksnapid() const {
  return *disksnapid_;
}
inline void diskSnapAvailable::set_disksnapid(const ::std::string& value) {
  set_has_disksnapid();
  if (disksnapid_ == &::google::protobuf::internal::kEmptyString) {
    disksnapid_ = new ::std::string;
  }
  disksnapid_->assign(value);
}
inline void diskSnapAvailable::set_disksnapid(const char* value) {
  set_has_disksnapid();
  if (disksnapid_ == &::google::protobuf::internal::kEmptyString) {
    disksnapid_ = new ::std::string;
  }
  disksnapid_->assign(value);
}
inline void diskSnapAvailable::set_disksnapid(const char* value, size_t size) {
  set_has_disksnapid();
  if (disksnapid_ == &::google::protobuf::internal::kEmptyString) {
    disksnapid_ = new ::std::string;
  }
  disksnapid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* diskSnapAvailable::mutable_disksnapid() {
  set_has_disksnapid();
  if (disksnapid_ == &::google::protobuf::internal::kEmptyString) {
    disksnapid_ = new ::std::string;
  }
  return disksnapid_;
}
inline ::std::string* diskSnapAvailable::release_disksnapid() {
  clear_has_disksnapid();
  if (disksnapid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = disksnapid_;
    disksnapid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void diskSnapAvailable::set_allocated_disksnapid(::std::string* disksnapid) {
  if (disksnapid_ != &::google::protobuf::internal::kEmptyString) {
    delete disksnapid_;
  }
  if (disksnapid) {
    set_has_disksnapid();
    disksnapid_ = disksnapid;
  } else {
    clear_has_disksnapid();
    disksnapid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string filename = 3;
inline bool diskSnapAvailable::has_filename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void diskSnapAvailable::set_has_filename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void diskSnapAvailable::clear_has_filename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void diskSnapAvailable::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& diskSnapAvailable::filename() const {
  return *filename_;
}
inline void diskSnapAvailable::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void diskSnapAvailable::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void diskSnapAvailable::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* diskSnapAvailable::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* diskSnapAvailable::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void diskSnapAvailable::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string hostname = 4;
inline bool diskSnapAvailable::has_hostname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void diskSnapAvailable::set_has_hostname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void diskSnapAvailable::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void diskSnapAvailable::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& diskSnapAvailable::hostname() const {
  return *hostname_;
}
inline void diskSnapAvailable::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void diskSnapAvailable::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void diskSnapAvailable::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* diskSnapAvailable::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* diskSnapAvailable::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void diskSnapAvailable::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SnapBroadcast

// optional string msgName = 1 [default = "SNAPBROADCAST"];
inline bool SnapBroadcast::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SnapBroadcast::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SnapBroadcast::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SnapBroadcast::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SnapBroadcast::msgname() const {
  return *msgname_;
}
inline void SnapBroadcast::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SnapBroadcast::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SnapBroadcast::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SnapBroadcast::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SnapBroadcast::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SnapBroadcast::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional float freqMHz = 2;
inline bool SnapBroadcast::has_freqmhz() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SnapBroadcast::set_has_freqmhz() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SnapBroadcast::clear_has_freqmhz() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SnapBroadcast::clear_freqmhz() {
  freqmhz_ = 0;
  clear_has_freqmhz();
}
inline float SnapBroadcast::freqmhz() const {
  return freqmhz_;
}
inline void SnapBroadcast::set_freqmhz(float value) {
  set_has_freqmhz();
  freqmhz_ = value;
}

// optional .tuner_msg.SnapBroadcast.State state = 3 [default = STOP];
inline bool SnapBroadcast::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SnapBroadcast::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SnapBroadcast::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SnapBroadcast::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::tuner_msg::SnapBroadcast_State SnapBroadcast::state() const {
  return static_cast< ::tuner_msg::SnapBroadcast_State >(state_);
}
inline void SnapBroadcast::set_state(::tuner_msg::SnapBroadcast_State value) {
  assert(::tuner_msg::SnapBroadcast_State_IsValid(value));
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// ReceiverRequest

// optional int32 appID = 1;
inline bool ReceiverRequest::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReceiverRequest::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReceiverRequest::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReceiverRequest::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 ReceiverRequest::appid() const {
  return appid_;
}
inline void ReceiverRequest::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// -------------------------------------------------------------------

// ReceiverRelease

// optional int32 appID = 1;
inline bool ReceiverRelease::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReceiverRelease::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReceiverRelease::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReceiverRelease::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 ReceiverRelease::appid() const {
  return appid_;
}
inline void ReceiverRelease::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional int32 channel = 2;
inline bool ReceiverRelease::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReceiverRelease::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReceiverRelease::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReceiverRelease::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 ReceiverRelease::channel() const {
  return channel_;
}
inline void ReceiverRelease::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// -------------------------------------------------------------------

// ReceiverAcquired

// optional int32 appID = 1;
inline bool ReceiverAcquired::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReceiverAcquired::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReceiverAcquired::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReceiverAcquired::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 ReceiverAcquired::appid() const {
  return appid_;
}
inline void ReceiverAcquired::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional int32 channel = 2;
inline bool ReceiverAcquired::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReceiverAcquired::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReceiverAcquired::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReceiverAcquired::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 ReceiverAcquired::channel() const {
  return channel_;
}
inline void ReceiverAcquired::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// -------------------------------------------------------------------

// ReceiverReleased

// optional int32 appID = 1;
inline bool ReceiverReleased::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReceiverReleased::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReceiverReleased::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReceiverReleased::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 ReceiverReleased::appid() const {
  return appid_;
}
inline void ReceiverReleased::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional int32 channel = 2;
inline bool ReceiverReleased::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReceiverReleased::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReceiverReleased::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReceiverReleased::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 ReceiverReleased::channel() const {
  return channel_;
}
inline void ReceiverReleased::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// -------------------------------------------------------------------

// ChangeRXTxConfig

// optional string msgName = 1 [default = "ChangeRXTxConfig"];
inline bool ChangeRXTxConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeRXTxConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeRXTxConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeRXTxConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ChangeRXTxConfig::msgname() const {
  return *msgname_;
}
inline void ChangeRXTxConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ChangeRXTxConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ChangeRXTxConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChangeRXTxConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ChangeRXTxConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ChangeRXTxConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string config = 2 [default = "RCH3"];
inline bool ChangeRXTxConfig::has_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeRXTxConfig::set_has_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeRXTxConfig::clear_has_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeRXTxConfig::clear_config() {
  if (config_ != _default_config_) {
    config_->assign(*_default_config_);
  }
  clear_has_config();
}
inline const ::std::string& ChangeRXTxConfig::config() const {
  return *config_;
}
inline void ChangeRXTxConfig::set_config(const ::std::string& value) {
  set_has_config();
  if (config_ == _default_config_) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void ChangeRXTxConfig::set_config(const char* value) {
  set_has_config();
  if (config_ == _default_config_) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void ChangeRXTxConfig::set_config(const char* value, size_t size) {
  set_has_config();
  if (config_ == _default_config_) {
    config_ = new ::std::string;
  }
  config_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChangeRXTxConfig::mutable_config() {
  set_has_config();
  if (config_ == _default_config_) {
    config_ = new ::std::string(*_default_config_);
  }
  return config_;
}
inline ::std::string* ChangeRXTxConfig::release_config() {
  clear_has_config();
  if (config_ == _default_config_) {
    return NULL;
  } else {
    ::std::string* temp = config_;
    config_ = const_cast< ::std::string*>(_default_config_);
    return temp;
  }
}
inline void ChangeRXTxConfig::set_allocated_config(::std::string* config) {
  if (config_ != _default_config_) {
    delete config_;
  }
  if (config) {
    set_has_config();
    config_ = config;
  } else {
    clear_has_config();
    config_ = const_cast< ::std::string*>(_default_config_);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace tuner_msg

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tuner_msg::ReceiverStatus_Status>() {
  return ::tuner_msg::ReceiverStatus_Status_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tuner_msg::DwellScan_State>() {
  return ::tuner_msg::DwellScan_State_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tuner_msg::DwellScan_GainMode>() {
  return ::tuner_msg::DwellScan_GainMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tuner_msg::SnapBroadcast_State>() {
  return ::tuner_msg::SnapBroadcast_State_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_TunerMessages_2eproto__INCLUDED
