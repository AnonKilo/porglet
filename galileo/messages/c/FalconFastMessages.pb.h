// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FalconFastMessages.proto

#ifndef PROTOBUF_FalconFastMessages_2eproto__INCLUDED
#define PROTOBUF_FalconFastMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace falcon_fast_msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_FalconFastMessages_2eproto();
void protobuf_AssignDesc_FalconFastMessages_2eproto();
void protobuf_ShutdownFile_FalconFastMessages_2eproto();

class AntennaMap;
class SatelliteMap;
class SearchTop;
class StartScan;
class SRAC;
class QSTAT;
class QueryPosist;
class Posist;
class UpdateSOIList;
class UpdateSignal;
class UpdateSignals;
class UpdateFiltList;
class TipDone;
class GlobalSignalAddition;
class AntScnStps;
class AntennaPointInfo;
class Switching;
class UpdateDetectionIDs;
class SnapExtraRequest;
class SnapExtraResponse;

// ===================================================================

class AntennaMap : public ::google::protobuf::Message {
 public:
  AntennaMap();
  virtual ~AntennaMap();

  AntennaMap(const AntennaMap& from);

  inline AntennaMap& operator=(const AntennaMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AntennaMap& default_instance();

  void Swap(AntennaMap* other);

  // implements Message ----------------------------------------------

  AntennaMap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AntennaMap& from);
  void MergeFrom(const AntennaMap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ANTENNA_MAP"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 chan = 2;
  inline bool has_chan() const;
  inline void clear_chan();
  static const int kChanFieldNumber = 2;
  inline ::google::protobuf::int32 chan() const;
  inline void set_chan(::google::protobuf::int32 value);

  // optional int32 ant = 3;
  inline bool has_ant() const;
  inline void clear_ant();
  static const int kAntFieldNumber = 3;
  inline ::google::protobuf::int32 ant() const;
  inline void set_ant(::google::protobuf::int32 value);

  // optional int32 mode = 4;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 4;
  inline ::google::protobuf::int32 mode() const;
  inline void set_mode(::google::protobuf::int32 value);

  // optional int32 slaved_to = 5;
  inline bool has_slaved_to() const;
  inline void clear_slaved_to();
  static const int kSlavedToFieldNumber = 5;
  inline ::google::protobuf::int32 slaved_to() const;
  inline void set_slaved_to(::google::protobuf::int32 value);

  // optional double min_freq = 6;
  inline bool has_min_freq() const;
  inline void clear_min_freq();
  static const int kMinFreqFieldNumber = 6;
  inline double min_freq() const;
  inline void set_min_freq(double value);

  // optional double max_freq = 7;
  inline bool has_max_freq() const;
  inline void clear_max_freq();
  static const int kMaxFreqFieldNumber = 7;
  inline double max_freq() const;
  inline void set_max_freq(double value);

  // optional int32 type = 8;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 8;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional float dwncnvt_lo = 9;
  inline bool has_dwncnvt_lo() const;
  inline void clear_dwncnvt_lo();
  static const int kDwncnvtLoFieldNumber = 9;
  inline float dwncnvt_lo() const;
  inline void set_dwncnvt_lo(float value);

  // optional float beamwidth = 10;
  inline bool has_beamwidth() const;
  inline void clear_beamwidth();
  static const int kBeamwidthFieldNumber = 10;
  inline float beamwidth() const;
  inline void set_beamwidth(float value);

  // optional string ant_name = 11;
  inline bool has_ant_name() const;
  inline void clear_ant_name();
  static const int kAntNameFieldNumber = 11;
  inline const ::std::string& ant_name() const;
  inline void set_ant_name(const ::std::string& value);
  inline void set_ant_name(const char* value);
  inline void set_ant_name(const char* value, size_t size);
  inline ::std::string* mutable_ant_name();
  inline ::std::string* release_ant_name();
  inline void set_allocated_ant_name(::std::string* ant_name);

  // optional double ant_angle = 12;
  inline bool has_ant_angle() const;
  inline void clear_ant_angle();
  static const int kAntAngleFieldNumber = 12;
  inline double ant_angle() const;
  inline void set_ant_angle(double value);

  // optional double ant_el = 13;
  inline bool has_ant_el() const;
  inline void clear_ant_el();
  static const int kAntElFieldNumber = 13;
  inline double ant_el() const;
  inline void set_ant_el(double value);

  // @@protoc_insertion_point(class_scope:falcon_fast_msg.AntennaMap)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_chan();
  inline void clear_has_chan();
  inline void set_has_ant();
  inline void clear_has_ant();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_slaved_to();
  inline void clear_has_slaved_to();
  inline void set_has_min_freq();
  inline void clear_has_min_freq();
  inline void set_has_max_freq();
  inline void clear_has_max_freq();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_dwncnvt_lo();
  inline void clear_has_dwncnvt_lo();
  inline void set_has_beamwidth();
  inline void clear_has_beamwidth();
  inline void set_has_ant_name();
  inline void clear_has_ant_name();
  inline void set_has_ant_angle();
  inline void clear_has_ant_angle();
  inline void set_has_ant_el();
  inline void clear_has_ant_el();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 chan_;
  ::google::protobuf::int32 ant_;
  ::google::protobuf::int32 mode_;
  ::google::protobuf::int32 slaved_to_;
  double min_freq_;
  double max_freq_;
  ::google::protobuf::int32 type_;
  float dwncnvt_lo_;
  ::std::string* ant_name_;
  double ant_angle_;
  double ant_el_;
  float beamwidth_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_FalconFastMessages_2eproto();
  friend void protobuf_AssignDesc_FalconFastMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconFastMessages_2eproto();

  void InitAsDefaultInstance();
  static AntennaMap* default_instance_;
};
// -------------------------------------------------------------------

class SatelliteMap : public ::google::protobuf::Message {
 public:
  SatelliteMap();
  virtual ~SatelliteMap();

  SatelliteMap(const SatelliteMap& from);

  inline SatelliteMap& operator=(const SatelliteMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SatelliteMap& default_instance();

  void Swap(SatelliteMap* other);

  // implements Message ----------------------------------------------

  SatelliteMap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SatelliteMap& from);
  void MergeFrom(const SatelliteMap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SATELLITE_MAP"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 chan = 2;
  inline bool has_chan() const;
  inline void clear_chan();
  static const int kChanFieldNumber = 2;
  inline ::google::protobuf::int32 chan() const;
  inline void set_chan(::google::protobuf::int32 value);

  // optional int32 ant = 3;
  inline bool has_ant() const;
  inline void clear_ant();
  static const int kAntFieldNumber = 3;
  inline ::google::protobuf::int32 ant() const;
  inline void set_ant(::google::protobuf::int32 value);

  // optional double min_freq = 4;
  inline bool has_min_freq() const;
  inline void clear_min_freq();
  static const int kMinFreqFieldNumber = 4;
  inline double min_freq() const;
  inline void set_min_freq(double value);

  // optional double max_freq = 5;
  inline bool has_max_freq() const;
  inline void clear_max_freq();
  static const int kMaxFreqFieldNumber = 5;
  inline double max_freq() const;
  inline void set_max_freq(double value);

  // optional int32 type = 6;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 6;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional float dwncnvt_lo = 7;
  inline bool has_dwncnvt_lo() const;
  inline void clear_dwncnvt_lo();
  static const int kDwncnvtLoFieldNumber = 7;
  inline float dwncnvt_lo() const;
  inline void set_dwncnvt_lo(float value);

  // optional string satname = 8;
  inline bool has_satname() const;
  inline void clear_satname();
  static const int kSatnameFieldNumber = 8;
  inline const ::std::string& satname() const;
  inline void set_satname(const ::std::string& value);
  inline void set_satname(const char* value);
  inline void set_satname(const char* value, size_t size);
  inline ::std::string* mutable_satname();
  inline ::std::string* release_satname();
  inline void set_allocated_satname(::std::string* satname);

  // optional int32 ssc = 9;
  inline bool has_ssc() const;
  inline void clear_ssc();
  static const int kSscFieldNumber = 9;
  inline ::google::protobuf::int32 ssc() const;
  inline void set_ssc(::google::protobuf::int32 value);

  // optional string band = 10;
  inline bool has_band() const;
  inline void clear_band();
  static const int kBandFieldNumber = 10;
  inline const ::std::string& band() const;
  inline void set_band(const ::std::string& value);
  inline void set_band(const char* value);
  inline void set_band(const char* value, size_t size);
  inline ::std::string* mutable_band();
  inline ::std::string* release_band();
  inline void set_allocated_band(::std::string* band);

  // optional string pol = 11;
  inline bool has_pol() const;
  inline void clear_pol();
  static const int kPolFieldNumber = 11;
  inline const ::std::string& pol() const;
  inline void set_pol(const ::std::string& value);
  inline void set_pol(const char* value);
  inline void set_pol(const char* value, size_t size);
  inline ::std::string* mutable_pol();
  inline ::std::string* release_pol();
  inline void set_allocated_pol(::std::string* pol);

  // @@protoc_insertion_point(class_scope:falcon_fast_msg.SatelliteMap)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_chan();
  inline void clear_has_chan();
  inline void set_has_ant();
  inline void clear_has_ant();
  inline void set_has_min_freq();
  inline void clear_has_min_freq();
  inline void set_has_max_freq();
  inline void clear_has_max_freq();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_dwncnvt_lo();
  inline void clear_has_dwncnvt_lo();
  inline void set_has_satname();
  inline void clear_has_satname();
  inline void set_has_ssc();
  inline void clear_has_ssc();
  inline void set_has_band();
  inline void clear_has_band();
  inline void set_has_pol();
  inline void clear_has_pol();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 chan_;
  ::google::protobuf::int32 ant_;
  double min_freq_;
  double max_freq_;
  ::google::protobuf::int32 type_;
  float dwncnvt_lo_;
  ::std::string* satname_;
  ::std::string* band_;
  ::std::string* pol_;
  ::google::protobuf::int32 ssc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_FalconFastMessages_2eproto();
  friend void protobuf_AssignDesc_FalconFastMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconFastMessages_2eproto();

  void InitAsDefaultInstance();
  static SatelliteMap* default_instance_;
};
// -------------------------------------------------------------------

class SearchTop : public ::google::protobuf::Message {
 public:
  SearchTop();
  virtual ~SearchTop();

  SearchTop(const SearchTop& from);

  inline SearchTop& operator=(const SearchTop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchTop& default_instance();

  void Swap(SearchTop* other);

  // implements Message ----------------------------------------------

  SearchTop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SearchTop& from);
  void MergeFrom(const SearchTop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SEARCH_TOP"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // @@protoc_insertion_point(class_scope:falcon_fast_msg.SearchTop)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_FalconFastMessages_2eproto();
  friend void protobuf_AssignDesc_FalconFastMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconFastMessages_2eproto();

  void InitAsDefaultInstance();
  static SearchTop* default_instance_;
};
// -------------------------------------------------------------------

class StartScan : public ::google::protobuf::Message {
 public:
  StartScan();
  virtual ~StartScan();

  StartScan(const StartScan& from);

  inline StartScan& operator=(const StartScan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartScan& default_instance();

  void Swap(StartScan* other);

  // implements Message ----------------------------------------------

  StartScan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StartScan& from);
  void MergeFrom(const StartScan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "START_SCAN"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // @@protoc_insertion_point(class_scope:falcon_fast_msg.StartScan)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_FalconFastMessages_2eproto();
  friend void protobuf_AssignDesc_FalconFastMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconFastMessages_2eproto();

  void InitAsDefaultInstance();
  static StartScan* default_instance_;
};
// -------------------------------------------------------------------

class SRAC : public ::google::protobuf::Message {
 public:
  SRAC();
  virtual ~SRAC();

  SRAC(const SRAC& from);

  inline SRAC& operator=(const SRAC& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SRAC& default_instance();

  void Swap(SRAC* other);

  // implements Message ----------------------------------------------

  SRAC* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SRAC& from);
  void MergeFrom(const SRAC& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SRAC"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 chan = 2;
  inline bool has_chan() const;
  inline void clear_chan();
  static const int kChanFieldNumber = 2;
  inline ::google::protobuf::int32 chan() const;
  inline void set_chan(::google::protobuf::int32 value);

  // optional int32 action = 3;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 3;
  inline ::google::protobuf::int32 action() const;
  inline void set_action(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_fast_msg.SRAC)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_chan();
  inline void clear_has_chan();
  inline void set_has_action();
  inline void clear_has_action();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 chan_;
  ::google::protobuf::int32 action_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconFastMessages_2eproto();
  friend void protobuf_AssignDesc_FalconFastMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconFastMessages_2eproto();

  void InitAsDefaultInstance();
  static SRAC* default_instance_;
};
// -------------------------------------------------------------------

class QSTAT : public ::google::protobuf::Message {
 public:
  QSTAT();
  virtual ~QSTAT();

  QSTAT(const QSTAT& from);

  inline QSTAT& operator=(const QSTAT& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QSTAT& default_instance();

  void Swap(QSTAT* other);

  // implements Message ----------------------------------------------

  QSTAT* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QSTAT& from);
  void MergeFrom(const QSTAT& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "QSTAT"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_fast_msg.QSTAT)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconFastMessages_2eproto();
  friend void protobuf_AssignDesc_FalconFastMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconFastMessages_2eproto();

  void InitAsDefaultInstance();
  static QSTAT* default_instance_;
};
// -------------------------------------------------------------------

class QueryPosist : public ::google::protobuf::Message {
 public:
  QueryPosist();
  virtual ~QueryPosist();

  QueryPosist(const QueryPosist& from);

  inline QueryPosist& operator=(const QueryPosist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryPosist& default_instance();

  void Swap(QueryPosist* other);

  // implements Message ----------------------------------------------

  QueryPosist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryPosist& from);
  void MergeFrom(const QueryPosist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "QUERY_POSIST"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // @@protoc_insertion_point(class_scope:falcon_fast_msg.QueryPosist)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_FalconFastMessages_2eproto();
  friend void protobuf_AssignDesc_FalconFastMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconFastMessages_2eproto();

  void InitAsDefaultInstance();
  static QueryPosist* default_instance_;
};
// -------------------------------------------------------------------

class Posist : public ::google::protobuf::Message {
 public:
  Posist();
  virtual ~Posist();

  Posist(const Posist& from);

  inline Posist& operator=(const Posist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Posist& default_instance();

  void Swap(Posist* other);

  // implements Message ----------------------------------------------

  Posist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Posist& from);
  void MergeFrom(const Posist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "POSIST"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 chan = 2;
  inline bool has_chan() const;
  inline void clear_chan();
  static const int kChanFieldNumber = 2;
  inline ::google::protobuf::int32 chan() const;
  inline void set_chan(::google::protobuf::int32 value);

  // optional float azimuth = 3;
  inline bool has_azimuth() const;
  inline void clear_azimuth();
  static const int kAzimuthFieldNumber = 3;
  inline float azimuth() const;
  inline void set_azimuth(float value);

  // optional float elevation = 4;
  inline bool has_elevation() const;
  inline void clear_elevation();
  static const int kElevationFieldNumber = 4;
  inline float elevation() const;
  inline void set_elevation(float value);

  // optional float velocity = 5;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 5;
  inline float velocity() const;
  inline void set_velocity(float value);

  // @@protoc_insertion_point(class_scope:falcon_fast_msg.Posist)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_chan();
  inline void clear_has_chan();
  inline void set_has_azimuth();
  inline void clear_has_azimuth();
  inline void set_has_elevation();
  inline void clear_has_elevation();
  inline void set_has_velocity();
  inline void clear_has_velocity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 chan_;
  float azimuth_;
  float elevation_;
  float velocity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_FalconFastMessages_2eproto();
  friend void protobuf_AssignDesc_FalconFastMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconFastMessages_2eproto();

  void InitAsDefaultInstance();
  static Posist* default_instance_;
};
// -------------------------------------------------------------------

class UpdateSOIList : public ::google::protobuf::Message {
 public:
  UpdateSOIList();
  virtual ~UpdateSOIList();

  UpdateSOIList(const UpdateSOIList& from);

  inline UpdateSOIList& operator=(const UpdateSOIList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateSOIList& default_instance();

  void Swap(UpdateSOIList* other);

  // implements Message ----------------------------------------------

  UpdateSOIList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateSOIList& from);
  void MergeFrom(const UpdateSOIList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "UPDATE_SOILIST"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // @@protoc_insertion_point(class_scope:falcon_fast_msg.UpdateSOIList)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_FalconFastMessages_2eproto();
  friend void protobuf_AssignDesc_FalconFastMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconFastMessages_2eproto();

  void InitAsDefaultInstance();
  static UpdateSOIList* default_instance_;
};
// -------------------------------------------------------------------

class UpdateSignal : public ::google::protobuf::Message {
 public:
  UpdateSignal();
  virtual ~UpdateSignal();

  UpdateSignal(const UpdateSignal& from);

  inline UpdateSignal& operator=(const UpdateSignal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateSignal& default_instance();

  void Swap(UpdateSignal* other);

  // implements Message ----------------------------------------------

  UpdateSignal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateSignal& from);
  void MergeFrom(const UpdateSignal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "UPDATE_SIGNAL"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional double startFreq = 2;
  inline bool has_startfreq() const;
  inline void clear_startfreq();
  static const int kStartFreqFieldNumber = 2;
  inline double startfreq() const;
  inline void set_startfreq(double value);

  // optional double stopFreq = 3;
  inline bool has_stopfreq() const;
  inline void clear_stopfreq();
  static const int kStopFreqFieldNumber = 3;
  inline double stopfreq() const;
  inline void set_stopfreq(double value);

  // optional double stepFreq = 4;
  inline bool has_stepfreq() const;
  inline void clear_stepfreq();
  static const int kStepFreqFieldNumber = 4;
  inline double stepfreq() const;
  inline void set_stepfreq(double value);

  // optional double dwell = 5 [default = -1];
  inline bool has_dwell() const;
  inline void clear_dwell();
  static const int kDwellFieldNumber = 5;
  inline double dwell() const;
  inline void set_dwell(double value);

  // optional double threshold = 6 [default = 4];
  inline bool has_threshold() const;
  inline void clear_threshold();
  static const int kThresholdFieldNumber = 6;
  inline double threshold() const;
  inline void set_threshold(double value);

  // @@protoc_insertion_point(class_scope:falcon_fast_msg.UpdateSignal)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_startfreq();
  inline void clear_has_startfreq();
  inline void set_has_stopfreq();
  inline void clear_has_stopfreq();
  inline void set_has_stepfreq();
  inline void clear_has_stepfreq();
  inline void set_has_dwell();
  inline void clear_has_dwell();
  inline void set_has_threshold();
  inline void clear_has_threshold();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  double startfreq_;
  double stopfreq_;
  double stepfreq_;
  double dwell_;
  double threshold_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_FalconFastMessages_2eproto();
  friend void protobuf_AssignDesc_FalconFastMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconFastMessages_2eproto();

  void InitAsDefaultInstance();
  static UpdateSignal* default_instance_;
};
// -------------------------------------------------------------------

class UpdateSignals : public ::google::protobuf::Message {
 public:
  UpdateSignals();
  virtual ~UpdateSignals();

  UpdateSignals(const UpdateSignals& from);

  inline UpdateSignals& operator=(const UpdateSignals& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateSignals& default_instance();

  void Swap(UpdateSignals* other);

  // implements Message ----------------------------------------------

  UpdateSignals* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateSignals& from);
  void MergeFrom(const UpdateSignals& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "UPDATE_SIGNALS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // repeated .falcon_fast_msg.UpdateSignal freqList = 2;
  inline int freqlist_size() const;
  inline void clear_freqlist();
  static const int kFreqListFieldNumber = 2;
  inline const ::falcon_fast_msg::UpdateSignal& freqlist(int index) const;
  inline ::falcon_fast_msg::UpdateSignal* mutable_freqlist(int index);
  inline ::falcon_fast_msg::UpdateSignal* add_freqlist();
  inline const ::google::protobuf::RepeatedPtrField< ::falcon_fast_msg::UpdateSignal >&
      freqlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::falcon_fast_msg::UpdateSignal >*
      mutable_freqlist();

  // optional int32 mode = 3 [default = 0];
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 3;
  inline ::google::protobuf::int32 mode() const;
  inline void set_mode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_fast_msg.UpdateSignals)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_mode();
  inline void clear_has_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::RepeatedPtrField< ::falcon_fast_msg::UpdateSignal > freqlist_;
  ::google::protobuf::int32 mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconFastMessages_2eproto();
  friend void protobuf_AssignDesc_FalconFastMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconFastMessages_2eproto();

  void InitAsDefaultInstance();
  static UpdateSignals* default_instance_;
};
// -------------------------------------------------------------------

class UpdateFiltList : public ::google::protobuf::Message {
 public:
  UpdateFiltList();
  virtual ~UpdateFiltList();

  UpdateFiltList(const UpdateFiltList& from);

  inline UpdateFiltList& operator=(const UpdateFiltList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateFiltList& default_instance();

  void Swap(UpdateFiltList* other);

  // implements Message ----------------------------------------------

  UpdateFiltList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateFiltList& from);
  void MergeFrom(const UpdateFiltList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "UPDATE_FILTLIST"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // @@protoc_insertion_point(class_scope:falcon_fast_msg.UpdateFiltList)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_FalconFastMessages_2eproto();
  friend void protobuf_AssignDesc_FalconFastMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconFastMessages_2eproto();

  void InitAsDefaultInstance();
  static UpdateFiltList* default_instance_;
};
// -------------------------------------------------------------------

class TipDone : public ::google::protobuf::Message {
 public:
  TipDone();
  virtual ~TipDone();

  TipDone(const TipDone& from);

  inline TipDone& operator=(const TipDone& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TipDone& default_instance();

  void Swap(TipDone* other);

  // implements Message ----------------------------------------------

  TipDone* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TipDone& from);
  void MergeFrom(const TipDone& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "TIP_DONE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // @@protoc_insertion_point(class_scope:falcon_fast_msg.TipDone)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_FalconFastMessages_2eproto();
  friend void protobuf_AssignDesc_FalconFastMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconFastMessages_2eproto();

  void InitAsDefaultInstance();
  static TipDone* default_instance_;
};
// -------------------------------------------------------------------

class GlobalSignalAddition : public ::google::protobuf::Message {
 public:
  GlobalSignalAddition();
  virtual ~GlobalSignalAddition();

  GlobalSignalAddition(const GlobalSignalAddition& from);

  inline GlobalSignalAddition& operator=(const GlobalSignalAddition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GlobalSignalAddition& default_instance();

  void Swap(GlobalSignalAddition* other);

  // implements Message ----------------------------------------------

  GlobalSignalAddition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GlobalSignalAddition& from);
  void MergeFrom(const GlobalSignalAddition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "GLOBAL_SIGNAL_ADDITION"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 feed_id = 2;
  inline bool has_feed_id() const;
  inline void clear_feed_id();
  static const int kFeedIdFieldNumber = 2;
  inline ::google::protobuf::int32 feed_id() const;
  inline void set_feed_id(::google::protobuf::int32 value);

  // repeated string uuids = 3;
  inline int uuids_size() const;
  inline void clear_uuids();
  static const int kUuidsFieldNumber = 3;
  inline const ::std::string& uuids(int index) const;
  inline ::std::string* mutable_uuids(int index);
  inline void set_uuids(int index, const ::std::string& value);
  inline void set_uuids(int index, const char* value);
  inline void set_uuids(int index, const char* value, size_t size);
  inline ::std::string* add_uuids();
  inline void add_uuids(const ::std::string& value);
  inline void add_uuids(const char* value);
  inline void add_uuids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& uuids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_uuids();

  // repeated int32 signal_ids = 4;
  inline int signal_ids_size() const;
  inline void clear_signal_ids();
  static const int kSignalIdsFieldNumber = 4;
  inline ::google::protobuf::int32 signal_ids(int index) const;
  inline void set_signal_ids(int index, ::google::protobuf::int32 value);
  inline void add_signal_ids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      signal_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_signal_ids();

  // repeated string old_uuids = 5;
  inline int old_uuids_size() const;
  inline void clear_old_uuids();
  static const int kOldUuidsFieldNumber = 5;
  inline const ::std::string& old_uuids(int index) const;
  inline ::std::string* mutable_old_uuids(int index);
  inline void set_old_uuids(int index, const ::std::string& value);
  inline void set_old_uuids(int index, const char* value);
  inline void set_old_uuids(int index, const char* value, size_t size);
  inline ::std::string* add_old_uuids();
  inline void add_old_uuids(const ::std::string& value);
  inline void add_old_uuids(const char* value);
  inline void add_old_uuids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& old_uuids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_old_uuids();

  // @@protoc_insertion_point(class_scope:falcon_fast_msg.GlobalSignalAddition)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_feed_id();
  inline void clear_has_feed_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::RepeatedPtrField< ::std::string> uuids_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > signal_ids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> old_uuids_;
  ::google::protobuf::int32 feed_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_FalconFastMessages_2eproto();
  friend void protobuf_AssignDesc_FalconFastMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconFastMessages_2eproto();

  void InitAsDefaultInstance();
  static GlobalSignalAddition* default_instance_;
};
// -------------------------------------------------------------------

class AntScnStps : public ::google::protobuf::Message {
 public:
  AntScnStps();
  virtual ~AntScnStps();

  AntScnStps(const AntScnStps& from);

  inline AntScnStps& operator=(const AntScnStps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AntScnStps& default_instance();

  void Swap(AntScnStps* other);

  // implements Message ----------------------------------------------

  AntScnStps* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AntScnStps& from);
  void MergeFrom(const AntScnStps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ANT_SCN_STPS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 appid = 2;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 2;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional int32 steps = 3;
  inline bool has_steps() const;
  inline void clear_steps();
  static const int kStepsFieldNumber = 3;
  inline ::google::protobuf::int32 steps() const;
  inline void set_steps(::google::protobuf::int32 value);

  // optional int32 chan = 4;
  inline bool has_chan() const;
  inline void clear_chan();
  static const int kChanFieldNumber = 4;
  inline ::google::protobuf::int32 chan() const;
  inline void set_chan(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_fast_msg.AntScnStps)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_steps();
  inline void clear_has_steps();
  inline void set_has_chan();
  inline void clear_has_chan();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 appid_;
  ::google::protobuf::int32 steps_;
  ::google::protobuf::int32 chan_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_FalconFastMessages_2eproto();
  friend void protobuf_AssignDesc_FalconFastMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconFastMessages_2eproto();

  void InitAsDefaultInstance();
  static AntScnStps* default_instance_;
};
// -------------------------------------------------------------------

class AntennaPointInfo : public ::google::protobuf::Message {
 public:
  AntennaPointInfo();
  virtual ~AntennaPointInfo();

  AntennaPointInfo(const AntennaPointInfo& from);

  inline AntennaPointInfo& operator=(const AntennaPointInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AntennaPointInfo& default_instance();

  void Swap(AntennaPointInfo* other);

  // implements Message ----------------------------------------------

  AntennaPointInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AntennaPointInfo& from);
  void MergeFrom(const AntennaPointInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ANTENNA_POINT_INFO"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 done = 2;
  inline bool has_done() const;
  inline void clear_done();
  static const int kDoneFieldNumber = 2;
  inline ::google::protobuf::int32 done() const;
  inline void set_done(::google::protobuf::int32 value);

  // optional int32 chan = 3;
  inline bool has_chan() const;
  inline void clear_chan();
  static const int kChanFieldNumber = 3;
  inline ::google::protobuf::int32 chan() const;
  inline void set_chan(::google::protobuf::int32 value);

  // optional float pos = 4;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 4;
  inline float pos() const;
  inline void set_pos(float value);

  // @@protoc_insertion_point(class_scope:falcon_fast_msg.AntennaPointInfo)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_done();
  inline void clear_has_done();
  inline void set_has_chan();
  inline void clear_has_chan();
  inline void set_has_pos();
  inline void clear_has_pos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 done_;
  ::google::protobuf::int32 chan_;
  float pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_FalconFastMessages_2eproto();
  friend void protobuf_AssignDesc_FalconFastMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconFastMessages_2eproto();

  void InitAsDefaultInstance();
  static AntennaPointInfo* default_instance_;
};
// -------------------------------------------------------------------

class Switching : public ::google::protobuf::Message {
 public:
  Switching();
  virtual ~Switching();

  Switching(const Switching& from);

  inline Switching& operator=(const Switching& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Switching& default_instance();

  void Swap(Switching* other);

  // implements Message ----------------------------------------------

  Switching* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Switching& from);
  void MergeFrom(const Switching& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SWITCHING"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // @@protoc_insertion_point(class_scope:falcon_fast_msg.Switching)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_FalconFastMessages_2eproto();
  friend void protobuf_AssignDesc_FalconFastMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconFastMessages_2eproto();

  void InitAsDefaultInstance();
  static Switching* default_instance_;
};
// -------------------------------------------------------------------

class UpdateDetectionIDs : public ::google::protobuf::Message {
 public:
  UpdateDetectionIDs();
  virtual ~UpdateDetectionIDs();

  UpdateDetectionIDs(const UpdateDetectionIDs& from);

  inline UpdateDetectionIDs& operator=(const UpdateDetectionIDs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateDetectionIDs& default_instance();

  void Swap(UpdateDetectionIDs* other);

  // implements Message ----------------------------------------------

  UpdateDetectionIDs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateDetectionIDs& from);
  void MergeFrom(const UpdateDetectionIDs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "UPDATE_DETECTION_IDS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // repeated int32 detIDs = 2;
  inline int detids_size() const;
  inline void clear_detids();
  static const int kDetIDsFieldNumber = 2;
  inline ::google::protobuf::int32 detids(int index) const;
  inline void set_detids(int index, ::google::protobuf::int32 value);
  inline void add_detids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      detids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_detids();

  // optional string filename = 3 [default = ""];
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 3;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional string machine = 4 [default = ""];
  inline bool has_machine() const;
  inline void clear_machine();
  static const int kMachineFieldNumber = 4;
  inline const ::std::string& machine() const;
  inline void set_machine(const ::std::string& value);
  inline void set_machine(const char* value);
  inline void set_machine(const char* value, size_t size);
  inline ::std::string* mutable_machine();
  inline ::std::string* release_machine();
  inline void set_allocated_machine(::std::string* machine);

  // @@protoc_insertion_point(class_scope:falcon_fast_msg.UpdateDetectionIDs)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_machine();
  inline void clear_has_machine();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > detids_;
  ::std::string* filename_;
  ::std::string* machine_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_FalconFastMessages_2eproto();
  friend void protobuf_AssignDesc_FalconFastMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconFastMessages_2eproto();

  void InitAsDefaultInstance();
  static UpdateDetectionIDs* default_instance_;
};
// -------------------------------------------------------------------

class SnapExtraRequest : public ::google::protobuf::Message {
 public:
  SnapExtraRequest();
  virtual ~SnapExtraRequest();

  SnapExtraRequest(const SnapExtraRequest& from);

  inline SnapExtraRequest& operator=(const SnapExtraRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SnapExtraRequest& default_instance();

  void Swap(SnapExtraRequest* other);

  // implements Message ----------------------------------------------

  SnapExtraRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SnapExtraRequest& from);
  void MergeFrom(const SnapExtraRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SNAP_EXTRA_REQUEST"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string archfile = 2;
  inline bool has_archfile() const;
  inline void clear_archfile();
  static const int kArchfileFieldNumber = 2;
  inline const ::std::string& archfile() const;
  inline void set_archfile(const ::std::string& value);
  inline void set_archfile(const char* value);
  inline void set_archfile(const char* value, size_t size);
  inline ::std::string* mutable_archfile();
  inline ::std::string* release_archfile();
  inline void set_allocated_archfile(::std::string* archfile);

  // repeated string tables = 3;
  inline int tables_size() const;
  inline void clear_tables();
  static const int kTablesFieldNumber = 3;
  inline const ::std::string& tables(int index) const;
  inline ::std::string* mutable_tables(int index);
  inline void set_tables(int index, const ::std::string& value);
  inline void set_tables(int index, const char* value);
  inline void set_tables(int index, const char* value, size_t size);
  inline ::std::string* add_tables();
  inline void add_tables(const ::std::string& value);
  inline void add_tables(const char* value);
  inline void add_tables(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tables() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tables();

  // repeated float freq = 4;
  inline int freq_size() const;
  inline void clear_freq();
  static const int kFreqFieldNumber = 4;
  inline float freq(int index) const;
  inline void set_freq(int index, float value);
  inline void add_freq(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      freq() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_freq();

  // repeated float bw = 5;
  inline int bw_size() const;
  inline void clear_bw();
  static const int kBwFieldNumber = 5;
  inline float bw(int index) const;
  inline void set_bw(int index, float value);
  inline void add_bw(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      bw() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_bw();

  // repeated float berth = 6;
  inline int berth_size() const;
  inline void clear_berth();
  static const int kBerthFieldNumber = 6;
  inline float berth(int index) const;
  inline void set_berth(int index, float value);
  inline void add_berth(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      berth() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_berth();

  // repeated int32 nframesth = 7;
  inline int nframesth_size() const;
  inline void clear_nframesth();
  static const int kNframesthFieldNumber = 7;
  inline ::google::protobuf::int32 nframesth(int index) const;
  inline void set_nframesth(int index, ::google::protobuf::int32 value);
  inline void add_nframesth(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      nframesth() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_nframesth();

  // repeated float ratelines = 8;
  inline int ratelines_size() const;
  inline void clear_ratelines();
  static const int kRatelinesFieldNumber = 8;
  inline float ratelines(int index) const;
  inline void set_ratelines(int index, float value);
  inline void add_ratelines(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      ratelines() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_ratelines();

  // repeated float chiprate = 9;
  inline int chiprate_size() const;
  inline void clear_chiprate();
  static const int kChiprateFieldNumber = 9;
  inline float chiprate(int index) const;
  inline void set_chiprate(int index, float value);
  inline void add_chiprate(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      chiprate() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_chiprate();

  // repeated string ofdm_names = 10;
  inline int ofdm_names_size() const;
  inline void clear_ofdm_names();
  static const int kOfdmNamesFieldNumber = 10;
  inline const ::std::string& ofdm_names(int index) const;
  inline ::std::string* mutable_ofdm_names(int index);
  inline void set_ofdm_names(int index, const ::std::string& value);
  inline void set_ofdm_names(int index, const char* value);
  inline void set_ofdm_names(int index, const char* value, size_t size);
  inline ::std::string* add_ofdm_names();
  inline void add_ofdm_names(const ::std::string& value);
  inline void add_ofdm_names(const char* value);
  inline void add_ofdm_names(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& ofdm_names() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ofdm_names();

  // optional int32 uniquefieldthreshold = 11;
  inline bool has_uniquefieldthreshold() const;
  inline void clear_uniquefieldthreshold();
  static const int kUniquefieldthresholdFieldNumber = 11;
  inline ::google::protobuf::int32 uniquefieldthreshold() const;
  inline void set_uniquefieldthreshold(::google::protobuf::int32 value);

  // optional string pristring = 12;
  inline bool has_pristring() const;
  inline void clear_pristring();
  static const int kPristringFieldNumber = 12;
  inline const ::std::string& pristring() const;
  inline void set_pristring(const ::std::string& value);
  inline void set_pristring(const char* value);
  inline void set_pristring(const char* value, size_t size);
  inline ::std::string* mutable_pristring();
  inline ::std::string* release_pristring();
  inline void set_allocated_pristring(::std::string* pristring);

  // optional string mod = 13;
  inline bool has_mod() const;
  inline void clear_mod();
  static const int kModFieldNumber = 13;
  inline const ::std::string& mod() const;
  inline void set_mod(const ::std::string& value);
  inline void set_mod(const char* value);
  inline void set_mod(const char* value, size_t size);
  inline ::std::string* mutable_mod();
  inline ::std::string* release_mod();
  inline void set_allocated_mod(::std::string* mod);

  // optional string revisitID = 14;
  inline bool has_revisitid() const;
  inline void clear_revisitid();
  static const int kRevisitIDFieldNumber = 14;
  inline const ::std::string& revisitid() const;
  inline void set_revisitid(const ::std::string& value);
  inline void set_revisitid(const char* value);
  inline void set_revisitid(const char* value, size_t size);
  inline ::std::string* mutable_revisitid();
  inline ::std::string* release_revisitid();
  inline void set_allocated_revisitid(::std::string* revisitid);

  // @@protoc_insertion_point(class_scope:falcon_fast_msg.SnapExtraRequest)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_archfile();
  inline void clear_has_archfile();
  inline void set_has_uniquefieldthreshold();
  inline void clear_has_uniquefieldthreshold();
  inline void set_has_pristring();
  inline void clear_has_pristring();
  inline void set_has_mod();
  inline void clear_has_mod();
  inline void set_has_revisitid();
  inline void clear_has_revisitid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* archfile_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tables_;
  ::google::protobuf::RepeatedField< float > freq_;
  ::google::protobuf::RepeatedField< float > bw_;
  ::google::protobuf::RepeatedField< float > berth_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > nframesth_;
  ::google::protobuf::RepeatedField< float > ratelines_;
  ::google::protobuf::RepeatedField< float > chiprate_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ofdm_names_;
  ::std::string* pristring_;
  ::std::string* mod_;
  ::std::string* revisitid_;
  ::google::protobuf::int32 uniquefieldthreshold_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_FalconFastMessages_2eproto();
  friend void protobuf_AssignDesc_FalconFastMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconFastMessages_2eproto();

  void InitAsDefaultInstance();
  static SnapExtraRequest* default_instance_;
};
// -------------------------------------------------------------------

class SnapExtraResponse : public ::google::protobuf::Message {
 public:
  SnapExtraResponse();
  virtual ~SnapExtraResponse();

  SnapExtraResponse(const SnapExtraResponse& from);

  inline SnapExtraResponse& operator=(const SnapExtraResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SnapExtraResponse& default_instance();

  void Swap(SnapExtraResponse* other);

  // implements Message ----------------------------------------------

  SnapExtraResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SnapExtraResponse& from);
  void MergeFrom(const SnapExtraResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SNAP_EXTRA_RESPONSE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string revisitID = 2;
  inline bool has_revisitid() const;
  inline void clear_revisitid();
  static const int kRevisitIDFieldNumber = 2;
  inline const ::std::string& revisitid() const;
  inline void set_revisitid(const ::std::string& value);
  inline void set_revisitid(const char* value);
  inline void set_revisitid(const char* value, size_t size);
  inline ::std::string* mutable_revisitid();
  inline ::std::string* release_revisitid();
  inline void set_allocated_revisitid(::std::string* revisitid);

  // optional string response = 3;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 3;
  inline const ::std::string& response() const;
  inline void set_response(const ::std::string& value);
  inline void set_response(const char* value);
  inline void set_response(const char* value, size_t size);
  inline ::std::string* mutable_response();
  inline ::std::string* release_response();
  inline void set_allocated_response(::std::string* response);

  // @@protoc_insertion_point(class_scope:falcon_fast_msg.SnapExtraResponse)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_revisitid();
  inline void clear_has_revisitid();
  inline void set_has_response();
  inline void clear_has_response();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* revisitid_;
  ::std::string* response_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconFastMessages_2eproto();
  friend void protobuf_AssignDesc_FalconFastMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconFastMessages_2eproto();

  void InitAsDefaultInstance();
  static SnapExtraResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// AntennaMap

// optional string msgName = 1 [default = "ANTENNA_MAP"];
inline bool AntennaMap::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AntennaMap::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AntennaMap::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AntennaMap::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& AntennaMap::msgname() const {
  return *msgname_;
}
inline void AntennaMap::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AntennaMap::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AntennaMap::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AntennaMap::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* AntennaMap::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void AntennaMap::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 chan = 2;
inline bool AntennaMap::has_chan() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AntennaMap::set_has_chan() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AntennaMap::clear_has_chan() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AntennaMap::clear_chan() {
  chan_ = 0;
  clear_has_chan();
}
inline ::google::protobuf::int32 AntennaMap::chan() const {
  return chan_;
}
inline void AntennaMap::set_chan(::google::protobuf::int32 value) {
  set_has_chan();
  chan_ = value;
}

// optional int32 ant = 3;
inline bool AntennaMap::has_ant() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AntennaMap::set_has_ant() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AntennaMap::clear_has_ant() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AntennaMap::clear_ant() {
  ant_ = 0;
  clear_has_ant();
}
inline ::google::protobuf::int32 AntennaMap::ant() const {
  return ant_;
}
inline void AntennaMap::set_ant(::google::protobuf::int32 value) {
  set_has_ant();
  ant_ = value;
}

// optional int32 mode = 4;
inline bool AntennaMap::has_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AntennaMap::set_has_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AntennaMap::clear_has_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AntennaMap::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::google::protobuf::int32 AntennaMap::mode() const {
  return mode_;
}
inline void AntennaMap::set_mode(::google::protobuf::int32 value) {
  set_has_mode();
  mode_ = value;
}

// optional int32 slaved_to = 5;
inline bool AntennaMap::has_slaved_to() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AntennaMap::set_has_slaved_to() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AntennaMap::clear_has_slaved_to() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AntennaMap::clear_slaved_to() {
  slaved_to_ = 0;
  clear_has_slaved_to();
}
inline ::google::protobuf::int32 AntennaMap::slaved_to() const {
  return slaved_to_;
}
inline void AntennaMap::set_slaved_to(::google::protobuf::int32 value) {
  set_has_slaved_to();
  slaved_to_ = value;
}

// optional double min_freq = 6;
inline bool AntennaMap::has_min_freq() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AntennaMap::set_has_min_freq() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AntennaMap::clear_has_min_freq() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AntennaMap::clear_min_freq() {
  min_freq_ = 0;
  clear_has_min_freq();
}
inline double AntennaMap::min_freq() const {
  return min_freq_;
}
inline void AntennaMap::set_min_freq(double value) {
  set_has_min_freq();
  min_freq_ = value;
}

// optional double max_freq = 7;
inline bool AntennaMap::has_max_freq() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AntennaMap::set_has_max_freq() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AntennaMap::clear_has_max_freq() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AntennaMap::clear_max_freq() {
  max_freq_ = 0;
  clear_has_max_freq();
}
inline double AntennaMap::max_freq() const {
  return max_freq_;
}
inline void AntennaMap::set_max_freq(double value) {
  set_has_max_freq();
  max_freq_ = value;
}

// optional int32 type = 8;
inline bool AntennaMap::has_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AntennaMap::set_has_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AntennaMap::clear_has_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AntennaMap::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 AntennaMap::type() const {
  return type_;
}
inline void AntennaMap::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional float dwncnvt_lo = 9;
inline bool AntennaMap::has_dwncnvt_lo() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AntennaMap::set_has_dwncnvt_lo() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AntennaMap::clear_has_dwncnvt_lo() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AntennaMap::clear_dwncnvt_lo() {
  dwncnvt_lo_ = 0;
  clear_has_dwncnvt_lo();
}
inline float AntennaMap::dwncnvt_lo() const {
  return dwncnvt_lo_;
}
inline void AntennaMap::set_dwncnvt_lo(float value) {
  set_has_dwncnvt_lo();
  dwncnvt_lo_ = value;
}

// optional float beamwidth = 10;
inline bool AntennaMap::has_beamwidth() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AntennaMap::set_has_beamwidth() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AntennaMap::clear_has_beamwidth() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AntennaMap::clear_beamwidth() {
  beamwidth_ = 0;
  clear_has_beamwidth();
}
inline float AntennaMap::beamwidth() const {
  return beamwidth_;
}
inline void AntennaMap::set_beamwidth(float value) {
  set_has_beamwidth();
  beamwidth_ = value;
}

// optional string ant_name = 11;
inline bool AntennaMap::has_ant_name() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AntennaMap::set_has_ant_name() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AntennaMap::clear_has_ant_name() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AntennaMap::clear_ant_name() {
  if (ant_name_ != &::google::protobuf::internal::kEmptyString) {
    ant_name_->clear();
  }
  clear_has_ant_name();
}
inline const ::std::string& AntennaMap::ant_name() const {
  return *ant_name_;
}
inline void AntennaMap::set_ant_name(const ::std::string& value) {
  set_has_ant_name();
  if (ant_name_ == &::google::protobuf::internal::kEmptyString) {
    ant_name_ = new ::std::string;
  }
  ant_name_->assign(value);
}
inline void AntennaMap::set_ant_name(const char* value) {
  set_has_ant_name();
  if (ant_name_ == &::google::protobuf::internal::kEmptyString) {
    ant_name_ = new ::std::string;
  }
  ant_name_->assign(value);
}
inline void AntennaMap::set_ant_name(const char* value, size_t size) {
  set_has_ant_name();
  if (ant_name_ == &::google::protobuf::internal::kEmptyString) {
    ant_name_ = new ::std::string;
  }
  ant_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AntennaMap::mutable_ant_name() {
  set_has_ant_name();
  if (ant_name_ == &::google::protobuf::internal::kEmptyString) {
    ant_name_ = new ::std::string;
  }
  return ant_name_;
}
inline ::std::string* AntennaMap::release_ant_name() {
  clear_has_ant_name();
  if (ant_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ant_name_;
    ant_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AntennaMap::set_allocated_ant_name(::std::string* ant_name) {
  if (ant_name_ != &::google::protobuf::internal::kEmptyString) {
    delete ant_name_;
  }
  if (ant_name) {
    set_has_ant_name();
    ant_name_ = ant_name;
  } else {
    clear_has_ant_name();
    ant_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double ant_angle = 12;
inline bool AntennaMap::has_ant_angle() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AntennaMap::set_has_ant_angle() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AntennaMap::clear_has_ant_angle() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AntennaMap::clear_ant_angle() {
  ant_angle_ = 0;
  clear_has_ant_angle();
}
inline double AntennaMap::ant_angle() const {
  return ant_angle_;
}
inline void AntennaMap::set_ant_angle(double value) {
  set_has_ant_angle();
  ant_angle_ = value;
}

// optional double ant_el = 13;
inline bool AntennaMap::has_ant_el() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AntennaMap::set_has_ant_el() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AntennaMap::clear_has_ant_el() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AntennaMap::clear_ant_el() {
  ant_el_ = 0;
  clear_has_ant_el();
}
inline double AntennaMap::ant_el() const {
  return ant_el_;
}
inline void AntennaMap::set_ant_el(double value) {
  set_has_ant_el();
  ant_el_ = value;
}

// -------------------------------------------------------------------

// SatelliteMap

// optional string msgName = 1 [default = "SATELLITE_MAP"];
inline bool SatelliteMap::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SatelliteMap::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SatelliteMap::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SatelliteMap::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SatelliteMap::msgname() const {
  return *msgname_;
}
inline void SatelliteMap::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SatelliteMap::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SatelliteMap::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SatelliteMap::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SatelliteMap::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SatelliteMap::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 chan = 2;
inline bool SatelliteMap::has_chan() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SatelliteMap::set_has_chan() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SatelliteMap::clear_has_chan() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SatelliteMap::clear_chan() {
  chan_ = 0;
  clear_has_chan();
}
inline ::google::protobuf::int32 SatelliteMap::chan() const {
  return chan_;
}
inline void SatelliteMap::set_chan(::google::protobuf::int32 value) {
  set_has_chan();
  chan_ = value;
}

// optional int32 ant = 3;
inline bool SatelliteMap::has_ant() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SatelliteMap::set_has_ant() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SatelliteMap::clear_has_ant() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SatelliteMap::clear_ant() {
  ant_ = 0;
  clear_has_ant();
}
inline ::google::protobuf::int32 SatelliteMap::ant() const {
  return ant_;
}
inline void SatelliteMap::set_ant(::google::protobuf::int32 value) {
  set_has_ant();
  ant_ = value;
}

// optional double min_freq = 4;
inline bool SatelliteMap::has_min_freq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SatelliteMap::set_has_min_freq() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SatelliteMap::clear_has_min_freq() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SatelliteMap::clear_min_freq() {
  min_freq_ = 0;
  clear_has_min_freq();
}
inline double SatelliteMap::min_freq() const {
  return min_freq_;
}
inline void SatelliteMap::set_min_freq(double value) {
  set_has_min_freq();
  min_freq_ = value;
}

// optional double max_freq = 5;
inline bool SatelliteMap::has_max_freq() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SatelliteMap::set_has_max_freq() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SatelliteMap::clear_has_max_freq() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SatelliteMap::clear_max_freq() {
  max_freq_ = 0;
  clear_has_max_freq();
}
inline double SatelliteMap::max_freq() const {
  return max_freq_;
}
inline void SatelliteMap::set_max_freq(double value) {
  set_has_max_freq();
  max_freq_ = value;
}

// optional int32 type = 6;
inline bool SatelliteMap::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SatelliteMap::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SatelliteMap::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SatelliteMap::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 SatelliteMap::type() const {
  return type_;
}
inline void SatelliteMap::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional float dwncnvt_lo = 7;
inline bool SatelliteMap::has_dwncnvt_lo() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SatelliteMap::set_has_dwncnvt_lo() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SatelliteMap::clear_has_dwncnvt_lo() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SatelliteMap::clear_dwncnvt_lo() {
  dwncnvt_lo_ = 0;
  clear_has_dwncnvt_lo();
}
inline float SatelliteMap::dwncnvt_lo() const {
  return dwncnvt_lo_;
}
inline void SatelliteMap::set_dwncnvt_lo(float value) {
  set_has_dwncnvt_lo();
  dwncnvt_lo_ = value;
}

// optional string satname = 8;
inline bool SatelliteMap::has_satname() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SatelliteMap::set_has_satname() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SatelliteMap::clear_has_satname() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SatelliteMap::clear_satname() {
  if (satname_ != &::google::protobuf::internal::kEmptyString) {
    satname_->clear();
  }
  clear_has_satname();
}
inline const ::std::string& SatelliteMap::satname() const {
  return *satname_;
}
inline void SatelliteMap::set_satname(const ::std::string& value) {
  set_has_satname();
  if (satname_ == &::google::protobuf::internal::kEmptyString) {
    satname_ = new ::std::string;
  }
  satname_->assign(value);
}
inline void SatelliteMap::set_satname(const char* value) {
  set_has_satname();
  if (satname_ == &::google::protobuf::internal::kEmptyString) {
    satname_ = new ::std::string;
  }
  satname_->assign(value);
}
inline void SatelliteMap::set_satname(const char* value, size_t size) {
  set_has_satname();
  if (satname_ == &::google::protobuf::internal::kEmptyString) {
    satname_ = new ::std::string;
  }
  satname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SatelliteMap::mutable_satname() {
  set_has_satname();
  if (satname_ == &::google::protobuf::internal::kEmptyString) {
    satname_ = new ::std::string;
  }
  return satname_;
}
inline ::std::string* SatelliteMap::release_satname() {
  clear_has_satname();
  if (satname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = satname_;
    satname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SatelliteMap::set_allocated_satname(::std::string* satname) {
  if (satname_ != &::google::protobuf::internal::kEmptyString) {
    delete satname_;
  }
  if (satname) {
    set_has_satname();
    satname_ = satname;
  } else {
    clear_has_satname();
    satname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 ssc = 9;
inline bool SatelliteMap::has_ssc() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SatelliteMap::set_has_ssc() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SatelliteMap::clear_has_ssc() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SatelliteMap::clear_ssc() {
  ssc_ = 0;
  clear_has_ssc();
}
inline ::google::protobuf::int32 SatelliteMap::ssc() const {
  return ssc_;
}
inline void SatelliteMap::set_ssc(::google::protobuf::int32 value) {
  set_has_ssc();
  ssc_ = value;
}

// optional string band = 10;
inline bool SatelliteMap::has_band() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SatelliteMap::set_has_band() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SatelliteMap::clear_has_band() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SatelliteMap::clear_band() {
  if (band_ != &::google::protobuf::internal::kEmptyString) {
    band_->clear();
  }
  clear_has_band();
}
inline const ::std::string& SatelliteMap::band() const {
  return *band_;
}
inline void SatelliteMap::set_band(const ::std::string& value) {
  set_has_band();
  if (band_ == &::google::protobuf::internal::kEmptyString) {
    band_ = new ::std::string;
  }
  band_->assign(value);
}
inline void SatelliteMap::set_band(const char* value) {
  set_has_band();
  if (band_ == &::google::protobuf::internal::kEmptyString) {
    band_ = new ::std::string;
  }
  band_->assign(value);
}
inline void SatelliteMap::set_band(const char* value, size_t size) {
  set_has_band();
  if (band_ == &::google::protobuf::internal::kEmptyString) {
    band_ = new ::std::string;
  }
  band_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SatelliteMap::mutable_band() {
  set_has_band();
  if (band_ == &::google::protobuf::internal::kEmptyString) {
    band_ = new ::std::string;
  }
  return band_;
}
inline ::std::string* SatelliteMap::release_band() {
  clear_has_band();
  if (band_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = band_;
    band_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SatelliteMap::set_allocated_band(::std::string* band) {
  if (band_ != &::google::protobuf::internal::kEmptyString) {
    delete band_;
  }
  if (band) {
    set_has_band();
    band_ = band;
  } else {
    clear_has_band();
    band_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pol = 11;
inline bool SatelliteMap::has_pol() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SatelliteMap::set_has_pol() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SatelliteMap::clear_has_pol() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SatelliteMap::clear_pol() {
  if (pol_ != &::google::protobuf::internal::kEmptyString) {
    pol_->clear();
  }
  clear_has_pol();
}
inline const ::std::string& SatelliteMap::pol() const {
  return *pol_;
}
inline void SatelliteMap::set_pol(const ::std::string& value) {
  set_has_pol();
  if (pol_ == &::google::protobuf::internal::kEmptyString) {
    pol_ = new ::std::string;
  }
  pol_->assign(value);
}
inline void SatelliteMap::set_pol(const char* value) {
  set_has_pol();
  if (pol_ == &::google::protobuf::internal::kEmptyString) {
    pol_ = new ::std::string;
  }
  pol_->assign(value);
}
inline void SatelliteMap::set_pol(const char* value, size_t size) {
  set_has_pol();
  if (pol_ == &::google::protobuf::internal::kEmptyString) {
    pol_ = new ::std::string;
  }
  pol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SatelliteMap::mutable_pol() {
  set_has_pol();
  if (pol_ == &::google::protobuf::internal::kEmptyString) {
    pol_ = new ::std::string;
  }
  return pol_;
}
inline ::std::string* SatelliteMap::release_pol() {
  clear_has_pol();
  if (pol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pol_;
    pol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SatelliteMap::set_allocated_pol(::std::string* pol) {
  if (pol_ != &::google::protobuf::internal::kEmptyString) {
    delete pol_;
  }
  if (pol) {
    set_has_pol();
    pol_ = pol;
  } else {
    clear_has_pol();
    pol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SearchTop

// optional string msgName = 1 [default = "SEARCH_TOP"];
inline bool SearchTop::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchTop::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchTop::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchTop::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SearchTop::msgname() const {
  return *msgname_;
}
inline void SearchTop::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SearchTop::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SearchTop::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchTop::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SearchTop::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SearchTop::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// -------------------------------------------------------------------

// StartScan

// optional string msgName = 1 [default = "START_SCAN"];
inline bool StartScan::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartScan::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartScan::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartScan::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& StartScan::msgname() const {
  return *msgname_;
}
inline void StartScan::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void StartScan::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void StartScan::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StartScan::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* StartScan::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void StartScan::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// -------------------------------------------------------------------

// SRAC

// optional string msgName = 1 [default = "SRAC"];
inline bool SRAC::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SRAC::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SRAC::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SRAC::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SRAC::msgname() const {
  return *msgname_;
}
inline void SRAC::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SRAC::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SRAC::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SRAC::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SRAC::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SRAC::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 chan = 2;
inline bool SRAC::has_chan() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SRAC::set_has_chan() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SRAC::clear_has_chan() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SRAC::clear_chan() {
  chan_ = 0;
  clear_has_chan();
}
inline ::google::protobuf::int32 SRAC::chan() const {
  return chan_;
}
inline void SRAC::set_chan(::google::protobuf::int32 value) {
  set_has_chan();
  chan_ = value;
}

// optional int32 action = 3;
inline bool SRAC::has_action() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SRAC::set_has_action() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SRAC::clear_has_action() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SRAC::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::google::protobuf::int32 SRAC::action() const {
  return action_;
}
inline void SRAC::set_action(::google::protobuf::int32 value) {
  set_has_action();
  action_ = value;
}

// -------------------------------------------------------------------

// QSTAT

// optional string msgName = 1 [default = "QSTAT"];
inline bool QSTAT::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QSTAT::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QSTAT::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QSTAT::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& QSTAT::msgname() const {
  return *msgname_;
}
inline void QSTAT::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void QSTAT::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void QSTAT::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QSTAT::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* QSTAT::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void QSTAT::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 status = 2;
inline bool QSTAT::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QSTAT::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QSTAT::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QSTAT::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 QSTAT::status() const {
  return status_;
}
inline void QSTAT::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// QueryPosist

// optional string msgName = 1 [default = "QUERY_POSIST"];
inline bool QueryPosist::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryPosist::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryPosist::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryPosist::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& QueryPosist::msgname() const {
  return *msgname_;
}
inline void QueryPosist::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void QueryPosist::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void QueryPosist::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryPosist::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* QueryPosist::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void QueryPosist::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// -------------------------------------------------------------------

// Posist

// optional string msgName = 1 [default = "POSIST"];
inline bool Posist::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Posist::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Posist::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Posist::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& Posist::msgname() const {
  return *msgname_;
}
inline void Posist::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void Posist::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void Posist::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Posist::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* Posist::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void Posist::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 chan = 2;
inline bool Posist::has_chan() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Posist::set_has_chan() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Posist::clear_has_chan() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Posist::clear_chan() {
  chan_ = 0;
  clear_has_chan();
}
inline ::google::protobuf::int32 Posist::chan() const {
  return chan_;
}
inline void Posist::set_chan(::google::protobuf::int32 value) {
  set_has_chan();
  chan_ = value;
}

// optional float azimuth = 3;
inline bool Posist::has_azimuth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Posist::set_has_azimuth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Posist::clear_has_azimuth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Posist::clear_azimuth() {
  azimuth_ = 0;
  clear_has_azimuth();
}
inline float Posist::azimuth() const {
  return azimuth_;
}
inline void Posist::set_azimuth(float value) {
  set_has_azimuth();
  azimuth_ = value;
}

// optional float elevation = 4;
inline bool Posist::has_elevation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Posist::set_has_elevation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Posist::clear_has_elevation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Posist::clear_elevation() {
  elevation_ = 0;
  clear_has_elevation();
}
inline float Posist::elevation() const {
  return elevation_;
}
inline void Posist::set_elevation(float value) {
  set_has_elevation();
  elevation_ = value;
}

// optional float velocity = 5;
inline bool Posist::has_velocity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Posist::set_has_velocity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Posist::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Posist::clear_velocity() {
  velocity_ = 0;
  clear_has_velocity();
}
inline float Posist::velocity() const {
  return velocity_;
}
inline void Posist::set_velocity(float value) {
  set_has_velocity();
  velocity_ = value;
}

// -------------------------------------------------------------------

// UpdateSOIList

// optional string msgName = 1 [default = "UPDATE_SOILIST"];
inline bool UpdateSOIList::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateSOIList::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateSOIList::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateSOIList::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& UpdateSOIList::msgname() const {
  return *msgname_;
}
inline void UpdateSOIList::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UpdateSOIList::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UpdateSOIList::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateSOIList::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* UpdateSOIList::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void UpdateSOIList::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// -------------------------------------------------------------------

// UpdateSignal

// optional string msgName = 1 [default = "UPDATE_SIGNAL"];
inline bool UpdateSignal::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateSignal::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateSignal::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateSignal::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& UpdateSignal::msgname() const {
  return *msgname_;
}
inline void UpdateSignal::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UpdateSignal::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UpdateSignal::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateSignal::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* UpdateSignal::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void UpdateSignal::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional double startFreq = 2;
inline bool UpdateSignal::has_startfreq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateSignal::set_has_startfreq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateSignal::clear_has_startfreq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateSignal::clear_startfreq() {
  startfreq_ = 0;
  clear_has_startfreq();
}
inline double UpdateSignal::startfreq() const {
  return startfreq_;
}
inline void UpdateSignal::set_startfreq(double value) {
  set_has_startfreq();
  startfreq_ = value;
}

// optional double stopFreq = 3;
inline bool UpdateSignal::has_stopfreq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateSignal::set_has_stopfreq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateSignal::clear_has_stopfreq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateSignal::clear_stopfreq() {
  stopfreq_ = 0;
  clear_has_stopfreq();
}
inline double UpdateSignal::stopfreq() const {
  return stopfreq_;
}
inline void UpdateSignal::set_stopfreq(double value) {
  set_has_stopfreq();
  stopfreq_ = value;
}

// optional double stepFreq = 4;
inline bool UpdateSignal::has_stepfreq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpdateSignal::set_has_stepfreq() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpdateSignal::clear_has_stepfreq() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpdateSignal::clear_stepfreq() {
  stepfreq_ = 0;
  clear_has_stepfreq();
}
inline double UpdateSignal::stepfreq() const {
  return stepfreq_;
}
inline void UpdateSignal::set_stepfreq(double value) {
  set_has_stepfreq();
  stepfreq_ = value;
}

// optional double dwell = 5 [default = -1];
inline bool UpdateSignal::has_dwell() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UpdateSignal::set_has_dwell() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UpdateSignal::clear_has_dwell() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UpdateSignal::clear_dwell() {
  dwell_ = -1;
  clear_has_dwell();
}
inline double UpdateSignal::dwell() const {
  return dwell_;
}
inline void UpdateSignal::set_dwell(double value) {
  set_has_dwell();
  dwell_ = value;
}

// optional double threshold = 6 [default = 4];
inline bool UpdateSignal::has_threshold() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UpdateSignal::set_has_threshold() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UpdateSignal::clear_has_threshold() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UpdateSignal::clear_threshold() {
  threshold_ = 4;
  clear_has_threshold();
}
inline double UpdateSignal::threshold() const {
  return threshold_;
}
inline void UpdateSignal::set_threshold(double value) {
  set_has_threshold();
  threshold_ = value;
}

// -------------------------------------------------------------------

// UpdateSignals

// optional string msgName = 1 [default = "UPDATE_SIGNALS"];
inline bool UpdateSignals::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateSignals::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateSignals::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateSignals::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& UpdateSignals::msgname() const {
  return *msgname_;
}
inline void UpdateSignals::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UpdateSignals::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UpdateSignals::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateSignals::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* UpdateSignals::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void UpdateSignals::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// repeated .falcon_fast_msg.UpdateSignal freqList = 2;
inline int UpdateSignals::freqlist_size() const {
  return freqlist_.size();
}
inline void UpdateSignals::clear_freqlist() {
  freqlist_.Clear();
}
inline const ::falcon_fast_msg::UpdateSignal& UpdateSignals::freqlist(int index) const {
  return freqlist_.Get(index);
}
inline ::falcon_fast_msg::UpdateSignal* UpdateSignals::mutable_freqlist(int index) {
  return freqlist_.Mutable(index);
}
inline ::falcon_fast_msg::UpdateSignal* UpdateSignals::add_freqlist() {
  return freqlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::falcon_fast_msg::UpdateSignal >&
UpdateSignals::freqlist() const {
  return freqlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::falcon_fast_msg::UpdateSignal >*
UpdateSignals::mutable_freqlist() {
  return &freqlist_;
}

// optional int32 mode = 3 [default = 0];
inline bool UpdateSignals::has_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateSignals::set_has_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateSignals::clear_has_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateSignals::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::google::protobuf::int32 UpdateSignals::mode() const {
  return mode_;
}
inline void UpdateSignals::set_mode(::google::protobuf::int32 value) {
  set_has_mode();
  mode_ = value;
}

// -------------------------------------------------------------------

// UpdateFiltList

// optional string msgName = 1 [default = "UPDATE_FILTLIST"];
inline bool UpdateFiltList::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateFiltList::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateFiltList::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateFiltList::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& UpdateFiltList::msgname() const {
  return *msgname_;
}
inline void UpdateFiltList::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UpdateFiltList::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UpdateFiltList::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateFiltList::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* UpdateFiltList::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void UpdateFiltList::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// -------------------------------------------------------------------

// TipDone

// optional string msgName = 1 [default = "TIP_DONE"];
inline bool TipDone::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TipDone::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TipDone::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TipDone::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& TipDone::msgname() const {
  return *msgname_;
}
inline void TipDone::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void TipDone::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void TipDone::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TipDone::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* TipDone::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void TipDone::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// -------------------------------------------------------------------

// GlobalSignalAddition

// optional string msgName = 1 [default = "GLOBAL_SIGNAL_ADDITION"];
inline bool GlobalSignalAddition::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GlobalSignalAddition::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GlobalSignalAddition::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GlobalSignalAddition::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& GlobalSignalAddition::msgname() const {
  return *msgname_;
}
inline void GlobalSignalAddition::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GlobalSignalAddition::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GlobalSignalAddition::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GlobalSignalAddition::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* GlobalSignalAddition::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void GlobalSignalAddition::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 feed_id = 2;
inline bool GlobalSignalAddition::has_feed_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GlobalSignalAddition::set_has_feed_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GlobalSignalAddition::clear_has_feed_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GlobalSignalAddition::clear_feed_id() {
  feed_id_ = 0;
  clear_has_feed_id();
}
inline ::google::protobuf::int32 GlobalSignalAddition::feed_id() const {
  return feed_id_;
}
inline void GlobalSignalAddition::set_feed_id(::google::protobuf::int32 value) {
  set_has_feed_id();
  feed_id_ = value;
}

// repeated string uuids = 3;
inline int GlobalSignalAddition::uuids_size() const {
  return uuids_.size();
}
inline void GlobalSignalAddition::clear_uuids() {
  uuids_.Clear();
}
inline const ::std::string& GlobalSignalAddition::uuids(int index) const {
  return uuids_.Get(index);
}
inline ::std::string* GlobalSignalAddition::mutable_uuids(int index) {
  return uuids_.Mutable(index);
}
inline void GlobalSignalAddition::set_uuids(int index, const ::std::string& value) {
  uuids_.Mutable(index)->assign(value);
}
inline void GlobalSignalAddition::set_uuids(int index, const char* value) {
  uuids_.Mutable(index)->assign(value);
}
inline void GlobalSignalAddition::set_uuids(int index, const char* value, size_t size) {
  uuids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GlobalSignalAddition::add_uuids() {
  return uuids_.Add();
}
inline void GlobalSignalAddition::add_uuids(const ::std::string& value) {
  uuids_.Add()->assign(value);
}
inline void GlobalSignalAddition::add_uuids(const char* value) {
  uuids_.Add()->assign(value);
}
inline void GlobalSignalAddition::add_uuids(const char* value, size_t size) {
  uuids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GlobalSignalAddition::uuids() const {
  return uuids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GlobalSignalAddition::mutable_uuids() {
  return &uuids_;
}

// repeated int32 signal_ids = 4;
inline int GlobalSignalAddition::signal_ids_size() const {
  return signal_ids_.size();
}
inline void GlobalSignalAddition::clear_signal_ids() {
  signal_ids_.Clear();
}
inline ::google::protobuf::int32 GlobalSignalAddition::signal_ids(int index) const {
  return signal_ids_.Get(index);
}
inline void GlobalSignalAddition::set_signal_ids(int index, ::google::protobuf::int32 value) {
  signal_ids_.Set(index, value);
}
inline void GlobalSignalAddition::add_signal_ids(::google::protobuf::int32 value) {
  signal_ids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GlobalSignalAddition::signal_ids() const {
  return signal_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GlobalSignalAddition::mutable_signal_ids() {
  return &signal_ids_;
}

// repeated string old_uuids = 5;
inline int GlobalSignalAddition::old_uuids_size() const {
  return old_uuids_.size();
}
inline void GlobalSignalAddition::clear_old_uuids() {
  old_uuids_.Clear();
}
inline const ::std::string& GlobalSignalAddition::old_uuids(int index) const {
  return old_uuids_.Get(index);
}
inline ::std::string* GlobalSignalAddition::mutable_old_uuids(int index) {
  return old_uuids_.Mutable(index);
}
inline void GlobalSignalAddition::set_old_uuids(int index, const ::std::string& value) {
  old_uuids_.Mutable(index)->assign(value);
}
inline void GlobalSignalAddition::set_old_uuids(int index, const char* value) {
  old_uuids_.Mutable(index)->assign(value);
}
inline void GlobalSignalAddition::set_old_uuids(int index, const char* value, size_t size) {
  old_uuids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GlobalSignalAddition::add_old_uuids() {
  return old_uuids_.Add();
}
inline void GlobalSignalAddition::add_old_uuids(const ::std::string& value) {
  old_uuids_.Add()->assign(value);
}
inline void GlobalSignalAddition::add_old_uuids(const char* value) {
  old_uuids_.Add()->assign(value);
}
inline void GlobalSignalAddition::add_old_uuids(const char* value, size_t size) {
  old_uuids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GlobalSignalAddition::old_uuids() const {
  return old_uuids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GlobalSignalAddition::mutable_old_uuids() {
  return &old_uuids_;
}

// -------------------------------------------------------------------

// AntScnStps

// optional string msgName = 1 [default = "ANT_SCN_STPS"];
inline bool AntScnStps::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AntScnStps::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AntScnStps::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AntScnStps::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& AntScnStps::msgname() const {
  return *msgname_;
}
inline void AntScnStps::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AntScnStps::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AntScnStps::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AntScnStps::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* AntScnStps::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void AntScnStps::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 appid = 2;
inline bool AntScnStps::has_appid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AntScnStps::set_has_appid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AntScnStps::clear_has_appid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AntScnStps::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 AntScnStps::appid() const {
  return appid_;
}
inline void AntScnStps::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional int32 steps = 3;
inline bool AntScnStps::has_steps() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AntScnStps::set_has_steps() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AntScnStps::clear_has_steps() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AntScnStps::clear_steps() {
  steps_ = 0;
  clear_has_steps();
}
inline ::google::protobuf::int32 AntScnStps::steps() const {
  return steps_;
}
inline void AntScnStps::set_steps(::google::protobuf::int32 value) {
  set_has_steps();
  steps_ = value;
}

// optional int32 chan = 4;
inline bool AntScnStps::has_chan() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AntScnStps::set_has_chan() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AntScnStps::clear_has_chan() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AntScnStps::clear_chan() {
  chan_ = 0;
  clear_has_chan();
}
inline ::google::protobuf::int32 AntScnStps::chan() const {
  return chan_;
}
inline void AntScnStps::set_chan(::google::protobuf::int32 value) {
  set_has_chan();
  chan_ = value;
}

// -------------------------------------------------------------------

// AntennaPointInfo

// optional string msgName = 1 [default = "ANTENNA_POINT_INFO"];
inline bool AntennaPointInfo::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AntennaPointInfo::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AntennaPointInfo::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AntennaPointInfo::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& AntennaPointInfo::msgname() const {
  return *msgname_;
}
inline void AntennaPointInfo::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AntennaPointInfo::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AntennaPointInfo::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AntennaPointInfo::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* AntennaPointInfo::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void AntennaPointInfo::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 done = 2;
inline bool AntennaPointInfo::has_done() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AntennaPointInfo::set_has_done() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AntennaPointInfo::clear_has_done() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AntennaPointInfo::clear_done() {
  done_ = 0;
  clear_has_done();
}
inline ::google::protobuf::int32 AntennaPointInfo::done() const {
  return done_;
}
inline void AntennaPointInfo::set_done(::google::protobuf::int32 value) {
  set_has_done();
  done_ = value;
}

// optional int32 chan = 3;
inline bool AntennaPointInfo::has_chan() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AntennaPointInfo::set_has_chan() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AntennaPointInfo::clear_has_chan() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AntennaPointInfo::clear_chan() {
  chan_ = 0;
  clear_has_chan();
}
inline ::google::protobuf::int32 AntennaPointInfo::chan() const {
  return chan_;
}
inline void AntennaPointInfo::set_chan(::google::protobuf::int32 value) {
  set_has_chan();
  chan_ = value;
}

// optional float pos = 4;
inline bool AntennaPointInfo::has_pos() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AntennaPointInfo::set_has_pos() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AntennaPointInfo::clear_has_pos() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AntennaPointInfo::clear_pos() {
  pos_ = 0;
  clear_has_pos();
}
inline float AntennaPointInfo::pos() const {
  return pos_;
}
inline void AntennaPointInfo::set_pos(float value) {
  set_has_pos();
  pos_ = value;
}

// -------------------------------------------------------------------

// Switching

// optional string msgName = 1 [default = "SWITCHING"];
inline bool Switching::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Switching::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Switching::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Switching::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& Switching::msgname() const {
  return *msgname_;
}
inline void Switching::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void Switching::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void Switching::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Switching::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* Switching::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void Switching::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// -------------------------------------------------------------------

// UpdateDetectionIDs

// optional string msgName = 1 [default = "UPDATE_DETECTION_IDS"];
inline bool UpdateDetectionIDs::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateDetectionIDs::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateDetectionIDs::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateDetectionIDs::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& UpdateDetectionIDs::msgname() const {
  return *msgname_;
}
inline void UpdateDetectionIDs::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UpdateDetectionIDs::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UpdateDetectionIDs::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateDetectionIDs::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* UpdateDetectionIDs::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void UpdateDetectionIDs::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// repeated int32 detIDs = 2;
inline int UpdateDetectionIDs::detids_size() const {
  return detids_.size();
}
inline void UpdateDetectionIDs::clear_detids() {
  detids_.Clear();
}
inline ::google::protobuf::int32 UpdateDetectionIDs::detids(int index) const {
  return detids_.Get(index);
}
inline void UpdateDetectionIDs::set_detids(int index, ::google::protobuf::int32 value) {
  detids_.Set(index, value);
}
inline void UpdateDetectionIDs::add_detids(::google::protobuf::int32 value) {
  detids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
UpdateDetectionIDs::detids() const {
  return detids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
UpdateDetectionIDs::mutable_detids() {
  return &detids_;
}

// optional string filename = 3 [default = ""];
inline bool UpdateDetectionIDs::has_filename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateDetectionIDs::set_has_filename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateDetectionIDs::clear_has_filename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateDetectionIDs::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& UpdateDetectionIDs::filename() const {
  return *filename_;
}
inline void UpdateDetectionIDs::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void UpdateDetectionIDs::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void UpdateDetectionIDs::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateDetectionIDs::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* UpdateDetectionIDs::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UpdateDetectionIDs::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string machine = 4 [default = ""];
inline bool UpdateDetectionIDs::has_machine() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpdateDetectionIDs::set_has_machine() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpdateDetectionIDs::clear_has_machine() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpdateDetectionIDs::clear_machine() {
  if (machine_ != &::google::protobuf::internal::kEmptyString) {
    machine_->clear();
  }
  clear_has_machine();
}
inline const ::std::string& UpdateDetectionIDs::machine() const {
  return *machine_;
}
inline void UpdateDetectionIDs::set_machine(const ::std::string& value) {
  set_has_machine();
  if (machine_ == &::google::protobuf::internal::kEmptyString) {
    machine_ = new ::std::string;
  }
  machine_->assign(value);
}
inline void UpdateDetectionIDs::set_machine(const char* value) {
  set_has_machine();
  if (machine_ == &::google::protobuf::internal::kEmptyString) {
    machine_ = new ::std::string;
  }
  machine_->assign(value);
}
inline void UpdateDetectionIDs::set_machine(const char* value, size_t size) {
  set_has_machine();
  if (machine_ == &::google::protobuf::internal::kEmptyString) {
    machine_ = new ::std::string;
  }
  machine_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateDetectionIDs::mutable_machine() {
  set_has_machine();
  if (machine_ == &::google::protobuf::internal::kEmptyString) {
    machine_ = new ::std::string;
  }
  return machine_;
}
inline ::std::string* UpdateDetectionIDs::release_machine() {
  clear_has_machine();
  if (machine_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_;
    machine_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UpdateDetectionIDs::set_allocated_machine(::std::string* machine) {
  if (machine_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_;
  }
  if (machine) {
    set_has_machine();
    machine_ = machine;
  } else {
    clear_has_machine();
    machine_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SnapExtraRequest

// optional string msgName = 1 [default = "SNAP_EXTRA_REQUEST"];
inline bool SnapExtraRequest::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SnapExtraRequest::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SnapExtraRequest::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SnapExtraRequest::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SnapExtraRequest::msgname() const {
  return *msgname_;
}
inline void SnapExtraRequest::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SnapExtraRequest::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SnapExtraRequest::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SnapExtraRequest::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SnapExtraRequest::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SnapExtraRequest::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string archfile = 2;
inline bool SnapExtraRequest::has_archfile() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SnapExtraRequest::set_has_archfile() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SnapExtraRequest::clear_has_archfile() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SnapExtraRequest::clear_archfile() {
  if (archfile_ != &::google::protobuf::internal::kEmptyString) {
    archfile_->clear();
  }
  clear_has_archfile();
}
inline const ::std::string& SnapExtraRequest::archfile() const {
  return *archfile_;
}
inline void SnapExtraRequest::set_archfile(const ::std::string& value) {
  set_has_archfile();
  if (archfile_ == &::google::protobuf::internal::kEmptyString) {
    archfile_ = new ::std::string;
  }
  archfile_->assign(value);
}
inline void SnapExtraRequest::set_archfile(const char* value) {
  set_has_archfile();
  if (archfile_ == &::google::protobuf::internal::kEmptyString) {
    archfile_ = new ::std::string;
  }
  archfile_->assign(value);
}
inline void SnapExtraRequest::set_archfile(const char* value, size_t size) {
  set_has_archfile();
  if (archfile_ == &::google::protobuf::internal::kEmptyString) {
    archfile_ = new ::std::string;
  }
  archfile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SnapExtraRequest::mutable_archfile() {
  set_has_archfile();
  if (archfile_ == &::google::protobuf::internal::kEmptyString) {
    archfile_ = new ::std::string;
  }
  return archfile_;
}
inline ::std::string* SnapExtraRequest::release_archfile() {
  clear_has_archfile();
  if (archfile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = archfile_;
    archfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SnapExtraRequest::set_allocated_archfile(::std::string* archfile) {
  if (archfile_ != &::google::protobuf::internal::kEmptyString) {
    delete archfile_;
  }
  if (archfile) {
    set_has_archfile();
    archfile_ = archfile;
  } else {
    clear_has_archfile();
    archfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string tables = 3;
inline int SnapExtraRequest::tables_size() const {
  return tables_.size();
}
inline void SnapExtraRequest::clear_tables() {
  tables_.Clear();
}
inline const ::std::string& SnapExtraRequest::tables(int index) const {
  return tables_.Get(index);
}
inline ::std::string* SnapExtraRequest::mutable_tables(int index) {
  return tables_.Mutable(index);
}
inline void SnapExtraRequest::set_tables(int index, const ::std::string& value) {
  tables_.Mutable(index)->assign(value);
}
inline void SnapExtraRequest::set_tables(int index, const char* value) {
  tables_.Mutable(index)->assign(value);
}
inline void SnapExtraRequest::set_tables(int index, const char* value, size_t size) {
  tables_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SnapExtraRequest::add_tables() {
  return tables_.Add();
}
inline void SnapExtraRequest::add_tables(const ::std::string& value) {
  tables_.Add()->assign(value);
}
inline void SnapExtraRequest::add_tables(const char* value) {
  tables_.Add()->assign(value);
}
inline void SnapExtraRequest::add_tables(const char* value, size_t size) {
  tables_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SnapExtraRequest::tables() const {
  return tables_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SnapExtraRequest::mutable_tables() {
  return &tables_;
}

// repeated float freq = 4;
inline int SnapExtraRequest::freq_size() const {
  return freq_.size();
}
inline void SnapExtraRequest::clear_freq() {
  freq_.Clear();
}
inline float SnapExtraRequest::freq(int index) const {
  return freq_.Get(index);
}
inline void SnapExtraRequest::set_freq(int index, float value) {
  freq_.Set(index, value);
}
inline void SnapExtraRequest::add_freq(float value) {
  freq_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
SnapExtraRequest::freq() const {
  return freq_;
}
inline ::google::protobuf::RepeatedField< float >*
SnapExtraRequest::mutable_freq() {
  return &freq_;
}

// repeated float bw = 5;
inline int SnapExtraRequest::bw_size() const {
  return bw_.size();
}
inline void SnapExtraRequest::clear_bw() {
  bw_.Clear();
}
inline float SnapExtraRequest::bw(int index) const {
  return bw_.Get(index);
}
inline void SnapExtraRequest::set_bw(int index, float value) {
  bw_.Set(index, value);
}
inline void SnapExtraRequest::add_bw(float value) {
  bw_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
SnapExtraRequest::bw() const {
  return bw_;
}
inline ::google::protobuf::RepeatedField< float >*
SnapExtraRequest::mutable_bw() {
  return &bw_;
}

// repeated float berth = 6;
inline int SnapExtraRequest::berth_size() const {
  return berth_.size();
}
inline void SnapExtraRequest::clear_berth() {
  berth_.Clear();
}
inline float SnapExtraRequest::berth(int index) const {
  return berth_.Get(index);
}
inline void SnapExtraRequest::set_berth(int index, float value) {
  berth_.Set(index, value);
}
inline void SnapExtraRequest::add_berth(float value) {
  berth_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
SnapExtraRequest::berth() const {
  return berth_;
}
inline ::google::protobuf::RepeatedField< float >*
SnapExtraRequest::mutable_berth() {
  return &berth_;
}

// repeated int32 nframesth = 7;
inline int SnapExtraRequest::nframesth_size() const {
  return nframesth_.size();
}
inline void SnapExtraRequest::clear_nframesth() {
  nframesth_.Clear();
}
inline ::google::protobuf::int32 SnapExtraRequest::nframesth(int index) const {
  return nframesth_.Get(index);
}
inline void SnapExtraRequest::set_nframesth(int index, ::google::protobuf::int32 value) {
  nframesth_.Set(index, value);
}
inline void SnapExtraRequest::add_nframesth(::google::protobuf::int32 value) {
  nframesth_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SnapExtraRequest::nframesth() const {
  return nframesth_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SnapExtraRequest::mutable_nframesth() {
  return &nframesth_;
}

// repeated float ratelines = 8;
inline int SnapExtraRequest::ratelines_size() const {
  return ratelines_.size();
}
inline void SnapExtraRequest::clear_ratelines() {
  ratelines_.Clear();
}
inline float SnapExtraRequest::ratelines(int index) const {
  return ratelines_.Get(index);
}
inline void SnapExtraRequest::set_ratelines(int index, float value) {
  ratelines_.Set(index, value);
}
inline void SnapExtraRequest::add_ratelines(float value) {
  ratelines_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
SnapExtraRequest::ratelines() const {
  return ratelines_;
}
inline ::google::protobuf::RepeatedField< float >*
SnapExtraRequest::mutable_ratelines() {
  return &ratelines_;
}

// repeated float chiprate = 9;
inline int SnapExtraRequest::chiprate_size() const {
  return chiprate_.size();
}
inline void SnapExtraRequest::clear_chiprate() {
  chiprate_.Clear();
}
inline float SnapExtraRequest::chiprate(int index) const {
  return chiprate_.Get(index);
}
inline void SnapExtraRequest::set_chiprate(int index, float value) {
  chiprate_.Set(index, value);
}
inline void SnapExtraRequest::add_chiprate(float value) {
  chiprate_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
SnapExtraRequest::chiprate() const {
  return chiprate_;
}
inline ::google::protobuf::RepeatedField< float >*
SnapExtraRequest::mutable_chiprate() {
  return &chiprate_;
}

// repeated string ofdm_names = 10;
inline int SnapExtraRequest::ofdm_names_size() const {
  return ofdm_names_.size();
}
inline void SnapExtraRequest::clear_ofdm_names() {
  ofdm_names_.Clear();
}
inline const ::std::string& SnapExtraRequest::ofdm_names(int index) const {
  return ofdm_names_.Get(index);
}
inline ::std::string* SnapExtraRequest::mutable_ofdm_names(int index) {
  return ofdm_names_.Mutable(index);
}
inline void SnapExtraRequest::set_ofdm_names(int index, const ::std::string& value) {
  ofdm_names_.Mutable(index)->assign(value);
}
inline void SnapExtraRequest::set_ofdm_names(int index, const char* value) {
  ofdm_names_.Mutable(index)->assign(value);
}
inline void SnapExtraRequest::set_ofdm_names(int index, const char* value, size_t size) {
  ofdm_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SnapExtraRequest::add_ofdm_names() {
  return ofdm_names_.Add();
}
inline void SnapExtraRequest::add_ofdm_names(const ::std::string& value) {
  ofdm_names_.Add()->assign(value);
}
inline void SnapExtraRequest::add_ofdm_names(const char* value) {
  ofdm_names_.Add()->assign(value);
}
inline void SnapExtraRequest::add_ofdm_names(const char* value, size_t size) {
  ofdm_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SnapExtraRequest::ofdm_names() const {
  return ofdm_names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SnapExtraRequest::mutable_ofdm_names() {
  return &ofdm_names_;
}

// optional int32 uniquefieldthreshold = 11;
inline bool SnapExtraRequest::has_uniquefieldthreshold() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SnapExtraRequest::set_has_uniquefieldthreshold() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SnapExtraRequest::clear_has_uniquefieldthreshold() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SnapExtraRequest::clear_uniquefieldthreshold() {
  uniquefieldthreshold_ = 0;
  clear_has_uniquefieldthreshold();
}
inline ::google::protobuf::int32 SnapExtraRequest::uniquefieldthreshold() const {
  return uniquefieldthreshold_;
}
inline void SnapExtraRequest::set_uniquefieldthreshold(::google::protobuf::int32 value) {
  set_has_uniquefieldthreshold();
  uniquefieldthreshold_ = value;
}

// optional string pristring = 12;
inline bool SnapExtraRequest::has_pristring() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SnapExtraRequest::set_has_pristring() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SnapExtraRequest::clear_has_pristring() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SnapExtraRequest::clear_pristring() {
  if (pristring_ != &::google::protobuf::internal::kEmptyString) {
    pristring_->clear();
  }
  clear_has_pristring();
}
inline const ::std::string& SnapExtraRequest::pristring() const {
  return *pristring_;
}
inline void SnapExtraRequest::set_pristring(const ::std::string& value) {
  set_has_pristring();
  if (pristring_ == &::google::protobuf::internal::kEmptyString) {
    pristring_ = new ::std::string;
  }
  pristring_->assign(value);
}
inline void SnapExtraRequest::set_pristring(const char* value) {
  set_has_pristring();
  if (pristring_ == &::google::protobuf::internal::kEmptyString) {
    pristring_ = new ::std::string;
  }
  pristring_->assign(value);
}
inline void SnapExtraRequest::set_pristring(const char* value, size_t size) {
  set_has_pristring();
  if (pristring_ == &::google::protobuf::internal::kEmptyString) {
    pristring_ = new ::std::string;
  }
  pristring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SnapExtraRequest::mutable_pristring() {
  set_has_pristring();
  if (pristring_ == &::google::protobuf::internal::kEmptyString) {
    pristring_ = new ::std::string;
  }
  return pristring_;
}
inline ::std::string* SnapExtraRequest::release_pristring() {
  clear_has_pristring();
  if (pristring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pristring_;
    pristring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SnapExtraRequest::set_allocated_pristring(::std::string* pristring) {
  if (pristring_ != &::google::protobuf::internal::kEmptyString) {
    delete pristring_;
  }
  if (pristring) {
    set_has_pristring();
    pristring_ = pristring;
  } else {
    clear_has_pristring();
    pristring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mod = 13;
inline bool SnapExtraRequest::has_mod() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SnapExtraRequest::set_has_mod() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SnapExtraRequest::clear_has_mod() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SnapExtraRequest::clear_mod() {
  if (mod_ != &::google::protobuf::internal::kEmptyString) {
    mod_->clear();
  }
  clear_has_mod();
}
inline const ::std::string& SnapExtraRequest::mod() const {
  return *mod_;
}
inline void SnapExtraRequest::set_mod(const ::std::string& value) {
  set_has_mod();
  if (mod_ == &::google::protobuf::internal::kEmptyString) {
    mod_ = new ::std::string;
  }
  mod_->assign(value);
}
inline void SnapExtraRequest::set_mod(const char* value) {
  set_has_mod();
  if (mod_ == &::google::protobuf::internal::kEmptyString) {
    mod_ = new ::std::string;
  }
  mod_->assign(value);
}
inline void SnapExtraRequest::set_mod(const char* value, size_t size) {
  set_has_mod();
  if (mod_ == &::google::protobuf::internal::kEmptyString) {
    mod_ = new ::std::string;
  }
  mod_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SnapExtraRequest::mutable_mod() {
  set_has_mod();
  if (mod_ == &::google::protobuf::internal::kEmptyString) {
    mod_ = new ::std::string;
  }
  return mod_;
}
inline ::std::string* SnapExtraRequest::release_mod() {
  clear_has_mod();
  if (mod_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mod_;
    mod_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SnapExtraRequest::set_allocated_mod(::std::string* mod) {
  if (mod_ != &::google::protobuf::internal::kEmptyString) {
    delete mod_;
  }
  if (mod) {
    set_has_mod();
    mod_ = mod;
  } else {
    clear_has_mod();
    mod_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string revisitID = 14;
inline bool SnapExtraRequest::has_revisitid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SnapExtraRequest::set_has_revisitid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SnapExtraRequest::clear_has_revisitid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SnapExtraRequest::clear_revisitid() {
  if (revisitid_ != &::google::protobuf::internal::kEmptyString) {
    revisitid_->clear();
  }
  clear_has_revisitid();
}
inline const ::std::string& SnapExtraRequest::revisitid() const {
  return *revisitid_;
}
inline void SnapExtraRequest::set_revisitid(const ::std::string& value) {
  set_has_revisitid();
  if (revisitid_ == &::google::protobuf::internal::kEmptyString) {
    revisitid_ = new ::std::string;
  }
  revisitid_->assign(value);
}
inline void SnapExtraRequest::set_revisitid(const char* value) {
  set_has_revisitid();
  if (revisitid_ == &::google::protobuf::internal::kEmptyString) {
    revisitid_ = new ::std::string;
  }
  revisitid_->assign(value);
}
inline void SnapExtraRequest::set_revisitid(const char* value, size_t size) {
  set_has_revisitid();
  if (revisitid_ == &::google::protobuf::internal::kEmptyString) {
    revisitid_ = new ::std::string;
  }
  revisitid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SnapExtraRequest::mutable_revisitid() {
  set_has_revisitid();
  if (revisitid_ == &::google::protobuf::internal::kEmptyString) {
    revisitid_ = new ::std::string;
  }
  return revisitid_;
}
inline ::std::string* SnapExtraRequest::release_revisitid() {
  clear_has_revisitid();
  if (revisitid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = revisitid_;
    revisitid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SnapExtraRequest::set_allocated_revisitid(::std::string* revisitid) {
  if (revisitid_ != &::google::protobuf::internal::kEmptyString) {
    delete revisitid_;
  }
  if (revisitid) {
    set_has_revisitid();
    revisitid_ = revisitid;
  } else {
    clear_has_revisitid();
    revisitid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SnapExtraResponse

// optional string msgName = 1 [default = "SNAP_EXTRA_RESPONSE"];
inline bool SnapExtraResponse::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SnapExtraResponse::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SnapExtraResponse::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SnapExtraResponse::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SnapExtraResponse::msgname() const {
  return *msgname_;
}
inline void SnapExtraResponse::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SnapExtraResponse::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SnapExtraResponse::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SnapExtraResponse::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SnapExtraResponse::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SnapExtraResponse::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string revisitID = 2;
inline bool SnapExtraResponse::has_revisitid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SnapExtraResponse::set_has_revisitid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SnapExtraResponse::clear_has_revisitid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SnapExtraResponse::clear_revisitid() {
  if (revisitid_ != &::google::protobuf::internal::kEmptyString) {
    revisitid_->clear();
  }
  clear_has_revisitid();
}
inline const ::std::string& SnapExtraResponse::revisitid() const {
  return *revisitid_;
}
inline void SnapExtraResponse::set_revisitid(const ::std::string& value) {
  set_has_revisitid();
  if (revisitid_ == &::google::protobuf::internal::kEmptyString) {
    revisitid_ = new ::std::string;
  }
  revisitid_->assign(value);
}
inline void SnapExtraResponse::set_revisitid(const char* value) {
  set_has_revisitid();
  if (revisitid_ == &::google::protobuf::internal::kEmptyString) {
    revisitid_ = new ::std::string;
  }
  revisitid_->assign(value);
}
inline void SnapExtraResponse::set_revisitid(const char* value, size_t size) {
  set_has_revisitid();
  if (revisitid_ == &::google::protobuf::internal::kEmptyString) {
    revisitid_ = new ::std::string;
  }
  revisitid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SnapExtraResponse::mutable_revisitid() {
  set_has_revisitid();
  if (revisitid_ == &::google::protobuf::internal::kEmptyString) {
    revisitid_ = new ::std::string;
  }
  return revisitid_;
}
inline ::std::string* SnapExtraResponse::release_revisitid() {
  clear_has_revisitid();
  if (revisitid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = revisitid_;
    revisitid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SnapExtraResponse::set_allocated_revisitid(::std::string* revisitid) {
  if (revisitid_ != &::google::protobuf::internal::kEmptyString) {
    delete revisitid_;
  }
  if (revisitid) {
    set_has_revisitid();
    revisitid_ = revisitid;
  } else {
    clear_has_revisitid();
    revisitid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string response = 3;
inline bool SnapExtraResponse::has_response() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SnapExtraResponse::set_has_response() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SnapExtraResponse::clear_has_response() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SnapExtraResponse::clear_response() {
  if (response_ != &::google::protobuf::internal::kEmptyString) {
    response_->clear();
  }
  clear_has_response();
}
inline const ::std::string& SnapExtraResponse::response() const {
  return *response_;
}
inline void SnapExtraResponse::set_response(const ::std::string& value) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  response_->assign(value);
}
inline void SnapExtraResponse::set_response(const char* value) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  response_->assign(value);
}
inline void SnapExtraResponse::set_response(const char* value, size_t size) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  response_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SnapExtraResponse::mutable_response() {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  return response_;
}
inline ::std::string* SnapExtraResponse::release_response() {
  clear_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = response_;
    response_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SnapExtraResponse::set_allocated_response(::std::string* response) {
  if (response_ != &::google::protobuf::internal::kEmptyString) {
    delete response_;
  }
  if (response) {
    set_has_response();
    response_ = response;
  } else {
    clear_has_response();
    response_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace falcon_fast_msg

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_FalconFastMessages_2eproto__INCLUDED
