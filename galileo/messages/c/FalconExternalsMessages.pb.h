// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FalconExternalsMessages.proto

#ifndef PROTOBUF_FalconExternalsMessages_2eproto__INCLUDED
#define PROTOBUF_FalconExternalsMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace falcon_externals_msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_FalconExternalsMessages_2eproto();
void protobuf_AssignDesc_FalconExternalsMessages_2eproto();
void protobuf_ShutdownFile_FalconExternalsMessages_2eproto();

class ExternalsHit;
class InternalsHit;
class DsssDescriptor;
class HopDescriptor;
class FSKDescriptor;
class CWDescriptor;
class SpreadDescriptor;
class AVDescriptor;
class QSTAT_RT;
class ExternalsRelease;
class NullHit;

enum ExternalsHit_Type {
  ExternalsHit_Type_KNOWN_RED = 0,
  ExternalsHit_Type_KNOWN_GRAY = 1,
  ExternalsHit_Type_KNOWN_BLUE = 2,
  ExternalsHit_Type_UNKNOWN = 3,
  ExternalsHit_Type_ANOMALY = 4
};
bool ExternalsHit_Type_IsValid(int value);
const ExternalsHit_Type ExternalsHit_Type_Type_MIN = ExternalsHit_Type_KNOWN_RED;
const ExternalsHit_Type ExternalsHit_Type_Type_MAX = ExternalsHit_Type_ANOMALY;
const int ExternalsHit_Type_Type_ARRAYSIZE = ExternalsHit_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExternalsHit_Type_descriptor();
inline const ::std::string& ExternalsHit_Type_Name(ExternalsHit_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExternalsHit_Type_descriptor(), value);
}
inline bool ExternalsHit_Type_Parse(
    const ::std::string& name, ExternalsHit_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExternalsHit_Type>(
    ExternalsHit_Type_descriptor(), name, value);
}
enum ExternalsRelease_Type {
  ExternalsRelease_Type_KNOWN_RED = 0,
  ExternalsRelease_Type_KNOWN_GRAY = 1,
  ExternalsRelease_Type_KNOWN_BLUE = 2,
  ExternalsRelease_Type_UNKNOWN = 3,
  ExternalsRelease_Type_ANOMALY = 4
};
bool ExternalsRelease_Type_IsValid(int value);
const ExternalsRelease_Type ExternalsRelease_Type_Type_MIN = ExternalsRelease_Type_KNOWN_RED;
const ExternalsRelease_Type ExternalsRelease_Type_Type_MAX = ExternalsRelease_Type_ANOMALY;
const int ExternalsRelease_Type_Type_ARRAYSIZE = ExternalsRelease_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExternalsRelease_Type_descriptor();
inline const ::std::string& ExternalsRelease_Type_Name(ExternalsRelease_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExternalsRelease_Type_descriptor(), value);
}
inline bool ExternalsRelease_Type_Parse(
    const ::std::string& name, ExternalsRelease_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExternalsRelease_Type>(
    ExternalsRelease_Type_descriptor(), name, value);
}
// ===================================================================

class ExternalsHit : public ::google::protobuf::Message {
 public:
  ExternalsHit();
  virtual ~ExternalsHit();

  ExternalsHit(const ExternalsHit& from);

  inline ExternalsHit& operator=(const ExternalsHit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExternalsHit& default_instance();

  void Swap(ExternalsHit* other);

  // implements Message ----------------------------------------------

  ExternalsHit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExternalsHit& from);
  void MergeFrom(const ExternalsHit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ExternalsHit_Type Type;
  static const Type KNOWN_RED = ExternalsHit_Type_KNOWN_RED;
  static const Type KNOWN_GRAY = ExternalsHit_Type_KNOWN_GRAY;
  static const Type KNOWN_BLUE = ExternalsHit_Type_KNOWN_BLUE;
  static const Type UNKNOWN = ExternalsHit_Type_UNKNOWN;
  static const Type ANOMALY = ExternalsHit_Type_ANOMALY;
  static inline bool Type_IsValid(int value) {
    return ExternalsHit_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ExternalsHit_Type_Type_MIN;
  static const Type Type_MAX =
    ExternalsHit_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ExternalsHit_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ExternalsHit_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ExternalsHit_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ExternalsHit_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EXTERNALSHIT"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .falcon_externals_msg.ExternalsHit.Type threatType = 3;
  inline bool has_threattype() const;
  inline void clear_threattype();
  static const int kThreatTypeFieldNumber = 3;
  inline ::falcon_externals_msg::ExternalsHit_Type threattype() const;
  inline void set_threattype(::falcon_externals_msg::ExternalsHit_Type value);

  // optional double freqMHz = 4;
  inline bool has_freqmhz() const;
  inline void clear_freqmhz();
  static const int kFreqMHzFieldNumber = 4;
  inline double freqmhz() const;
  inline void set_freqmhz(double value);

  // optional string globalId = 5 [default = "Functional"];
  inline bool has_globalid() const;
  inline void clear_globalid();
  static const int kGlobalIdFieldNumber = 5;
  inline const ::std::string& globalid() const;
  inline void set_globalid(const ::std::string& value);
  inline void set_globalid(const char* value);
  inline void set_globalid(const char* value, size_t size);
  inline ::std::string* mutable_globalid();
  inline ::std::string* release_globalid();
  inline void set_allocated_globalid(::std::string* globalid);

  // optional int32 psuedoUniqueId = 6 [default = 0];
  inline bool has_psuedouniqueid() const;
  inline void clear_psuedouniqueid();
  static const int kPsuedoUniqueIdFieldNumber = 6;
  inline ::google::protobuf::int32 psuedouniqueid() const;
  inline void set_psuedouniqueid(::google::protobuf::int32 value);

  // optional int32 globalIdNum = 7 [default = 0];
  inline bool has_globalidnum() const;
  inline void clear_globalidnum();
  static const int kGlobalIdNumFieldNumber = 7;
  inline ::google::protobuf::int32 globalidnum() const;
  inline void set_globalidnum(::google::protobuf::int32 value);

  // optional string timestamp = 8;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 8;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  inline void set_allocated_timestamp(::std::string* timestamp);

  // optional string channel = 9 [default = "1"];
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 9;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // optional bool isTrigger = 10 [default = false];
  inline bool has_istrigger() const;
  inline void clear_istrigger();
  static const int kIsTriggerFieldNumber = 10;
  inline bool istrigger() const;
  inline void set_istrigger(bool value);

  // optional .falcon_externals_msg.HopDescriptor hopDescriptor = 11;
  inline bool has_hopdescriptor() const;
  inline void clear_hopdescriptor();
  static const int kHopDescriptorFieldNumber = 11;
  inline const ::falcon_externals_msg::HopDescriptor& hopdescriptor() const;
  inline ::falcon_externals_msg::HopDescriptor* mutable_hopdescriptor();
  inline ::falcon_externals_msg::HopDescriptor* release_hopdescriptor();
  inline void set_allocated_hopdescriptor(::falcon_externals_msg::HopDescriptor* hopdescriptor);

  // optional .falcon_externals_msg.FSKDescriptor fskDescriptor = 12;
  inline bool has_fskdescriptor() const;
  inline void clear_fskdescriptor();
  static const int kFskDescriptorFieldNumber = 12;
  inline const ::falcon_externals_msg::FSKDescriptor& fskdescriptor() const;
  inline ::falcon_externals_msg::FSKDescriptor* mutable_fskdescriptor();
  inline ::falcon_externals_msg::FSKDescriptor* release_fskdescriptor();
  inline void set_allocated_fskdescriptor(::falcon_externals_msg::FSKDescriptor* fskdescriptor);

  // optional .falcon_externals_msg.CWDescriptor cwDescriptor = 13;
  inline bool has_cwdescriptor() const;
  inline void clear_cwdescriptor();
  static const int kCwDescriptorFieldNumber = 13;
  inline const ::falcon_externals_msg::CWDescriptor& cwdescriptor() const;
  inline ::falcon_externals_msg::CWDescriptor* mutable_cwdescriptor();
  inline ::falcon_externals_msg::CWDescriptor* release_cwdescriptor();
  inline void set_allocated_cwdescriptor(::falcon_externals_msg::CWDescriptor* cwdescriptor);

  // optional .falcon_externals_msg.SpreadDescriptor spreadDescriptor = 14;
  inline bool has_spreaddescriptor() const;
  inline void clear_spreaddescriptor();
  static const int kSpreadDescriptorFieldNumber = 14;
  inline const ::falcon_externals_msg::SpreadDescriptor& spreaddescriptor() const;
  inline ::falcon_externals_msg::SpreadDescriptor* mutable_spreaddescriptor();
  inline ::falcon_externals_msg::SpreadDescriptor* release_spreaddescriptor();
  inline void set_allocated_spreaddescriptor(::falcon_externals_msg::SpreadDescriptor* spreaddescriptor);

  // optional .falcon_externals_msg.AVDescriptor AVidDescriptor = 15;
  inline bool has_aviddescriptor() const;
  inline void clear_aviddescriptor();
  static const int kAVidDescriptorFieldNumber = 15;
  inline const ::falcon_externals_msg::AVDescriptor& aviddescriptor() const;
  inline ::falcon_externals_msg::AVDescriptor* mutable_aviddescriptor();
  inline ::falcon_externals_msg::AVDescriptor* release_aviddescriptor();
  inline void set_allocated_aviddescriptor(::falcon_externals_msg::AVDescriptor* aviddescriptor);

  // optional .falcon_externals_msg.DsssDescriptor DsssDescriptor = 16;
  inline bool has_dsssdescriptor() const;
  inline void clear_dsssdescriptor();
  static const int kDsssDescriptorFieldNumber = 16;
  inline const ::falcon_externals_msg::DsssDescriptor& dsssdescriptor() const;
  inline ::falcon_externals_msg::DsssDescriptor* mutable_dsssdescriptor();
  inline ::falcon_externals_msg::DsssDescriptor* release_dsssdescriptor();
  inline void set_allocated_dsssdescriptor(::falcon_externals_msg::DsssDescriptor* dsssdescriptor);

  // optional int32 updateValues = 17 [default = 0];
  inline bool has_updatevalues() const;
  inline void clear_updatevalues();
  static const int kUpdateValuesFieldNumber = 17;
  inline ::google::protobuf::int32 updatevalues() const;
  inline void set_updatevalues(::google::protobuf::int32 value);

  // optional string soiNum = 18 [default = "0"];
  inline bool has_soinum() const;
  inline void clear_soinum();
  static const int kSoiNumFieldNumber = 18;
  inline const ::std::string& soinum() const;
  inline void set_soinum(const ::std::string& value);
  inline void set_soinum(const char* value);
  inline void set_soinum(const char* value, size_t size);
  inline ::std::string* mutable_soinum();
  inline ::std::string* release_soinum();
  inline void set_allocated_soinum(::std::string* soinum);

  // @@protoc_insertion_point(class_scope:falcon_externals_msg.ExternalsHit)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_threattype();
  inline void clear_has_threattype();
  inline void set_has_freqmhz();
  inline void clear_has_freqmhz();
  inline void set_has_globalid();
  inline void clear_has_globalid();
  inline void set_has_psuedouniqueid();
  inline void clear_has_psuedouniqueid();
  inline void set_has_globalidnum();
  inline void clear_has_globalidnum();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_istrigger();
  inline void clear_has_istrigger();
  inline void set_has_hopdescriptor();
  inline void clear_has_hopdescriptor();
  inline void set_has_fskdescriptor();
  inline void clear_has_fskdescriptor();
  inline void set_has_cwdescriptor();
  inline void clear_has_cwdescriptor();
  inline void set_has_spreaddescriptor();
  inline void clear_has_spreaddescriptor();
  inline void set_has_aviddescriptor();
  inline void clear_has_aviddescriptor();
  inline void set_has_dsssdescriptor();
  inline void clear_has_dsssdescriptor();
  inline void set_has_updatevalues();
  inline void clear_has_updatevalues();
  inline void set_has_soinum();
  inline void clear_has_soinum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* name_;
  double freqmhz_;
  int threattype_;
  ::google::protobuf::int32 psuedouniqueid_;
  ::std::string* globalid_;
  static ::std::string* _default_globalid_;
  ::std::string* timestamp_;
  ::google::protobuf::int32 globalidnum_;
  bool istrigger_;
  ::std::string* channel_;
  static ::std::string* _default_channel_;
  ::falcon_externals_msg::HopDescriptor* hopdescriptor_;
  ::falcon_externals_msg::FSKDescriptor* fskdescriptor_;
  ::falcon_externals_msg::CWDescriptor* cwdescriptor_;
  ::falcon_externals_msg::SpreadDescriptor* spreaddescriptor_;
  ::falcon_externals_msg::AVDescriptor* aviddescriptor_;
  ::falcon_externals_msg::DsssDescriptor* dsssdescriptor_;
  ::std::string* soinum_;
  static ::std::string* _default_soinum_;
  ::google::protobuf::int32 updatevalues_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void  protobuf_AddDesc_FalconExternalsMessages_2eproto();
  friend void protobuf_AssignDesc_FalconExternalsMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconExternalsMessages_2eproto();

  void InitAsDefaultInstance();
  static ExternalsHit* default_instance_;
};
// -------------------------------------------------------------------

class InternalsHit : public ::google::protobuf::Message {
 public:
  InternalsHit();
  virtual ~InternalsHit();

  InternalsHit(const InternalsHit& from);

  inline InternalsHit& operator=(const InternalsHit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalsHit& default_instance();

  void Swap(InternalsHit* other);

  // implements Message ----------------------------------------------

  InternalsHit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalsHit& from);
  void MergeFrom(const InternalsHit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "INTERNALSHIT"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional double freqMHz = 3;
  inline bool has_freqmhz() const;
  inline void clear_freqmhz();
  static const int kFreqMHzFieldNumber = 3;
  inline double freqmhz() const;
  inline void set_freqmhz(double value);

  // optional string globalId = 4 [default = "Functional"];
  inline bool has_globalid() const;
  inline void clear_globalid();
  static const int kGlobalIdFieldNumber = 4;
  inline const ::std::string& globalid() const;
  inline void set_globalid(const ::std::string& value);
  inline void set_globalid(const char* value);
  inline void set_globalid(const char* value, size_t size);
  inline ::std::string* mutable_globalid();
  inline ::std::string* release_globalid();
  inline void set_allocated_globalid(::std::string* globalid);

  // optional int32 psuedoUniqueId = 5 [default = 0];
  inline bool has_psuedouniqueid() const;
  inline void clear_psuedouniqueid();
  static const int kPsuedoUniqueIdFieldNumber = 5;
  inline ::google::protobuf::int32 psuedouniqueid() const;
  inline void set_psuedouniqueid(::google::protobuf::int32 value);

  // optional int32 globalIdNum = 6 [default = 0];
  inline bool has_globalidnum() const;
  inline void clear_globalidnum();
  static const int kGlobalIdNumFieldNumber = 6;
  inline ::google::protobuf::int32 globalidnum() const;
  inline void set_globalidnum(::google::protobuf::int32 value);

  // optional string timestamp = 7;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 7;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  inline void set_allocated_timestamp(::std::string* timestamp);

  // optional string channel = 8 [default = "1"];
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 8;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // optional bool isTrigger = 9 [default = false];
  inline bool has_istrigger() const;
  inline void clear_istrigger();
  static const int kIsTriggerFieldNumber = 9;
  inline bool istrigger() const;
  inline void set_istrigger(bool value);

  // optional .falcon_externals_msg.HopDescriptor hopDescriptor = 10;
  inline bool has_hopdescriptor() const;
  inline void clear_hopdescriptor();
  static const int kHopDescriptorFieldNumber = 10;
  inline const ::falcon_externals_msg::HopDescriptor& hopdescriptor() const;
  inline ::falcon_externals_msg::HopDescriptor* mutable_hopdescriptor();
  inline ::falcon_externals_msg::HopDescriptor* release_hopdescriptor();
  inline void set_allocated_hopdescriptor(::falcon_externals_msg::HopDescriptor* hopdescriptor);

  // optional .falcon_externals_msg.FSKDescriptor fskDescriptor = 11;
  inline bool has_fskdescriptor() const;
  inline void clear_fskdescriptor();
  static const int kFskDescriptorFieldNumber = 11;
  inline const ::falcon_externals_msg::FSKDescriptor& fskdescriptor() const;
  inline ::falcon_externals_msg::FSKDescriptor* mutable_fskdescriptor();
  inline ::falcon_externals_msg::FSKDescriptor* release_fskdescriptor();
  inline void set_allocated_fskdescriptor(::falcon_externals_msg::FSKDescriptor* fskdescriptor);

  // optional .falcon_externals_msg.CWDescriptor cwDescriptor = 12;
  inline bool has_cwdescriptor() const;
  inline void clear_cwdescriptor();
  static const int kCwDescriptorFieldNumber = 12;
  inline const ::falcon_externals_msg::CWDescriptor& cwdescriptor() const;
  inline ::falcon_externals_msg::CWDescriptor* mutable_cwdescriptor();
  inline ::falcon_externals_msg::CWDescriptor* release_cwdescriptor();
  inline void set_allocated_cwdescriptor(::falcon_externals_msg::CWDescriptor* cwdescriptor);

  // optional .falcon_externals_msg.SpreadDescriptor spreadDescriptor = 13;
  inline bool has_spreaddescriptor() const;
  inline void clear_spreaddescriptor();
  static const int kSpreadDescriptorFieldNumber = 13;
  inline const ::falcon_externals_msg::SpreadDescriptor& spreaddescriptor() const;
  inline ::falcon_externals_msg::SpreadDescriptor* mutable_spreaddescriptor();
  inline ::falcon_externals_msg::SpreadDescriptor* release_spreaddescriptor();
  inline void set_allocated_spreaddescriptor(::falcon_externals_msg::SpreadDescriptor* spreaddescriptor);

  // optional .falcon_externals_msg.AVDescriptor AVidDescriptor = 14;
  inline bool has_aviddescriptor() const;
  inline void clear_aviddescriptor();
  static const int kAVidDescriptorFieldNumber = 14;
  inline const ::falcon_externals_msg::AVDescriptor& aviddescriptor() const;
  inline ::falcon_externals_msg::AVDescriptor* mutable_aviddescriptor();
  inline ::falcon_externals_msg::AVDescriptor* release_aviddescriptor();
  inline void set_allocated_aviddescriptor(::falcon_externals_msg::AVDescriptor* aviddescriptor);

  // optional .falcon_externals_msg.DsssDescriptor DsssDescriptor = 16;
  inline bool has_dsssdescriptor() const;
  inline void clear_dsssdescriptor();
  static const int kDsssDescriptorFieldNumber = 16;
  inline const ::falcon_externals_msg::DsssDescriptor& dsssdescriptor() const;
  inline ::falcon_externals_msg::DsssDescriptor* mutable_dsssdescriptor();
  inline ::falcon_externals_msg::DsssDescriptor* release_dsssdescriptor();
  inline void set_allocated_dsssdescriptor(::falcon_externals_msg::DsssDescriptor* dsssdescriptor);

  // optional int32 updateValues = 17 [default = 0];
  inline bool has_updatevalues() const;
  inline void clear_updatevalues();
  static const int kUpdateValuesFieldNumber = 17;
  inline ::google::protobuf::int32 updatevalues() const;
  inline void set_updatevalues(::google::protobuf::int32 value);

  // optional string soiNum = 18 [default = "0"];
  inline bool has_soinum() const;
  inline void clear_soinum();
  static const int kSoiNumFieldNumber = 18;
  inline const ::std::string& soinum() const;
  inline void set_soinum(const ::std::string& value);
  inline void set_soinum(const char* value);
  inline void set_soinum(const char* value, size_t size);
  inline ::std::string* mutable_soinum();
  inline ::std::string* release_soinum();
  inline void set_allocated_soinum(::std::string* soinum);

  // @@protoc_insertion_point(class_scope:falcon_externals_msg.InternalsHit)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_freqmhz();
  inline void clear_has_freqmhz();
  inline void set_has_globalid();
  inline void clear_has_globalid();
  inline void set_has_psuedouniqueid();
  inline void clear_has_psuedouniqueid();
  inline void set_has_globalidnum();
  inline void clear_has_globalidnum();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_istrigger();
  inline void clear_has_istrigger();
  inline void set_has_hopdescriptor();
  inline void clear_has_hopdescriptor();
  inline void set_has_fskdescriptor();
  inline void clear_has_fskdescriptor();
  inline void set_has_cwdescriptor();
  inline void clear_has_cwdescriptor();
  inline void set_has_spreaddescriptor();
  inline void clear_has_spreaddescriptor();
  inline void set_has_aviddescriptor();
  inline void clear_has_aviddescriptor();
  inline void set_has_dsssdescriptor();
  inline void clear_has_dsssdescriptor();
  inline void set_has_updatevalues();
  inline void clear_has_updatevalues();
  inline void set_has_soinum();
  inline void clear_has_soinum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* name_;
  double freqmhz_;
  ::std::string* globalid_;
  static ::std::string* _default_globalid_;
  ::google::protobuf::int32 psuedouniqueid_;
  ::google::protobuf::int32 globalidnum_;
  ::std::string* timestamp_;
  ::std::string* channel_;
  static ::std::string* _default_channel_;
  ::falcon_externals_msg::HopDescriptor* hopdescriptor_;
  ::falcon_externals_msg::FSKDescriptor* fskdescriptor_;
  ::falcon_externals_msg::CWDescriptor* cwdescriptor_;
  bool istrigger_;
  ::google::protobuf::int32 updatevalues_;
  ::falcon_externals_msg::SpreadDescriptor* spreaddescriptor_;
  ::falcon_externals_msg::AVDescriptor* aviddescriptor_;
  ::falcon_externals_msg::DsssDescriptor* dsssdescriptor_;
  ::std::string* soinum_;
  static ::std::string* _default_soinum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  friend void  protobuf_AddDesc_FalconExternalsMessages_2eproto();
  friend void protobuf_AssignDesc_FalconExternalsMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconExternalsMessages_2eproto();

  void InitAsDefaultInstance();
  static InternalsHit* default_instance_;
};
// -------------------------------------------------------------------

class DsssDescriptor : public ::google::protobuf::Message {
 public:
  DsssDescriptor();
  virtual ~DsssDescriptor();

  DsssDescriptor(const DsssDescriptor& from);

  inline DsssDescriptor& operator=(const DsssDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DsssDescriptor& default_instance();

  void Swap(DsssDescriptor* other);

  // implements Message ----------------------------------------------

  DsssDescriptor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DsssDescriptor& from);
  void MergeFrom(const DsssDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string fileName = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional int32 mode = 2;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 2;
  inline ::google::protobuf::int32 mode() const;
  inline void set_mode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_externals_msg.DsssDescriptor)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_mode();
  inline void clear_has_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* filename_;
  ::google::protobuf::int32 mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconExternalsMessages_2eproto();
  friend void protobuf_AssignDesc_FalconExternalsMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconExternalsMessages_2eproto();

  void InitAsDefaultInstance();
  static DsssDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class HopDescriptor : public ::google::protobuf::Message {
 public:
  HopDescriptor();
  virtual ~HopDescriptor();

  HopDescriptor(const HopDescriptor& from);

  inline HopDescriptor& operator=(const HopDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HopDescriptor& default_instance();

  void Swap(HopDescriptor* other);

  // implements Message ----------------------------------------------

  HopDescriptor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HopDescriptor& from);
  void MergeFrom(const HopDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double hopRate = 1;
  inline bool has_hoprate() const;
  inline void clear_hoprate();
  static const int kHopRateFieldNumber = 1;
  inline double hoprate() const;
  inline void set_hoprate(double value);

  // optional double totalHopBW = 2;
  inline bool has_totalhopbw() const;
  inline void clear_totalhopbw();
  static const int kTotalHopBWFieldNumber = 2;
  inline double totalhopbw() const;
  inline void set_totalhopbw(double value);

  // optional double indHopBW = 3;
  inline bool has_indhopbw() const;
  inline void clear_indhopbw();
  static const int kIndHopBWFieldNumber = 3;
  inline double indhopbw() const;
  inline void set_indhopbw(double value);

  // optional double hopDuration = 4;
  inline bool has_hopduration() const;
  inline void clear_hopduration();
  static const int kHopDurationFieldNumber = 4;
  inline double hopduration() const;
  inline void set_hopduration(double value);

  // optional double hopPower = 5;
  inline bool has_hoppower() const;
  inline void clear_hoppower();
  static const int kHopPowerFieldNumber = 5;
  inline double hoppower() const;
  inline void set_hoppower(double value);

  // optional int32 freqsUsedBlind = 6;
  inline bool has_freqsusedblind() const;
  inline void clear_freqsusedblind();
  static const int kFreqsUsedBlindFieldNumber = 6;
  inline ::google::protobuf::int32 freqsusedblind() const;
  inline void set_freqsusedblind(::google::protobuf::int32 value);

  // optional int32 freqsUsedCorr = 7;
  inline bool has_freqsusedcorr() const;
  inline void clear_freqsusedcorr();
  static const int kFreqsUsedCorrFieldNumber = 7;
  inline ::google::protobuf::int32 freqsusedcorr() const;
  inline void set_freqsusedcorr(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_externals_msg.HopDescriptor)
 private:
  inline void set_has_hoprate();
  inline void clear_has_hoprate();
  inline void set_has_totalhopbw();
  inline void clear_has_totalhopbw();
  inline void set_has_indhopbw();
  inline void clear_has_indhopbw();
  inline void set_has_hopduration();
  inline void clear_has_hopduration();
  inline void set_has_hoppower();
  inline void clear_has_hoppower();
  inline void set_has_freqsusedblind();
  inline void clear_has_freqsusedblind();
  inline void set_has_freqsusedcorr();
  inline void clear_has_freqsusedcorr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double hoprate_;
  double totalhopbw_;
  double indhopbw_;
  double hopduration_;
  double hoppower_;
  ::google::protobuf::int32 freqsusedblind_;
  ::google::protobuf::int32 freqsusedcorr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_FalconExternalsMessages_2eproto();
  friend void protobuf_AssignDesc_FalconExternalsMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconExternalsMessages_2eproto();

  void InitAsDefaultInstance();
  static HopDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class FSKDescriptor : public ::google::protobuf::Message {
 public:
  FSKDescriptor();
  virtual ~FSKDescriptor();

  FSKDescriptor(const FSKDescriptor& from);

  inline FSKDescriptor& operator=(const FSKDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FSKDescriptor& default_instance();

  void Swap(FSKDescriptor* other);

  // implements Message ----------------------------------------------

  FSKDescriptor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FSKDescriptor& from);
  void MergeFrom(const FSKDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double centerFreq = 1;
  inline bool has_centerfreq() const;
  inline void clear_centerfreq();
  static const int kCenterFreqFieldNumber = 1;
  inline double centerfreq() const;
  inline void set_centerfreq(double value);

  // optional double excursion = 2;
  inline bool has_excursion() const;
  inline void clear_excursion();
  static const int kExcursionFieldNumber = 2;
  inline double excursion() const;
  inline void set_excursion(double value);

  // optional double baudRate = 3;
  inline bool has_baudrate() const;
  inline void clear_baudrate();
  static const int kBaudRateFieldNumber = 3;
  inline double baudrate() const;
  inline void set_baudrate(double value);

  // @@protoc_insertion_point(class_scope:falcon_externals_msg.FSKDescriptor)
 private:
  inline void set_has_centerfreq();
  inline void clear_has_centerfreq();
  inline void set_has_excursion();
  inline void clear_has_excursion();
  inline void set_has_baudrate();
  inline void clear_has_baudrate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double centerfreq_;
  double excursion_;
  double baudrate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconExternalsMessages_2eproto();
  friend void protobuf_AssignDesc_FalconExternalsMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconExternalsMessages_2eproto();

  void InitAsDefaultInstance();
  static FSKDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class CWDescriptor : public ::google::protobuf::Message {
 public:
  CWDescriptor();
  virtual ~CWDescriptor();

  CWDescriptor(const CWDescriptor& from);

  inline CWDescriptor& operator=(const CWDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CWDescriptor& default_instance();

  void Swap(CWDescriptor* other);

  // implements Message ----------------------------------------------

  CWDescriptor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CWDescriptor& from);
  void MergeFrom(const CWDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double centerFreq = 1;
  inline bool has_centerfreq() const;
  inline void clear_centerfreq();
  static const int kCenterFreqFieldNumber = 1;
  inline double centerfreq() const;
  inline void set_centerfreq(double value);

  // optional double power = 2;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 2;
  inline double power() const;
  inline void set_power(double value);

  // @@protoc_insertion_point(class_scope:falcon_externals_msg.CWDescriptor)
 private:
  inline void set_has_centerfreq();
  inline void clear_has_centerfreq();
  inline void set_has_power();
  inline void clear_has_power();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double centerfreq_;
  double power_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconExternalsMessages_2eproto();
  friend void protobuf_AssignDesc_FalconExternalsMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconExternalsMessages_2eproto();

  void InitAsDefaultInstance();
  static CWDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class SpreadDescriptor : public ::google::protobuf::Message {
 public:
  SpreadDescriptor();
  virtual ~SpreadDescriptor();

  SpreadDescriptor(const SpreadDescriptor& from);

  inline SpreadDescriptor& operator=(const SpreadDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpreadDescriptor& default_instance();

  void Swap(SpreadDescriptor* other);

  // implements Message ----------------------------------------------

  SpreadDescriptor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SpreadDescriptor& from);
  void MergeFrom(const SpreadDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double centerFreq = 1;
  inline bool has_centerfreq() const;
  inline void clear_centerfreq();
  static const int kCenterFreqFieldNumber = 1;
  inline double centerfreq() const;
  inline void set_centerfreq(double value);

  // optional double chipRate = 2;
  inline bool has_chiprate() const;
  inline void clear_chiprate();
  static const int kChipRateFieldNumber = 2;
  inline double chiprate() const;
  inline void set_chiprate(double value);

  // optional string modulation = 3;
  inline bool has_modulation() const;
  inline void clear_modulation();
  static const int kModulationFieldNumber = 3;
  inline const ::std::string& modulation() const;
  inline void set_modulation(const ::std::string& value);
  inline void set_modulation(const char* value);
  inline void set_modulation(const char* value, size_t size);
  inline ::std::string* mutable_modulation();
  inline ::std::string* release_modulation();
  inline void set_allocated_modulation(::std::string* modulation);

  // optional int32 pnSeqLength = 4;
  inline bool has_pnseqlength() const;
  inline void clear_pnseqlength();
  static const int kPnSeqLengthFieldNumber = 4;
  inline ::google::protobuf::int32 pnseqlength() const;
  inline void set_pnseqlength(::google::protobuf::int32 value);

  // optional string polynomial = 5;
  inline bool has_polynomial() const;
  inline void clear_polynomial();
  static const int kPolynomialFieldNumber = 5;
  inline const ::std::string& polynomial() const;
  inline void set_polynomial(const ::std::string& value);
  inline void set_polynomial(const char* value);
  inline void set_polynomial(const char* value, size_t size);
  inline ::std::string* mutable_polynomial();
  inline ::std::string* release_polynomial();
  inline void set_allocated_polynomial(::std::string* polynomial);

  // optional string fill = 6;
  inline bool has_fill() const;
  inline void clear_fill();
  static const int kFillFieldNumber = 6;
  inline const ::std::string& fill() const;
  inline void set_fill(const ::std::string& value);
  inline void set_fill(const char* value);
  inline void set_fill(const char* value, size_t size);
  inline ::std::string* mutable_fill();
  inline ::std::string* release_fill();
  inline void set_allocated_fill(::std::string* fill);

  // @@protoc_insertion_point(class_scope:falcon_externals_msg.SpreadDescriptor)
 private:
  inline void set_has_centerfreq();
  inline void clear_has_centerfreq();
  inline void set_has_chiprate();
  inline void clear_has_chiprate();
  inline void set_has_modulation();
  inline void clear_has_modulation();
  inline void set_has_pnseqlength();
  inline void clear_has_pnseqlength();
  inline void set_has_polynomial();
  inline void clear_has_polynomial();
  inline void set_has_fill();
  inline void clear_has_fill();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double centerfreq_;
  double chiprate_;
  ::std::string* modulation_;
  ::std::string* polynomial_;
  ::std::string* fill_;
  ::google::protobuf::int32 pnseqlength_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_FalconExternalsMessages_2eproto();
  friend void protobuf_AssignDesc_FalconExternalsMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconExternalsMessages_2eproto();

  void InitAsDefaultInstance();
  static SpreadDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class AVDescriptor : public ::google::protobuf::Message {
 public:
  AVDescriptor();
  virtual ~AVDescriptor();

  AVDescriptor(const AVDescriptor& from);

  inline AVDescriptor& operator=(const AVDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AVDescriptor& default_instance();

  void Swap(AVDescriptor* other);

  // implements Message ----------------------------------------------

  AVDescriptor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AVDescriptor& from);
  void MergeFrom(const AVDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double centerFreq = 1;
  inline bool has_centerfreq() const;
  inline void clear_centerfreq();
  static const int kCenterFreqFieldNumber = 1;
  inline double centerfreq() const;
  inline void set_centerfreq(double value);

  // optional bool detected = 2;
  inline bool has_detected() const;
  inline void clear_detected();
  static const int kDetectedFieldNumber = 2;
  inline bool detected() const;
  inline void set_detected(bool value);

  // @@protoc_insertion_point(class_scope:falcon_externals_msg.AVDescriptor)
 private:
  inline void set_has_centerfreq();
  inline void clear_has_centerfreq();
  inline void set_has_detected();
  inline void clear_has_detected();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double centerfreq_;
  bool detected_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconExternalsMessages_2eproto();
  friend void protobuf_AssignDesc_FalconExternalsMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconExternalsMessages_2eproto();

  void InitAsDefaultInstance();
  static AVDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class QSTAT_RT : public ::google::protobuf::Message {
 public:
  QSTAT_RT();
  virtual ~QSTAT_RT();

  QSTAT_RT(const QSTAT_RT& from);

  inline QSTAT_RT& operator=(const QSTAT_RT& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QSTAT_RT& default_instance();

  void Swap(QSTAT_RT* other);

  // implements Message ----------------------------------------------

  QSTAT_RT* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QSTAT_RT& from);
  void MergeFrom(const QSTAT_RT& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "QSTAT_RT"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string sender = 2;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 2;
  inline const ::std::string& sender() const;
  inline void set_sender(const ::std::string& value);
  inline void set_sender(const char* value);
  inline void set_sender(const char* value, size_t size);
  inline ::std::string* mutable_sender();
  inline ::std::string* release_sender();
  inline void set_allocated_sender(::std::string* sender);

  // optional string status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline const ::std::string& status() const;
  inline void set_status(const ::std::string& value);
  inline void set_status(const char* value);
  inline void set_status(const char* value, size_t size);
  inline ::std::string* mutable_status();
  inline ::std::string* release_status();
  inline void set_allocated_status(::std::string* status);

  // optional int32 appId = 4;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIdFieldNumber = 4;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_externals_msg.QSTAT_RT)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_appid();
  inline void clear_has_appid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* sender_;
  ::std::string* status_;
  ::google::protobuf::int32 appid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_FalconExternalsMessages_2eproto();
  friend void protobuf_AssignDesc_FalconExternalsMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconExternalsMessages_2eproto();

  void InitAsDefaultInstance();
  static QSTAT_RT* default_instance_;
};
// -------------------------------------------------------------------

class ExternalsRelease : public ::google::protobuf::Message {
 public:
  ExternalsRelease();
  virtual ~ExternalsRelease();

  ExternalsRelease(const ExternalsRelease& from);

  inline ExternalsRelease& operator=(const ExternalsRelease& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExternalsRelease& default_instance();

  void Swap(ExternalsRelease* other);

  // implements Message ----------------------------------------------

  ExternalsRelease* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExternalsRelease& from);
  void MergeFrom(const ExternalsRelease& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ExternalsRelease_Type Type;
  static const Type KNOWN_RED = ExternalsRelease_Type_KNOWN_RED;
  static const Type KNOWN_GRAY = ExternalsRelease_Type_KNOWN_GRAY;
  static const Type KNOWN_BLUE = ExternalsRelease_Type_KNOWN_BLUE;
  static const Type UNKNOWN = ExternalsRelease_Type_UNKNOWN;
  static const Type ANOMALY = ExternalsRelease_Type_ANOMALY;
  static inline bool Type_IsValid(int value) {
    return ExternalsRelease_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ExternalsRelease_Type_Type_MIN;
  static const Type Type_MAX =
    ExternalsRelease_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ExternalsRelease_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ExternalsRelease_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ExternalsRelease_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ExternalsRelease_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EXTERNALSRELEASE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .falcon_externals_msg.ExternalsRelease.Type threatType = 3;
  inline bool has_threattype() const;
  inline void clear_threattype();
  static const int kThreatTypeFieldNumber = 3;
  inline ::falcon_externals_msg::ExternalsRelease_Type threattype() const;
  inline void set_threattype(::falcon_externals_msg::ExternalsRelease_Type value);

  // optional double freqMHz = 4;
  inline bool has_freqmhz() const;
  inline void clear_freqmhz();
  static const int kFreqMHzFieldNumber = 4;
  inline double freqmhz() const;
  inline void set_freqmhz(double value);

  // @@protoc_insertion_point(class_scope:falcon_externals_msg.ExternalsRelease)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_threattype();
  inline void clear_has_threattype();
  inline void set_has_freqmhz();
  inline void clear_has_freqmhz();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* name_;
  double freqmhz_;
  int threattype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_FalconExternalsMessages_2eproto();
  friend void protobuf_AssignDesc_FalconExternalsMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconExternalsMessages_2eproto();

  void InitAsDefaultInstance();
  static ExternalsRelease* default_instance_;
};
// -------------------------------------------------------------------

class NullHit : public ::google::protobuf::Message {
 public:
  NullHit();
  virtual ~NullHit();

  NullHit(const NullHit& from);

  inline NullHit& operator=(const NullHit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NullHit& default_instance();

  void Swap(NullHit* other);

  // implements Message ----------------------------------------------

  NullHit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NullHit& from);
  void MergeFrom(const NullHit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "NULLHIT"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  inline void set_allocated_timestamp(::std::string* timestamp);

  // optional double freqHz = 3;
  inline bool has_freqhz() const;
  inline void clear_freqhz();
  static const int kFreqHzFieldNumber = 3;
  inline double freqhz() const;
  inline void set_freqhz(double value);

  // optional string ramSnapID = 4;
  inline bool has_ramsnapid() const;
  inline void clear_ramsnapid();
  static const int kRamSnapIDFieldNumber = 4;
  inline const ::std::string& ramsnapid() const;
  inline void set_ramsnapid(const ::std::string& value);
  inline void set_ramsnapid(const char* value);
  inline void set_ramsnapid(const char* value, size_t size);
  inline ::std::string* mutable_ramsnapid();
  inline ::std::string* release_ramsnapid();
  inline void set_allocated_ramsnapid(::std::string* ramsnapid);

  // optional string detectorName = 5;
  inline bool has_detectorname() const;
  inline void clear_detectorname();
  static const int kDetectorNameFieldNumber = 5;
  inline const ::std::string& detectorname() const;
  inline void set_detectorname(const ::std::string& value);
  inline void set_detectorname(const char* value);
  inline void set_detectorname(const char* value, size_t size);
  inline ::std::string* mutable_detectorname();
  inline ::std::string* release_detectorname();
  inline void set_allocated_detectorname(::std::string* detectorname);

  // @@protoc_insertion_point(class_scope:falcon_externals_msg.NullHit)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_freqhz();
  inline void clear_has_freqhz();
  inline void set_has_ramsnapid();
  inline void clear_has_ramsnapid();
  inline void set_has_detectorname();
  inline void clear_has_detectorname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* timestamp_;
  double freqhz_;
  ::std::string* ramsnapid_;
  ::std::string* detectorname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_FalconExternalsMessages_2eproto();
  friend void protobuf_AssignDesc_FalconExternalsMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconExternalsMessages_2eproto();

  void InitAsDefaultInstance();
  static NullHit* default_instance_;
};
// ===================================================================


// ===================================================================

// ExternalsHit

// optional string msgName = 1 [default = "EXTERNALSHIT"];
inline bool ExternalsHit::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExternalsHit::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExternalsHit::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExternalsHit::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ExternalsHit::msgname() const {
  return *msgname_;
}
inline void ExternalsHit::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ExternalsHit::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ExternalsHit::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExternalsHit::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ExternalsHit::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ExternalsHit::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string name = 2;
inline bool ExternalsHit::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExternalsHit::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExternalsHit::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExternalsHit::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ExternalsHit::name() const {
  return *name_;
}
inline void ExternalsHit::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ExternalsHit::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ExternalsHit::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExternalsHit::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ExternalsHit::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExternalsHit::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .falcon_externals_msg.ExternalsHit.Type threatType = 3;
inline bool ExternalsHit::has_threattype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExternalsHit::set_has_threattype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExternalsHit::clear_has_threattype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExternalsHit::clear_threattype() {
  threattype_ = 0;
  clear_has_threattype();
}
inline ::falcon_externals_msg::ExternalsHit_Type ExternalsHit::threattype() const {
  return static_cast< ::falcon_externals_msg::ExternalsHit_Type >(threattype_);
}
inline void ExternalsHit::set_threattype(::falcon_externals_msg::ExternalsHit_Type value) {
  assert(::falcon_externals_msg::ExternalsHit_Type_IsValid(value));
  set_has_threattype();
  threattype_ = value;
}

// optional double freqMHz = 4;
inline bool ExternalsHit::has_freqmhz() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExternalsHit::set_has_freqmhz() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExternalsHit::clear_has_freqmhz() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExternalsHit::clear_freqmhz() {
  freqmhz_ = 0;
  clear_has_freqmhz();
}
inline double ExternalsHit::freqmhz() const {
  return freqmhz_;
}
inline void ExternalsHit::set_freqmhz(double value) {
  set_has_freqmhz();
  freqmhz_ = value;
}

// optional string globalId = 5 [default = "Functional"];
inline bool ExternalsHit::has_globalid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExternalsHit::set_has_globalid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExternalsHit::clear_has_globalid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExternalsHit::clear_globalid() {
  if (globalid_ != _default_globalid_) {
    globalid_->assign(*_default_globalid_);
  }
  clear_has_globalid();
}
inline const ::std::string& ExternalsHit::globalid() const {
  return *globalid_;
}
inline void ExternalsHit::set_globalid(const ::std::string& value) {
  set_has_globalid();
  if (globalid_ == _default_globalid_) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void ExternalsHit::set_globalid(const char* value) {
  set_has_globalid();
  if (globalid_ == _default_globalid_) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void ExternalsHit::set_globalid(const char* value, size_t size) {
  set_has_globalid();
  if (globalid_ == _default_globalid_) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExternalsHit::mutable_globalid() {
  set_has_globalid();
  if (globalid_ == _default_globalid_) {
    globalid_ = new ::std::string(*_default_globalid_);
  }
  return globalid_;
}
inline ::std::string* ExternalsHit::release_globalid() {
  clear_has_globalid();
  if (globalid_ == _default_globalid_) {
    return NULL;
  } else {
    ::std::string* temp = globalid_;
    globalid_ = const_cast< ::std::string*>(_default_globalid_);
    return temp;
  }
}
inline void ExternalsHit::set_allocated_globalid(::std::string* globalid) {
  if (globalid_ != _default_globalid_) {
    delete globalid_;
  }
  if (globalid) {
    set_has_globalid();
    globalid_ = globalid;
  } else {
    clear_has_globalid();
    globalid_ = const_cast< ::std::string*>(_default_globalid_);
  }
}

// optional int32 psuedoUniqueId = 6 [default = 0];
inline bool ExternalsHit::has_psuedouniqueid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ExternalsHit::set_has_psuedouniqueid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ExternalsHit::clear_has_psuedouniqueid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ExternalsHit::clear_psuedouniqueid() {
  psuedouniqueid_ = 0;
  clear_has_psuedouniqueid();
}
inline ::google::protobuf::int32 ExternalsHit::psuedouniqueid() const {
  return psuedouniqueid_;
}
inline void ExternalsHit::set_psuedouniqueid(::google::protobuf::int32 value) {
  set_has_psuedouniqueid();
  psuedouniqueid_ = value;
}

// optional int32 globalIdNum = 7 [default = 0];
inline bool ExternalsHit::has_globalidnum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ExternalsHit::set_has_globalidnum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ExternalsHit::clear_has_globalidnum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ExternalsHit::clear_globalidnum() {
  globalidnum_ = 0;
  clear_has_globalidnum();
}
inline ::google::protobuf::int32 ExternalsHit::globalidnum() const {
  return globalidnum_;
}
inline void ExternalsHit::set_globalidnum(::google::protobuf::int32 value) {
  set_has_globalidnum();
  globalidnum_ = value;
}

// optional string timestamp = 8;
inline bool ExternalsHit::has_timestamp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ExternalsHit::set_has_timestamp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ExternalsHit::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ExternalsHit::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& ExternalsHit::timestamp() const {
  return *timestamp_;
}
inline void ExternalsHit::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void ExternalsHit::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void ExternalsHit::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExternalsHit::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* ExternalsHit::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExternalsHit::set_allocated_timestamp(::std::string* timestamp) {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    delete timestamp_;
  }
  if (timestamp) {
    set_has_timestamp();
    timestamp_ = timestamp;
  } else {
    clear_has_timestamp();
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string channel = 9 [default = "1"];
inline bool ExternalsHit::has_channel() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ExternalsHit::set_has_channel() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ExternalsHit::clear_has_channel() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ExternalsHit::clear_channel() {
  if (channel_ != _default_channel_) {
    channel_->assign(*_default_channel_);
  }
  clear_has_channel();
}
inline const ::std::string& ExternalsHit::channel() const {
  return *channel_;
}
inline void ExternalsHit::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == _default_channel_) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void ExternalsHit::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == _default_channel_) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void ExternalsHit::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == _default_channel_) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExternalsHit::mutable_channel() {
  set_has_channel();
  if (channel_ == _default_channel_) {
    channel_ = new ::std::string(*_default_channel_);
  }
  return channel_;
}
inline ::std::string* ExternalsHit::release_channel() {
  clear_has_channel();
  if (channel_ == _default_channel_) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(_default_channel_);
    return temp;
  }
}
inline void ExternalsHit::set_allocated_channel(::std::string* channel) {
  if (channel_ != _default_channel_) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(_default_channel_);
  }
}

// optional bool isTrigger = 10 [default = false];
inline bool ExternalsHit::has_istrigger() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ExternalsHit::set_has_istrigger() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ExternalsHit::clear_has_istrigger() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ExternalsHit::clear_istrigger() {
  istrigger_ = false;
  clear_has_istrigger();
}
inline bool ExternalsHit::istrigger() const {
  return istrigger_;
}
inline void ExternalsHit::set_istrigger(bool value) {
  set_has_istrigger();
  istrigger_ = value;
}

// optional .falcon_externals_msg.HopDescriptor hopDescriptor = 11;
inline bool ExternalsHit::has_hopdescriptor() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ExternalsHit::set_has_hopdescriptor() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ExternalsHit::clear_has_hopdescriptor() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ExternalsHit::clear_hopdescriptor() {
  if (hopdescriptor_ != NULL) hopdescriptor_->::falcon_externals_msg::HopDescriptor::Clear();
  clear_has_hopdescriptor();
}
inline const ::falcon_externals_msg::HopDescriptor& ExternalsHit::hopdescriptor() const {
  return hopdescriptor_ != NULL ? *hopdescriptor_ : *default_instance_->hopdescriptor_;
}
inline ::falcon_externals_msg::HopDescriptor* ExternalsHit::mutable_hopdescriptor() {
  set_has_hopdescriptor();
  if (hopdescriptor_ == NULL) hopdescriptor_ = new ::falcon_externals_msg::HopDescriptor;
  return hopdescriptor_;
}
inline ::falcon_externals_msg::HopDescriptor* ExternalsHit::release_hopdescriptor() {
  clear_has_hopdescriptor();
  ::falcon_externals_msg::HopDescriptor* temp = hopdescriptor_;
  hopdescriptor_ = NULL;
  return temp;
}
inline void ExternalsHit::set_allocated_hopdescriptor(::falcon_externals_msg::HopDescriptor* hopdescriptor) {
  delete hopdescriptor_;
  hopdescriptor_ = hopdescriptor;
  if (hopdescriptor) {
    set_has_hopdescriptor();
  } else {
    clear_has_hopdescriptor();
  }
}

// optional .falcon_externals_msg.FSKDescriptor fskDescriptor = 12;
inline bool ExternalsHit::has_fskdescriptor() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ExternalsHit::set_has_fskdescriptor() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ExternalsHit::clear_has_fskdescriptor() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ExternalsHit::clear_fskdescriptor() {
  if (fskdescriptor_ != NULL) fskdescriptor_->::falcon_externals_msg::FSKDescriptor::Clear();
  clear_has_fskdescriptor();
}
inline const ::falcon_externals_msg::FSKDescriptor& ExternalsHit::fskdescriptor() const {
  return fskdescriptor_ != NULL ? *fskdescriptor_ : *default_instance_->fskdescriptor_;
}
inline ::falcon_externals_msg::FSKDescriptor* ExternalsHit::mutable_fskdescriptor() {
  set_has_fskdescriptor();
  if (fskdescriptor_ == NULL) fskdescriptor_ = new ::falcon_externals_msg::FSKDescriptor;
  return fskdescriptor_;
}
inline ::falcon_externals_msg::FSKDescriptor* ExternalsHit::release_fskdescriptor() {
  clear_has_fskdescriptor();
  ::falcon_externals_msg::FSKDescriptor* temp = fskdescriptor_;
  fskdescriptor_ = NULL;
  return temp;
}
inline void ExternalsHit::set_allocated_fskdescriptor(::falcon_externals_msg::FSKDescriptor* fskdescriptor) {
  delete fskdescriptor_;
  fskdescriptor_ = fskdescriptor;
  if (fskdescriptor) {
    set_has_fskdescriptor();
  } else {
    clear_has_fskdescriptor();
  }
}

// optional .falcon_externals_msg.CWDescriptor cwDescriptor = 13;
inline bool ExternalsHit::has_cwdescriptor() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ExternalsHit::set_has_cwdescriptor() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ExternalsHit::clear_has_cwdescriptor() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ExternalsHit::clear_cwdescriptor() {
  if (cwdescriptor_ != NULL) cwdescriptor_->::falcon_externals_msg::CWDescriptor::Clear();
  clear_has_cwdescriptor();
}
inline const ::falcon_externals_msg::CWDescriptor& ExternalsHit::cwdescriptor() const {
  return cwdescriptor_ != NULL ? *cwdescriptor_ : *default_instance_->cwdescriptor_;
}
inline ::falcon_externals_msg::CWDescriptor* ExternalsHit::mutable_cwdescriptor() {
  set_has_cwdescriptor();
  if (cwdescriptor_ == NULL) cwdescriptor_ = new ::falcon_externals_msg::CWDescriptor;
  return cwdescriptor_;
}
inline ::falcon_externals_msg::CWDescriptor* ExternalsHit::release_cwdescriptor() {
  clear_has_cwdescriptor();
  ::falcon_externals_msg::CWDescriptor* temp = cwdescriptor_;
  cwdescriptor_ = NULL;
  return temp;
}
inline void ExternalsHit::set_allocated_cwdescriptor(::falcon_externals_msg::CWDescriptor* cwdescriptor) {
  delete cwdescriptor_;
  cwdescriptor_ = cwdescriptor;
  if (cwdescriptor) {
    set_has_cwdescriptor();
  } else {
    clear_has_cwdescriptor();
  }
}

// optional .falcon_externals_msg.SpreadDescriptor spreadDescriptor = 14;
inline bool ExternalsHit::has_spreaddescriptor() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ExternalsHit::set_has_spreaddescriptor() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ExternalsHit::clear_has_spreaddescriptor() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ExternalsHit::clear_spreaddescriptor() {
  if (spreaddescriptor_ != NULL) spreaddescriptor_->::falcon_externals_msg::SpreadDescriptor::Clear();
  clear_has_spreaddescriptor();
}
inline const ::falcon_externals_msg::SpreadDescriptor& ExternalsHit::spreaddescriptor() const {
  return spreaddescriptor_ != NULL ? *spreaddescriptor_ : *default_instance_->spreaddescriptor_;
}
inline ::falcon_externals_msg::SpreadDescriptor* ExternalsHit::mutable_spreaddescriptor() {
  set_has_spreaddescriptor();
  if (spreaddescriptor_ == NULL) spreaddescriptor_ = new ::falcon_externals_msg::SpreadDescriptor;
  return spreaddescriptor_;
}
inline ::falcon_externals_msg::SpreadDescriptor* ExternalsHit::release_spreaddescriptor() {
  clear_has_spreaddescriptor();
  ::falcon_externals_msg::SpreadDescriptor* temp = spreaddescriptor_;
  spreaddescriptor_ = NULL;
  return temp;
}
inline void ExternalsHit::set_allocated_spreaddescriptor(::falcon_externals_msg::SpreadDescriptor* spreaddescriptor) {
  delete spreaddescriptor_;
  spreaddescriptor_ = spreaddescriptor;
  if (spreaddescriptor) {
    set_has_spreaddescriptor();
  } else {
    clear_has_spreaddescriptor();
  }
}

// optional .falcon_externals_msg.AVDescriptor AVidDescriptor = 15;
inline bool ExternalsHit::has_aviddescriptor() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ExternalsHit::set_has_aviddescriptor() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ExternalsHit::clear_has_aviddescriptor() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ExternalsHit::clear_aviddescriptor() {
  if (aviddescriptor_ != NULL) aviddescriptor_->::falcon_externals_msg::AVDescriptor::Clear();
  clear_has_aviddescriptor();
}
inline const ::falcon_externals_msg::AVDescriptor& ExternalsHit::aviddescriptor() const {
  return aviddescriptor_ != NULL ? *aviddescriptor_ : *default_instance_->aviddescriptor_;
}
inline ::falcon_externals_msg::AVDescriptor* ExternalsHit::mutable_aviddescriptor() {
  set_has_aviddescriptor();
  if (aviddescriptor_ == NULL) aviddescriptor_ = new ::falcon_externals_msg::AVDescriptor;
  return aviddescriptor_;
}
inline ::falcon_externals_msg::AVDescriptor* ExternalsHit::release_aviddescriptor() {
  clear_has_aviddescriptor();
  ::falcon_externals_msg::AVDescriptor* temp = aviddescriptor_;
  aviddescriptor_ = NULL;
  return temp;
}
inline void ExternalsHit::set_allocated_aviddescriptor(::falcon_externals_msg::AVDescriptor* aviddescriptor) {
  delete aviddescriptor_;
  aviddescriptor_ = aviddescriptor;
  if (aviddescriptor) {
    set_has_aviddescriptor();
  } else {
    clear_has_aviddescriptor();
  }
}

// optional .falcon_externals_msg.DsssDescriptor DsssDescriptor = 16;
inline bool ExternalsHit::has_dsssdescriptor() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ExternalsHit::set_has_dsssdescriptor() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ExternalsHit::clear_has_dsssdescriptor() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ExternalsHit::clear_dsssdescriptor() {
  if (dsssdescriptor_ != NULL) dsssdescriptor_->::falcon_externals_msg::DsssDescriptor::Clear();
  clear_has_dsssdescriptor();
}
inline const ::falcon_externals_msg::DsssDescriptor& ExternalsHit::dsssdescriptor() const {
  return dsssdescriptor_ != NULL ? *dsssdescriptor_ : *default_instance_->dsssdescriptor_;
}
inline ::falcon_externals_msg::DsssDescriptor* ExternalsHit::mutable_dsssdescriptor() {
  set_has_dsssdescriptor();
  if (dsssdescriptor_ == NULL) dsssdescriptor_ = new ::falcon_externals_msg::DsssDescriptor;
  return dsssdescriptor_;
}
inline ::falcon_externals_msg::DsssDescriptor* ExternalsHit::release_dsssdescriptor() {
  clear_has_dsssdescriptor();
  ::falcon_externals_msg::DsssDescriptor* temp = dsssdescriptor_;
  dsssdescriptor_ = NULL;
  return temp;
}
inline void ExternalsHit::set_allocated_dsssdescriptor(::falcon_externals_msg::DsssDescriptor* dsssdescriptor) {
  delete dsssdescriptor_;
  dsssdescriptor_ = dsssdescriptor;
  if (dsssdescriptor) {
    set_has_dsssdescriptor();
  } else {
    clear_has_dsssdescriptor();
  }
}

// optional int32 updateValues = 17 [default = 0];
inline bool ExternalsHit::has_updatevalues() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ExternalsHit::set_has_updatevalues() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ExternalsHit::clear_has_updatevalues() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ExternalsHit::clear_updatevalues() {
  updatevalues_ = 0;
  clear_has_updatevalues();
}
inline ::google::protobuf::int32 ExternalsHit::updatevalues() const {
  return updatevalues_;
}
inline void ExternalsHit::set_updatevalues(::google::protobuf::int32 value) {
  set_has_updatevalues();
  updatevalues_ = value;
}

// optional string soiNum = 18 [default = "0"];
inline bool ExternalsHit::has_soinum() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ExternalsHit::set_has_soinum() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ExternalsHit::clear_has_soinum() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ExternalsHit::clear_soinum() {
  if (soinum_ != _default_soinum_) {
    soinum_->assign(*_default_soinum_);
  }
  clear_has_soinum();
}
inline const ::std::string& ExternalsHit::soinum() const {
  return *soinum_;
}
inline void ExternalsHit::set_soinum(const ::std::string& value) {
  set_has_soinum();
  if (soinum_ == _default_soinum_) {
    soinum_ = new ::std::string;
  }
  soinum_->assign(value);
}
inline void ExternalsHit::set_soinum(const char* value) {
  set_has_soinum();
  if (soinum_ == _default_soinum_) {
    soinum_ = new ::std::string;
  }
  soinum_->assign(value);
}
inline void ExternalsHit::set_soinum(const char* value, size_t size) {
  set_has_soinum();
  if (soinum_ == _default_soinum_) {
    soinum_ = new ::std::string;
  }
  soinum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExternalsHit::mutable_soinum() {
  set_has_soinum();
  if (soinum_ == _default_soinum_) {
    soinum_ = new ::std::string(*_default_soinum_);
  }
  return soinum_;
}
inline ::std::string* ExternalsHit::release_soinum() {
  clear_has_soinum();
  if (soinum_ == _default_soinum_) {
    return NULL;
  } else {
    ::std::string* temp = soinum_;
    soinum_ = const_cast< ::std::string*>(_default_soinum_);
    return temp;
  }
}
inline void ExternalsHit::set_allocated_soinum(::std::string* soinum) {
  if (soinum_ != _default_soinum_) {
    delete soinum_;
  }
  if (soinum) {
    set_has_soinum();
    soinum_ = soinum;
  } else {
    clear_has_soinum();
    soinum_ = const_cast< ::std::string*>(_default_soinum_);
  }
}

// -------------------------------------------------------------------

// InternalsHit

// optional string msgName = 1 [default = "INTERNALSHIT"];
inline bool InternalsHit::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalsHit::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalsHit::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalsHit::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& InternalsHit::msgname() const {
  return *msgname_;
}
inline void InternalsHit::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void InternalsHit::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void InternalsHit::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InternalsHit::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* InternalsHit::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void InternalsHit::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string name = 2;
inline bool InternalsHit::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalsHit::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalsHit::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalsHit::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& InternalsHit::name() const {
  return *name_;
}
inline void InternalsHit::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void InternalsHit::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void InternalsHit::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InternalsHit::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* InternalsHit::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InternalsHit::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double freqMHz = 3;
inline bool InternalsHit::has_freqmhz() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InternalsHit::set_has_freqmhz() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InternalsHit::clear_has_freqmhz() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InternalsHit::clear_freqmhz() {
  freqmhz_ = 0;
  clear_has_freqmhz();
}
inline double InternalsHit::freqmhz() const {
  return freqmhz_;
}
inline void InternalsHit::set_freqmhz(double value) {
  set_has_freqmhz();
  freqmhz_ = value;
}

// optional string globalId = 4 [default = "Functional"];
inline bool InternalsHit::has_globalid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InternalsHit::set_has_globalid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InternalsHit::clear_has_globalid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InternalsHit::clear_globalid() {
  if (globalid_ != _default_globalid_) {
    globalid_->assign(*_default_globalid_);
  }
  clear_has_globalid();
}
inline const ::std::string& InternalsHit::globalid() const {
  return *globalid_;
}
inline void InternalsHit::set_globalid(const ::std::string& value) {
  set_has_globalid();
  if (globalid_ == _default_globalid_) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void InternalsHit::set_globalid(const char* value) {
  set_has_globalid();
  if (globalid_ == _default_globalid_) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void InternalsHit::set_globalid(const char* value, size_t size) {
  set_has_globalid();
  if (globalid_ == _default_globalid_) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InternalsHit::mutable_globalid() {
  set_has_globalid();
  if (globalid_ == _default_globalid_) {
    globalid_ = new ::std::string(*_default_globalid_);
  }
  return globalid_;
}
inline ::std::string* InternalsHit::release_globalid() {
  clear_has_globalid();
  if (globalid_ == _default_globalid_) {
    return NULL;
  } else {
    ::std::string* temp = globalid_;
    globalid_ = const_cast< ::std::string*>(_default_globalid_);
    return temp;
  }
}
inline void InternalsHit::set_allocated_globalid(::std::string* globalid) {
  if (globalid_ != _default_globalid_) {
    delete globalid_;
  }
  if (globalid) {
    set_has_globalid();
    globalid_ = globalid;
  } else {
    clear_has_globalid();
    globalid_ = const_cast< ::std::string*>(_default_globalid_);
  }
}

// optional int32 psuedoUniqueId = 5 [default = 0];
inline bool InternalsHit::has_psuedouniqueid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InternalsHit::set_has_psuedouniqueid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InternalsHit::clear_has_psuedouniqueid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InternalsHit::clear_psuedouniqueid() {
  psuedouniqueid_ = 0;
  clear_has_psuedouniqueid();
}
inline ::google::protobuf::int32 InternalsHit::psuedouniqueid() const {
  return psuedouniqueid_;
}
inline void InternalsHit::set_psuedouniqueid(::google::protobuf::int32 value) {
  set_has_psuedouniqueid();
  psuedouniqueid_ = value;
}

// optional int32 globalIdNum = 6 [default = 0];
inline bool InternalsHit::has_globalidnum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InternalsHit::set_has_globalidnum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InternalsHit::clear_has_globalidnum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InternalsHit::clear_globalidnum() {
  globalidnum_ = 0;
  clear_has_globalidnum();
}
inline ::google::protobuf::int32 InternalsHit::globalidnum() const {
  return globalidnum_;
}
inline void InternalsHit::set_globalidnum(::google::protobuf::int32 value) {
  set_has_globalidnum();
  globalidnum_ = value;
}

// optional string timestamp = 7;
inline bool InternalsHit::has_timestamp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InternalsHit::set_has_timestamp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InternalsHit::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InternalsHit::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& InternalsHit::timestamp() const {
  return *timestamp_;
}
inline void InternalsHit::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void InternalsHit::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void InternalsHit::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InternalsHit::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* InternalsHit::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InternalsHit::set_allocated_timestamp(::std::string* timestamp) {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    delete timestamp_;
  }
  if (timestamp) {
    set_has_timestamp();
    timestamp_ = timestamp;
  } else {
    clear_has_timestamp();
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string channel = 8 [default = "1"];
inline bool InternalsHit::has_channel() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InternalsHit::set_has_channel() {
  _has_bits_[0] |= 0x00000080u;
}
inline void InternalsHit::clear_has_channel() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void InternalsHit::clear_channel() {
  if (channel_ != _default_channel_) {
    channel_->assign(*_default_channel_);
  }
  clear_has_channel();
}
inline const ::std::string& InternalsHit::channel() const {
  return *channel_;
}
inline void InternalsHit::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == _default_channel_) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void InternalsHit::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == _default_channel_) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void InternalsHit::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == _default_channel_) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InternalsHit::mutable_channel() {
  set_has_channel();
  if (channel_ == _default_channel_) {
    channel_ = new ::std::string(*_default_channel_);
  }
  return channel_;
}
inline ::std::string* InternalsHit::release_channel() {
  clear_has_channel();
  if (channel_ == _default_channel_) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(_default_channel_);
    return temp;
  }
}
inline void InternalsHit::set_allocated_channel(::std::string* channel) {
  if (channel_ != _default_channel_) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(_default_channel_);
  }
}

// optional bool isTrigger = 9 [default = false];
inline bool InternalsHit::has_istrigger() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void InternalsHit::set_has_istrigger() {
  _has_bits_[0] |= 0x00000100u;
}
inline void InternalsHit::clear_has_istrigger() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void InternalsHit::clear_istrigger() {
  istrigger_ = false;
  clear_has_istrigger();
}
inline bool InternalsHit::istrigger() const {
  return istrigger_;
}
inline void InternalsHit::set_istrigger(bool value) {
  set_has_istrigger();
  istrigger_ = value;
}

// optional .falcon_externals_msg.HopDescriptor hopDescriptor = 10;
inline bool InternalsHit::has_hopdescriptor() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void InternalsHit::set_has_hopdescriptor() {
  _has_bits_[0] |= 0x00000200u;
}
inline void InternalsHit::clear_has_hopdescriptor() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void InternalsHit::clear_hopdescriptor() {
  if (hopdescriptor_ != NULL) hopdescriptor_->::falcon_externals_msg::HopDescriptor::Clear();
  clear_has_hopdescriptor();
}
inline const ::falcon_externals_msg::HopDescriptor& InternalsHit::hopdescriptor() const {
  return hopdescriptor_ != NULL ? *hopdescriptor_ : *default_instance_->hopdescriptor_;
}
inline ::falcon_externals_msg::HopDescriptor* InternalsHit::mutable_hopdescriptor() {
  set_has_hopdescriptor();
  if (hopdescriptor_ == NULL) hopdescriptor_ = new ::falcon_externals_msg::HopDescriptor;
  return hopdescriptor_;
}
inline ::falcon_externals_msg::HopDescriptor* InternalsHit::release_hopdescriptor() {
  clear_has_hopdescriptor();
  ::falcon_externals_msg::HopDescriptor* temp = hopdescriptor_;
  hopdescriptor_ = NULL;
  return temp;
}
inline void InternalsHit::set_allocated_hopdescriptor(::falcon_externals_msg::HopDescriptor* hopdescriptor) {
  delete hopdescriptor_;
  hopdescriptor_ = hopdescriptor;
  if (hopdescriptor) {
    set_has_hopdescriptor();
  } else {
    clear_has_hopdescriptor();
  }
}

// optional .falcon_externals_msg.FSKDescriptor fskDescriptor = 11;
inline bool InternalsHit::has_fskdescriptor() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void InternalsHit::set_has_fskdescriptor() {
  _has_bits_[0] |= 0x00000400u;
}
inline void InternalsHit::clear_has_fskdescriptor() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void InternalsHit::clear_fskdescriptor() {
  if (fskdescriptor_ != NULL) fskdescriptor_->::falcon_externals_msg::FSKDescriptor::Clear();
  clear_has_fskdescriptor();
}
inline const ::falcon_externals_msg::FSKDescriptor& InternalsHit::fskdescriptor() const {
  return fskdescriptor_ != NULL ? *fskdescriptor_ : *default_instance_->fskdescriptor_;
}
inline ::falcon_externals_msg::FSKDescriptor* InternalsHit::mutable_fskdescriptor() {
  set_has_fskdescriptor();
  if (fskdescriptor_ == NULL) fskdescriptor_ = new ::falcon_externals_msg::FSKDescriptor;
  return fskdescriptor_;
}
inline ::falcon_externals_msg::FSKDescriptor* InternalsHit::release_fskdescriptor() {
  clear_has_fskdescriptor();
  ::falcon_externals_msg::FSKDescriptor* temp = fskdescriptor_;
  fskdescriptor_ = NULL;
  return temp;
}
inline void InternalsHit::set_allocated_fskdescriptor(::falcon_externals_msg::FSKDescriptor* fskdescriptor) {
  delete fskdescriptor_;
  fskdescriptor_ = fskdescriptor;
  if (fskdescriptor) {
    set_has_fskdescriptor();
  } else {
    clear_has_fskdescriptor();
  }
}

// optional .falcon_externals_msg.CWDescriptor cwDescriptor = 12;
inline bool InternalsHit::has_cwdescriptor() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void InternalsHit::set_has_cwdescriptor() {
  _has_bits_[0] |= 0x00000800u;
}
inline void InternalsHit::clear_has_cwdescriptor() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void InternalsHit::clear_cwdescriptor() {
  if (cwdescriptor_ != NULL) cwdescriptor_->::falcon_externals_msg::CWDescriptor::Clear();
  clear_has_cwdescriptor();
}
inline const ::falcon_externals_msg::CWDescriptor& InternalsHit::cwdescriptor() const {
  return cwdescriptor_ != NULL ? *cwdescriptor_ : *default_instance_->cwdescriptor_;
}
inline ::falcon_externals_msg::CWDescriptor* InternalsHit::mutable_cwdescriptor() {
  set_has_cwdescriptor();
  if (cwdescriptor_ == NULL) cwdescriptor_ = new ::falcon_externals_msg::CWDescriptor;
  return cwdescriptor_;
}
inline ::falcon_externals_msg::CWDescriptor* InternalsHit::release_cwdescriptor() {
  clear_has_cwdescriptor();
  ::falcon_externals_msg::CWDescriptor* temp = cwdescriptor_;
  cwdescriptor_ = NULL;
  return temp;
}
inline void InternalsHit::set_allocated_cwdescriptor(::falcon_externals_msg::CWDescriptor* cwdescriptor) {
  delete cwdescriptor_;
  cwdescriptor_ = cwdescriptor;
  if (cwdescriptor) {
    set_has_cwdescriptor();
  } else {
    clear_has_cwdescriptor();
  }
}

// optional .falcon_externals_msg.SpreadDescriptor spreadDescriptor = 13;
inline bool InternalsHit::has_spreaddescriptor() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void InternalsHit::set_has_spreaddescriptor() {
  _has_bits_[0] |= 0x00001000u;
}
inline void InternalsHit::clear_has_spreaddescriptor() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void InternalsHit::clear_spreaddescriptor() {
  if (spreaddescriptor_ != NULL) spreaddescriptor_->::falcon_externals_msg::SpreadDescriptor::Clear();
  clear_has_spreaddescriptor();
}
inline const ::falcon_externals_msg::SpreadDescriptor& InternalsHit::spreaddescriptor() const {
  return spreaddescriptor_ != NULL ? *spreaddescriptor_ : *default_instance_->spreaddescriptor_;
}
inline ::falcon_externals_msg::SpreadDescriptor* InternalsHit::mutable_spreaddescriptor() {
  set_has_spreaddescriptor();
  if (spreaddescriptor_ == NULL) spreaddescriptor_ = new ::falcon_externals_msg::SpreadDescriptor;
  return spreaddescriptor_;
}
inline ::falcon_externals_msg::SpreadDescriptor* InternalsHit::release_spreaddescriptor() {
  clear_has_spreaddescriptor();
  ::falcon_externals_msg::SpreadDescriptor* temp = spreaddescriptor_;
  spreaddescriptor_ = NULL;
  return temp;
}
inline void InternalsHit::set_allocated_spreaddescriptor(::falcon_externals_msg::SpreadDescriptor* spreaddescriptor) {
  delete spreaddescriptor_;
  spreaddescriptor_ = spreaddescriptor;
  if (spreaddescriptor) {
    set_has_spreaddescriptor();
  } else {
    clear_has_spreaddescriptor();
  }
}

// optional .falcon_externals_msg.AVDescriptor AVidDescriptor = 14;
inline bool InternalsHit::has_aviddescriptor() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void InternalsHit::set_has_aviddescriptor() {
  _has_bits_[0] |= 0x00002000u;
}
inline void InternalsHit::clear_has_aviddescriptor() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void InternalsHit::clear_aviddescriptor() {
  if (aviddescriptor_ != NULL) aviddescriptor_->::falcon_externals_msg::AVDescriptor::Clear();
  clear_has_aviddescriptor();
}
inline const ::falcon_externals_msg::AVDescriptor& InternalsHit::aviddescriptor() const {
  return aviddescriptor_ != NULL ? *aviddescriptor_ : *default_instance_->aviddescriptor_;
}
inline ::falcon_externals_msg::AVDescriptor* InternalsHit::mutable_aviddescriptor() {
  set_has_aviddescriptor();
  if (aviddescriptor_ == NULL) aviddescriptor_ = new ::falcon_externals_msg::AVDescriptor;
  return aviddescriptor_;
}
inline ::falcon_externals_msg::AVDescriptor* InternalsHit::release_aviddescriptor() {
  clear_has_aviddescriptor();
  ::falcon_externals_msg::AVDescriptor* temp = aviddescriptor_;
  aviddescriptor_ = NULL;
  return temp;
}
inline void InternalsHit::set_allocated_aviddescriptor(::falcon_externals_msg::AVDescriptor* aviddescriptor) {
  delete aviddescriptor_;
  aviddescriptor_ = aviddescriptor;
  if (aviddescriptor) {
    set_has_aviddescriptor();
  } else {
    clear_has_aviddescriptor();
  }
}

// optional .falcon_externals_msg.DsssDescriptor DsssDescriptor = 16;
inline bool InternalsHit::has_dsssdescriptor() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void InternalsHit::set_has_dsssdescriptor() {
  _has_bits_[0] |= 0x00004000u;
}
inline void InternalsHit::clear_has_dsssdescriptor() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void InternalsHit::clear_dsssdescriptor() {
  if (dsssdescriptor_ != NULL) dsssdescriptor_->::falcon_externals_msg::DsssDescriptor::Clear();
  clear_has_dsssdescriptor();
}
inline const ::falcon_externals_msg::DsssDescriptor& InternalsHit::dsssdescriptor() const {
  return dsssdescriptor_ != NULL ? *dsssdescriptor_ : *default_instance_->dsssdescriptor_;
}
inline ::falcon_externals_msg::DsssDescriptor* InternalsHit::mutable_dsssdescriptor() {
  set_has_dsssdescriptor();
  if (dsssdescriptor_ == NULL) dsssdescriptor_ = new ::falcon_externals_msg::DsssDescriptor;
  return dsssdescriptor_;
}
inline ::falcon_externals_msg::DsssDescriptor* InternalsHit::release_dsssdescriptor() {
  clear_has_dsssdescriptor();
  ::falcon_externals_msg::DsssDescriptor* temp = dsssdescriptor_;
  dsssdescriptor_ = NULL;
  return temp;
}
inline void InternalsHit::set_allocated_dsssdescriptor(::falcon_externals_msg::DsssDescriptor* dsssdescriptor) {
  delete dsssdescriptor_;
  dsssdescriptor_ = dsssdescriptor;
  if (dsssdescriptor) {
    set_has_dsssdescriptor();
  } else {
    clear_has_dsssdescriptor();
  }
}

// optional int32 updateValues = 17 [default = 0];
inline bool InternalsHit::has_updatevalues() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void InternalsHit::set_has_updatevalues() {
  _has_bits_[0] |= 0x00008000u;
}
inline void InternalsHit::clear_has_updatevalues() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void InternalsHit::clear_updatevalues() {
  updatevalues_ = 0;
  clear_has_updatevalues();
}
inline ::google::protobuf::int32 InternalsHit::updatevalues() const {
  return updatevalues_;
}
inline void InternalsHit::set_updatevalues(::google::protobuf::int32 value) {
  set_has_updatevalues();
  updatevalues_ = value;
}

// optional string soiNum = 18 [default = "0"];
inline bool InternalsHit::has_soinum() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void InternalsHit::set_has_soinum() {
  _has_bits_[0] |= 0x00010000u;
}
inline void InternalsHit::clear_has_soinum() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void InternalsHit::clear_soinum() {
  if (soinum_ != _default_soinum_) {
    soinum_->assign(*_default_soinum_);
  }
  clear_has_soinum();
}
inline const ::std::string& InternalsHit::soinum() const {
  return *soinum_;
}
inline void InternalsHit::set_soinum(const ::std::string& value) {
  set_has_soinum();
  if (soinum_ == _default_soinum_) {
    soinum_ = new ::std::string;
  }
  soinum_->assign(value);
}
inline void InternalsHit::set_soinum(const char* value) {
  set_has_soinum();
  if (soinum_ == _default_soinum_) {
    soinum_ = new ::std::string;
  }
  soinum_->assign(value);
}
inline void InternalsHit::set_soinum(const char* value, size_t size) {
  set_has_soinum();
  if (soinum_ == _default_soinum_) {
    soinum_ = new ::std::string;
  }
  soinum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InternalsHit::mutable_soinum() {
  set_has_soinum();
  if (soinum_ == _default_soinum_) {
    soinum_ = new ::std::string(*_default_soinum_);
  }
  return soinum_;
}
inline ::std::string* InternalsHit::release_soinum() {
  clear_has_soinum();
  if (soinum_ == _default_soinum_) {
    return NULL;
  } else {
    ::std::string* temp = soinum_;
    soinum_ = const_cast< ::std::string*>(_default_soinum_);
    return temp;
  }
}
inline void InternalsHit::set_allocated_soinum(::std::string* soinum) {
  if (soinum_ != _default_soinum_) {
    delete soinum_;
  }
  if (soinum) {
    set_has_soinum();
    soinum_ = soinum;
  } else {
    clear_has_soinum();
    soinum_ = const_cast< ::std::string*>(_default_soinum_);
  }
}

// -------------------------------------------------------------------

// DsssDescriptor

// optional string fileName = 1;
inline bool DsssDescriptor::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DsssDescriptor::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DsssDescriptor::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DsssDescriptor::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& DsssDescriptor::filename() const {
  return *filename_;
}
inline void DsssDescriptor::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void DsssDescriptor::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void DsssDescriptor::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DsssDescriptor::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* DsssDescriptor::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DsssDescriptor::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 mode = 2;
inline bool DsssDescriptor::has_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DsssDescriptor::set_has_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DsssDescriptor::clear_has_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DsssDescriptor::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::google::protobuf::int32 DsssDescriptor::mode() const {
  return mode_;
}
inline void DsssDescriptor::set_mode(::google::protobuf::int32 value) {
  set_has_mode();
  mode_ = value;
}

// -------------------------------------------------------------------

// HopDescriptor

// optional double hopRate = 1;
inline bool HopDescriptor::has_hoprate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HopDescriptor::set_has_hoprate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HopDescriptor::clear_has_hoprate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HopDescriptor::clear_hoprate() {
  hoprate_ = 0;
  clear_has_hoprate();
}
inline double HopDescriptor::hoprate() const {
  return hoprate_;
}
inline void HopDescriptor::set_hoprate(double value) {
  set_has_hoprate();
  hoprate_ = value;
}

// optional double totalHopBW = 2;
inline bool HopDescriptor::has_totalhopbw() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HopDescriptor::set_has_totalhopbw() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HopDescriptor::clear_has_totalhopbw() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HopDescriptor::clear_totalhopbw() {
  totalhopbw_ = 0;
  clear_has_totalhopbw();
}
inline double HopDescriptor::totalhopbw() const {
  return totalhopbw_;
}
inline void HopDescriptor::set_totalhopbw(double value) {
  set_has_totalhopbw();
  totalhopbw_ = value;
}

// optional double indHopBW = 3;
inline bool HopDescriptor::has_indhopbw() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HopDescriptor::set_has_indhopbw() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HopDescriptor::clear_has_indhopbw() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HopDescriptor::clear_indhopbw() {
  indhopbw_ = 0;
  clear_has_indhopbw();
}
inline double HopDescriptor::indhopbw() const {
  return indhopbw_;
}
inline void HopDescriptor::set_indhopbw(double value) {
  set_has_indhopbw();
  indhopbw_ = value;
}

// optional double hopDuration = 4;
inline bool HopDescriptor::has_hopduration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HopDescriptor::set_has_hopduration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HopDescriptor::clear_has_hopduration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HopDescriptor::clear_hopduration() {
  hopduration_ = 0;
  clear_has_hopduration();
}
inline double HopDescriptor::hopduration() const {
  return hopduration_;
}
inline void HopDescriptor::set_hopduration(double value) {
  set_has_hopduration();
  hopduration_ = value;
}

// optional double hopPower = 5;
inline bool HopDescriptor::has_hoppower() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HopDescriptor::set_has_hoppower() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HopDescriptor::clear_has_hoppower() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HopDescriptor::clear_hoppower() {
  hoppower_ = 0;
  clear_has_hoppower();
}
inline double HopDescriptor::hoppower() const {
  return hoppower_;
}
inline void HopDescriptor::set_hoppower(double value) {
  set_has_hoppower();
  hoppower_ = value;
}

// optional int32 freqsUsedBlind = 6;
inline bool HopDescriptor::has_freqsusedblind() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HopDescriptor::set_has_freqsusedblind() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HopDescriptor::clear_has_freqsusedblind() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HopDescriptor::clear_freqsusedblind() {
  freqsusedblind_ = 0;
  clear_has_freqsusedblind();
}
inline ::google::protobuf::int32 HopDescriptor::freqsusedblind() const {
  return freqsusedblind_;
}
inline void HopDescriptor::set_freqsusedblind(::google::protobuf::int32 value) {
  set_has_freqsusedblind();
  freqsusedblind_ = value;
}

// optional int32 freqsUsedCorr = 7;
inline bool HopDescriptor::has_freqsusedcorr() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HopDescriptor::set_has_freqsusedcorr() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HopDescriptor::clear_has_freqsusedcorr() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HopDescriptor::clear_freqsusedcorr() {
  freqsusedcorr_ = 0;
  clear_has_freqsusedcorr();
}
inline ::google::protobuf::int32 HopDescriptor::freqsusedcorr() const {
  return freqsusedcorr_;
}
inline void HopDescriptor::set_freqsusedcorr(::google::protobuf::int32 value) {
  set_has_freqsusedcorr();
  freqsusedcorr_ = value;
}

// -------------------------------------------------------------------

// FSKDescriptor

// optional double centerFreq = 1;
inline bool FSKDescriptor::has_centerfreq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FSKDescriptor::set_has_centerfreq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FSKDescriptor::clear_has_centerfreq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FSKDescriptor::clear_centerfreq() {
  centerfreq_ = 0;
  clear_has_centerfreq();
}
inline double FSKDescriptor::centerfreq() const {
  return centerfreq_;
}
inline void FSKDescriptor::set_centerfreq(double value) {
  set_has_centerfreq();
  centerfreq_ = value;
}

// optional double excursion = 2;
inline bool FSKDescriptor::has_excursion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FSKDescriptor::set_has_excursion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FSKDescriptor::clear_has_excursion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FSKDescriptor::clear_excursion() {
  excursion_ = 0;
  clear_has_excursion();
}
inline double FSKDescriptor::excursion() const {
  return excursion_;
}
inline void FSKDescriptor::set_excursion(double value) {
  set_has_excursion();
  excursion_ = value;
}

// optional double baudRate = 3;
inline bool FSKDescriptor::has_baudrate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FSKDescriptor::set_has_baudrate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FSKDescriptor::clear_has_baudrate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FSKDescriptor::clear_baudrate() {
  baudrate_ = 0;
  clear_has_baudrate();
}
inline double FSKDescriptor::baudrate() const {
  return baudrate_;
}
inline void FSKDescriptor::set_baudrate(double value) {
  set_has_baudrate();
  baudrate_ = value;
}

// -------------------------------------------------------------------

// CWDescriptor

// optional double centerFreq = 1;
inline bool CWDescriptor::has_centerfreq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CWDescriptor::set_has_centerfreq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CWDescriptor::clear_has_centerfreq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CWDescriptor::clear_centerfreq() {
  centerfreq_ = 0;
  clear_has_centerfreq();
}
inline double CWDescriptor::centerfreq() const {
  return centerfreq_;
}
inline void CWDescriptor::set_centerfreq(double value) {
  set_has_centerfreq();
  centerfreq_ = value;
}

// optional double power = 2;
inline bool CWDescriptor::has_power() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CWDescriptor::set_has_power() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CWDescriptor::clear_has_power() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CWDescriptor::clear_power() {
  power_ = 0;
  clear_has_power();
}
inline double CWDescriptor::power() const {
  return power_;
}
inline void CWDescriptor::set_power(double value) {
  set_has_power();
  power_ = value;
}

// -------------------------------------------------------------------

// SpreadDescriptor

// optional double centerFreq = 1;
inline bool SpreadDescriptor::has_centerfreq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpreadDescriptor::set_has_centerfreq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpreadDescriptor::clear_has_centerfreq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpreadDescriptor::clear_centerfreq() {
  centerfreq_ = 0;
  clear_has_centerfreq();
}
inline double SpreadDescriptor::centerfreq() const {
  return centerfreq_;
}
inline void SpreadDescriptor::set_centerfreq(double value) {
  set_has_centerfreq();
  centerfreq_ = value;
}

// optional double chipRate = 2;
inline bool SpreadDescriptor::has_chiprate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpreadDescriptor::set_has_chiprate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpreadDescriptor::clear_has_chiprate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpreadDescriptor::clear_chiprate() {
  chiprate_ = 0;
  clear_has_chiprate();
}
inline double SpreadDescriptor::chiprate() const {
  return chiprate_;
}
inline void SpreadDescriptor::set_chiprate(double value) {
  set_has_chiprate();
  chiprate_ = value;
}

// optional string modulation = 3;
inline bool SpreadDescriptor::has_modulation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SpreadDescriptor::set_has_modulation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SpreadDescriptor::clear_has_modulation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SpreadDescriptor::clear_modulation() {
  if (modulation_ != &::google::protobuf::internal::kEmptyString) {
    modulation_->clear();
  }
  clear_has_modulation();
}
inline const ::std::string& SpreadDescriptor::modulation() const {
  return *modulation_;
}
inline void SpreadDescriptor::set_modulation(const ::std::string& value) {
  set_has_modulation();
  if (modulation_ == &::google::protobuf::internal::kEmptyString) {
    modulation_ = new ::std::string;
  }
  modulation_->assign(value);
}
inline void SpreadDescriptor::set_modulation(const char* value) {
  set_has_modulation();
  if (modulation_ == &::google::protobuf::internal::kEmptyString) {
    modulation_ = new ::std::string;
  }
  modulation_->assign(value);
}
inline void SpreadDescriptor::set_modulation(const char* value, size_t size) {
  set_has_modulation();
  if (modulation_ == &::google::protobuf::internal::kEmptyString) {
    modulation_ = new ::std::string;
  }
  modulation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpreadDescriptor::mutable_modulation() {
  set_has_modulation();
  if (modulation_ == &::google::protobuf::internal::kEmptyString) {
    modulation_ = new ::std::string;
  }
  return modulation_;
}
inline ::std::string* SpreadDescriptor::release_modulation() {
  clear_has_modulation();
  if (modulation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = modulation_;
    modulation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SpreadDescriptor::set_allocated_modulation(::std::string* modulation) {
  if (modulation_ != &::google::protobuf::internal::kEmptyString) {
    delete modulation_;
  }
  if (modulation) {
    set_has_modulation();
    modulation_ = modulation;
  } else {
    clear_has_modulation();
    modulation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 pnSeqLength = 4;
inline bool SpreadDescriptor::has_pnseqlength() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SpreadDescriptor::set_has_pnseqlength() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SpreadDescriptor::clear_has_pnseqlength() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SpreadDescriptor::clear_pnseqlength() {
  pnseqlength_ = 0;
  clear_has_pnseqlength();
}
inline ::google::protobuf::int32 SpreadDescriptor::pnseqlength() const {
  return pnseqlength_;
}
inline void SpreadDescriptor::set_pnseqlength(::google::protobuf::int32 value) {
  set_has_pnseqlength();
  pnseqlength_ = value;
}

// optional string polynomial = 5;
inline bool SpreadDescriptor::has_polynomial() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SpreadDescriptor::set_has_polynomial() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SpreadDescriptor::clear_has_polynomial() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SpreadDescriptor::clear_polynomial() {
  if (polynomial_ != &::google::protobuf::internal::kEmptyString) {
    polynomial_->clear();
  }
  clear_has_polynomial();
}
inline const ::std::string& SpreadDescriptor::polynomial() const {
  return *polynomial_;
}
inline void SpreadDescriptor::set_polynomial(const ::std::string& value) {
  set_has_polynomial();
  if (polynomial_ == &::google::protobuf::internal::kEmptyString) {
    polynomial_ = new ::std::string;
  }
  polynomial_->assign(value);
}
inline void SpreadDescriptor::set_polynomial(const char* value) {
  set_has_polynomial();
  if (polynomial_ == &::google::protobuf::internal::kEmptyString) {
    polynomial_ = new ::std::string;
  }
  polynomial_->assign(value);
}
inline void SpreadDescriptor::set_polynomial(const char* value, size_t size) {
  set_has_polynomial();
  if (polynomial_ == &::google::protobuf::internal::kEmptyString) {
    polynomial_ = new ::std::string;
  }
  polynomial_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpreadDescriptor::mutable_polynomial() {
  set_has_polynomial();
  if (polynomial_ == &::google::protobuf::internal::kEmptyString) {
    polynomial_ = new ::std::string;
  }
  return polynomial_;
}
inline ::std::string* SpreadDescriptor::release_polynomial() {
  clear_has_polynomial();
  if (polynomial_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = polynomial_;
    polynomial_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SpreadDescriptor::set_allocated_polynomial(::std::string* polynomial) {
  if (polynomial_ != &::google::protobuf::internal::kEmptyString) {
    delete polynomial_;
  }
  if (polynomial) {
    set_has_polynomial();
    polynomial_ = polynomial;
  } else {
    clear_has_polynomial();
    polynomial_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string fill = 6;
inline bool SpreadDescriptor::has_fill() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SpreadDescriptor::set_has_fill() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SpreadDescriptor::clear_has_fill() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SpreadDescriptor::clear_fill() {
  if (fill_ != &::google::protobuf::internal::kEmptyString) {
    fill_->clear();
  }
  clear_has_fill();
}
inline const ::std::string& SpreadDescriptor::fill() const {
  return *fill_;
}
inline void SpreadDescriptor::set_fill(const ::std::string& value) {
  set_has_fill();
  if (fill_ == &::google::protobuf::internal::kEmptyString) {
    fill_ = new ::std::string;
  }
  fill_->assign(value);
}
inline void SpreadDescriptor::set_fill(const char* value) {
  set_has_fill();
  if (fill_ == &::google::protobuf::internal::kEmptyString) {
    fill_ = new ::std::string;
  }
  fill_->assign(value);
}
inline void SpreadDescriptor::set_fill(const char* value, size_t size) {
  set_has_fill();
  if (fill_ == &::google::protobuf::internal::kEmptyString) {
    fill_ = new ::std::string;
  }
  fill_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpreadDescriptor::mutable_fill() {
  set_has_fill();
  if (fill_ == &::google::protobuf::internal::kEmptyString) {
    fill_ = new ::std::string;
  }
  return fill_;
}
inline ::std::string* SpreadDescriptor::release_fill() {
  clear_has_fill();
  if (fill_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fill_;
    fill_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SpreadDescriptor::set_allocated_fill(::std::string* fill) {
  if (fill_ != &::google::protobuf::internal::kEmptyString) {
    delete fill_;
  }
  if (fill) {
    set_has_fill();
    fill_ = fill;
  } else {
    clear_has_fill();
    fill_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AVDescriptor

// optional double centerFreq = 1;
inline bool AVDescriptor::has_centerfreq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AVDescriptor::set_has_centerfreq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AVDescriptor::clear_has_centerfreq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AVDescriptor::clear_centerfreq() {
  centerfreq_ = 0;
  clear_has_centerfreq();
}
inline double AVDescriptor::centerfreq() const {
  return centerfreq_;
}
inline void AVDescriptor::set_centerfreq(double value) {
  set_has_centerfreq();
  centerfreq_ = value;
}

// optional bool detected = 2;
inline bool AVDescriptor::has_detected() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AVDescriptor::set_has_detected() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AVDescriptor::clear_has_detected() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AVDescriptor::clear_detected() {
  detected_ = false;
  clear_has_detected();
}
inline bool AVDescriptor::detected() const {
  return detected_;
}
inline void AVDescriptor::set_detected(bool value) {
  set_has_detected();
  detected_ = value;
}

// -------------------------------------------------------------------

// QSTAT_RT

// optional string msgName = 1 [default = "QSTAT_RT"];
inline bool QSTAT_RT::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QSTAT_RT::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QSTAT_RT::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QSTAT_RT::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& QSTAT_RT::msgname() const {
  return *msgname_;
}
inline void QSTAT_RT::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void QSTAT_RT::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void QSTAT_RT::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QSTAT_RT::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* QSTAT_RT::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void QSTAT_RT::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string sender = 2;
inline bool QSTAT_RT::has_sender() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QSTAT_RT::set_has_sender() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QSTAT_RT::clear_has_sender() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QSTAT_RT::clear_sender() {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    sender_->clear();
  }
  clear_has_sender();
}
inline const ::std::string& QSTAT_RT::sender() const {
  return *sender_;
}
inline void QSTAT_RT::set_sender(const ::std::string& value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void QSTAT_RT::set_sender(const char* value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void QSTAT_RT::set_sender(const char* value, size_t size) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QSTAT_RT::mutable_sender() {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  return sender_;
}
inline ::std::string* QSTAT_RT::release_sender() {
  clear_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sender_;
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QSTAT_RT::set_allocated_sender(::std::string* sender) {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    delete sender_;
  }
  if (sender) {
    set_has_sender();
    sender_ = sender;
  } else {
    clear_has_sender();
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string status = 3;
inline bool QSTAT_RT::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QSTAT_RT::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QSTAT_RT::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QSTAT_RT::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& QSTAT_RT::status() const {
  return *status_;
}
inline void QSTAT_RT::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void QSTAT_RT::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void QSTAT_RT::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QSTAT_RT::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* QSTAT_RT::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QSTAT_RT::set_allocated_status(::std::string* status) {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    delete status_;
  }
  if (status) {
    set_has_status();
    status_ = status;
  } else {
    clear_has_status();
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 appId = 4;
inline bool QSTAT_RT::has_appid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QSTAT_RT::set_has_appid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QSTAT_RT::clear_has_appid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QSTAT_RT::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 QSTAT_RT::appid() const {
  return appid_;
}
inline void QSTAT_RT::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// -------------------------------------------------------------------

// ExternalsRelease

// optional string msgName = 1 [default = "EXTERNALSRELEASE"];
inline bool ExternalsRelease::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExternalsRelease::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExternalsRelease::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExternalsRelease::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ExternalsRelease::msgname() const {
  return *msgname_;
}
inline void ExternalsRelease::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ExternalsRelease::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ExternalsRelease::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExternalsRelease::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ExternalsRelease::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ExternalsRelease::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string name = 2;
inline bool ExternalsRelease::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExternalsRelease::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExternalsRelease::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExternalsRelease::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ExternalsRelease::name() const {
  return *name_;
}
inline void ExternalsRelease::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ExternalsRelease::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ExternalsRelease::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExternalsRelease::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ExternalsRelease::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExternalsRelease::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .falcon_externals_msg.ExternalsRelease.Type threatType = 3;
inline bool ExternalsRelease::has_threattype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExternalsRelease::set_has_threattype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExternalsRelease::clear_has_threattype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExternalsRelease::clear_threattype() {
  threattype_ = 0;
  clear_has_threattype();
}
inline ::falcon_externals_msg::ExternalsRelease_Type ExternalsRelease::threattype() const {
  return static_cast< ::falcon_externals_msg::ExternalsRelease_Type >(threattype_);
}
inline void ExternalsRelease::set_threattype(::falcon_externals_msg::ExternalsRelease_Type value) {
  assert(::falcon_externals_msg::ExternalsRelease_Type_IsValid(value));
  set_has_threattype();
  threattype_ = value;
}

// optional double freqMHz = 4;
inline bool ExternalsRelease::has_freqmhz() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExternalsRelease::set_has_freqmhz() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExternalsRelease::clear_has_freqmhz() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExternalsRelease::clear_freqmhz() {
  freqmhz_ = 0;
  clear_has_freqmhz();
}
inline double ExternalsRelease::freqmhz() const {
  return freqmhz_;
}
inline void ExternalsRelease::set_freqmhz(double value) {
  set_has_freqmhz();
  freqmhz_ = value;
}

// -------------------------------------------------------------------

// NullHit

// optional string msgName = 1 [default = "NULLHIT"];
inline bool NullHit::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NullHit::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NullHit::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NullHit::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& NullHit::msgname() const {
  return *msgname_;
}
inline void NullHit::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void NullHit::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void NullHit::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NullHit::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* NullHit::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void NullHit::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string timestamp = 2;
inline bool NullHit::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NullHit::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NullHit::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NullHit::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& NullHit::timestamp() const {
  return *timestamp_;
}
inline void NullHit::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void NullHit::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void NullHit::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NullHit::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* NullHit::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NullHit::set_allocated_timestamp(::std::string* timestamp) {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    delete timestamp_;
  }
  if (timestamp) {
    set_has_timestamp();
    timestamp_ = timestamp;
  } else {
    clear_has_timestamp();
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double freqHz = 3;
inline bool NullHit::has_freqhz() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NullHit::set_has_freqhz() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NullHit::clear_has_freqhz() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NullHit::clear_freqhz() {
  freqhz_ = 0;
  clear_has_freqhz();
}
inline double NullHit::freqhz() const {
  return freqhz_;
}
inline void NullHit::set_freqhz(double value) {
  set_has_freqhz();
  freqhz_ = value;
}

// optional string ramSnapID = 4;
inline bool NullHit::has_ramsnapid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NullHit::set_has_ramsnapid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NullHit::clear_has_ramsnapid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NullHit::clear_ramsnapid() {
  if (ramsnapid_ != &::google::protobuf::internal::kEmptyString) {
    ramsnapid_->clear();
  }
  clear_has_ramsnapid();
}
inline const ::std::string& NullHit::ramsnapid() const {
  return *ramsnapid_;
}
inline void NullHit::set_ramsnapid(const ::std::string& value) {
  set_has_ramsnapid();
  if (ramsnapid_ == &::google::protobuf::internal::kEmptyString) {
    ramsnapid_ = new ::std::string;
  }
  ramsnapid_->assign(value);
}
inline void NullHit::set_ramsnapid(const char* value) {
  set_has_ramsnapid();
  if (ramsnapid_ == &::google::protobuf::internal::kEmptyString) {
    ramsnapid_ = new ::std::string;
  }
  ramsnapid_->assign(value);
}
inline void NullHit::set_ramsnapid(const char* value, size_t size) {
  set_has_ramsnapid();
  if (ramsnapid_ == &::google::protobuf::internal::kEmptyString) {
    ramsnapid_ = new ::std::string;
  }
  ramsnapid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NullHit::mutable_ramsnapid() {
  set_has_ramsnapid();
  if (ramsnapid_ == &::google::protobuf::internal::kEmptyString) {
    ramsnapid_ = new ::std::string;
  }
  return ramsnapid_;
}
inline ::std::string* NullHit::release_ramsnapid() {
  clear_has_ramsnapid();
  if (ramsnapid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ramsnapid_;
    ramsnapid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NullHit::set_allocated_ramsnapid(::std::string* ramsnapid) {
  if (ramsnapid_ != &::google::protobuf::internal::kEmptyString) {
    delete ramsnapid_;
  }
  if (ramsnapid) {
    set_has_ramsnapid();
    ramsnapid_ = ramsnapid;
  } else {
    clear_has_ramsnapid();
    ramsnapid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string detectorName = 5;
inline bool NullHit::has_detectorname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NullHit::set_has_detectorname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NullHit::clear_has_detectorname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NullHit::clear_detectorname() {
  if (detectorname_ != &::google::protobuf::internal::kEmptyString) {
    detectorname_->clear();
  }
  clear_has_detectorname();
}
inline const ::std::string& NullHit::detectorname() const {
  return *detectorname_;
}
inline void NullHit::set_detectorname(const ::std::string& value) {
  set_has_detectorname();
  if (detectorname_ == &::google::protobuf::internal::kEmptyString) {
    detectorname_ = new ::std::string;
  }
  detectorname_->assign(value);
}
inline void NullHit::set_detectorname(const char* value) {
  set_has_detectorname();
  if (detectorname_ == &::google::protobuf::internal::kEmptyString) {
    detectorname_ = new ::std::string;
  }
  detectorname_->assign(value);
}
inline void NullHit::set_detectorname(const char* value, size_t size) {
  set_has_detectorname();
  if (detectorname_ == &::google::protobuf::internal::kEmptyString) {
    detectorname_ = new ::std::string;
  }
  detectorname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NullHit::mutable_detectorname() {
  set_has_detectorname();
  if (detectorname_ == &::google::protobuf::internal::kEmptyString) {
    detectorname_ = new ::std::string;
  }
  return detectorname_;
}
inline ::std::string* NullHit::release_detectorname() {
  clear_has_detectorname();
  if (detectorname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = detectorname_;
    detectorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NullHit::set_allocated_detectorname(::std::string* detectorname) {
  if (detectorname_ != &::google::protobuf::internal::kEmptyString) {
    delete detectorname_;
  }
  if (detectorname) {
    set_has_detectorname();
    detectorname_ = detectorname;
  } else {
    clear_has_detectorname();
    detectorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace falcon_externals_msg

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_externals_msg::ExternalsHit_Type>() {
  return ::falcon_externals_msg::ExternalsHit_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_externals_msg::ExternalsRelease_Type>() {
  return ::falcon_externals_msg::ExternalsRelease_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_FalconExternalsMessages_2eproto__INCLUDED
