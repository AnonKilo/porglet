// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ServiceInfrastructureCommon.proto

#ifndef PROTOBUF_ServiceInfrastructureCommon_2eproto__INCLUDED
#define PROTOBUF_ServiceInfrastructureCommon_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace service_infrastructure {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ServiceInfrastructureCommon_2eproto();
void protobuf_AssignDesc_ServiceInfrastructureCommon_2eproto();
void protobuf_ShutdownFile_ServiceInfrastructureCommon_2eproto();

class Header;
class Ack;
class NAck;
class HandshakeTopic;
class StartupNotification;
class ShutDownNotification;
class ConnectionRequest;
class ConnectionResponse;
class Version;
class ConfigurationRequest;
class ConfigurationResponse;
class Configuration;
class SearchConfiguration;
class Band;
class Channel;

enum ErrorCode {
  UNKNOWN = 0,
  INCOMPATIBLE_RELEASE = 1,
  INCOMPATIBLE_ICD = 2,
  INCOMPATIBLE_CONFIGURATION = 3,
  UNKNOWN_SIGNAL = 100,
  INVALID_SIGNAL_STATE = 101,
  NO_AVAILABLE_RESOURCES = 102,
  UNSUPPORTED_SIGNAL = 103
};
bool ErrorCode_IsValid(int value);
const ErrorCode ErrorCode_MIN = UNKNOWN;
const ErrorCode ErrorCode_MAX = UNSUPPORTED_SIGNAL;
const int ErrorCode_ARRAYSIZE = ErrorCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ErrorCode_descriptor();
inline const ::std::string& ErrorCode_Name(ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ErrorCode_descriptor(), value);
}
inline bool ErrorCode_Parse(
    const ::std::string& name, ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrorCode>(
    ErrorCode_descriptor(), name, value);
}
// ===================================================================

class Header : public ::google::protobuf::Message {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  void Swap(Header* other);

  // implements Message ----------------------------------------------

  Header* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 sequence_number = 1;
  inline bool has_sequence_number() const;
  inline void clear_sequence_number();
  static const int kSequenceNumberFieldNumber = 1;
  inline ::google::protobuf::int64 sequence_number() const;
  inline void set_sequence_number(::google::protobuf::int64 value);

  // optional string timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  inline void set_allocated_timestamp(::std::string* timestamp);

  // optional int32 pid = 3;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 3;
  inline ::google::protobuf::int32 pid() const;
  inline void set_pid(::google::protobuf::int32 value);

  // optional string sensorName = 4 [default = ""];
  inline bool has_sensorname() const;
  inline void clear_sensorname();
  static const int kSensorNameFieldNumber = 4;
  inline const ::std::string& sensorname() const;
  inline void set_sensorname(const ::std::string& value);
  inline void set_sensorname(const char* value);
  inline void set_sensorname(const char* value, size_t size);
  inline ::std::string* mutable_sensorname();
  inline ::std::string* release_sensorname();
  inline void set_allocated_sensorname(::std::string* sensorname);

  // @@protoc_insertion_point(class_scope:service_infrastructure.Header)
 private:
  inline void set_has_sequence_number();
  inline void clear_has_sequence_number();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_sensorname();
  inline void clear_has_sensorname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 sequence_number_;
  ::std::string* timestamp_;
  ::std::string* sensorname_;
  ::google::protobuf::int32 pid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureCommon_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureCommon_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureCommon_2eproto();

  void InitAsDefaultInstance();
  static Header* default_instance_;
};
// -------------------------------------------------------------------

class Ack : public ::google::protobuf::Message {
 public:
  Ack();
  virtual ~Ack();

  Ack(const Ack& from);

  inline Ack& operator=(const Ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ack& default_instance();

  void Swap(Ack* other);

  // implements Message ----------------------------------------------

  Ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ack& from);
  void MergeFrom(const Ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:service_infrastructure.Ack)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_ServiceInfrastructureCommon_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureCommon_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureCommon_2eproto();

  void InitAsDefaultInstance();
  static Ack* default_instance_;
};
// -------------------------------------------------------------------

class NAck : public ::google::protobuf::Message {
 public:
  NAck();
  virtual ~NAck();

  NAck(const NAck& from);

  inline NAck& operator=(const NAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NAck& default_instance();

  void Swap(NAck* other);

  // implements Message ----------------------------------------------

  NAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NAck& from);
  void MergeFrom(const NAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.ErrorCode error_code = 2 [default = UNKNOWN];
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::service_infrastructure::ErrorCode error_code() const;
  inline void set_error_code(::service_infrastructure::ErrorCode value);

  // optional string error_description = 3;
  inline bool has_error_description() const;
  inline void clear_error_description();
  static const int kErrorDescriptionFieldNumber = 3;
  inline const ::std::string& error_description() const;
  inline void set_error_description(const ::std::string& value);
  inline void set_error_description(const char* value);
  inline void set_error_description(const char* value, size_t size);
  inline ::std::string* mutable_error_description();
  inline ::std::string* release_error_description();
  inline void set_allocated_error_description(::std::string* error_description);

  // @@protoc_insertion_point(class_scope:service_infrastructure.NAck)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_error_description();
  inline void clear_has_error_description();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* error_description_;
  int error_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureCommon_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureCommon_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureCommon_2eproto();

  void InitAsDefaultInstance();
  static NAck* default_instance_;
};
// -------------------------------------------------------------------

class HandshakeTopic : public ::google::protobuf::Message {
 public:
  HandshakeTopic();
  virtual ~HandshakeTopic();

  HandshakeTopic(const HandshakeTopic& from);

  inline HandshakeTopic& operator=(const HandshakeTopic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HandshakeTopic& default_instance();

  void Swap(HandshakeTopic* other);

  // implements Message ----------------------------------------------

  HandshakeTopic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HandshakeTopic& from);
  void MergeFrom(const HandshakeTopic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 100;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 100;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional .service_infrastructure.Ack ack = 1;
  inline bool has_ack() const;
  inline void clear_ack();
  static const int kAckFieldNumber = 1;
  inline const ::service_infrastructure::Ack& ack() const;
  inline ::service_infrastructure::Ack* mutable_ack();
  inline ::service_infrastructure::Ack* release_ack();
  inline void set_allocated_ack(::service_infrastructure::Ack* ack);

  // optional .service_infrastructure.NAck nack = 2;
  inline bool has_nack() const;
  inline void clear_nack();
  static const int kNackFieldNumber = 2;
  inline const ::service_infrastructure::NAck& nack() const;
  inline ::service_infrastructure::NAck* mutable_nack();
  inline ::service_infrastructure::NAck* release_nack();
  inline void set_allocated_nack(::service_infrastructure::NAck* nack);

  // optional .service_infrastructure.StartupNotification startup_notification = 3;
  inline bool has_startup_notification() const;
  inline void clear_startup_notification();
  static const int kStartupNotificationFieldNumber = 3;
  inline const ::service_infrastructure::StartupNotification& startup_notification() const;
  inline ::service_infrastructure::StartupNotification* mutable_startup_notification();
  inline ::service_infrastructure::StartupNotification* release_startup_notification();
  inline void set_allocated_startup_notification(::service_infrastructure::StartupNotification* startup_notification);

  // optional .service_infrastructure.ShutDownNotification shutdown_notification = 4;
  inline bool has_shutdown_notification() const;
  inline void clear_shutdown_notification();
  static const int kShutdownNotificationFieldNumber = 4;
  inline const ::service_infrastructure::ShutDownNotification& shutdown_notification() const;
  inline ::service_infrastructure::ShutDownNotification* mutable_shutdown_notification();
  inline ::service_infrastructure::ShutDownNotification* release_shutdown_notification();
  inline void set_allocated_shutdown_notification(::service_infrastructure::ShutDownNotification* shutdown_notification);

  // optional .service_infrastructure.ConnectionRequest connection_request = 5;
  inline bool has_connection_request() const;
  inline void clear_connection_request();
  static const int kConnectionRequestFieldNumber = 5;
  inline const ::service_infrastructure::ConnectionRequest& connection_request() const;
  inline ::service_infrastructure::ConnectionRequest* mutable_connection_request();
  inline ::service_infrastructure::ConnectionRequest* release_connection_request();
  inline void set_allocated_connection_request(::service_infrastructure::ConnectionRequest* connection_request);

  // optional .service_infrastructure.ConnectionResponse connection_response = 6;
  inline bool has_connection_response() const;
  inline void clear_connection_response();
  static const int kConnectionResponseFieldNumber = 6;
  inline const ::service_infrastructure::ConnectionResponse& connection_response() const;
  inline ::service_infrastructure::ConnectionResponse* mutable_connection_response();
  inline ::service_infrastructure::ConnectionResponse* release_connection_response();
  inline void set_allocated_connection_response(::service_infrastructure::ConnectionResponse* connection_response);

  // optional .service_infrastructure.ConfigurationRequest configuration_request = 7;
  inline bool has_configuration_request() const;
  inline void clear_configuration_request();
  static const int kConfigurationRequestFieldNumber = 7;
  inline const ::service_infrastructure::ConfigurationRequest& configuration_request() const;
  inline ::service_infrastructure::ConfigurationRequest* mutable_configuration_request();
  inline ::service_infrastructure::ConfigurationRequest* release_configuration_request();
  inline void set_allocated_configuration_request(::service_infrastructure::ConfigurationRequest* configuration_request);

  // optional .service_infrastructure.ConfigurationResponse configuration_response = 8;
  inline bool has_configuration_response() const;
  inline void clear_configuration_response();
  static const int kConfigurationResponseFieldNumber = 8;
  inline const ::service_infrastructure::ConfigurationResponse& configuration_response() const;
  inline ::service_infrastructure::ConfigurationResponse* mutable_configuration_response();
  inline ::service_infrastructure::ConfigurationResponse* release_configuration_response();
  inline void set_allocated_configuration_response(::service_infrastructure::ConfigurationResponse* configuration_response);

  // @@protoc_insertion_point(class_scope:service_infrastructure.HandshakeTopic)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_ack();
  inline void clear_has_ack();
  inline void set_has_nack();
  inline void clear_has_nack();
  inline void set_has_startup_notification();
  inline void clear_has_startup_notification();
  inline void set_has_shutdown_notification();
  inline void clear_has_shutdown_notification();
  inline void set_has_connection_request();
  inline void clear_has_connection_request();
  inline void set_has_connection_response();
  inline void clear_has_connection_response();
  inline void set_has_configuration_request();
  inline void clear_has_configuration_request();
  inline void set_has_configuration_response();
  inline void clear_has_configuration_response();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::service_infrastructure::Ack* ack_;
  ::service_infrastructure::NAck* nack_;
  ::service_infrastructure::StartupNotification* startup_notification_;
  ::service_infrastructure::ShutDownNotification* shutdown_notification_;
  ::service_infrastructure::ConnectionRequest* connection_request_;
  ::service_infrastructure::ConnectionResponse* connection_response_;
  ::service_infrastructure::ConfigurationRequest* configuration_request_;
  ::service_infrastructure::ConfigurationResponse* configuration_response_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureCommon_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureCommon_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureCommon_2eproto();

  void InitAsDefaultInstance();
  static HandshakeTopic* default_instance_;
};
// -------------------------------------------------------------------

class StartupNotification : public ::google::protobuf::Message {
 public:
  StartupNotification();
  virtual ~StartupNotification();

  StartupNotification(const StartupNotification& from);

  inline StartupNotification& operator=(const StartupNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartupNotification& default_instance();

  void Swap(StartupNotification* other);

  // implements Message ----------------------------------------------

  StartupNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StartupNotification& from);
  void MergeFrom(const StartupNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:service_infrastructure.StartupNotification)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_ServiceInfrastructureCommon_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureCommon_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureCommon_2eproto();

  void InitAsDefaultInstance();
  static StartupNotification* default_instance_;
};
// -------------------------------------------------------------------

class ShutDownNotification : public ::google::protobuf::Message {
 public:
  ShutDownNotification();
  virtual ~ShutDownNotification();

  ShutDownNotification(const ShutDownNotification& from);

  inline ShutDownNotification& operator=(const ShutDownNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShutDownNotification& default_instance();

  void Swap(ShutDownNotification* other);

  // implements Message ----------------------------------------------

  ShutDownNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShutDownNotification& from);
  void MergeFrom(const ShutDownNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:service_infrastructure.ShutDownNotification)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_ServiceInfrastructureCommon_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureCommon_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureCommon_2eproto();

  void InitAsDefaultInstance();
  static ShutDownNotification* default_instance_;
};
// -------------------------------------------------------------------

class ConnectionRequest : public ::google::protobuf::Message {
 public:
  ConnectionRequest();
  virtual ~ConnectionRequest();

  ConnectionRequest(const ConnectionRequest& from);

  inline ConnectionRequest& operator=(const ConnectionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectionRequest& default_instance();

  void Swap(ConnectionRequest* other);

  // implements Message ----------------------------------------------

  ConnectionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectionRequest& from);
  void MergeFrom(const ConnectionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Version release = 1;
  inline bool has_release() const;
  inline void clear_release();
  static const int kReleaseFieldNumber = 1;
  inline const ::service_infrastructure::Version& release() const;
  inline ::service_infrastructure::Version* mutable_release();
  inline ::service_infrastructure::Version* release_release();
  inline void set_allocated_release(::service_infrastructure::Version* release);

  // optional .service_infrastructure.Version icd = 2;
  inline bool has_icd() const;
  inline void clear_icd();
  static const int kIcdFieldNumber = 2;
  inline const ::service_infrastructure::Version& icd() const;
  inline ::service_infrastructure::Version* mutable_icd();
  inline ::service_infrastructure::Version* release_icd();
  inline void set_allocated_icd(::service_infrastructure::Version* icd);

  // @@protoc_insertion_point(class_scope:service_infrastructure.ConnectionRequest)
 private:
  inline void set_has_release();
  inline void clear_has_release();
  inline void set_has_icd();
  inline void clear_has_icd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Version* release_;
  ::service_infrastructure::Version* icd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureCommon_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureCommon_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureCommon_2eproto();

  void InitAsDefaultInstance();
  static ConnectionRequest* default_instance_;
};
// -------------------------------------------------------------------

class ConnectionResponse : public ::google::protobuf::Message {
 public:
  ConnectionResponse();
  virtual ~ConnectionResponse();

  ConnectionResponse(const ConnectionResponse& from);

  inline ConnectionResponse& operator=(const ConnectionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectionResponse& default_instance();

  void Swap(ConnectionResponse* other);

  // implements Message ----------------------------------------------

  ConnectionResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectionResponse& from);
  void MergeFrom(const ConnectionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Version release = 1;
  inline bool has_release() const;
  inline void clear_release();
  static const int kReleaseFieldNumber = 1;
  inline const ::service_infrastructure::Version& release() const;
  inline ::service_infrastructure::Version* mutable_release();
  inline ::service_infrastructure::Version* release_release();
  inline void set_allocated_release(::service_infrastructure::Version* release);

  // optional .service_infrastructure.Version icd = 2;
  inline bool has_icd() const;
  inline void clear_icd();
  static const int kIcdFieldNumber = 2;
  inline const ::service_infrastructure::Version& icd() const;
  inline ::service_infrastructure::Version* mutable_icd();
  inline ::service_infrastructure::Version* release_icd();
  inline void set_allocated_icd(::service_infrastructure::Version* icd);

  // @@protoc_insertion_point(class_scope:service_infrastructure.ConnectionResponse)
 private:
  inline void set_has_release();
  inline void clear_has_release();
  inline void set_has_icd();
  inline void clear_has_icd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Version* release_;
  ::service_infrastructure::Version* icd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureCommon_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureCommon_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureCommon_2eproto();

  void InitAsDefaultInstance();
  static ConnectionResponse* default_instance_;
};
// -------------------------------------------------------------------

class Version : public ::google::protobuf::Message {
 public:
  Version();
  virtual ~Version();

  Version(const Version& from);

  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Version& default_instance();

  void Swap(Version* other);

  // implements Message ----------------------------------------------

  Version* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Version& from);
  void MergeFrom(const Version& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 major = 1 [default = -1];
  inline bool has_major() const;
  inline void clear_major();
  static const int kMajorFieldNumber = 1;
  inline ::google::protobuf::int64 major() const;
  inline void set_major(::google::protobuf::int64 value);

  // optional int64 minor = 2 [default = -1];
  inline bool has_minor() const;
  inline void clear_minor();
  static const int kMinorFieldNumber = 2;
  inline ::google::protobuf::int64 minor() const;
  inline void set_minor(::google::protobuf::int64 value);

  // optional int64 patch = 3 [default = -1];
  inline bool has_patch() const;
  inline void clear_patch();
  static const int kPatchFieldNumber = 3;
  inline ::google::protobuf::int64 patch() const;
  inline void set_patch(::google::protobuf::int64 value);

  // optional string date = 4 [default = "0-0-0"];
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 4;
  inline const ::std::string& date() const;
  inline void set_date(const ::std::string& value);
  inline void set_date(const char* value);
  inline void set_date(const char* value, size_t size);
  inline ::std::string* mutable_date();
  inline ::std::string* release_date();
  inline void set_allocated_date(::std::string* date);

  // optional string commit = 5;
  inline bool has_commit() const;
  inline void clear_commit();
  static const int kCommitFieldNumber = 5;
  inline const ::std::string& commit() const;
  inline void set_commit(const ::std::string& value);
  inline void set_commit(const char* value);
  inline void set_commit(const char* value, size_t size);
  inline ::std::string* mutable_commit();
  inline ::std::string* release_commit();
  inline void set_allocated_commit(::std::string* commit);

  // @@protoc_insertion_point(class_scope:service_infrastructure.Version)
 private:
  inline void set_has_major();
  inline void clear_has_major();
  inline void set_has_minor();
  inline void clear_has_minor();
  inline void set_has_patch();
  inline void clear_has_patch();
  inline void set_has_date();
  inline void clear_has_date();
  inline void set_has_commit();
  inline void clear_has_commit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 major_;
  ::google::protobuf::int64 minor_;
  ::google::protobuf::int64 patch_;
  ::std::string* date_;
  static ::std::string* _default_date_;
  ::std::string* commit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureCommon_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureCommon_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureCommon_2eproto();

  void InitAsDefaultInstance();
  static Version* default_instance_;
};
// -------------------------------------------------------------------

class ConfigurationRequest : public ::google::protobuf::Message {
 public:
  ConfigurationRequest();
  virtual ~ConfigurationRequest();

  ConfigurationRequest(const ConfigurationRequest& from);

  inline ConfigurationRequest& operator=(const ConfigurationRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigurationRequest& default_instance();

  void Swap(ConfigurationRequest* other);

  // implements Message ----------------------------------------------

  ConfigurationRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConfigurationRequest& from);
  void MergeFrom(const ConfigurationRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Configuration requested_configuration = 1;
  inline bool has_requested_configuration() const;
  inline void clear_requested_configuration();
  static const int kRequestedConfigurationFieldNumber = 1;
  inline const ::service_infrastructure::Configuration& requested_configuration() const;
  inline ::service_infrastructure::Configuration* mutable_requested_configuration();
  inline ::service_infrastructure::Configuration* release_requested_configuration();
  inline void set_allocated_requested_configuration(::service_infrastructure::Configuration* requested_configuration);

  // @@protoc_insertion_point(class_scope:service_infrastructure.ConfigurationRequest)
 private:
  inline void set_has_requested_configuration();
  inline void clear_has_requested_configuration();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Configuration* requested_configuration_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureCommon_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureCommon_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureCommon_2eproto();

  void InitAsDefaultInstance();
  static ConfigurationRequest* default_instance_;
};
// -------------------------------------------------------------------

class ConfigurationResponse : public ::google::protobuf::Message {
 public:
  ConfigurationResponse();
  virtual ~ConfigurationResponse();

  ConfigurationResponse(const ConfigurationResponse& from);

  inline ConfigurationResponse& operator=(const ConfigurationResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigurationResponse& default_instance();

  void Swap(ConfigurationResponse* other);

  // implements Message ----------------------------------------------

  ConfigurationResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConfigurationResponse& from);
  void MergeFrom(const ConfigurationResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Configuration current_configuration = 1;
  inline bool has_current_configuration() const;
  inline void clear_current_configuration();
  static const int kCurrentConfigurationFieldNumber = 1;
  inline const ::service_infrastructure::Configuration& current_configuration() const;
  inline ::service_infrastructure::Configuration* mutable_current_configuration();
  inline ::service_infrastructure::Configuration* release_current_configuration();
  inline void set_allocated_current_configuration(::service_infrastructure::Configuration* current_configuration);

  // @@protoc_insertion_point(class_scope:service_infrastructure.ConfigurationResponse)
 private:
  inline void set_has_current_configuration();
  inline void clear_has_current_configuration();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Configuration* current_configuration_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureCommon_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureCommon_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureCommon_2eproto();

  void InitAsDefaultInstance();
  static ConfigurationResponse* default_instance_;
};
// -------------------------------------------------------------------

class Configuration : public ::google::protobuf::Message {
 public:
  Configuration();
  virtual ~Configuration();

  Configuration(const Configuration& from);

  inline Configuration& operator=(const Configuration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Configuration& default_instance();

  void Swap(Configuration* other);

  // implements Message ----------------------------------------------

  Configuration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Configuration& from);
  void MergeFrom(const Configuration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 max_file_duration = 1;
  inline bool has_max_file_duration() const;
  inline void clear_max_file_duration();
  static const int kMaxFileDurationFieldNumber = 1;
  inline ::google::protobuf::int64 max_file_duration() const;
  inline void set_max_file_duration(::google::protobuf::int64 value);

  // optional int64 min_buffer_depth = 2;
  inline bool has_min_buffer_depth() const;
  inline void clear_min_buffer_depth();
  static const int kMinBufferDepthFieldNumber = 2;
  inline ::google::protobuf::int64 min_buffer_depth() const;
  inline void set_min_buffer_depth(::google::protobuf::int64 value);

  // optional bool use_agc = 3 [default = true];
  inline bool has_use_agc() const;
  inline void clear_use_agc();
  static const int kUseAgcFieldNumber = 3;
  inline bool use_agc() const;
  inline void set_use_agc(bool value);

  // repeated .service_infrastructure.Band bands = 4;
  inline int bands_size() const;
  inline void clear_bands();
  static const int kBandsFieldNumber = 4;
  inline const ::service_infrastructure::Band& bands(int index) const;
  inline ::service_infrastructure::Band* mutable_bands(int index);
  inline ::service_infrastructure::Band* add_bands();
  inline const ::google::protobuf::RepeatedPtrField< ::service_infrastructure::Band >&
      bands() const;
  inline ::google::protobuf::RepeatedPtrField< ::service_infrastructure::Band >*
      mutable_bands();

  // repeated .service_infrastructure.Channel rx_channels = 5;
  inline int rx_channels_size() const;
  inline void clear_rx_channels();
  static const int kRxChannelsFieldNumber = 5;
  inline const ::service_infrastructure::Channel& rx_channels(int index) const;
  inline ::service_infrastructure::Channel* mutable_rx_channels(int index);
  inline ::service_infrastructure::Channel* add_rx_channels();
  inline const ::google::protobuf::RepeatedPtrField< ::service_infrastructure::Channel >&
      rx_channels() const;
  inline ::google::protobuf::RepeatedPtrField< ::service_infrastructure::Channel >*
      mutable_rx_channels();

  // repeated .service_infrastructure.Channel tx_channels = 6;
  inline int tx_channels_size() const;
  inline void clear_tx_channels();
  static const int kTxChannelsFieldNumber = 6;
  inline const ::service_infrastructure::Channel& tx_channels(int index) const;
  inline ::service_infrastructure::Channel* mutable_tx_channels(int index);
  inline ::service_infrastructure::Channel* add_tx_channels();
  inline const ::google::protobuf::RepeatedPtrField< ::service_infrastructure::Channel >&
      tx_channels() const;
  inline ::google::protobuf::RepeatedPtrField< ::service_infrastructure::Channel >*
      mutable_tx_channels();

  // repeated .service_infrastructure.SearchConfiguration search_configuration = 7;
  inline int search_configuration_size() const;
  inline void clear_search_configuration();
  static const int kSearchConfigurationFieldNumber = 7;
  inline const ::service_infrastructure::SearchConfiguration& search_configuration(int index) const;
  inline ::service_infrastructure::SearchConfiguration* mutable_search_configuration(int index);
  inline ::service_infrastructure::SearchConfiguration* add_search_configuration();
  inline const ::google::protobuf::RepeatedPtrField< ::service_infrastructure::SearchConfiguration >&
      search_configuration() const;
  inline ::google::protobuf::RepeatedPtrField< ::service_infrastructure::SearchConfiguration >*
      mutable_search_configuration();

  // @@protoc_insertion_point(class_scope:service_infrastructure.Configuration)
 private:
  inline void set_has_max_file_duration();
  inline void clear_has_max_file_duration();
  inline void set_has_min_buffer_depth();
  inline void clear_has_min_buffer_depth();
  inline void set_has_use_agc();
  inline void clear_has_use_agc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 max_file_duration_;
  ::google::protobuf::int64 min_buffer_depth_;
  ::google::protobuf::RepeatedPtrField< ::service_infrastructure::Band > bands_;
  ::google::protobuf::RepeatedPtrField< ::service_infrastructure::Channel > rx_channels_;
  ::google::protobuf::RepeatedPtrField< ::service_infrastructure::Channel > tx_channels_;
  ::google::protobuf::RepeatedPtrField< ::service_infrastructure::SearchConfiguration > search_configuration_;
  bool use_agc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureCommon_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureCommon_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureCommon_2eproto();

  void InitAsDefaultInstance();
  static Configuration* default_instance_;
};
// -------------------------------------------------------------------

class SearchConfiguration : public ::google::protobuf::Message {
 public:
  SearchConfiguration();
  virtual ~SearchConfiguration();

  SearchConfiguration(const SearchConfiguration& from);

  inline SearchConfiguration& operator=(const SearchConfiguration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchConfiguration& default_instance();

  void Swap(SearchConfiguration* other);

  // implements Message ----------------------------------------------

  SearchConfiguration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SearchConfiguration& from);
  void MergeFrom(const SearchConfiguration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float start_az = 1;
  inline bool has_start_az() const;
  inline void clear_start_az();
  static const int kStartAzFieldNumber = 1;
  inline float start_az() const;
  inline void set_start_az(float value);

  // optional float stop_az = 2;
  inline bool has_stop_az() const;
  inline void clear_stop_az();
  static const int kStopAzFieldNumber = 2;
  inline float stop_az() const;
  inline void set_stop_az(float value);

  // optional float start_el = 3;
  inline bool has_start_el() const;
  inline void clear_start_el();
  static const int kStartElFieldNumber = 3;
  inline float start_el() const;
  inline void set_start_el(float value);

  // optional float stop_el = 4;
  inline bool has_stop_el() const;
  inline void clear_stop_el();
  static const int kStopElFieldNumber = 4;
  inline float stop_el() const;
  inline void set_stop_el(float value);

  // optional int32 antenna = 5;
  inline bool has_antenna() const;
  inline void clear_antenna();
  static const int kAntennaFieldNumber = 5;
  inline ::google::protobuf::int32 antenna() const;
  inline void set_antenna(::google::protobuf::int32 value);

  // optional float step_az = 6;
  inline bool has_step_az() const;
  inline void clear_step_az();
  static const int kStepAzFieldNumber = 6;
  inline float step_az() const;
  inline void set_step_az(float value);

  // optional float step_el = 7;
  inline bool has_step_el() const;
  inline void clear_step_el();
  static const int kStepElFieldNumber = 7;
  inline float step_el() const;
  inline void set_step_el(float value);

  // optional float step_time = 8;
  inline bool has_step_time() const;
  inline void clear_step_time();
  static const int kStepTimeFieldNumber = 8;
  inline float step_time() const;
  inline void set_step_time(float value);

  // @@protoc_insertion_point(class_scope:service_infrastructure.SearchConfiguration)
 private:
  inline void set_has_start_az();
  inline void clear_has_start_az();
  inline void set_has_stop_az();
  inline void clear_has_stop_az();
  inline void set_has_start_el();
  inline void clear_has_start_el();
  inline void set_has_stop_el();
  inline void clear_has_stop_el();
  inline void set_has_antenna();
  inline void clear_has_antenna();
  inline void set_has_step_az();
  inline void clear_has_step_az();
  inline void set_has_step_el();
  inline void clear_has_step_el();
  inline void set_has_step_time();
  inline void clear_has_step_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float start_az_;
  float stop_az_;
  float start_el_;
  float stop_el_;
  ::google::protobuf::int32 antenna_;
  float step_az_;
  float step_el_;
  float step_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureCommon_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureCommon_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureCommon_2eproto();

  void InitAsDefaultInstance();
  static SearchConfiguration* default_instance_;
};
// -------------------------------------------------------------------

class Band : public ::google::protobuf::Message {
 public:
  Band();
  virtual ~Band();

  Band(const Band& from);

  inline Band& operator=(const Band& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Band& default_instance();

  void Swap(Band* other);

  // implements Message ----------------------------------------------

  Band* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Band& from);
  void MergeFrom(const Band& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string label = 1;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 1;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  inline void set_allocated_label(::std::string* label);

  // optional double start_freq_hz = 2;
  inline bool has_start_freq_hz() const;
  inline void clear_start_freq_hz();
  static const int kStartFreqHzFieldNumber = 2;
  inline double start_freq_hz() const;
  inline void set_start_freq_hz(double value);

  // optional double stop_freq_hz = 3;
  inline bool has_stop_freq_hz() const;
  inline void clear_stop_freq_hz();
  static const int kStopFreqHzFieldNumber = 3;
  inline double stop_freq_hz() const;
  inline void set_stop_freq_hz(double value);

  // @@protoc_insertion_point(class_scope:service_infrastructure.Band)
 private:
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_start_freq_hz();
  inline void clear_has_start_freq_hz();
  inline void set_has_stop_freq_hz();
  inline void clear_has_stop_freq_hz();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* label_;
  double start_freq_hz_;
  double stop_freq_hz_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureCommon_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureCommon_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureCommon_2eproto();

  void InitAsDefaultInstance();
  static Band* default_instance_;
};
// -------------------------------------------------------------------

class Channel : public ::google::protobuf::Message {
 public:
  Channel();
  virtual ~Channel();

  Channel(const Channel& from);

  inline Channel& operator=(const Channel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Channel& default_instance();

  void Swap(Channel* other);

  // implements Message ----------------------------------------------

  Channel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Channel& from);
  void MergeFrom(const Channel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 channel_number = 1;
  inline bool has_channel_number() const;
  inline void clear_channel_number();
  static const int kChannelNumberFieldNumber = 1;
  inline ::google::protobuf::int32 channel_number() const;
  inline void set_channel_number(::google::protobuf::int32 value);

  // optional double sample_rate_sps = 2;
  inline bool has_sample_rate_sps() const;
  inline void clear_sample_rate_sps();
  static const int kSampleRateSpsFieldNumber = 2;
  inline double sample_rate_sps() const;
  inline void set_sample_rate_sps(double value);

  // optional double bandwidth_hz = 3;
  inline bool has_bandwidth_hz() const;
  inline void clear_bandwidth_hz();
  static const int kBandwidthHzFieldNumber = 3;
  inline double bandwidth_hz() const;
  inline void set_bandwidth_hz(double value);

  // optional double decimation = 4;
  inline bool has_decimation() const;
  inline void clear_decimation();
  static const int kDecimationFieldNumber = 4;
  inline double decimation() const;
  inline void set_decimation(double value);

  // @@protoc_insertion_point(class_scope:service_infrastructure.Channel)
 private:
  inline void set_has_channel_number();
  inline void clear_has_channel_number();
  inline void set_has_sample_rate_sps();
  inline void clear_has_sample_rate_sps();
  inline void set_has_bandwidth_hz();
  inline void clear_has_bandwidth_hz();
  inline void set_has_decimation();
  inline void clear_has_decimation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double sample_rate_sps_;
  double bandwidth_hz_;
  double decimation_;
  ::google::protobuf::int32 channel_number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureCommon_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureCommon_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureCommon_2eproto();

  void InitAsDefaultInstance();
  static Channel* default_instance_;
};
// ===================================================================


// ===================================================================

// Header

// optional int64 sequence_number = 1;
inline bool Header::has_sequence_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header::set_has_sequence_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header::clear_has_sequence_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header::clear_sequence_number() {
  sequence_number_ = GOOGLE_LONGLONG(0);
  clear_has_sequence_number();
}
inline ::google::protobuf::int64 Header::sequence_number() const {
  return sequence_number_;
}
inline void Header::set_sequence_number(::google::protobuf::int64 value) {
  set_has_sequence_number();
  sequence_number_ = value;
}

// optional string timestamp = 2;
inline bool Header::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& Header::timestamp() const {
  return *timestamp_;
}
inline void Header::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void Header::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void Header::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Header::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* Header::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Header::set_allocated_timestamp(::std::string* timestamp) {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    delete timestamp_;
  }
  if (timestamp) {
    set_has_timestamp();
    timestamp_ = timestamp;
  } else {
    clear_has_timestamp();
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 pid = 3;
inline bool Header::has_pid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Header::set_has_pid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Header::clear_has_pid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Header::clear_pid() {
  pid_ = 0;
  clear_has_pid();
}
inline ::google::protobuf::int32 Header::pid() const {
  return pid_;
}
inline void Header::set_pid(::google::protobuf::int32 value) {
  set_has_pid();
  pid_ = value;
}

// optional string sensorName = 4 [default = ""];
inline bool Header::has_sensorname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Header::set_has_sensorname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Header::clear_has_sensorname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Header::clear_sensorname() {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    sensorname_->clear();
  }
  clear_has_sensorname();
}
inline const ::std::string& Header::sensorname() const {
  return *sensorname_;
}
inline void Header::set_sensorname(const ::std::string& value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void Header::set_sensorname(const char* value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void Header::set_sensorname(const char* value, size_t size) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Header::mutable_sensorname() {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  return sensorname_;
}
inline ::std::string* Header::release_sensorname() {
  clear_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sensorname_;
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Header::set_allocated_sensorname(::std::string* sensorname) {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    delete sensorname_;
  }
  if (sensorname) {
    set_has_sensorname();
    sensorname_ = sensorname;
  } else {
    clear_has_sensorname();
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Ack

// -------------------------------------------------------------------

// NAck

// optional .service_infrastructure.ErrorCode error_code = 2 [default = UNKNOWN];
inline bool NAck::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NAck::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NAck::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NAck::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::service_infrastructure::ErrorCode NAck::error_code() const {
  return static_cast< ::service_infrastructure::ErrorCode >(error_code_);
}
inline void NAck::set_error_code(::service_infrastructure::ErrorCode value) {
  assert(::service_infrastructure::ErrorCode_IsValid(value));
  set_has_error_code();
  error_code_ = value;
}

// optional string error_description = 3;
inline bool NAck::has_error_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NAck::set_has_error_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NAck::clear_has_error_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NAck::clear_error_description() {
  if (error_description_ != &::google::protobuf::internal::kEmptyString) {
    error_description_->clear();
  }
  clear_has_error_description();
}
inline const ::std::string& NAck::error_description() const {
  return *error_description_;
}
inline void NAck::set_error_description(const ::std::string& value) {
  set_has_error_description();
  if (error_description_ == &::google::protobuf::internal::kEmptyString) {
    error_description_ = new ::std::string;
  }
  error_description_->assign(value);
}
inline void NAck::set_error_description(const char* value) {
  set_has_error_description();
  if (error_description_ == &::google::protobuf::internal::kEmptyString) {
    error_description_ = new ::std::string;
  }
  error_description_->assign(value);
}
inline void NAck::set_error_description(const char* value, size_t size) {
  set_has_error_description();
  if (error_description_ == &::google::protobuf::internal::kEmptyString) {
    error_description_ = new ::std::string;
  }
  error_description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NAck::mutable_error_description() {
  set_has_error_description();
  if (error_description_ == &::google::protobuf::internal::kEmptyString) {
    error_description_ = new ::std::string;
  }
  return error_description_;
}
inline ::std::string* NAck::release_error_description() {
  clear_has_error_description();
  if (error_description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_description_;
    error_description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NAck::set_allocated_error_description(::std::string* error_description) {
  if (error_description_ != &::google::protobuf::internal::kEmptyString) {
    delete error_description_;
  }
  if (error_description) {
    set_has_error_description();
    error_description_ = error_description;
  } else {
    clear_has_error_description();
    error_description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// HandshakeTopic

// optional .service_infrastructure.Header header = 100;
inline bool HandshakeTopic::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HandshakeTopic::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HandshakeTopic::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HandshakeTopic::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& HandshakeTopic::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* HandshakeTopic::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* HandshakeTopic::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void HandshakeTopic::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .service_infrastructure.Ack ack = 1;
inline bool HandshakeTopic::has_ack() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HandshakeTopic::set_has_ack() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HandshakeTopic::clear_has_ack() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HandshakeTopic::clear_ack() {
  if (ack_ != NULL) ack_->::service_infrastructure::Ack::Clear();
  clear_has_ack();
}
inline const ::service_infrastructure::Ack& HandshakeTopic::ack() const {
  return ack_ != NULL ? *ack_ : *default_instance_->ack_;
}
inline ::service_infrastructure::Ack* HandshakeTopic::mutable_ack() {
  set_has_ack();
  if (ack_ == NULL) ack_ = new ::service_infrastructure::Ack;
  return ack_;
}
inline ::service_infrastructure::Ack* HandshakeTopic::release_ack() {
  clear_has_ack();
  ::service_infrastructure::Ack* temp = ack_;
  ack_ = NULL;
  return temp;
}
inline void HandshakeTopic::set_allocated_ack(::service_infrastructure::Ack* ack) {
  delete ack_;
  ack_ = ack;
  if (ack) {
    set_has_ack();
  } else {
    clear_has_ack();
  }
}

// optional .service_infrastructure.NAck nack = 2;
inline bool HandshakeTopic::has_nack() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HandshakeTopic::set_has_nack() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HandshakeTopic::clear_has_nack() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HandshakeTopic::clear_nack() {
  if (nack_ != NULL) nack_->::service_infrastructure::NAck::Clear();
  clear_has_nack();
}
inline const ::service_infrastructure::NAck& HandshakeTopic::nack() const {
  return nack_ != NULL ? *nack_ : *default_instance_->nack_;
}
inline ::service_infrastructure::NAck* HandshakeTopic::mutable_nack() {
  set_has_nack();
  if (nack_ == NULL) nack_ = new ::service_infrastructure::NAck;
  return nack_;
}
inline ::service_infrastructure::NAck* HandshakeTopic::release_nack() {
  clear_has_nack();
  ::service_infrastructure::NAck* temp = nack_;
  nack_ = NULL;
  return temp;
}
inline void HandshakeTopic::set_allocated_nack(::service_infrastructure::NAck* nack) {
  delete nack_;
  nack_ = nack;
  if (nack) {
    set_has_nack();
  } else {
    clear_has_nack();
  }
}

// optional .service_infrastructure.StartupNotification startup_notification = 3;
inline bool HandshakeTopic::has_startup_notification() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HandshakeTopic::set_has_startup_notification() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HandshakeTopic::clear_has_startup_notification() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HandshakeTopic::clear_startup_notification() {
  if (startup_notification_ != NULL) startup_notification_->::service_infrastructure::StartupNotification::Clear();
  clear_has_startup_notification();
}
inline const ::service_infrastructure::StartupNotification& HandshakeTopic::startup_notification() const {
  return startup_notification_ != NULL ? *startup_notification_ : *default_instance_->startup_notification_;
}
inline ::service_infrastructure::StartupNotification* HandshakeTopic::mutable_startup_notification() {
  set_has_startup_notification();
  if (startup_notification_ == NULL) startup_notification_ = new ::service_infrastructure::StartupNotification;
  return startup_notification_;
}
inline ::service_infrastructure::StartupNotification* HandshakeTopic::release_startup_notification() {
  clear_has_startup_notification();
  ::service_infrastructure::StartupNotification* temp = startup_notification_;
  startup_notification_ = NULL;
  return temp;
}
inline void HandshakeTopic::set_allocated_startup_notification(::service_infrastructure::StartupNotification* startup_notification) {
  delete startup_notification_;
  startup_notification_ = startup_notification;
  if (startup_notification) {
    set_has_startup_notification();
  } else {
    clear_has_startup_notification();
  }
}

// optional .service_infrastructure.ShutDownNotification shutdown_notification = 4;
inline bool HandshakeTopic::has_shutdown_notification() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HandshakeTopic::set_has_shutdown_notification() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HandshakeTopic::clear_has_shutdown_notification() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HandshakeTopic::clear_shutdown_notification() {
  if (shutdown_notification_ != NULL) shutdown_notification_->::service_infrastructure::ShutDownNotification::Clear();
  clear_has_shutdown_notification();
}
inline const ::service_infrastructure::ShutDownNotification& HandshakeTopic::shutdown_notification() const {
  return shutdown_notification_ != NULL ? *shutdown_notification_ : *default_instance_->shutdown_notification_;
}
inline ::service_infrastructure::ShutDownNotification* HandshakeTopic::mutable_shutdown_notification() {
  set_has_shutdown_notification();
  if (shutdown_notification_ == NULL) shutdown_notification_ = new ::service_infrastructure::ShutDownNotification;
  return shutdown_notification_;
}
inline ::service_infrastructure::ShutDownNotification* HandshakeTopic::release_shutdown_notification() {
  clear_has_shutdown_notification();
  ::service_infrastructure::ShutDownNotification* temp = shutdown_notification_;
  shutdown_notification_ = NULL;
  return temp;
}
inline void HandshakeTopic::set_allocated_shutdown_notification(::service_infrastructure::ShutDownNotification* shutdown_notification) {
  delete shutdown_notification_;
  shutdown_notification_ = shutdown_notification;
  if (shutdown_notification) {
    set_has_shutdown_notification();
  } else {
    clear_has_shutdown_notification();
  }
}

// optional .service_infrastructure.ConnectionRequest connection_request = 5;
inline bool HandshakeTopic::has_connection_request() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HandshakeTopic::set_has_connection_request() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HandshakeTopic::clear_has_connection_request() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HandshakeTopic::clear_connection_request() {
  if (connection_request_ != NULL) connection_request_->::service_infrastructure::ConnectionRequest::Clear();
  clear_has_connection_request();
}
inline const ::service_infrastructure::ConnectionRequest& HandshakeTopic::connection_request() const {
  return connection_request_ != NULL ? *connection_request_ : *default_instance_->connection_request_;
}
inline ::service_infrastructure::ConnectionRequest* HandshakeTopic::mutable_connection_request() {
  set_has_connection_request();
  if (connection_request_ == NULL) connection_request_ = new ::service_infrastructure::ConnectionRequest;
  return connection_request_;
}
inline ::service_infrastructure::ConnectionRequest* HandshakeTopic::release_connection_request() {
  clear_has_connection_request();
  ::service_infrastructure::ConnectionRequest* temp = connection_request_;
  connection_request_ = NULL;
  return temp;
}
inline void HandshakeTopic::set_allocated_connection_request(::service_infrastructure::ConnectionRequest* connection_request) {
  delete connection_request_;
  connection_request_ = connection_request;
  if (connection_request) {
    set_has_connection_request();
  } else {
    clear_has_connection_request();
  }
}

// optional .service_infrastructure.ConnectionResponse connection_response = 6;
inline bool HandshakeTopic::has_connection_response() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HandshakeTopic::set_has_connection_response() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HandshakeTopic::clear_has_connection_response() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HandshakeTopic::clear_connection_response() {
  if (connection_response_ != NULL) connection_response_->::service_infrastructure::ConnectionResponse::Clear();
  clear_has_connection_response();
}
inline const ::service_infrastructure::ConnectionResponse& HandshakeTopic::connection_response() const {
  return connection_response_ != NULL ? *connection_response_ : *default_instance_->connection_response_;
}
inline ::service_infrastructure::ConnectionResponse* HandshakeTopic::mutable_connection_response() {
  set_has_connection_response();
  if (connection_response_ == NULL) connection_response_ = new ::service_infrastructure::ConnectionResponse;
  return connection_response_;
}
inline ::service_infrastructure::ConnectionResponse* HandshakeTopic::release_connection_response() {
  clear_has_connection_response();
  ::service_infrastructure::ConnectionResponse* temp = connection_response_;
  connection_response_ = NULL;
  return temp;
}
inline void HandshakeTopic::set_allocated_connection_response(::service_infrastructure::ConnectionResponse* connection_response) {
  delete connection_response_;
  connection_response_ = connection_response;
  if (connection_response) {
    set_has_connection_response();
  } else {
    clear_has_connection_response();
  }
}

// optional .service_infrastructure.ConfigurationRequest configuration_request = 7;
inline bool HandshakeTopic::has_configuration_request() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HandshakeTopic::set_has_configuration_request() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HandshakeTopic::clear_has_configuration_request() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HandshakeTopic::clear_configuration_request() {
  if (configuration_request_ != NULL) configuration_request_->::service_infrastructure::ConfigurationRequest::Clear();
  clear_has_configuration_request();
}
inline const ::service_infrastructure::ConfigurationRequest& HandshakeTopic::configuration_request() const {
  return configuration_request_ != NULL ? *configuration_request_ : *default_instance_->configuration_request_;
}
inline ::service_infrastructure::ConfigurationRequest* HandshakeTopic::mutable_configuration_request() {
  set_has_configuration_request();
  if (configuration_request_ == NULL) configuration_request_ = new ::service_infrastructure::ConfigurationRequest;
  return configuration_request_;
}
inline ::service_infrastructure::ConfigurationRequest* HandshakeTopic::release_configuration_request() {
  clear_has_configuration_request();
  ::service_infrastructure::ConfigurationRequest* temp = configuration_request_;
  configuration_request_ = NULL;
  return temp;
}
inline void HandshakeTopic::set_allocated_configuration_request(::service_infrastructure::ConfigurationRequest* configuration_request) {
  delete configuration_request_;
  configuration_request_ = configuration_request;
  if (configuration_request) {
    set_has_configuration_request();
  } else {
    clear_has_configuration_request();
  }
}

// optional .service_infrastructure.ConfigurationResponse configuration_response = 8;
inline bool HandshakeTopic::has_configuration_response() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HandshakeTopic::set_has_configuration_response() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HandshakeTopic::clear_has_configuration_response() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HandshakeTopic::clear_configuration_response() {
  if (configuration_response_ != NULL) configuration_response_->::service_infrastructure::ConfigurationResponse::Clear();
  clear_has_configuration_response();
}
inline const ::service_infrastructure::ConfigurationResponse& HandshakeTopic::configuration_response() const {
  return configuration_response_ != NULL ? *configuration_response_ : *default_instance_->configuration_response_;
}
inline ::service_infrastructure::ConfigurationResponse* HandshakeTopic::mutable_configuration_response() {
  set_has_configuration_response();
  if (configuration_response_ == NULL) configuration_response_ = new ::service_infrastructure::ConfigurationResponse;
  return configuration_response_;
}
inline ::service_infrastructure::ConfigurationResponse* HandshakeTopic::release_configuration_response() {
  clear_has_configuration_response();
  ::service_infrastructure::ConfigurationResponse* temp = configuration_response_;
  configuration_response_ = NULL;
  return temp;
}
inline void HandshakeTopic::set_allocated_configuration_response(::service_infrastructure::ConfigurationResponse* configuration_response) {
  delete configuration_response_;
  configuration_response_ = configuration_response;
  if (configuration_response) {
    set_has_configuration_response();
  } else {
    clear_has_configuration_response();
  }
}

// -------------------------------------------------------------------

// StartupNotification

// -------------------------------------------------------------------

// ShutDownNotification

// -------------------------------------------------------------------

// ConnectionRequest

// optional .service_infrastructure.Version release = 1;
inline bool ConnectionRequest::has_release() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectionRequest::set_has_release() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectionRequest::clear_has_release() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectionRequest::clear_release() {
  if (release_ != NULL) release_->::service_infrastructure::Version::Clear();
  clear_has_release();
}
inline const ::service_infrastructure::Version& ConnectionRequest::release() const {
  return release_ != NULL ? *release_ : *default_instance_->release_;
}
inline ::service_infrastructure::Version* ConnectionRequest::mutable_release() {
  set_has_release();
  if (release_ == NULL) release_ = new ::service_infrastructure::Version;
  return release_;
}
inline ::service_infrastructure::Version* ConnectionRequest::release_release() {
  clear_has_release();
  ::service_infrastructure::Version* temp = release_;
  release_ = NULL;
  return temp;
}
inline void ConnectionRequest::set_allocated_release(::service_infrastructure::Version* release) {
  delete release_;
  release_ = release;
  if (release) {
    set_has_release();
  } else {
    clear_has_release();
  }
}

// optional .service_infrastructure.Version icd = 2;
inline bool ConnectionRequest::has_icd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectionRequest::set_has_icd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectionRequest::clear_has_icd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectionRequest::clear_icd() {
  if (icd_ != NULL) icd_->::service_infrastructure::Version::Clear();
  clear_has_icd();
}
inline const ::service_infrastructure::Version& ConnectionRequest::icd() const {
  return icd_ != NULL ? *icd_ : *default_instance_->icd_;
}
inline ::service_infrastructure::Version* ConnectionRequest::mutable_icd() {
  set_has_icd();
  if (icd_ == NULL) icd_ = new ::service_infrastructure::Version;
  return icd_;
}
inline ::service_infrastructure::Version* ConnectionRequest::release_icd() {
  clear_has_icd();
  ::service_infrastructure::Version* temp = icd_;
  icd_ = NULL;
  return temp;
}
inline void ConnectionRequest::set_allocated_icd(::service_infrastructure::Version* icd) {
  delete icd_;
  icd_ = icd;
  if (icd) {
    set_has_icd();
  } else {
    clear_has_icd();
  }
}

// -------------------------------------------------------------------

// ConnectionResponse

// optional .service_infrastructure.Version release = 1;
inline bool ConnectionResponse::has_release() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectionResponse::set_has_release() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectionResponse::clear_has_release() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectionResponse::clear_release() {
  if (release_ != NULL) release_->::service_infrastructure::Version::Clear();
  clear_has_release();
}
inline const ::service_infrastructure::Version& ConnectionResponse::release() const {
  return release_ != NULL ? *release_ : *default_instance_->release_;
}
inline ::service_infrastructure::Version* ConnectionResponse::mutable_release() {
  set_has_release();
  if (release_ == NULL) release_ = new ::service_infrastructure::Version;
  return release_;
}
inline ::service_infrastructure::Version* ConnectionResponse::release_release() {
  clear_has_release();
  ::service_infrastructure::Version* temp = release_;
  release_ = NULL;
  return temp;
}
inline void ConnectionResponse::set_allocated_release(::service_infrastructure::Version* release) {
  delete release_;
  release_ = release;
  if (release) {
    set_has_release();
  } else {
    clear_has_release();
  }
}

// optional .service_infrastructure.Version icd = 2;
inline bool ConnectionResponse::has_icd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectionResponse::set_has_icd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectionResponse::clear_has_icd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectionResponse::clear_icd() {
  if (icd_ != NULL) icd_->::service_infrastructure::Version::Clear();
  clear_has_icd();
}
inline const ::service_infrastructure::Version& ConnectionResponse::icd() const {
  return icd_ != NULL ? *icd_ : *default_instance_->icd_;
}
inline ::service_infrastructure::Version* ConnectionResponse::mutable_icd() {
  set_has_icd();
  if (icd_ == NULL) icd_ = new ::service_infrastructure::Version;
  return icd_;
}
inline ::service_infrastructure::Version* ConnectionResponse::release_icd() {
  clear_has_icd();
  ::service_infrastructure::Version* temp = icd_;
  icd_ = NULL;
  return temp;
}
inline void ConnectionResponse::set_allocated_icd(::service_infrastructure::Version* icd) {
  delete icd_;
  icd_ = icd;
  if (icd) {
    set_has_icd();
  } else {
    clear_has_icd();
  }
}

// -------------------------------------------------------------------

// Version

// optional int64 major = 1 [default = -1];
inline bool Version::has_major() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Version::set_has_major() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Version::clear_has_major() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Version::clear_major() {
  major_ = GOOGLE_LONGLONG(-1);
  clear_has_major();
}
inline ::google::protobuf::int64 Version::major() const {
  return major_;
}
inline void Version::set_major(::google::protobuf::int64 value) {
  set_has_major();
  major_ = value;
}

// optional int64 minor = 2 [default = -1];
inline bool Version::has_minor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Version::set_has_minor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Version::clear_has_minor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Version::clear_minor() {
  minor_ = GOOGLE_LONGLONG(-1);
  clear_has_minor();
}
inline ::google::protobuf::int64 Version::minor() const {
  return minor_;
}
inline void Version::set_minor(::google::protobuf::int64 value) {
  set_has_minor();
  minor_ = value;
}

// optional int64 patch = 3 [default = -1];
inline bool Version::has_patch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Version::set_has_patch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Version::clear_has_patch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Version::clear_patch() {
  patch_ = GOOGLE_LONGLONG(-1);
  clear_has_patch();
}
inline ::google::protobuf::int64 Version::patch() const {
  return patch_;
}
inline void Version::set_patch(::google::protobuf::int64 value) {
  set_has_patch();
  patch_ = value;
}

// optional string date = 4 [default = "0-0-0"];
inline bool Version::has_date() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Version::set_has_date() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Version::clear_has_date() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Version::clear_date() {
  if (date_ != _default_date_) {
    date_->assign(*_default_date_);
  }
  clear_has_date();
}
inline const ::std::string& Version::date() const {
  return *date_;
}
inline void Version::set_date(const ::std::string& value) {
  set_has_date();
  if (date_ == _default_date_) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void Version::set_date(const char* value) {
  set_has_date();
  if (date_ == _default_date_) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void Version::set_date(const char* value, size_t size) {
  set_has_date();
  if (date_ == _default_date_) {
    date_ = new ::std::string;
  }
  date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Version::mutable_date() {
  set_has_date();
  if (date_ == _default_date_) {
    date_ = new ::std::string(*_default_date_);
  }
  return date_;
}
inline ::std::string* Version::release_date() {
  clear_has_date();
  if (date_ == _default_date_) {
    return NULL;
  } else {
    ::std::string* temp = date_;
    date_ = const_cast< ::std::string*>(_default_date_);
    return temp;
  }
}
inline void Version::set_allocated_date(::std::string* date) {
  if (date_ != _default_date_) {
    delete date_;
  }
  if (date) {
    set_has_date();
    date_ = date;
  } else {
    clear_has_date();
    date_ = const_cast< ::std::string*>(_default_date_);
  }
}

// optional string commit = 5;
inline bool Version::has_commit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Version::set_has_commit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Version::clear_has_commit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Version::clear_commit() {
  if (commit_ != &::google::protobuf::internal::kEmptyString) {
    commit_->clear();
  }
  clear_has_commit();
}
inline const ::std::string& Version::commit() const {
  return *commit_;
}
inline void Version::set_commit(const ::std::string& value) {
  set_has_commit();
  if (commit_ == &::google::protobuf::internal::kEmptyString) {
    commit_ = new ::std::string;
  }
  commit_->assign(value);
}
inline void Version::set_commit(const char* value) {
  set_has_commit();
  if (commit_ == &::google::protobuf::internal::kEmptyString) {
    commit_ = new ::std::string;
  }
  commit_->assign(value);
}
inline void Version::set_commit(const char* value, size_t size) {
  set_has_commit();
  if (commit_ == &::google::protobuf::internal::kEmptyString) {
    commit_ = new ::std::string;
  }
  commit_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Version::mutable_commit() {
  set_has_commit();
  if (commit_ == &::google::protobuf::internal::kEmptyString) {
    commit_ = new ::std::string;
  }
  return commit_;
}
inline ::std::string* Version::release_commit() {
  clear_has_commit();
  if (commit_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = commit_;
    commit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Version::set_allocated_commit(::std::string* commit) {
  if (commit_ != &::google::protobuf::internal::kEmptyString) {
    delete commit_;
  }
  if (commit) {
    set_has_commit();
    commit_ = commit;
  } else {
    clear_has_commit();
    commit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ConfigurationRequest

// optional .service_infrastructure.Configuration requested_configuration = 1;
inline bool ConfigurationRequest::has_requested_configuration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfigurationRequest::set_has_requested_configuration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfigurationRequest::clear_has_requested_configuration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfigurationRequest::clear_requested_configuration() {
  if (requested_configuration_ != NULL) requested_configuration_->::service_infrastructure::Configuration::Clear();
  clear_has_requested_configuration();
}
inline const ::service_infrastructure::Configuration& ConfigurationRequest::requested_configuration() const {
  return requested_configuration_ != NULL ? *requested_configuration_ : *default_instance_->requested_configuration_;
}
inline ::service_infrastructure::Configuration* ConfigurationRequest::mutable_requested_configuration() {
  set_has_requested_configuration();
  if (requested_configuration_ == NULL) requested_configuration_ = new ::service_infrastructure::Configuration;
  return requested_configuration_;
}
inline ::service_infrastructure::Configuration* ConfigurationRequest::release_requested_configuration() {
  clear_has_requested_configuration();
  ::service_infrastructure::Configuration* temp = requested_configuration_;
  requested_configuration_ = NULL;
  return temp;
}
inline void ConfigurationRequest::set_allocated_requested_configuration(::service_infrastructure::Configuration* requested_configuration) {
  delete requested_configuration_;
  requested_configuration_ = requested_configuration;
  if (requested_configuration) {
    set_has_requested_configuration();
  } else {
    clear_has_requested_configuration();
  }
}

// -------------------------------------------------------------------

// ConfigurationResponse

// optional .service_infrastructure.Configuration current_configuration = 1;
inline bool ConfigurationResponse::has_current_configuration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfigurationResponse::set_has_current_configuration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfigurationResponse::clear_has_current_configuration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfigurationResponse::clear_current_configuration() {
  if (current_configuration_ != NULL) current_configuration_->::service_infrastructure::Configuration::Clear();
  clear_has_current_configuration();
}
inline const ::service_infrastructure::Configuration& ConfigurationResponse::current_configuration() const {
  return current_configuration_ != NULL ? *current_configuration_ : *default_instance_->current_configuration_;
}
inline ::service_infrastructure::Configuration* ConfigurationResponse::mutable_current_configuration() {
  set_has_current_configuration();
  if (current_configuration_ == NULL) current_configuration_ = new ::service_infrastructure::Configuration;
  return current_configuration_;
}
inline ::service_infrastructure::Configuration* ConfigurationResponse::release_current_configuration() {
  clear_has_current_configuration();
  ::service_infrastructure::Configuration* temp = current_configuration_;
  current_configuration_ = NULL;
  return temp;
}
inline void ConfigurationResponse::set_allocated_current_configuration(::service_infrastructure::Configuration* current_configuration) {
  delete current_configuration_;
  current_configuration_ = current_configuration;
  if (current_configuration) {
    set_has_current_configuration();
  } else {
    clear_has_current_configuration();
  }
}

// -------------------------------------------------------------------

// Configuration

// optional int64 max_file_duration = 1;
inline bool Configuration::has_max_file_duration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Configuration::set_has_max_file_duration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Configuration::clear_has_max_file_duration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Configuration::clear_max_file_duration() {
  max_file_duration_ = GOOGLE_LONGLONG(0);
  clear_has_max_file_duration();
}
inline ::google::protobuf::int64 Configuration::max_file_duration() const {
  return max_file_duration_;
}
inline void Configuration::set_max_file_duration(::google::protobuf::int64 value) {
  set_has_max_file_duration();
  max_file_duration_ = value;
}

// optional int64 min_buffer_depth = 2;
inline bool Configuration::has_min_buffer_depth() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Configuration::set_has_min_buffer_depth() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Configuration::clear_has_min_buffer_depth() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Configuration::clear_min_buffer_depth() {
  min_buffer_depth_ = GOOGLE_LONGLONG(0);
  clear_has_min_buffer_depth();
}
inline ::google::protobuf::int64 Configuration::min_buffer_depth() const {
  return min_buffer_depth_;
}
inline void Configuration::set_min_buffer_depth(::google::protobuf::int64 value) {
  set_has_min_buffer_depth();
  min_buffer_depth_ = value;
}

// optional bool use_agc = 3 [default = true];
inline bool Configuration::has_use_agc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Configuration::set_has_use_agc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Configuration::clear_has_use_agc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Configuration::clear_use_agc() {
  use_agc_ = true;
  clear_has_use_agc();
}
inline bool Configuration::use_agc() const {
  return use_agc_;
}
inline void Configuration::set_use_agc(bool value) {
  set_has_use_agc();
  use_agc_ = value;
}

// repeated .service_infrastructure.Band bands = 4;
inline int Configuration::bands_size() const {
  return bands_.size();
}
inline void Configuration::clear_bands() {
  bands_.Clear();
}
inline const ::service_infrastructure::Band& Configuration::bands(int index) const {
  return bands_.Get(index);
}
inline ::service_infrastructure::Band* Configuration::mutable_bands(int index) {
  return bands_.Mutable(index);
}
inline ::service_infrastructure::Band* Configuration::add_bands() {
  return bands_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::service_infrastructure::Band >&
Configuration::bands() const {
  return bands_;
}
inline ::google::protobuf::RepeatedPtrField< ::service_infrastructure::Band >*
Configuration::mutable_bands() {
  return &bands_;
}

// repeated .service_infrastructure.Channel rx_channels = 5;
inline int Configuration::rx_channels_size() const {
  return rx_channels_.size();
}
inline void Configuration::clear_rx_channels() {
  rx_channels_.Clear();
}
inline const ::service_infrastructure::Channel& Configuration::rx_channels(int index) const {
  return rx_channels_.Get(index);
}
inline ::service_infrastructure::Channel* Configuration::mutable_rx_channels(int index) {
  return rx_channels_.Mutable(index);
}
inline ::service_infrastructure::Channel* Configuration::add_rx_channels() {
  return rx_channels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::service_infrastructure::Channel >&
Configuration::rx_channels() const {
  return rx_channels_;
}
inline ::google::protobuf::RepeatedPtrField< ::service_infrastructure::Channel >*
Configuration::mutable_rx_channels() {
  return &rx_channels_;
}

// repeated .service_infrastructure.Channel tx_channels = 6;
inline int Configuration::tx_channels_size() const {
  return tx_channels_.size();
}
inline void Configuration::clear_tx_channels() {
  tx_channels_.Clear();
}
inline const ::service_infrastructure::Channel& Configuration::tx_channels(int index) const {
  return tx_channels_.Get(index);
}
inline ::service_infrastructure::Channel* Configuration::mutable_tx_channels(int index) {
  return tx_channels_.Mutable(index);
}
inline ::service_infrastructure::Channel* Configuration::add_tx_channels() {
  return tx_channels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::service_infrastructure::Channel >&
Configuration::tx_channels() const {
  return tx_channels_;
}
inline ::google::protobuf::RepeatedPtrField< ::service_infrastructure::Channel >*
Configuration::mutable_tx_channels() {
  return &tx_channels_;
}

// repeated .service_infrastructure.SearchConfiguration search_configuration = 7;
inline int Configuration::search_configuration_size() const {
  return search_configuration_.size();
}
inline void Configuration::clear_search_configuration() {
  search_configuration_.Clear();
}
inline const ::service_infrastructure::SearchConfiguration& Configuration::search_configuration(int index) const {
  return search_configuration_.Get(index);
}
inline ::service_infrastructure::SearchConfiguration* Configuration::mutable_search_configuration(int index) {
  return search_configuration_.Mutable(index);
}
inline ::service_infrastructure::SearchConfiguration* Configuration::add_search_configuration() {
  return search_configuration_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::service_infrastructure::SearchConfiguration >&
Configuration::search_configuration() const {
  return search_configuration_;
}
inline ::google::protobuf::RepeatedPtrField< ::service_infrastructure::SearchConfiguration >*
Configuration::mutable_search_configuration() {
  return &search_configuration_;
}

// -------------------------------------------------------------------

// SearchConfiguration

// optional float start_az = 1;
inline bool SearchConfiguration::has_start_az() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchConfiguration::set_has_start_az() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchConfiguration::clear_has_start_az() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchConfiguration::clear_start_az() {
  start_az_ = 0;
  clear_has_start_az();
}
inline float SearchConfiguration::start_az() const {
  return start_az_;
}
inline void SearchConfiguration::set_start_az(float value) {
  set_has_start_az();
  start_az_ = value;
}

// optional float stop_az = 2;
inline bool SearchConfiguration::has_stop_az() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SearchConfiguration::set_has_stop_az() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SearchConfiguration::clear_has_stop_az() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SearchConfiguration::clear_stop_az() {
  stop_az_ = 0;
  clear_has_stop_az();
}
inline float SearchConfiguration::stop_az() const {
  return stop_az_;
}
inline void SearchConfiguration::set_stop_az(float value) {
  set_has_stop_az();
  stop_az_ = value;
}

// optional float start_el = 3;
inline bool SearchConfiguration::has_start_el() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SearchConfiguration::set_has_start_el() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SearchConfiguration::clear_has_start_el() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SearchConfiguration::clear_start_el() {
  start_el_ = 0;
  clear_has_start_el();
}
inline float SearchConfiguration::start_el() const {
  return start_el_;
}
inline void SearchConfiguration::set_start_el(float value) {
  set_has_start_el();
  start_el_ = value;
}

// optional float stop_el = 4;
inline bool SearchConfiguration::has_stop_el() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SearchConfiguration::set_has_stop_el() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SearchConfiguration::clear_has_stop_el() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SearchConfiguration::clear_stop_el() {
  stop_el_ = 0;
  clear_has_stop_el();
}
inline float SearchConfiguration::stop_el() const {
  return stop_el_;
}
inline void SearchConfiguration::set_stop_el(float value) {
  set_has_stop_el();
  stop_el_ = value;
}

// optional int32 antenna = 5;
inline bool SearchConfiguration::has_antenna() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SearchConfiguration::set_has_antenna() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SearchConfiguration::clear_has_antenna() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SearchConfiguration::clear_antenna() {
  antenna_ = 0;
  clear_has_antenna();
}
inline ::google::protobuf::int32 SearchConfiguration::antenna() const {
  return antenna_;
}
inline void SearchConfiguration::set_antenna(::google::protobuf::int32 value) {
  set_has_antenna();
  antenna_ = value;
}

// optional float step_az = 6;
inline bool SearchConfiguration::has_step_az() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SearchConfiguration::set_has_step_az() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SearchConfiguration::clear_has_step_az() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SearchConfiguration::clear_step_az() {
  step_az_ = 0;
  clear_has_step_az();
}
inline float SearchConfiguration::step_az() const {
  return step_az_;
}
inline void SearchConfiguration::set_step_az(float value) {
  set_has_step_az();
  step_az_ = value;
}

// optional float step_el = 7;
inline bool SearchConfiguration::has_step_el() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SearchConfiguration::set_has_step_el() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SearchConfiguration::clear_has_step_el() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SearchConfiguration::clear_step_el() {
  step_el_ = 0;
  clear_has_step_el();
}
inline float SearchConfiguration::step_el() const {
  return step_el_;
}
inline void SearchConfiguration::set_step_el(float value) {
  set_has_step_el();
  step_el_ = value;
}

// optional float step_time = 8;
inline bool SearchConfiguration::has_step_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SearchConfiguration::set_has_step_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SearchConfiguration::clear_has_step_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SearchConfiguration::clear_step_time() {
  step_time_ = 0;
  clear_has_step_time();
}
inline float SearchConfiguration::step_time() const {
  return step_time_;
}
inline void SearchConfiguration::set_step_time(float value) {
  set_has_step_time();
  step_time_ = value;
}

// -------------------------------------------------------------------

// Band

// optional string label = 1;
inline bool Band::has_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Band::set_has_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Band::clear_has_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Band::clear_label() {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& Band::label() const {
  return *label_;
}
inline void Band::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void Band::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void Band::set_label(const char* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Band::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  return label_;
}
inline ::std::string* Band::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Band::set_allocated_label(::std::string* label) {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    delete label_;
  }
  if (label) {
    set_has_label();
    label_ = label;
  } else {
    clear_has_label();
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double start_freq_hz = 2;
inline bool Band::has_start_freq_hz() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Band::set_has_start_freq_hz() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Band::clear_has_start_freq_hz() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Band::clear_start_freq_hz() {
  start_freq_hz_ = 0;
  clear_has_start_freq_hz();
}
inline double Band::start_freq_hz() const {
  return start_freq_hz_;
}
inline void Band::set_start_freq_hz(double value) {
  set_has_start_freq_hz();
  start_freq_hz_ = value;
}

// optional double stop_freq_hz = 3;
inline bool Band::has_stop_freq_hz() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Band::set_has_stop_freq_hz() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Band::clear_has_stop_freq_hz() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Band::clear_stop_freq_hz() {
  stop_freq_hz_ = 0;
  clear_has_stop_freq_hz();
}
inline double Band::stop_freq_hz() const {
  return stop_freq_hz_;
}
inline void Band::set_stop_freq_hz(double value) {
  set_has_stop_freq_hz();
  stop_freq_hz_ = value;
}

// -------------------------------------------------------------------

// Channel

// optional int32 channel_number = 1;
inline bool Channel::has_channel_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Channel::set_has_channel_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Channel::clear_has_channel_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Channel::clear_channel_number() {
  channel_number_ = 0;
  clear_has_channel_number();
}
inline ::google::protobuf::int32 Channel::channel_number() const {
  return channel_number_;
}
inline void Channel::set_channel_number(::google::protobuf::int32 value) {
  set_has_channel_number();
  channel_number_ = value;
}

// optional double sample_rate_sps = 2;
inline bool Channel::has_sample_rate_sps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Channel::set_has_sample_rate_sps() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Channel::clear_has_sample_rate_sps() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Channel::clear_sample_rate_sps() {
  sample_rate_sps_ = 0;
  clear_has_sample_rate_sps();
}
inline double Channel::sample_rate_sps() const {
  return sample_rate_sps_;
}
inline void Channel::set_sample_rate_sps(double value) {
  set_has_sample_rate_sps();
  sample_rate_sps_ = value;
}

// optional double bandwidth_hz = 3;
inline bool Channel::has_bandwidth_hz() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Channel::set_has_bandwidth_hz() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Channel::clear_has_bandwidth_hz() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Channel::clear_bandwidth_hz() {
  bandwidth_hz_ = 0;
  clear_has_bandwidth_hz();
}
inline double Channel::bandwidth_hz() const {
  return bandwidth_hz_;
}
inline void Channel::set_bandwidth_hz(double value) {
  set_has_bandwidth_hz();
  bandwidth_hz_ = value;
}

// optional double decimation = 4;
inline bool Channel::has_decimation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Channel::set_has_decimation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Channel::clear_has_decimation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Channel::clear_decimation() {
  decimation_ = 0;
  clear_has_decimation();
}
inline double Channel::decimation() const {
  return decimation_;
}
inline void Channel::set_decimation(double value) {
  set_has_decimation();
  decimation_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace service_infrastructure

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service_infrastructure::ErrorCode>() {
  return ::service_infrastructure::ErrorCode_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ServiceInfrastructureCommon_2eproto__INCLUDED
