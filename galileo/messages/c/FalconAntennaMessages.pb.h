// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FalconAntennaMessages.proto

#ifndef PROTOBUF_FalconAntennaMessages_2eproto__INCLUDED
#define PROTOBUF_FalconAntennaMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace falcon_antenna_msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_FalconAntennaMessages_2eproto();
void protobuf_AssignDesc_FalconAntennaMessages_2eproto();
void protobuf_ShutdownFile_FalconAntennaMessages_2eproto();

class RotorStep;
class RotorSlew;
class RotorPoint;
class RotorStop;
class QueryRotorPosition;
class ModifyRotorScanRange;
class AntennaTrack;
class AntennaScan;
class ModifyRotorOffset;
class RotorPosition;
class RotorStatus;
class SwitchMap;
class SwitchMapInputFail;
class QuerySwitchStatus;
class SwitchStatus;
class SlaveAntWaitScan;

enum RotorSlew_Type {
  RotorSlew_Type_CONTINUOUS = 0,
  RotorSlew_Type_ENERGY = 1
};
bool RotorSlew_Type_IsValid(int value);
const RotorSlew_Type RotorSlew_Type_Type_MIN = RotorSlew_Type_CONTINUOUS;
const RotorSlew_Type RotorSlew_Type_Type_MAX = RotorSlew_Type_ENERGY;
const int RotorSlew_Type_Type_ARRAYSIZE = RotorSlew_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* RotorSlew_Type_descriptor();
inline const ::std::string& RotorSlew_Type_Name(RotorSlew_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    RotorSlew_Type_descriptor(), value);
}
inline bool RotorSlew_Type_Parse(
    const ::std::string& name, RotorSlew_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RotorSlew_Type>(
    RotorSlew_Type_descriptor(), name, value);
}
enum AntennaTrack_Status {
  AntennaTrack_Status_OFF = 0,
  AntennaTrack_Status_ON = 1
};
bool AntennaTrack_Status_IsValid(int value);
const AntennaTrack_Status AntennaTrack_Status_Status_MIN = AntennaTrack_Status_OFF;
const AntennaTrack_Status AntennaTrack_Status_Status_MAX = AntennaTrack_Status_ON;
const int AntennaTrack_Status_Status_ARRAYSIZE = AntennaTrack_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* AntennaTrack_Status_descriptor();
inline const ::std::string& AntennaTrack_Status_Name(AntennaTrack_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    AntennaTrack_Status_descriptor(), value);
}
inline bool AntennaTrack_Status_Parse(
    const ::std::string& name, AntennaTrack_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AntennaTrack_Status>(
    AntennaTrack_Status_descriptor(), name, value);
}
enum AntennaScan_ScanType {
  AntennaScan_ScanType_OFF = 0,
  AntennaScan_ScanType_CONTINUOUS = 1,
  AntennaScan_ScanType_ENERGY = 2,
  AntennaScan_ScanType_CONTINUOUS_STEP = 3,
  AntennaScan_ScanType_ENERGY_STEP = 4,
  AntennaScan_ScanType_DEFAULT = 5
};
bool AntennaScan_ScanType_IsValid(int value);
const AntennaScan_ScanType AntennaScan_ScanType_ScanType_MIN = AntennaScan_ScanType_OFF;
const AntennaScan_ScanType AntennaScan_ScanType_ScanType_MAX = AntennaScan_ScanType_DEFAULT;
const int AntennaScan_ScanType_ScanType_ARRAYSIZE = AntennaScan_ScanType_ScanType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AntennaScan_ScanType_descriptor();
inline const ::std::string& AntennaScan_ScanType_Name(AntennaScan_ScanType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AntennaScan_ScanType_descriptor(), value);
}
inline bool AntennaScan_ScanType_Parse(
    const ::std::string& name, AntennaScan_ScanType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AntennaScan_ScanType>(
    AntennaScan_ScanType_descriptor(), name, value);
}
enum RotorPosition_Status {
  RotorPosition_Status_IDLE = 0,
  RotorPosition_Status_MOVING = 1,
  RotorPosition_Status_DONE = 2,
  RotorPosition_Status_FAILED = 3,
  RotorPosition_Status_CANCELLED = 4,
  RotorPosition_Status_MOVING_SLEW = 5
};
bool RotorPosition_Status_IsValid(int value);
const RotorPosition_Status RotorPosition_Status_Status_MIN = RotorPosition_Status_IDLE;
const RotorPosition_Status RotorPosition_Status_Status_MAX = RotorPosition_Status_MOVING_SLEW;
const int RotorPosition_Status_Status_ARRAYSIZE = RotorPosition_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* RotorPosition_Status_descriptor();
inline const ::std::string& RotorPosition_Status_Name(RotorPosition_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    RotorPosition_Status_descriptor(), value);
}
inline bool RotorPosition_Status_Parse(
    const ::std::string& name, RotorPosition_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RotorPosition_Status>(
    RotorPosition_Status_descriptor(), name, value);
}
enum RotorStatus_Status {
  RotorStatus_Status_NO_ROTOR = -1,
  RotorStatus_Status_NO_CONNECTION = 0,
  RotorStatus_Status_CONNECTED = 1
};
bool RotorStatus_Status_IsValid(int value);
const RotorStatus_Status RotorStatus_Status_Status_MIN = RotorStatus_Status_NO_ROTOR;
const RotorStatus_Status RotorStatus_Status_Status_MAX = RotorStatus_Status_CONNECTED;
const int RotorStatus_Status_Status_ARRAYSIZE = RotorStatus_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* RotorStatus_Status_descriptor();
inline const ::std::string& RotorStatus_Status_Name(RotorStatus_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    RotorStatus_Status_descriptor(), value);
}
inline bool RotorStatus_Status_Parse(
    const ::std::string& name, RotorStatus_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RotorStatus_Status>(
    RotorStatus_Status_descriptor(), name, value);
}
enum RotorStatus_CutoutStatus {
  RotorStatus_CutoutStatus_CUTOUT = 0,
  RotorStatus_CutoutStatus_NO_CUTOUT = 1
};
bool RotorStatus_CutoutStatus_IsValid(int value);
const RotorStatus_CutoutStatus RotorStatus_CutoutStatus_CutoutStatus_MIN = RotorStatus_CutoutStatus_CUTOUT;
const RotorStatus_CutoutStatus RotorStatus_CutoutStatus_CutoutStatus_MAX = RotorStatus_CutoutStatus_NO_CUTOUT;
const int RotorStatus_CutoutStatus_CutoutStatus_ARRAYSIZE = RotorStatus_CutoutStatus_CutoutStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* RotorStatus_CutoutStatus_descriptor();
inline const ::std::string& RotorStatus_CutoutStatus_Name(RotorStatus_CutoutStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    RotorStatus_CutoutStatus_descriptor(), value);
}
inline bool RotorStatus_CutoutStatus_Parse(
    const ::std::string& name, RotorStatus_CutoutStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RotorStatus_CutoutStatus>(
    RotorStatus_CutoutStatus_descriptor(), name, value);
}
enum SwitchStatus_Status {
  SwitchStatus_Status_NO_CONNECTION = -2,
  SwitchStatus_Status_NO_RFSW = -1,
  SwitchStatus_Status_CONNECTED = 0
};
bool SwitchStatus_Status_IsValid(int value);
const SwitchStatus_Status SwitchStatus_Status_Status_MIN = SwitchStatus_Status_NO_CONNECTION;
const SwitchStatus_Status SwitchStatus_Status_Status_MAX = SwitchStatus_Status_CONNECTED;
const int SwitchStatus_Status_Status_ARRAYSIZE = SwitchStatus_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* SwitchStatus_Status_descriptor();
inline const ::std::string& SwitchStatus_Status_Name(SwitchStatus_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    SwitchStatus_Status_descriptor(), value);
}
inline bool SwitchStatus_Status_Parse(
    const ::std::string& name, SwitchStatus_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SwitchStatus_Status>(
    SwitchStatus_Status_descriptor(), name, value);
}
enum SwitchStatus_Response {
  SwitchStatus_Response_FAILURE = -1,
  SwitchStatus_Response_SUCCESS = 0
};
bool SwitchStatus_Response_IsValid(int value);
const SwitchStatus_Response SwitchStatus_Response_Response_MIN = SwitchStatus_Response_FAILURE;
const SwitchStatus_Response SwitchStatus_Response_Response_MAX = SwitchStatus_Response_SUCCESS;
const int SwitchStatus_Response_Response_ARRAYSIZE = SwitchStatus_Response_Response_MAX + 1;

const ::google::protobuf::EnumDescriptor* SwitchStatus_Response_descriptor();
inline const ::std::string& SwitchStatus_Response_Name(SwitchStatus_Response value) {
  return ::google::protobuf::internal::NameOfEnum(
    SwitchStatus_Response_descriptor(), value);
}
inline bool SwitchStatus_Response_Parse(
    const ::std::string& name, SwitchStatus_Response* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SwitchStatus_Response>(
    SwitchStatus_Response_descriptor(), name, value);
}
// ===================================================================

class RotorStep : public ::google::protobuf::Message {
 public:
  RotorStep();
  virtual ~RotorStep();

  RotorStep(const RotorStep& from);

  inline RotorStep& operator=(const RotorStep& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RotorStep& default_instance();

  void Swap(RotorStep* other);

  // implements Message ----------------------------------------------

  RotorStep* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RotorStep& from);
  void MergeFrom(const RotorStep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ROTOR_STEP"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string resID = 2;
  inline bool has_resid() const;
  inline void clear_resid();
  static const int kResIDFieldNumber = 2;
  inline const ::std::string& resid() const;
  inline void set_resid(const ::std::string& value);
  inline void set_resid(const char* value);
  inline void set_resid(const char* value, size_t size);
  inline ::std::string* mutable_resid();
  inline ::std::string* release_resid();
  inline void set_allocated_resid(::std::string* resid);

  // optional int32 appID = 3;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 3;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional float azimuth = 4 [default = -1];
  inline bool has_azimuth() const;
  inline void clear_azimuth();
  static const int kAzimuthFieldNumber = 4;
  inline float azimuth() const;
  inline void set_azimuth(float value);

  // optional float elevation = 5 [default = -1];
  inline bool has_elevation() const;
  inline void clear_elevation();
  static const int kElevationFieldNumber = 5;
  inline float elevation() const;
  inline void set_elevation(float value);

  // optional float velocity = 6;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 6;
  inline float velocity() const;
  inline void set_velocity(float value);

  // optional double msgID = 7 [default = 0];
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgIDFieldNumber = 7;
  inline double msgid() const;
  inline void set_msgid(double value);

  // @@protoc_insertion_point(class_scope:falcon_antenna_msg.RotorStep)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_resid();
  inline void clear_has_resid();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_azimuth();
  inline void clear_has_azimuth();
  inline void set_has_elevation();
  inline void clear_has_elevation();
  inline void set_has_velocity();
  inline void clear_has_velocity();
  inline void set_has_msgid();
  inline void clear_has_msgid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* resid_;
  ::google::protobuf::int32 appid_;
  float azimuth_;
  float elevation_;
  float velocity_;
  double msgid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_AssignDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconAntennaMessages_2eproto();

  void InitAsDefaultInstance();
  static RotorStep* default_instance_;
};
// -------------------------------------------------------------------

class RotorSlew : public ::google::protobuf::Message {
 public:
  RotorSlew();
  virtual ~RotorSlew();

  RotorSlew(const RotorSlew& from);

  inline RotorSlew& operator=(const RotorSlew& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RotorSlew& default_instance();

  void Swap(RotorSlew* other);

  // implements Message ----------------------------------------------

  RotorSlew* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RotorSlew& from);
  void MergeFrom(const RotorSlew& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RotorSlew_Type Type;
  static const Type CONTINUOUS = RotorSlew_Type_CONTINUOUS;
  static const Type ENERGY = RotorSlew_Type_ENERGY;
  static inline bool Type_IsValid(int value) {
    return RotorSlew_Type_IsValid(value);
  }
  static const Type Type_MIN =
    RotorSlew_Type_Type_MIN;
  static const Type Type_MAX =
    RotorSlew_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    RotorSlew_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return RotorSlew_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return RotorSlew_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return RotorSlew_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ROTOR_SLEW"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string resID = 2;
  inline bool has_resid() const;
  inline void clear_resid();
  static const int kResIDFieldNumber = 2;
  inline const ::std::string& resid() const;
  inline void set_resid(const ::std::string& value);
  inline void set_resid(const char* value);
  inline void set_resid(const char* value, size_t size);
  inline ::std::string* mutable_resid();
  inline ::std::string* release_resid();
  inline void set_allocated_resid(::std::string* resid);

  // optional int32 appID = 3;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 3;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // repeated float azimuth = 4;
  inline int azimuth_size() const;
  inline void clear_azimuth();
  static const int kAzimuthFieldNumber = 4;
  inline float azimuth(int index) const;
  inline void set_azimuth(int index, float value);
  inline void add_azimuth(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      azimuth() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_azimuth();

  // optional float elevation = 5;
  inline bool has_elevation() const;
  inline void clear_elevation();
  static const int kElevationFieldNumber = 5;
  inline float elevation() const;
  inline void set_elevation(float value);

  // optional float velocity = 6;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 6;
  inline float velocity() const;
  inline void set_velocity(float value);

  // optional bool retToStart = 7;
  inline bool has_rettostart() const;
  inline void clear_rettostart();
  static const int kRetToStartFieldNumber = 7;
  inline bool rettostart() const;
  inline void set_rettostart(bool value);

  // optional .falcon_antenna_msg.RotorSlew.Type slewType = 8 [default = CONTINUOUS];
  inline bool has_slewtype() const;
  inline void clear_slewtype();
  static const int kSlewTypeFieldNumber = 8;
  inline ::falcon_antenna_msg::RotorSlew_Type slewtype() const;
  inline void set_slewtype(::falcon_antenna_msg::RotorSlew_Type value);

  // @@protoc_insertion_point(class_scope:falcon_antenna_msg.RotorSlew)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_resid();
  inline void clear_has_resid();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_elevation();
  inline void clear_has_elevation();
  inline void set_has_velocity();
  inline void clear_has_velocity();
  inline void set_has_rettostart();
  inline void clear_has_rettostart();
  inline void set_has_slewtype();
  inline void clear_has_slewtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* resid_;
  ::google::protobuf::RepeatedField< float > azimuth_;
  ::google::protobuf::int32 appid_;
  float elevation_;
  float velocity_;
  bool rettostart_;
  int slewtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_AssignDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconAntennaMessages_2eproto();

  void InitAsDefaultInstance();
  static RotorSlew* default_instance_;
};
// -------------------------------------------------------------------

class RotorPoint : public ::google::protobuf::Message {
 public:
  RotorPoint();
  virtual ~RotorPoint();

  RotorPoint(const RotorPoint& from);

  inline RotorPoint& operator=(const RotorPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RotorPoint& default_instance();

  void Swap(RotorPoint* other);

  // implements Message ----------------------------------------------

  RotorPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RotorPoint& from);
  void MergeFrom(const RotorPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ROTOR_POINT"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string resID = 2;
  inline bool has_resid() const;
  inline void clear_resid();
  static const int kResIDFieldNumber = 2;
  inline const ::std::string& resid() const;
  inline void set_resid(const ::std::string& value);
  inline void set_resid(const char* value);
  inline void set_resid(const char* value, size_t size);
  inline ::std::string* mutable_resid();
  inline ::std::string* release_resid();
  inline void set_allocated_resid(::std::string* resid);

  // optional int32 appID = 3;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 3;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional float trackLat = 4;
  inline bool has_tracklat() const;
  inline void clear_tracklat();
  static const int kTrackLatFieldNumber = 4;
  inline float tracklat() const;
  inline void set_tracklat(float value);

  // optional float trackLon = 5;
  inline bool has_tracklon() const;
  inline void clear_tracklon();
  static const int kTrackLonFieldNumber = 5;
  inline float tracklon() const;
  inline void set_tracklon(float value);

  // optional float trackAlt = 6;
  inline bool has_trackalt() const;
  inline void clear_trackalt();
  static const int kTrackAltFieldNumber = 6;
  inline float trackalt() const;
  inline void set_trackalt(float value);

  // optional double msgID = 7 [default = 0];
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgIDFieldNumber = 7;
  inline double msgid() const;
  inline void set_msgid(double value);

  // @@protoc_insertion_point(class_scope:falcon_antenna_msg.RotorPoint)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_resid();
  inline void clear_has_resid();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_tracklat();
  inline void clear_has_tracklat();
  inline void set_has_tracklon();
  inline void clear_has_tracklon();
  inline void set_has_trackalt();
  inline void clear_has_trackalt();
  inline void set_has_msgid();
  inline void clear_has_msgid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* resid_;
  ::google::protobuf::int32 appid_;
  float tracklat_;
  float tracklon_;
  float trackalt_;
  double msgid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_AssignDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconAntennaMessages_2eproto();

  void InitAsDefaultInstance();
  static RotorPoint* default_instance_;
};
// -------------------------------------------------------------------

class RotorStop : public ::google::protobuf::Message {
 public:
  RotorStop();
  virtual ~RotorStop();

  RotorStop(const RotorStop& from);

  inline RotorStop& operator=(const RotorStop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RotorStop& default_instance();

  void Swap(RotorStop* other);

  // implements Message ----------------------------------------------

  RotorStop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RotorStop& from);
  void MergeFrom(const RotorStop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ROTOR_STOP"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string resID = 2;
  inline bool has_resid() const;
  inline void clear_resid();
  static const int kResIDFieldNumber = 2;
  inline const ::std::string& resid() const;
  inline void set_resid(const ::std::string& value);
  inline void set_resid(const char* value);
  inline void set_resid(const char* value, size_t size);
  inline ::std::string* mutable_resid();
  inline ::std::string* release_resid();
  inline void set_allocated_resid(::std::string* resid);

  // optional int32 appID = 3;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 3;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_antenna_msg.RotorStop)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_resid();
  inline void clear_has_resid();
  inline void set_has_appid();
  inline void clear_has_appid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* resid_;
  ::google::protobuf::int32 appid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_AssignDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconAntennaMessages_2eproto();

  void InitAsDefaultInstance();
  static RotorStop* default_instance_;
};
// -------------------------------------------------------------------

class QueryRotorPosition : public ::google::protobuf::Message {
 public:
  QueryRotorPosition();
  virtual ~QueryRotorPosition();

  QueryRotorPosition(const QueryRotorPosition& from);

  inline QueryRotorPosition& operator=(const QueryRotorPosition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryRotorPosition& default_instance();

  void Swap(QueryRotorPosition* other);

  // implements Message ----------------------------------------------

  QueryRotorPosition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryRotorPosition& from);
  void MergeFrom(const QueryRotorPosition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "QUERY_ROTOR_POSITION"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string resID = 2;
  inline bool has_resid() const;
  inline void clear_resid();
  static const int kResIDFieldNumber = 2;
  inline const ::std::string& resid() const;
  inline void set_resid(const ::std::string& value);
  inline void set_resid(const char* value);
  inline void set_resid(const char* value, size_t size);
  inline ::std::string* mutable_resid();
  inline ::std::string* release_resid();
  inline void set_allocated_resid(::std::string* resid);

  // optional int32 appID = 3;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 3;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_antenna_msg.QueryRotorPosition)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_resid();
  inline void clear_has_resid();
  inline void set_has_appid();
  inline void clear_has_appid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* resid_;
  ::google::protobuf::int32 appid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_AssignDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconAntennaMessages_2eproto();

  void InitAsDefaultInstance();
  static QueryRotorPosition* default_instance_;
};
// -------------------------------------------------------------------

class ModifyRotorScanRange : public ::google::protobuf::Message {
 public:
  ModifyRotorScanRange();
  virtual ~ModifyRotorScanRange();

  ModifyRotorScanRange(const ModifyRotorScanRange& from);

  inline ModifyRotorScanRange& operator=(const ModifyRotorScanRange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyRotorScanRange& default_instance();

  void Swap(ModifyRotorScanRange* other);

  // implements Message ----------------------------------------------

  ModifyRotorScanRange* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyRotorScanRange& from);
  void MergeFrom(const ModifyRotorScanRange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "MODIFY_ROTOR_SCAN_RANGE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string resID = 2;
  inline bool has_resid() const;
  inline void clear_resid();
  static const int kResIDFieldNumber = 2;
  inline const ::std::string& resid() const;
  inline void set_resid(const ::std::string& value);
  inline void set_resid(const char* value);
  inline void set_resid(const char* value, size_t size);
  inline ::std::string* mutable_resid();
  inline ::std::string* release_resid();
  inline void set_allocated_resid(::std::string* resid);

  // optional float minScanAngle = 3 [default = -1];
  inline bool has_minscanangle() const;
  inline void clear_minscanangle();
  static const int kMinScanAngleFieldNumber = 3;
  inline float minscanangle() const;
  inline void set_minscanangle(float value);

  // optional float maxScanAngle = 4 [default = -1];
  inline bool has_maxscanangle() const;
  inline void clear_maxscanangle();
  static const int kMaxScanAngleFieldNumber = 4;
  inline float maxscanangle() const;
  inline void set_maxscanangle(float value);

  // optional double msgID = 5 [default = 0];
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgIDFieldNumber = 5;
  inline double msgid() const;
  inline void set_msgid(double value);

  // @@protoc_insertion_point(class_scope:falcon_antenna_msg.ModifyRotorScanRange)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_resid();
  inline void clear_has_resid();
  inline void set_has_minscanangle();
  inline void clear_has_minscanangle();
  inline void set_has_maxscanangle();
  inline void clear_has_maxscanangle();
  inline void set_has_msgid();
  inline void clear_has_msgid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* resid_;
  float minscanangle_;
  float maxscanangle_;
  double msgid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_AssignDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconAntennaMessages_2eproto();

  void InitAsDefaultInstance();
  static ModifyRotorScanRange* default_instance_;
};
// -------------------------------------------------------------------

class AntennaTrack : public ::google::protobuf::Message {
 public:
  AntennaTrack();
  virtual ~AntennaTrack();

  AntennaTrack(const AntennaTrack& from);

  inline AntennaTrack& operator=(const AntennaTrack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AntennaTrack& default_instance();

  void Swap(AntennaTrack* other);

  // implements Message ----------------------------------------------

  AntennaTrack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AntennaTrack& from);
  void MergeFrom(const AntennaTrack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AntennaTrack_Status Status;
  static const Status OFF = AntennaTrack_Status_OFF;
  static const Status ON = AntennaTrack_Status_ON;
  static inline bool Status_IsValid(int value) {
    return AntennaTrack_Status_IsValid(value);
  }
  static const Status Status_MIN =
    AntennaTrack_Status_Status_MIN;
  static const Status Status_MAX =
    AntennaTrack_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    AntennaTrack_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return AntennaTrack_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return AntennaTrack_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return AntennaTrack_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ANTENNA_TRACK"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 appID = 2;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 2;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional .falcon_antenna_msg.AntennaTrack.Status trackStatus = 3 [default = OFF];
  inline bool has_trackstatus() const;
  inline void clear_trackstatus();
  static const int kTrackStatusFieldNumber = 3;
  inline ::falcon_antenna_msg::AntennaTrack_Status trackstatus() const;
  inline void set_trackstatus(::falcon_antenna_msg::AntennaTrack_Status value);

  // optional double msgID = 4 [default = 0];
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgIDFieldNumber = 4;
  inline double msgid() const;
  inline void set_msgid(double value);

  // @@protoc_insertion_point(class_scope:falcon_antenna_msg.AntennaTrack)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_trackstatus();
  inline void clear_has_trackstatus();
  inline void set_has_msgid();
  inline void clear_has_msgid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 appid_;
  int trackstatus_;
  double msgid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_AssignDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconAntennaMessages_2eproto();

  void InitAsDefaultInstance();
  static AntennaTrack* default_instance_;
};
// -------------------------------------------------------------------

class AntennaScan : public ::google::protobuf::Message {
 public:
  AntennaScan();
  virtual ~AntennaScan();

  AntennaScan(const AntennaScan& from);

  inline AntennaScan& operator=(const AntennaScan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AntennaScan& default_instance();

  void Swap(AntennaScan* other);

  // implements Message ----------------------------------------------

  AntennaScan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AntennaScan& from);
  void MergeFrom(const AntennaScan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AntennaScan_ScanType ScanType;
  static const ScanType OFF = AntennaScan_ScanType_OFF;
  static const ScanType CONTINUOUS = AntennaScan_ScanType_CONTINUOUS;
  static const ScanType ENERGY = AntennaScan_ScanType_ENERGY;
  static const ScanType CONTINUOUS_STEP = AntennaScan_ScanType_CONTINUOUS_STEP;
  static const ScanType ENERGY_STEP = AntennaScan_ScanType_ENERGY_STEP;
  static const ScanType DEFAULT = AntennaScan_ScanType_DEFAULT;
  static inline bool ScanType_IsValid(int value) {
    return AntennaScan_ScanType_IsValid(value);
  }
  static const ScanType ScanType_MIN =
    AntennaScan_ScanType_ScanType_MIN;
  static const ScanType ScanType_MAX =
    AntennaScan_ScanType_ScanType_MAX;
  static const int ScanType_ARRAYSIZE =
    AntennaScan_ScanType_ScanType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ScanType_descriptor() {
    return AntennaScan_ScanType_descriptor();
  }
  static inline const ::std::string& ScanType_Name(ScanType value) {
    return AntennaScan_ScanType_Name(value);
  }
  static inline bool ScanType_Parse(const ::std::string& name,
      ScanType* value) {
    return AntennaScan_ScanType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ANTENNA_SCAN"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string resID = 2;
  inline bool has_resid() const;
  inline void clear_resid();
  static const int kResIDFieldNumber = 2;
  inline const ::std::string& resid() const;
  inline void set_resid(const ::std::string& value);
  inline void set_resid(const char* value);
  inline void set_resid(const char* value, size_t size);
  inline ::std::string* mutable_resid();
  inline ::std::string* release_resid();
  inline void set_allocated_resid(::std::string* resid);

  // optional int32 appID = 3;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 3;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional .falcon_antenna_msg.AntennaScan.ScanType scanType = 4;
  inline bool has_scantype() const;
  inline void clear_scantype();
  static const int kScanTypeFieldNumber = 4;
  inline ::falcon_antenna_msg::AntennaScan_ScanType scantype() const;
  inline void set_scantype(::falcon_antenna_msg::AntennaScan_ScanType value);

  // optional float scanStart = 5;
  inline bool has_scanstart() const;
  inline void clear_scanstart();
  static const int kScanStartFieldNumber = 5;
  inline float scanstart() const;
  inline void set_scanstart(float value);

  // optional float scanEnd = 6;
  inline bool has_scanend() const;
  inline void clear_scanend();
  static const int kScanEndFieldNumber = 6;
  inline float scanend() const;
  inline void set_scanend(float value);

  // optional float scanVelocity = 7;
  inline bool has_scanvelocity() const;
  inline void clear_scanvelocity();
  static const int kScanVelocityFieldNumber = 7;
  inline float scanvelocity() const;
  inline void set_scanvelocity(float value);

  // optional double msgID = 8 [default = 0];
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgIDFieldNumber = 8;
  inline double msgid() const;
  inline void set_msgid(double value);

  // @@protoc_insertion_point(class_scope:falcon_antenna_msg.AntennaScan)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_resid();
  inline void clear_has_resid();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_scantype();
  inline void clear_has_scantype();
  inline void set_has_scanstart();
  inline void clear_has_scanstart();
  inline void set_has_scanend();
  inline void clear_has_scanend();
  inline void set_has_scanvelocity();
  inline void clear_has_scanvelocity();
  inline void set_has_msgid();
  inline void clear_has_msgid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* resid_;
  ::google::protobuf::int32 appid_;
  int scantype_;
  float scanstart_;
  float scanend_;
  double msgid_;
  float scanvelocity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_AssignDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconAntennaMessages_2eproto();

  void InitAsDefaultInstance();
  static AntennaScan* default_instance_;
};
// -------------------------------------------------------------------

class ModifyRotorOffset : public ::google::protobuf::Message {
 public:
  ModifyRotorOffset();
  virtual ~ModifyRotorOffset();

  ModifyRotorOffset(const ModifyRotorOffset& from);

  inline ModifyRotorOffset& operator=(const ModifyRotorOffset& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyRotorOffset& default_instance();

  void Swap(ModifyRotorOffset* other);

  // implements Message ----------------------------------------------

  ModifyRotorOffset* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyRotorOffset& from);
  void MergeFrom(const ModifyRotorOffset& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "MODIFY_ROTOR_OFFSET"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string resID = 2;
  inline bool has_resid() const;
  inline void clear_resid();
  static const int kResIDFieldNumber = 2;
  inline const ::std::string& resid() const;
  inline void set_resid(const ::std::string& value);
  inline void set_resid(const char* value);
  inline void set_resid(const char* value, size_t size);
  inline ::std::string* mutable_resid();
  inline ::std::string* release_resid();
  inline void set_allocated_resid(::std::string* resid);

  // optional float azimuthOffset = 3 [default = 0];
  inline bool has_azimuthoffset() const;
  inline void clear_azimuthoffset();
  static const int kAzimuthOffsetFieldNumber = 3;
  inline float azimuthoffset() const;
  inline void set_azimuthoffset(float value);

  // optional float elevationOffset = 4 [default = 0];
  inline bool has_elevationoffset() const;
  inline void clear_elevationoffset();
  static const int kElevationOffsetFieldNumber = 4;
  inline float elevationoffset() const;
  inline void set_elevationoffset(float value);

  // optional double msgID = 5 [default = 0];
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgIDFieldNumber = 5;
  inline double msgid() const;
  inline void set_msgid(double value);

  // @@protoc_insertion_point(class_scope:falcon_antenna_msg.ModifyRotorOffset)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_resid();
  inline void clear_has_resid();
  inline void set_has_azimuthoffset();
  inline void clear_has_azimuthoffset();
  inline void set_has_elevationoffset();
  inline void clear_has_elevationoffset();
  inline void set_has_msgid();
  inline void clear_has_msgid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* resid_;
  float azimuthoffset_;
  float elevationoffset_;
  double msgid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_AssignDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconAntennaMessages_2eproto();

  void InitAsDefaultInstance();
  static ModifyRotorOffset* default_instance_;
};
// -------------------------------------------------------------------

class RotorPosition : public ::google::protobuf::Message {
 public:
  RotorPosition();
  virtual ~RotorPosition();

  RotorPosition(const RotorPosition& from);

  inline RotorPosition& operator=(const RotorPosition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RotorPosition& default_instance();

  void Swap(RotorPosition* other);

  // implements Message ----------------------------------------------

  RotorPosition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RotorPosition& from);
  void MergeFrom(const RotorPosition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RotorPosition_Status Status;
  static const Status IDLE = RotorPosition_Status_IDLE;
  static const Status MOVING = RotorPosition_Status_MOVING;
  static const Status DONE = RotorPosition_Status_DONE;
  static const Status FAILED = RotorPosition_Status_FAILED;
  static const Status CANCELLED = RotorPosition_Status_CANCELLED;
  static const Status MOVING_SLEW = RotorPosition_Status_MOVING_SLEW;
  static inline bool Status_IsValid(int value) {
    return RotorPosition_Status_IsValid(value);
  }
  static const Status Status_MIN =
    RotorPosition_Status_Status_MIN;
  static const Status Status_MAX =
    RotorPosition_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    RotorPosition_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return RotorPosition_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return RotorPosition_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return RotorPosition_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ROTOR_POSITION"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string resID = 2;
  inline bool has_resid() const;
  inline void clear_resid();
  static const int kResIDFieldNumber = 2;
  inline const ::std::string& resid() const;
  inline void set_resid(const ::std::string& value);
  inline void set_resid(const char* value);
  inline void set_resid(const char* value, size_t size);
  inline ::std::string* mutable_resid();
  inline ::std::string* release_resid();
  inline void set_allocated_resid(::std::string* resid);

  // optional .falcon_antenna_msg.RotorPosition.Status status = 3 [default = IDLE];
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::falcon_antenna_msg::RotorPosition_Status status() const;
  inline void set_status(::falcon_antenna_msg::RotorPosition_Status value);

  // optional float time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline float time() const;
  inline void set_time(float value);

  // optional float azimuth = 5;
  inline bool has_azimuth() const;
  inline void clear_azimuth();
  static const int kAzimuthFieldNumber = 5;
  inline float azimuth() const;
  inline void set_azimuth(float value);

  // optional float elevation = 6;
  inline bool has_elevation() const;
  inline void clear_elevation();
  static const int kElevationFieldNumber = 6;
  inline float elevation() const;
  inline void set_elevation(float value);

  // optional float velocity = 7;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 7;
  inline float velocity() const;
  inline void set_velocity(float value);

  // @@protoc_insertion_point(class_scope:falcon_antenna_msg.RotorPosition)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_resid();
  inline void clear_has_resid();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_azimuth();
  inline void clear_has_azimuth();
  inline void set_has_elevation();
  inline void clear_has_elevation();
  inline void set_has_velocity();
  inline void clear_has_velocity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* resid_;
  int status_;
  float time_;
  float azimuth_;
  float elevation_;
  float velocity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_AssignDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconAntennaMessages_2eproto();

  void InitAsDefaultInstance();
  static RotorPosition* default_instance_;
};
// -------------------------------------------------------------------

class RotorStatus : public ::google::protobuf::Message {
 public:
  RotorStatus();
  virtual ~RotorStatus();

  RotorStatus(const RotorStatus& from);

  inline RotorStatus& operator=(const RotorStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RotorStatus& default_instance();

  void Swap(RotorStatus* other);

  // implements Message ----------------------------------------------

  RotorStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RotorStatus& from);
  void MergeFrom(const RotorStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RotorStatus_Status Status;
  static const Status NO_ROTOR = RotorStatus_Status_NO_ROTOR;
  static const Status NO_CONNECTION = RotorStatus_Status_NO_CONNECTION;
  static const Status CONNECTED = RotorStatus_Status_CONNECTED;
  static inline bool Status_IsValid(int value) {
    return RotorStatus_Status_IsValid(value);
  }
  static const Status Status_MIN =
    RotorStatus_Status_Status_MIN;
  static const Status Status_MAX =
    RotorStatus_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    RotorStatus_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return RotorStatus_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return RotorStatus_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return RotorStatus_Status_Parse(name, value);
  }

  typedef RotorStatus_CutoutStatus CutoutStatus;
  static const CutoutStatus CUTOUT = RotorStatus_CutoutStatus_CUTOUT;
  static const CutoutStatus NO_CUTOUT = RotorStatus_CutoutStatus_NO_CUTOUT;
  static inline bool CutoutStatus_IsValid(int value) {
    return RotorStatus_CutoutStatus_IsValid(value);
  }
  static const CutoutStatus CutoutStatus_MIN =
    RotorStatus_CutoutStatus_CutoutStatus_MIN;
  static const CutoutStatus CutoutStatus_MAX =
    RotorStatus_CutoutStatus_CutoutStatus_MAX;
  static const int CutoutStatus_ARRAYSIZE =
    RotorStatus_CutoutStatus_CutoutStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CutoutStatus_descriptor() {
    return RotorStatus_CutoutStatus_descriptor();
  }
  static inline const ::std::string& CutoutStatus_Name(CutoutStatus value) {
    return RotorStatus_CutoutStatus_Name(value);
  }
  static inline bool CutoutStatus_Parse(const ::std::string& name,
      CutoutStatus* value) {
    return RotorStatus_CutoutStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ROTOR_STATUS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string resID = 2;
  inline bool has_resid() const;
  inline void clear_resid();
  static const int kResIDFieldNumber = 2;
  inline const ::std::string& resid() const;
  inline void set_resid(const ::std::string& value);
  inline void set_resid(const char* value);
  inline void set_resid(const char* value, size_t size);
  inline ::std::string* mutable_resid();
  inline ::std::string* release_resid();
  inline void set_allocated_resid(::std::string* resid);

  // optional .falcon_antenna_msg.RotorStatus.Status status = 3 [default = CONNECTED];
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::falcon_antenna_msg::RotorStatus_Status status() const;
  inline void set_status(::falcon_antenna_msg::RotorStatus_Status value);

  // optional float minScanAngle = 4;
  inline bool has_minscanangle() const;
  inline void clear_minscanangle();
  static const int kMinScanAngleFieldNumber = 4;
  inline float minscanangle() const;
  inline void set_minscanangle(float value);

  // optional float maxScanAngle = 5;
  inline bool has_maxscanangle() const;
  inline void clear_maxscanangle();
  static const int kMaxScanAngleFieldNumber = 5;
  inline float maxscanangle() const;
  inline void set_maxscanangle(float value);

  // optional float azOffset = 6;
  inline bool has_azoffset() const;
  inline void clear_azoffset();
  static const int kAzOffsetFieldNumber = 6;
  inline float azoffset() const;
  inline void set_azoffset(float value);

  // optional float elOffset = 7;
  inline bool has_eloffset() const;
  inline void clear_eloffset();
  static const int kElOffsetFieldNumber = 7;
  inline float eloffset() const;
  inline void set_eloffset(float value);

  // optional bool elCtrl = 8 [default = false];
  inline bool has_elctrl() const;
  inline void clear_elctrl();
  static const int kElCtrlFieldNumber = 8;
  inline bool elctrl() const;
  inline void set_elctrl(bool value);

  // optional bool velCtrl = 9 [default = false];
  inline bool has_velctrl() const;
  inline void clear_velctrl();
  static const int kVelCtrlFieldNumber = 9;
  inline bool velctrl() const;
  inline void set_velctrl(bool value);

  // optional .falcon_antenna_msg.RotorStatus.CutoutStatus cutout = 10 [default = NO_CUTOUT];
  inline bool has_cutout() const;
  inline void clear_cutout();
  static const int kCutoutFieldNumber = 10;
  inline ::falcon_antenna_msg::RotorStatus_CutoutStatus cutout() const;
  inline void set_cutout(::falcon_antenna_msg::RotorStatus_CutoutStatus value);

  // @@protoc_insertion_point(class_scope:falcon_antenna_msg.RotorStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_resid();
  inline void clear_has_resid();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_minscanangle();
  inline void clear_has_minscanangle();
  inline void set_has_maxscanangle();
  inline void clear_has_maxscanangle();
  inline void set_has_azoffset();
  inline void clear_has_azoffset();
  inline void set_has_eloffset();
  inline void clear_has_eloffset();
  inline void set_has_elctrl();
  inline void clear_has_elctrl();
  inline void set_has_velctrl();
  inline void clear_has_velctrl();
  inline void set_has_cutout();
  inline void clear_has_cutout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* resid_;
  int status_;
  float minscanangle_;
  float maxscanangle_;
  float azoffset_;
  float eloffset_;
  bool elctrl_;
  bool velctrl_;
  int cutout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_AssignDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconAntennaMessages_2eproto();

  void InitAsDefaultInstance();
  static RotorStatus* default_instance_;
};
// -------------------------------------------------------------------

class SwitchMap : public ::google::protobuf::Message {
 public:
  SwitchMap();
  virtual ~SwitchMap();

  SwitchMap(const SwitchMap& from);

  inline SwitchMap& operator=(const SwitchMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SwitchMap& default_instance();

  void Swap(SwitchMap* other);

  // implements Message ----------------------------------------------

  SwitchMap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SwitchMap& from);
  void MergeFrom(const SwitchMap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SWITCH_MAP"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string resID = 2;
  inline bool has_resid() const;
  inline void clear_resid();
  static const int kResIDFieldNumber = 2;
  inline const ::std::string& resid() const;
  inline void set_resid(const ::std::string& value);
  inline void set_resid(const char* value);
  inline void set_resid(const char* value, size_t size);
  inline ::std::string* mutable_resid();
  inline ::std::string* release_resid();
  inline void set_allocated_resid(::std::string* resid);

  // optional int32 appID = 3;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 3;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional int32 inputPort = 4;
  inline bool has_inputport() const;
  inline void clear_inputport();
  static const int kInputPortFieldNumber = 4;
  inline ::google::protobuf::int32 inputport() const;
  inline void set_inputport(::google::protobuf::int32 value);

  // optional int32 outputPort = 5;
  inline bool has_outputport() const;
  inline void clear_outputport();
  static const int kOutputPortFieldNumber = 5;
  inline ::google::protobuf::int32 outputport() const;
  inline void set_outputport(::google::protobuf::int32 value);

  // optional double msgID = 6 [default = 0];
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgIDFieldNumber = 6;
  inline double msgid() const;
  inline void set_msgid(double value);

  // @@protoc_insertion_point(class_scope:falcon_antenna_msg.SwitchMap)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_resid();
  inline void clear_has_resid();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_inputport();
  inline void clear_has_inputport();
  inline void set_has_outputport();
  inline void clear_has_outputport();
  inline void set_has_msgid();
  inline void clear_has_msgid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* resid_;
  ::google::protobuf::int32 appid_;
  ::google::protobuf::int32 inputport_;
  double msgid_;
  ::google::protobuf::int32 outputport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_AssignDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconAntennaMessages_2eproto();

  void InitAsDefaultInstance();
  static SwitchMap* default_instance_;
};
// -------------------------------------------------------------------

class SwitchMapInputFail : public ::google::protobuf::Message {
 public:
  SwitchMapInputFail();
  virtual ~SwitchMapInputFail();

  SwitchMapInputFail(const SwitchMapInputFail& from);

  inline SwitchMapInputFail& operator=(const SwitchMapInputFail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SwitchMapInputFail& default_instance();

  void Swap(SwitchMapInputFail* other);

  // implements Message ----------------------------------------------

  SwitchMapInputFail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SwitchMapInputFail& from);
  void MergeFrom(const SwitchMapInputFail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SWITCH_MAP_INPUT_FAIL"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string inputPortID = 2;
  inline bool has_inputportid() const;
  inline void clear_inputportid();
  static const int kInputPortIDFieldNumber = 2;
  inline const ::std::string& inputportid() const;
  inline void set_inputportid(const ::std::string& value);
  inline void set_inputportid(const char* value);
  inline void set_inputportid(const char* value, size_t size);
  inline ::std::string* mutable_inputportid();
  inline ::std::string* release_inputportid();
  inline void set_allocated_inputportid(::std::string* inputportid);

  // optional .falcon_antenna_msg.SwitchMap map = 3;
  inline bool has_map() const;
  inline void clear_map();
  static const int kMapFieldNumber = 3;
  inline const ::falcon_antenna_msg::SwitchMap& map() const;
  inline ::falcon_antenna_msg::SwitchMap* mutable_map();
  inline ::falcon_antenna_msg::SwitchMap* release_map();
  inline void set_allocated_map(::falcon_antenna_msg::SwitchMap* map);

  // @@protoc_insertion_point(class_scope:falcon_antenna_msg.SwitchMapInputFail)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_inputportid();
  inline void clear_has_inputportid();
  inline void set_has_map();
  inline void clear_has_map();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* inputportid_;
  ::falcon_antenna_msg::SwitchMap* map_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_AssignDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconAntennaMessages_2eproto();

  void InitAsDefaultInstance();
  static SwitchMapInputFail* default_instance_;
};
// -------------------------------------------------------------------

class QuerySwitchStatus : public ::google::protobuf::Message {
 public:
  QuerySwitchStatus();
  virtual ~QuerySwitchStatus();

  QuerySwitchStatus(const QuerySwitchStatus& from);

  inline QuerySwitchStatus& operator=(const QuerySwitchStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QuerySwitchStatus& default_instance();

  void Swap(QuerySwitchStatus* other);

  // implements Message ----------------------------------------------

  QuerySwitchStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QuerySwitchStatus& from);
  void MergeFrom(const QuerySwitchStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "QUERY_SWITCH_STATUS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string resID = 2;
  inline bool has_resid() const;
  inline void clear_resid();
  static const int kResIDFieldNumber = 2;
  inline const ::std::string& resid() const;
  inline void set_resid(const ::std::string& value);
  inline void set_resid(const char* value);
  inline void set_resid(const char* value, size_t size);
  inline ::std::string* mutable_resid();
  inline ::std::string* release_resid();
  inline void set_allocated_resid(::std::string* resid);

  // optional int32 appID = 3;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 3;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_antenna_msg.QuerySwitchStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_resid();
  inline void clear_has_resid();
  inline void set_has_appid();
  inline void clear_has_appid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* resid_;
  ::google::protobuf::int32 appid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_AssignDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconAntennaMessages_2eproto();

  void InitAsDefaultInstance();
  static QuerySwitchStatus* default_instance_;
};
// -------------------------------------------------------------------

class SwitchStatus : public ::google::protobuf::Message {
 public:
  SwitchStatus();
  virtual ~SwitchStatus();

  SwitchStatus(const SwitchStatus& from);

  inline SwitchStatus& operator=(const SwitchStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SwitchStatus& default_instance();

  void Swap(SwitchStatus* other);

  // implements Message ----------------------------------------------

  SwitchStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SwitchStatus& from);
  void MergeFrom(const SwitchStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SwitchStatus_Status Status;
  static const Status NO_CONNECTION = SwitchStatus_Status_NO_CONNECTION;
  static const Status NO_RFSW = SwitchStatus_Status_NO_RFSW;
  static const Status CONNECTED = SwitchStatus_Status_CONNECTED;
  static inline bool Status_IsValid(int value) {
    return SwitchStatus_Status_IsValid(value);
  }
  static const Status Status_MIN =
    SwitchStatus_Status_Status_MIN;
  static const Status Status_MAX =
    SwitchStatus_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    SwitchStatus_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return SwitchStatus_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return SwitchStatus_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return SwitchStatus_Status_Parse(name, value);
  }

  typedef SwitchStatus_Response Response;
  static const Response FAILURE = SwitchStatus_Response_FAILURE;
  static const Response SUCCESS = SwitchStatus_Response_SUCCESS;
  static inline bool Response_IsValid(int value) {
    return SwitchStatus_Response_IsValid(value);
  }
  static const Response Response_MIN =
    SwitchStatus_Response_Response_MIN;
  static const Response Response_MAX =
    SwitchStatus_Response_Response_MAX;
  static const int Response_ARRAYSIZE =
    SwitchStatus_Response_Response_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Response_descriptor() {
    return SwitchStatus_Response_descriptor();
  }
  static inline const ::std::string& Response_Name(Response value) {
    return SwitchStatus_Response_Name(value);
  }
  static inline bool Response_Parse(const ::std::string& name,
      Response* value) {
    return SwitchStatus_Response_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SWITCH_STATUS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string resID = 2;
  inline bool has_resid() const;
  inline void clear_resid();
  static const int kResIDFieldNumber = 2;
  inline const ::std::string& resid() const;
  inline void set_resid(const ::std::string& value);
  inline void set_resid(const char* value);
  inline void set_resid(const char* value, size_t size);
  inline ::std::string* mutable_resid();
  inline ::std::string* release_resid();
  inline void set_allocated_resid(::std::string* resid);

  // repeated int32 outputPorts = 3;
  inline int outputports_size() const;
  inline void clear_outputports();
  static const int kOutputPortsFieldNumber = 3;
  inline ::google::protobuf::int32 outputports(int index) const;
  inline void set_outputports(int index, ::google::protobuf::int32 value);
  inline void add_outputports(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      outputports() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_outputports();

  // repeated int32 inputPorts = 4;
  inline int inputports_size() const;
  inline void clear_inputports();
  static const int kInputPortsFieldNumber = 4;
  inline ::google::protobuf::int32 inputports(int index) const;
  inline void set_inputports(int index, ::google::protobuf::int32 value);
  inline void add_inputports(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      inputports() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_inputports();

  // optional .falcon_antenna_msg.SwitchStatus.Status status = 5 [default = CONNECTED];
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 5;
  inline ::falcon_antenna_msg::SwitchStatus_Status status() const;
  inline void set_status(::falcon_antenna_msg::SwitchStatus_Status value);

  // optional .falcon_antenna_msg.SwitchStatus.Response cmdStatus = 6;
  inline bool has_cmdstatus() const;
  inline void clear_cmdstatus();
  static const int kCmdStatusFieldNumber = 6;
  inline ::falcon_antenna_msg::SwitchStatus_Response cmdstatus() const;
  inline void set_cmdstatus(::falcon_antenna_msg::SwitchStatus_Response value);

  // optional string serialPort = 7;
  inline bool has_serialport() const;
  inline void clear_serialport();
  static const int kSerialPortFieldNumber = 7;
  inline const ::std::string& serialport() const;
  inline void set_serialport(const ::std::string& value);
  inline void set_serialport(const char* value);
  inline void set_serialport(const char* value, size_t size);
  inline ::std::string* mutable_serialport();
  inline ::std::string* release_serialport();
  inline void set_allocated_serialport(::std::string* serialport);

  // repeated string state = 8;
  inline int state_size() const;
  inline void clear_state();
  static const int kStateFieldNumber = 8;
  inline const ::std::string& state(int index) const;
  inline ::std::string* mutable_state(int index);
  inline void set_state(int index, const ::std::string& value);
  inline void set_state(int index, const char* value);
  inline void set_state(int index, const char* value, size_t size);
  inline ::std::string* add_state();
  inline void add_state(const ::std::string& value);
  inline void add_state(const char* value);
  inline void add_state(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& state() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_state();

  // @@protoc_insertion_point(class_scope:falcon_antenna_msg.SwitchStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_resid();
  inline void clear_has_resid();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_cmdstatus();
  inline void clear_has_cmdstatus();
  inline void set_has_serialport();
  inline void clear_has_serialport();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* resid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > outputports_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > inputports_;
  int status_;
  int cmdstatus_;
  ::std::string* serialport_;
  ::google::protobuf::RepeatedPtrField< ::std::string> state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_AssignDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconAntennaMessages_2eproto();

  void InitAsDefaultInstance();
  static SwitchStatus* default_instance_;
};
// -------------------------------------------------------------------

class SlaveAntWaitScan : public ::google::protobuf::Message {
 public:
  SlaveAntWaitScan();
  virtual ~SlaveAntWaitScan();

  SlaveAntWaitScan(const SlaveAntWaitScan& from);

  inline SlaveAntWaitScan& operator=(const SlaveAntWaitScan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveAntWaitScan& default_instance();

  void Swap(SlaveAntWaitScan* other);

  // implements Message ----------------------------------------------

  SlaveAntWaitScan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveAntWaitScan& from);
  void MergeFrom(const SlaveAntWaitScan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SLAVE_ANT_WAIT_SCAN"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional bool ScanState = 2;
  inline bool has_scanstate() const;
  inline void clear_scanstate();
  static const int kScanStateFieldNumber = 2;
  inline bool scanstate() const;
  inline void set_scanstate(bool value);

  // @@protoc_insertion_point(class_scope:falcon_antenna_msg.SlaveAntWaitScan)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_scanstate();
  inline void clear_has_scanstate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  bool scanstate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_AssignDesc_FalconAntennaMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconAntennaMessages_2eproto();

  void InitAsDefaultInstance();
  static SlaveAntWaitScan* default_instance_;
};
// ===================================================================


// ===================================================================

// RotorStep

// optional string msgName = 1 [default = "ROTOR_STEP"];
inline bool RotorStep::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RotorStep::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RotorStep::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RotorStep::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& RotorStep::msgname() const {
  return *msgname_;
}
inline void RotorStep::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RotorStep::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RotorStep::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorStep::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* RotorStep::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void RotorStep::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string resID = 2;
inline bool RotorStep::has_resid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RotorStep::set_has_resid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RotorStep::clear_has_resid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RotorStep::clear_resid() {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    resid_->clear();
  }
  clear_has_resid();
}
inline const ::std::string& RotorStep::resid() const {
  return *resid_;
}
inline void RotorStep::set_resid(const ::std::string& value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void RotorStep::set_resid(const char* value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void RotorStep::set_resid(const char* value, size_t size) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorStep::mutable_resid() {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  return resid_;
}
inline ::std::string* RotorStep::release_resid() {
  clear_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resid_;
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RotorStep::set_allocated_resid(::std::string* resid) {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    delete resid_;
  }
  if (resid) {
    set_has_resid();
    resid_ = resid;
  } else {
    clear_has_resid();
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 appID = 3;
inline bool RotorStep::has_appid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RotorStep::set_has_appid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RotorStep::clear_has_appid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RotorStep::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 RotorStep::appid() const {
  return appid_;
}
inline void RotorStep::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional float azimuth = 4 [default = -1];
inline bool RotorStep::has_azimuth() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RotorStep::set_has_azimuth() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RotorStep::clear_has_azimuth() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RotorStep::clear_azimuth() {
  azimuth_ = -1;
  clear_has_azimuth();
}
inline float RotorStep::azimuth() const {
  return azimuth_;
}
inline void RotorStep::set_azimuth(float value) {
  set_has_azimuth();
  azimuth_ = value;
}

// optional float elevation = 5 [default = -1];
inline bool RotorStep::has_elevation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RotorStep::set_has_elevation() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RotorStep::clear_has_elevation() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RotorStep::clear_elevation() {
  elevation_ = -1;
  clear_has_elevation();
}
inline float RotorStep::elevation() const {
  return elevation_;
}
inline void RotorStep::set_elevation(float value) {
  set_has_elevation();
  elevation_ = value;
}

// optional float velocity = 6;
inline bool RotorStep::has_velocity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RotorStep::set_has_velocity() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RotorStep::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RotorStep::clear_velocity() {
  velocity_ = 0;
  clear_has_velocity();
}
inline float RotorStep::velocity() const {
  return velocity_;
}
inline void RotorStep::set_velocity(float value) {
  set_has_velocity();
  velocity_ = value;
}

// optional double msgID = 7 [default = 0];
inline bool RotorStep::has_msgid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RotorStep::set_has_msgid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RotorStep::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RotorStep::clear_msgid() {
  msgid_ = 0;
  clear_has_msgid();
}
inline double RotorStep::msgid() const {
  return msgid_;
}
inline void RotorStep::set_msgid(double value) {
  set_has_msgid();
  msgid_ = value;
}

// -------------------------------------------------------------------

// RotorSlew

// optional string msgName = 1 [default = "ROTOR_SLEW"];
inline bool RotorSlew::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RotorSlew::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RotorSlew::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RotorSlew::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& RotorSlew::msgname() const {
  return *msgname_;
}
inline void RotorSlew::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RotorSlew::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RotorSlew::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorSlew::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* RotorSlew::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void RotorSlew::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string resID = 2;
inline bool RotorSlew::has_resid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RotorSlew::set_has_resid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RotorSlew::clear_has_resid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RotorSlew::clear_resid() {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    resid_->clear();
  }
  clear_has_resid();
}
inline const ::std::string& RotorSlew::resid() const {
  return *resid_;
}
inline void RotorSlew::set_resid(const ::std::string& value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void RotorSlew::set_resid(const char* value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void RotorSlew::set_resid(const char* value, size_t size) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorSlew::mutable_resid() {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  return resid_;
}
inline ::std::string* RotorSlew::release_resid() {
  clear_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resid_;
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RotorSlew::set_allocated_resid(::std::string* resid) {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    delete resid_;
  }
  if (resid) {
    set_has_resid();
    resid_ = resid;
  } else {
    clear_has_resid();
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 appID = 3;
inline bool RotorSlew::has_appid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RotorSlew::set_has_appid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RotorSlew::clear_has_appid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RotorSlew::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 RotorSlew::appid() const {
  return appid_;
}
inline void RotorSlew::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// repeated float azimuth = 4;
inline int RotorSlew::azimuth_size() const {
  return azimuth_.size();
}
inline void RotorSlew::clear_azimuth() {
  azimuth_.Clear();
}
inline float RotorSlew::azimuth(int index) const {
  return azimuth_.Get(index);
}
inline void RotorSlew::set_azimuth(int index, float value) {
  azimuth_.Set(index, value);
}
inline void RotorSlew::add_azimuth(float value) {
  azimuth_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
RotorSlew::azimuth() const {
  return azimuth_;
}
inline ::google::protobuf::RepeatedField< float >*
RotorSlew::mutable_azimuth() {
  return &azimuth_;
}

// optional float elevation = 5;
inline bool RotorSlew::has_elevation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RotorSlew::set_has_elevation() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RotorSlew::clear_has_elevation() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RotorSlew::clear_elevation() {
  elevation_ = 0;
  clear_has_elevation();
}
inline float RotorSlew::elevation() const {
  return elevation_;
}
inline void RotorSlew::set_elevation(float value) {
  set_has_elevation();
  elevation_ = value;
}

// optional float velocity = 6;
inline bool RotorSlew::has_velocity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RotorSlew::set_has_velocity() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RotorSlew::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RotorSlew::clear_velocity() {
  velocity_ = 0;
  clear_has_velocity();
}
inline float RotorSlew::velocity() const {
  return velocity_;
}
inline void RotorSlew::set_velocity(float value) {
  set_has_velocity();
  velocity_ = value;
}

// optional bool retToStart = 7;
inline bool RotorSlew::has_rettostart() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RotorSlew::set_has_rettostart() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RotorSlew::clear_has_rettostart() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RotorSlew::clear_rettostart() {
  rettostart_ = false;
  clear_has_rettostart();
}
inline bool RotorSlew::rettostart() const {
  return rettostart_;
}
inline void RotorSlew::set_rettostart(bool value) {
  set_has_rettostart();
  rettostart_ = value;
}

// optional .falcon_antenna_msg.RotorSlew.Type slewType = 8 [default = CONTINUOUS];
inline bool RotorSlew::has_slewtype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RotorSlew::set_has_slewtype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RotorSlew::clear_has_slewtype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RotorSlew::clear_slewtype() {
  slewtype_ = 0;
  clear_has_slewtype();
}
inline ::falcon_antenna_msg::RotorSlew_Type RotorSlew::slewtype() const {
  return static_cast< ::falcon_antenna_msg::RotorSlew_Type >(slewtype_);
}
inline void RotorSlew::set_slewtype(::falcon_antenna_msg::RotorSlew_Type value) {
  assert(::falcon_antenna_msg::RotorSlew_Type_IsValid(value));
  set_has_slewtype();
  slewtype_ = value;
}

// -------------------------------------------------------------------

// RotorPoint

// optional string msgName = 1 [default = "ROTOR_POINT"];
inline bool RotorPoint::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RotorPoint::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RotorPoint::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RotorPoint::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& RotorPoint::msgname() const {
  return *msgname_;
}
inline void RotorPoint::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RotorPoint::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RotorPoint::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorPoint::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* RotorPoint::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void RotorPoint::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string resID = 2;
inline bool RotorPoint::has_resid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RotorPoint::set_has_resid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RotorPoint::clear_has_resid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RotorPoint::clear_resid() {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    resid_->clear();
  }
  clear_has_resid();
}
inline const ::std::string& RotorPoint::resid() const {
  return *resid_;
}
inline void RotorPoint::set_resid(const ::std::string& value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void RotorPoint::set_resid(const char* value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void RotorPoint::set_resid(const char* value, size_t size) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorPoint::mutable_resid() {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  return resid_;
}
inline ::std::string* RotorPoint::release_resid() {
  clear_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resid_;
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RotorPoint::set_allocated_resid(::std::string* resid) {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    delete resid_;
  }
  if (resid) {
    set_has_resid();
    resid_ = resid;
  } else {
    clear_has_resid();
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 appID = 3;
inline bool RotorPoint::has_appid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RotorPoint::set_has_appid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RotorPoint::clear_has_appid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RotorPoint::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 RotorPoint::appid() const {
  return appid_;
}
inline void RotorPoint::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional float trackLat = 4;
inline bool RotorPoint::has_tracklat() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RotorPoint::set_has_tracklat() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RotorPoint::clear_has_tracklat() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RotorPoint::clear_tracklat() {
  tracklat_ = 0;
  clear_has_tracklat();
}
inline float RotorPoint::tracklat() const {
  return tracklat_;
}
inline void RotorPoint::set_tracklat(float value) {
  set_has_tracklat();
  tracklat_ = value;
}

// optional float trackLon = 5;
inline bool RotorPoint::has_tracklon() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RotorPoint::set_has_tracklon() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RotorPoint::clear_has_tracklon() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RotorPoint::clear_tracklon() {
  tracklon_ = 0;
  clear_has_tracklon();
}
inline float RotorPoint::tracklon() const {
  return tracklon_;
}
inline void RotorPoint::set_tracklon(float value) {
  set_has_tracklon();
  tracklon_ = value;
}

// optional float trackAlt = 6;
inline bool RotorPoint::has_trackalt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RotorPoint::set_has_trackalt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RotorPoint::clear_has_trackalt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RotorPoint::clear_trackalt() {
  trackalt_ = 0;
  clear_has_trackalt();
}
inline float RotorPoint::trackalt() const {
  return trackalt_;
}
inline void RotorPoint::set_trackalt(float value) {
  set_has_trackalt();
  trackalt_ = value;
}

// optional double msgID = 7 [default = 0];
inline bool RotorPoint::has_msgid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RotorPoint::set_has_msgid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RotorPoint::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RotorPoint::clear_msgid() {
  msgid_ = 0;
  clear_has_msgid();
}
inline double RotorPoint::msgid() const {
  return msgid_;
}
inline void RotorPoint::set_msgid(double value) {
  set_has_msgid();
  msgid_ = value;
}

// -------------------------------------------------------------------

// RotorStop

// optional string msgName = 1 [default = "ROTOR_STOP"];
inline bool RotorStop::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RotorStop::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RotorStop::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RotorStop::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& RotorStop::msgname() const {
  return *msgname_;
}
inline void RotorStop::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RotorStop::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RotorStop::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorStop::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* RotorStop::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void RotorStop::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string resID = 2;
inline bool RotorStop::has_resid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RotorStop::set_has_resid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RotorStop::clear_has_resid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RotorStop::clear_resid() {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    resid_->clear();
  }
  clear_has_resid();
}
inline const ::std::string& RotorStop::resid() const {
  return *resid_;
}
inline void RotorStop::set_resid(const ::std::string& value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void RotorStop::set_resid(const char* value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void RotorStop::set_resid(const char* value, size_t size) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorStop::mutable_resid() {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  return resid_;
}
inline ::std::string* RotorStop::release_resid() {
  clear_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resid_;
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RotorStop::set_allocated_resid(::std::string* resid) {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    delete resid_;
  }
  if (resid) {
    set_has_resid();
    resid_ = resid;
  } else {
    clear_has_resid();
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 appID = 3;
inline bool RotorStop::has_appid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RotorStop::set_has_appid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RotorStop::clear_has_appid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RotorStop::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 RotorStop::appid() const {
  return appid_;
}
inline void RotorStop::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// -------------------------------------------------------------------

// QueryRotorPosition

// optional string msgName = 1 [default = "QUERY_ROTOR_POSITION"];
inline bool QueryRotorPosition::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryRotorPosition::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryRotorPosition::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryRotorPosition::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& QueryRotorPosition::msgname() const {
  return *msgname_;
}
inline void QueryRotorPosition::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void QueryRotorPosition::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void QueryRotorPosition::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryRotorPosition::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* QueryRotorPosition::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void QueryRotorPosition::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string resID = 2;
inline bool QueryRotorPosition::has_resid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryRotorPosition::set_has_resid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryRotorPosition::clear_has_resid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryRotorPosition::clear_resid() {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    resid_->clear();
  }
  clear_has_resid();
}
inline const ::std::string& QueryRotorPosition::resid() const {
  return *resid_;
}
inline void QueryRotorPosition::set_resid(const ::std::string& value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void QueryRotorPosition::set_resid(const char* value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void QueryRotorPosition::set_resid(const char* value, size_t size) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryRotorPosition::mutable_resid() {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  return resid_;
}
inline ::std::string* QueryRotorPosition::release_resid() {
  clear_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resid_;
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryRotorPosition::set_allocated_resid(::std::string* resid) {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    delete resid_;
  }
  if (resid) {
    set_has_resid();
    resid_ = resid;
  } else {
    clear_has_resid();
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 appID = 3;
inline bool QueryRotorPosition::has_appid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QueryRotorPosition::set_has_appid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QueryRotorPosition::clear_has_appid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QueryRotorPosition::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 QueryRotorPosition::appid() const {
  return appid_;
}
inline void QueryRotorPosition::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// -------------------------------------------------------------------

// ModifyRotorScanRange

// optional string msgName = 1 [default = "MODIFY_ROTOR_SCAN_RANGE"];
inline bool ModifyRotorScanRange::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyRotorScanRange::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyRotorScanRange::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyRotorScanRange::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ModifyRotorScanRange::msgname() const {
  return *msgname_;
}
inline void ModifyRotorScanRange::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ModifyRotorScanRange::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ModifyRotorScanRange::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyRotorScanRange::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ModifyRotorScanRange::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ModifyRotorScanRange::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string resID = 2;
inline bool ModifyRotorScanRange::has_resid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyRotorScanRange::set_has_resid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyRotorScanRange::clear_has_resid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyRotorScanRange::clear_resid() {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    resid_->clear();
  }
  clear_has_resid();
}
inline const ::std::string& ModifyRotorScanRange::resid() const {
  return *resid_;
}
inline void ModifyRotorScanRange::set_resid(const ::std::string& value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void ModifyRotorScanRange::set_resid(const char* value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void ModifyRotorScanRange::set_resid(const char* value, size_t size) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyRotorScanRange::mutable_resid() {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  return resid_;
}
inline ::std::string* ModifyRotorScanRange::release_resid() {
  clear_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resid_;
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModifyRotorScanRange::set_allocated_resid(::std::string* resid) {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    delete resid_;
  }
  if (resid) {
    set_has_resid();
    resid_ = resid;
  } else {
    clear_has_resid();
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float minScanAngle = 3 [default = -1];
inline bool ModifyRotorScanRange::has_minscanangle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModifyRotorScanRange::set_has_minscanangle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModifyRotorScanRange::clear_has_minscanangle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModifyRotorScanRange::clear_minscanangle() {
  minscanangle_ = -1;
  clear_has_minscanangle();
}
inline float ModifyRotorScanRange::minscanangle() const {
  return minscanangle_;
}
inline void ModifyRotorScanRange::set_minscanangle(float value) {
  set_has_minscanangle();
  minscanangle_ = value;
}

// optional float maxScanAngle = 4 [default = -1];
inline bool ModifyRotorScanRange::has_maxscanangle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModifyRotorScanRange::set_has_maxscanangle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModifyRotorScanRange::clear_has_maxscanangle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModifyRotorScanRange::clear_maxscanangle() {
  maxscanangle_ = -1;
  clear_has_maxscanangle();
}
inline float ModifyRotorScanRange::maxscanangle() const {
  return maxscanangle_;
}
inline void ModifyRotorScanRange::set_maxscanangle(float value) {
  set_has_maxscanangle();
  maxscanangle_ = value;
}

// optional double msgID = 5 [default = 0];
inline bool ModifyRotorScanRange::has_msgid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ModifyRotorScanRange::set_has_msgid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ModifyRotorScanRange::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ModifyRotorScanRange::clear_msgid() {
  msgid_ = 0;
  clear_has_msgid();
}
inline double ModifyRotorScanRange::msgid() const {
  return msgid_;
}
inline void ModifyRotorScanRange::set_msgid(double value) {
  set_has_msgid();
  msgid_ = value;
}

// -------------------------------------------------------------------

// AntennaTrack

// optional string msgName = 1 [default = "ANTENNA_TRACK"];
inline bool AntennaTrack::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AntennaTrack::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AntennaTrack::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AntennaTrack::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& AntennaTrack::msgname() const {
  return *msgname_;
}
inline void AntennaTrack::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AntennaTrack::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AntennaTrack::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AntennaTrack::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* AntennaTrack::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void AntennaTrack::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 appID = 2;
inline bool AntennaTrack::has_appid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AntennaTrack::set_has_appid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AntennaTrack::clear_has_appid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AntennaTrack::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 AntennaTrack::appid() const {
  return appid_;
}
inline void AntennaTrack::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional .falcon_antenna_msg.AntennaTrack.Status trackStatus = 3 [default = OFF];
inline bool AntennaTrack::has_trackstatus() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AntennaTrack::set_has_trackstatus() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AntennaTrack::clear_has_trackstatus() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AntennaTrack::clear_trackstatus() {
  trackstatus_ = 0;
  clear_has_trackstatus();
}
inline ::falcon_antenna_msg::AntennaTrack_Status AntennaTrack::trackstatus() const {
  return static_cast< ::falcon_antenna_msg::AntennaTrack_Status >(trackstatus_);
}
inline void AntennaTrack::set_trackstatus(::falcon_antenna_msg::AntennaTrack_Status value) {
  assert(::falcon_antenna_msg::AntennaTrack_Status_IsValid(value));
  set_has_trackstatus();
  trackstatus_ = value;
}

// optional double msgID = 4 [default = 0];
inline bool AntennaTrack::has_msgid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AntennaTrack::set_has_msgid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AntennaTrack::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AntennaTrack::clear_msgid() {
  msgid_ = 0;
  clear_has_msgid();
}
inline double AntennaTrack::msgid() const {
  return msgid_;
}
inline void AntennaTrack::set_msgid(double value) {
  set_has_msgid();
  msgid_ = value;
}

// -------------------------------------------------------------------

// AntennaScan

// optional string msgName = 1 [default = "ANTENNA_SCAN"];
inline bool AntennaScan::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AntennaScan::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AntennaScan::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AntennaScan::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& AntennaScan::msgname() const {
  return *msgname_;
}
inline void AntennaScan::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AntennaScan::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AntennaScan::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AntennaScan::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* AntennaScan::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void AntennaScan::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string resID = 2;
inline bool AntennaScan::has_resid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AntennaScan::set_has_resid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AntennaScan::clear_has_resid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AntennaScan::clear_resid() {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    resid_->clear();
  }
  clear_has_resid();
}
inline const ::std::string& AntennaScan::resid() const {
  return *resid_;
}
inline void AntennaScan::set_resid(const ::std::string& value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void AntennaScan::set_resid(const char* value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void AntennaScan::set_resid(const char* value, size_t size) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AntennaScan::mutable_resid() {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  return resid_;
}
inline ::std::string* AntennaScan::release_resid() {
  clear_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resid_;
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AntennaScan::set_allocated_resid(::std::string* resid) {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    delete resid_;
  }
  if (resid) {
    set_has_resid();
    resid_ = resid;
  } else {
    clear_has_resid();
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 appID = 3;
inline bool AntennaScan::has_appid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AntennaScan::set_has_appid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AntennaScan::clear_has_appid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AntennaScan::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 AntennaScan::appid() const {
  return appid_;
}
inline void AntennaScan::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional .falcon_antenna_msg.AntennaScan.ScanType scanType = 4;
inline bool AntennaScan::has_scantype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AntennaScan::set_has_scantype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AntennaScan::clear_has_scantype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AntennaScan::clear_scantype() {
  scantype_ = 0;
  clear_has_scantype();
}
inline ::falcon_antenna_msg::AntennaScan_ScanType AntennaScan::scantype() const {
  return static_cast< ::falcon_antenna_msg::AntennaScan_ScanType >(scantype_);
}
inline void AntennaScan::set_scantype(::falcon_antenna_msg::AntennaScan_ScanType value) {
  assert(::falcon_antenna_msg::AntennaScan_ScanType_IsValid(value));
  set_has_scantype();
  scantype_ = value;
}

// optional float scanStart = 5;
inline bool AntennaScan::has_scanstart() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AntennaScan::set_has_scanstart() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AntennaScan::clear_has_scanstart() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AntennaScan::clear_scanstart() {
  scanstart_ = 0;
  clear_has_scanstart();
}
inline float AntennaScan::scanstart() const {
  return scanstart_;
}
inline void AntennaScan::set_scanstart(float value) {
  set_has_scanstart();
  scanstart_ = value;
}

// optional float scanEnd = 6;
inline bool AntennaScan::has_scanend() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AntennaScan::set_has_scanend() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AntennaScan::clear_has_scanend() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AntennaScan::clear_scanend() {
  scanend_ = 0;
  clear_has_scanend();
}
inline float AntennaScan::scanend() const {
  return scanend_;
}
inline void AntennaScan::set_scanend(float value) {
  set_has_scanend();
  scanend_ = value;
}

// optional float scanVelocity = 7;
inline bool AntennaScan::has_scanvelocity() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AntennaScan::set_has_scanvelocity() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AntennaScan::clear_has_scanvelocity() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AntennaScan::clear_scanvelocity() {
  scanvelocity_ = 0;
  clear_has_scanvelocity();
}
inline float AntennaScan::scanvelocity() const {
  return scanvelocity_;
}
inline void AntennaScan::set_scanvelocity(float value) {
  set_has_scanvelocity();
  scanvelocity_ = value;
}

// optional double msgID = 8 [default = 0];
inline bool AntennaScan::has_msgid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AntennaScan::set_has_msgid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AntennaScan::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AntennaScan::clear_msgid() {
  msgid_ = 0;
  clear_has_msgid();
}
inline double AntennaScan::msgid() const {
  return msgid_;
}
inline void AntennaScan::set_msgid(double value) {
  set_has_msgid();
  msgid_ = value;
}

// -------------------------------------------------------------------

// ModifyRotorOffset

// optional string msgName = 1 [default = "MODIFY_ROTOR_OFFSET"];
inline bool ModifyRotorOffset::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyRotorOffset::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyRotorOffset::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyRotorOffset::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ModifyRotorOffset::msgname() const {
  return *msgname_;
}
inline void ModifyRotorOffset::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ModifyRotorOffset::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ModifyRotorOffset::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyRotorOffset::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ModifyRotorOffset::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ModifyRotorOffset::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string resID = 2;
inline bool ModifyRotorOffset::has_resid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyRotorOffset::set_has_resid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyRotorOffset::clear_has_resid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyRotorOffset::clear_resid() {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    resid_->clear();
  }
  clear_has_resid();
}
inline const ::std::string& ModifyRotorOffset::resid() const {
  return *resid_;
}
inline void ModifyRotorOffset::set_resid(const ::std::string& value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void ModifyRotorOffset::set_resid(const char* value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void ModifyRotorOffset::set_resid(const char* value, size_t size) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyRotorOffset::mutable_resid() {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  return resid_;
}
inline ::std::string* ModifyRotorOffset::release_resid() {
  clear_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resid_;
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModifyRotorOffset::set_allocated_resid(::std::string* resid) {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    delete resid_;
  }
  if (resid) {
    set_has_resid();
    resid_ = resid;
  } else {
    clear_has_resid();
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float azimuthOffset = 3 [default = 0];
inline bool ModifyRotorOffset::has_azimuthoffset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModifyRotorOffset::set_has_azimuthoffset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModifyRotorOffset::clear_has_azimuthoffset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModifyRotorOffset::clear_azimuthoffset() {
  azimuthoffset_ = 0;
  clear_has_azimuthoffset();
}
inline float ModifyRotorOffset::azimuthoffset() const {
  return azimuthoffset_;
}
inline void ModifyRotorOffset::set_azimuthoffset(float value) {
  set_has_azimuthoffset();
  azimuthoffset_ = value;
}

// optional float elevationOffset = 4 [default = 0];
inline bool ModifyRotorOffset::has_elevationoffset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModifyRotorOffset::set_has_elevationoffset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModifyRotorOffset::clear_has_elevationoffset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModifyRotorOffset::clear_elevationoffset() {
  elevationoffset_ = 0;
  clear_has_elevationoffset();
}
inline float ModifyRotorOffset::elevationoffset() const {
  return elevationoffset_;
}
inline void ModifyRotorOffset::set_elevationoffset(float value) {
  set_has_elevationoffset();
  elevationoffset_ = value;
}

// optional double msgID = 5 [default = 0];
inline bool ModifyRotorOffset::has_msgid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ModifyRotorOffset::set_has_msgid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ModifyRotorOffset::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ModifyRotorOffset::clear_msgid() {
  msgid_ = 0;
  clear_has_msgid();
}
inline double ModifyRotorOffset::msgid() const {
  return msgid_;
}
inline void ModifyRotorOffset::set_msgid(double value) {
  set_has_msgid();
  msgid_ = value;
}

// -------------------------------------------------------------------

// RotorPosition

// optional string msgName = 1 [default = "ROTOR_POSITION"];
inline bool RotorPosition::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RotorPosition::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RotorPosition::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RotorPosition::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& RotorPosition::msgname() const {
  return *msgname_;
}
inline void RotorPosition::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RotorPosition::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RotorPosition::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorPosition::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* RotorPosition::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void RotorPosition::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string resID = 2;
inline bool RotorPosition::has_resid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RotorPosition::set_has_resid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RotorPosition::clear_has_resid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RotorPosition::clear_resid() {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    resid_->clear();
  }
  clear_has_resid();
}
inline const ::std::string& RotorPosition::resid() const {
  return *resid_;
}
inline void RotorPosition::set_resid(const ::std::string& value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void RotorPosition::set_resid(const char* value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void RotorPosition::set_resid(const char* value, size_t size) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorPosition::mutable_resid() {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  return resid_;
}
inline ::std::string* RotorPosition::release_resid() {
  clear_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resid_;
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RotorPosition::set_allocated_resid(::std::string* resid) {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    delete resid_;
  }
  if (resid) {
    set_has_resid();
    resid_ = resid;
  } else {
    clear_has_resid();
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .falcon_antenna_msg.RotorPosition.Status status = 3 [default = IDLE];
inline bool RotorPosition::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RotorPosition::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RotorPosition::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RotorPosition::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::falcon_antenna_msg::RotorPosition_Status RotorPosition::status() const {
  return static_cast< ::falcon_antenna_msg::RotorPosition_Status >(status_);
}
inline void RotorPosition::set_status(::falcon_antenna_msg::RotorPosition_Status value) {
  assert(::falcon_antenna_msg::RotorPosition_Status_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional float time = 4;
inline bool RotorPosition::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RotorPosition::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RotorPosition::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RotorPosition::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline float RotorPosition::time() const {
  return time_;
}
inline void RotorPosition::set_time(float value) {
  set_has_time();
  time_ = value;
}

// optional float azimuth = 5;
inline bool RotorPosition::has_azimuth() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RotorPosition::set_has_azimuth() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RotorPosition::clear_has_azimuth() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RotorPosition::clear_azimuth() {
  azimuth_ = 0;
  clear_has_azimuth();
}
inline float RotorPosition::azimuth() const {
  return azimuth_;
}
inline void RotorPosition::set_azimuth(float value) {
  set_has_azimuth();
  azimuth_ = value;
}

// optional float elevation = 6;
inline bool RotorPosition::has_elevation() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RotorPosition::set_has_elevation() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RotorPosition::clear_has_elevation() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RotorPosition::clear_elevation() {
  elevation_ = 0;
  clear_has_elevation();
}
inline float RotorPosition::elevation() const {
  return elevation_;
}
inline void RotorPosition::set_elevation(float value) {
  set_has_elevation();
  elevation_ = value;
}

// optional float velocity = 7;
inline bool RotorPosition::has_velocity() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RotorPosition::set_has_velocity() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RotorPosition::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RotorPosition::clear_velocity() {
  velocity_ = 0;
  clear_has_velocity();
}
inline float RotorPosition::velocity() const {
  return velocity_;
}
inline void RotorPosition::set_velocity(float value) {
  set_has_velocity();
  velocity_ = value;
}

// -------------------------------------------------------------------

// RotorStatus

// optional string msgName = 1 [default = "ROTOR_STATUS"];
inline bool RotorStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RotorStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RotorStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RotorStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& RotorStatus::msgname() const {
  return *msgname_;
}
inline void RotorStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RotorStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RotorStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* RotorStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void RotorStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string resID = 2;
inline bool RotorStatus::has_resid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RotorStatus::set_has_resid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RotorStatus::clear_has_resid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RotorStatus::clear_resid() {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    resid_->clear();
  }
  clear_has_resid();
}
inline const ::std::string& RotorStatus::resid() const {
  return *resid_;
}
inline void RotorStatus::set_resid(const ::std::string& value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void RotorStatus::set_resid(const char* value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void RotorStatus::set_resid(const char* value, size_t size) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RotorStatus::mutable_resid() {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  return resid_;
}
inline ::std::string* RotorStatus::release_resid() {
  clear_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resid_;
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RotorStatus::set_allocated_resid(::std::string* resid) {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    delete resid_;
  }
  if (resid) {
    set_has_resid();
    resid_ = resid;
  } else {
    clear_has_resid();
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .falcon_antenna_msg.RotorStatus.Status status = 3 [default = CONNECTED];
inline bool RotorStatus::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RotorStatus::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RotorStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RotorStatus::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::falcon_antenna_msg::RotorStatus_Status RotorStatus::status() const {
  return static_cast< ::falcon_antenna_msg::RotorStatus_Status >(status_);
}
inline void RotorStatus::set_status(::falcon_antenna_msg::RotorStatus_Status value) {
  assert(::falcon_antenna_msg::RotorStatus_Status_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional float minScanAngle = 4;
inline bool RotorStatus::has_minscanangle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RotorStatus::set_has_minscanangle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RotorStatus::clear_has_minscanangle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RotorStatus::clear_minscanangle() {
  minscanangle_ = 0;
  clear_has_minscanangle();
}
inline float RotorStatus::minscanangle() const {
  return minscanangle_;
}
inline void RotorStatus::set_minscanangle(float value) {
  set_has_minscanangle();
  minscanangle_ = value;
}

// optional float maxScanAngle = 5;
inline bool RotorStatus::has_maxscanangle() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RotorStatus::set_has_maxscanangle() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RotorStatus::clear_has_maxscanangle() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RotorStatus::clear_maxscanangle() {
  maxscanangle_ = 0;
  clear_has_maxscanangle();
}
inline float RotorStatus::maxscanangle() const {
  return maxscanangle_;
}
inline void RotorStatus::set_maxscanangle(float value) {
  set_has_maxscanangle();
  maxscanangle_ = value;
}

// optional float azOffset = 6;
inline bool RotorStatus::has_azoffset() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RotorStatus::set_has_azoffset() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RotorStatus::clear_has_azoffset() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RotorStatus::clear_azoffset() {
  azoffset_ = 0;
  clear_has_azoffset();
}
inline float RotorStatus::azoffset() const {
  return azoffset_;
}
inline void RotorStatus::set_azoffset(float value) {
  set_has_azoffset();
  azoffset_ = value;
}

// optional float elOffset = 7;
inline bool RotorStatus::has_eloffset() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RotorStatus::set_has_eloffset() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RotorStatus::clear_has_eloffset() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RotorStatus::clear_eloffset() {
  eloffset_ = 0;
  clear_has_eloffset();
}
inline float RotorStatus::eloffset() const {
  return eloffset_;
}
inline void RotorStatus::set_eloffset(float value) {
  set_has_eloffset();
  eloffset_ = value;
}

// optional bool elCtrl = 8 [default = false];
inline bool RotorStatus::has_elctrl() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RotorStatus::set_has_elctrl() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RotorStatus::clear_has_elctrl() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RotorStatus::clear_elctrl() {
  elctrl_ = false;
  clear_has_elctrl();
}
inline bool RotorStatus::elctrl() const {
  return elctrl_;
}
inline void RotorStatus::set_elctrl(bool value) {
  set_has_elctrl();
  elctrl_ = value;
}

// optional bool velCtrl = 9 [default = false];
inline bool RotorStatus::has_velctrl() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RotorStatus::set_has_velctrl() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RotorStatus::clear_has_velctrl() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RotorStatus::clear_velctrl() {
  velctrl_ = false;
  clear_has_velctrl();
}
inline bool RotorStatus::velctrl() const {
  return velctrl_;
}
inline void RotorStatus::set_velctrl(bool value) {
  set_has_velctrl();
  velctrl_ = value;
}

// optional .falcon_antenna_msg.RotorStatus.CutoutStatus cutout = 10 [default = NO_CUTOUT];
inline bool RotorStatus::has_cutout() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RotorStatus::set_has_cutout() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RotorStatus::clear_has_cutout() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RotorStatus::clear_cutout() {
  cutout_ = 1;
  clear_has_cutout();
}
inline ::falcon_antenna_msg::RotorStatus_CutoutStatus RotorStatus::cutout() const {
  return static_cast< ::falcon_antenna_msg::RotorStatus_CutoutStatus >(cutout_);
}
inline void RotorStatus::set_cutout(::falcon_antenna_msg::RotorStatus_CutoutStatus value) {
  assert(::falcon_antenna_msg::RotorStatus_CutoutStatus_IsValid(value));
  set_has_cutout();
  cutout_ = value;
}

// -------------------------------------------------------------------

// SwitchMap

// optional string msgName = 1 [default = "SWITCH_MAP"];
inline bool SwitchMap::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SwitchMap::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SwitchMap::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SwitchMap::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SwitchMap::msgname() const {
  return *msgname_;
}
inline void SwitchMap::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SwitchMap::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SwitchMap::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwitchMap::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SwitchMap::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SwitchMap::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string resID = 2;
inline bool SwitchMap::has_resid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SwitchMap::set_has_resid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SwitchMap::clear_has_resid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SwitchMap::clear_resid() {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    resid_->clear();
  }
  clear_has_resid();
}
inline const ::std::string& SwitchMap::resid() const {
  return *resid_;
}
inline void SwitchMap::set_resid(const ::std::string& value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void SwitchMap::set_resid(const char* value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void SwitchMap::set_resid(const char* value, size_t size) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwitchMap::mutable_resid() {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  return resid_;
}
inline ::std::string* SwitchMap::release_resid() {
  clear_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resid_;
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SwitchMap::set_allocated_resid(::std::string* resid) {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    delete resid_;
  }
  if (resid) {
    set_has_resid();
    resid_ = resid;
  } else {
    clear_has_resid();
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 appID = 3;
inline bool SwitchMap::has_appid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SwitchMap::set_has_appid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SwitchMap::clear_has_appid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SwitchMap::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 SwitchMap::appid() const {
  return appid_;
}
inline void SwitchMap::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional int32 inputPort = 4;
inline bool SwitchMap::has_inputport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SwitchMap::set_has_inputport() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SwitchMap::clear_has_inputport() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SwitchMap::clear_inputport() {
  inputport_ = 0;
  clear_has_inputport();
}
inline ::google::protobuf::int32 SwitchMap::inputport() const {
  return inputport_;
}
inline void SwitchMap::set_inputport(::google::protobuf::int32 value) {
  set_has_inputport();
  inputport_ = value;
}

// optional int32 outputPort = 5;
inline bool SwitchMap::has_outputport() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SwitchMap::set_has_outputport() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SwitchMap::clear_has_outputport() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SwitchMap::clear_outputport() {
  outputport_ = 0;
  clear_has_outputport();
}
inline ::google::protobuf::int32 SwitchMap::outputport() const {
  return outputport_;
}
inline void SwitchMap::set_outputport(::google::protobuf::int32 value) {
  set_has_outputport();
  outputport_ = value;
}

// optional double msgID = 6 [default = 0];
inline bool SwitchMap::has_msgid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SwitchMap::set_has_msgid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SwitchMap::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SwitchMap::clear_msgid() {
  msgid_ = 0;
  clear_has_msgid();
}
inline double SwitchMap::msgid() const {
  return msgid_;
}
inline void SwitchMap::set_msgid(double value) {
  set_has_msgid();
  msgid_ = value;
}

// -------------------------------------------------------------------

// SwitchMapInputFail

// optional string msgName = 1 [default = "SWITCH_MAP_INPUT_FAIL"];
inline bool SwitchMapInputFail::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SwitchMapInputFail::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SwitchMapInputFail::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SwitchMapInputFail::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SwitchMapInputFail::msgname() const {
  return *msgname_;
}
inline void SwitchMapInputFail::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SwitchMapInputFail::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SwitchMapInputFail::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwitchMapInputFail::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SwitchMapInputFail::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SwitchMapInputFail::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string inputPortID = 2;
inline bool SwitchMapInputFail::has_inputportid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SwitchMapInputFail::set_has_inputportid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SwitchMapInputFail::clear_has_inputportid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SwitchMapInputFail::clear_inputportid() {
  if (inputportid_ != &::google::protobuf::internal::kEmptyString) {
    inputportid_->clear();
  }
  clear_has_inputportid();
}
inline const ::std::string& SwitchMapInputFail::inputportid() const {
  return *inputportid_;
}
inline void SwitchMapInputFail::set_inputportid(const ::std::string& value) {
  set_has_inputportid();
  if (inputportid_ == &::google::protobuf::internal::kEmptyString) {
    inputportid_ = new ::std::string;
  }
  inputportid_->assign(value);
}
inline void SwitchMapInputFail::set_inputportid(const char* value) {
  set_has_inputportid();
  if (inputportid_ == &::google::protobuf::internal::kEmptyString) {
    inputportid_ = new ::std::string;
  }
  inputportid_->assign(value);
}
inline void SwitchMapInputFail::set_inputportid(const char* value, size_t size) {
  set_has_inputportid();
  if (inputportid_ == &::google::protobuf::internal::kEmptyString) {
    inputportid_ = new ::std::string;
  }
  inputportid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwitchMapInputFail::mutable_inputportid() {
  set_has_inputportid();
  if (inputportid_ == &::google::protobuf::internal::kEmptyString) {
    inputportid_ = new ::std::string;
  }
  return inputportid_;
}
inline ::std::string* SwitchMapInputFail::release_inputportid() {
  clear_has_inputportid();
  if (inputportid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inputportid_;
    inputportid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SwitchMapInputFail::set_allocated_inputportid(::std::string* inputportid) {
  if (inputportid_ != &::google::protobuf::internal::kEmptyString) {
    delete inputportid_;
  }
  if (inputportid) {
    set_has_inputportid();
    inputportid_ = inputportid;
  } else {
    clear_has_inputportid();
    inputportid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .falcon_antenna_msg.SwitchMap map = 3;
inline bool SwitchMapInputFail::has_map() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SwitchMapInputFail::set_has_map() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SwitchMapInputFail::clear_has_map() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SwitchMapInputFail::clear_map() {
  if (map_ != NULL) map_->::falcon_antenna_msg::SwitchMap::Clear();
  clear_has_map();
}
inline const ::falcon_antenna_msg::SwitchMap& SwitchMapInputFail::map() const {
  return map_ != NULL ? *map_ : *default_instance_->map_;
}
inline ::falcon_antenna_msg::SwitchMap* SwitchMapInputFail::mutable_map() {
  set_has_map();
  if (map_ == NULL) map_ = new ::falcon_antenna_msg::SwitchMap;
  return map_;
}
inline ::falcon_antenna_msg::SwitchMap* SwitchMapInputFail::release_map() {
  clear_has_map();
  ::falcon_antenna_msg::SwitchMap* temp = map_;
  map_ = NULL;
  return temp;
}
inline void SwitchMapInputFail::set_allocated_map(::falcon_antenna_msg::SwitchMap* map) {
  delete map_;
  map_ = map;
  if (map) {
    set_has_map();
  } else {
    clear_has_map();
  }
}

// -------------------------------------------------------------------

// QuerySwitchStatus

// optional string msgName = 1 [default = "QUERY_SWITCH_STATUS"];
inline bool QuerySwitchStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QuerySwitchStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QuerySwitchStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QuerySwitchStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& QuerySwitchStatus::msgname() const {
  return *msgname_;
}
inline void QuerySwitchStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void QuerySwitchStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void QuerySwitchStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QuerySwitchStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* QuerySwitchStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void QuerySwitchStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string resID = 2;
inline bool QuerySwitchStatus::has_resid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QuerySwitchStatus::set_has_resid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QuerySwitchStatus::clear_has_resid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QuerySwitchStatus::clear_resid() {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    resid_->clear();
  }
  clear_has_resid();
}
inline const ::std::string& QuerySwitchStatus::resid() const {
  return *resid_;
}
inline void QuerySwitchStatus::set_resid(const ::std::string& value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void QuerySwitchStatus::set_resid(const char* value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void QuerySwitchStatus::set_resid(const char* value, size_t size) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QuerySwitchStatus::mutable_resid() {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  return resid_;
}
inline ::std::string* QuerySwitchStatus::release_resid() {
  clear_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resid_;
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QuerySwitchStatus::set_allocated_resid(::std::string* resid) {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    delete resid_;
  }
  if (resid) {
    set_has_resid();
    resid_ = resid;
  } else {
    clear_has_resid();
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 appID = 3;
inline bool QuerySwitchStatus::has_appid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QuerySwitchStatus::set_has_appid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QuerySwitchStatus::clear_has_appid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QuerySwitchStatus::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 QuerySwitchStatus::appid() const {
  return appid_;
}
inline void QuerySwitchStatus::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// -------------------------------------------------------------------

// SwitchStatus

// optional string msgName = 1 [default = "SWITCH_STATUS"];
inline bool SwitchStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SwitchStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SwitchStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SwitchStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SwitchStatus::msgname() const {
  return *msgname_;
}
inline void SwitchStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SwitchStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SwitchStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwitchStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SwitchStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SwitchStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string resID = 2;
inline bool SwitchStatus::has_resid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SwitchStatus::set_has_resid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SwitchStatus::clear_has_resid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SwitchStatus::clear_resid() {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    resid_->clear();
  }
  clear_has_resid();
}
inline const ::std::string& SwitchStatus::resid() const {
  return *resid_;
}
inline void SwitchStatus::set_resid(const ::std::string& value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void SwitchStatus::set_resid(const char* value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void SwitchStatus::set_resid(const char* value, size_t size) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwitchStatus::mutable_resid() {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  return resid_;
}
inline ::std::string* SwitchStatus::release_resid() {
  clear_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resid_;
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SwitchStatus::set_allocated_resid(::std::string* resid) {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    delete resid_;
  }
  if (resid) {
    set_has_resid();
    resid_ = resid;
  } else {
    clear_has_resid();
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated int32 outputPorts = 3;
inline int SwitchStatus::outputports_size() const {
  return outputports_.size();
}
inline void SwitchStatus::clear_outputports() {
  outputports_.Clear();
}
inline ::google::protobuf::int32 SwitchStatus::outputports(int index) const {
  return outputports_.Get(index);
}
inline void SwitchStatus::set_outputports(int index, ::google::protobuf::int32 value) {
  outputports_.Set(index, value);
}
inline void SwitchStatus::add_outputports(::google::protobuf::int32 value) {
  outputports_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SwitchStatus::outputports() const {
  return outputports_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SwitchStatus::mutable_outputports() {
  return &outputports_;
}

// repeated int32 inputPorts = 4;
inline int SwitchStatus::inputports_size() const {
  return inputports_.size();
}
inline void SwitchStatus::clear_inputports() {
  inputports_.Clear();
}
inline ::google::protobuf::int32 SwitchStatus::inputports(int index) const {
  return inputports_.Get(index);
}
inline void SwitchStatus::set_inputports(int index, ::google::protobuf::int32 value) {
  inputports_.Set(index, value);
}
inline void SwitchStatus::add_inputports(::google::protobuf::int32 value) {
  inputports_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SwitchStatus::inputports() const {
  return inputports_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SwitchStatus::mutable_inputports() {
  return &inputports_;
}

// optional .falcon_antenna_msg.SwitchStatus.Status status = 5 [default = CONNECTED];
inline bool SwitchStatus::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SwitchStatus::set_has_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SwitchStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SwitchStatus::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::falcon_antenna_msg::SwitchStatus_Status SwitchStatus::status() const {
  return static_cast< ::falcon_antenna_msg::SwitchStatus_Status >(status_);
}
inline void SwitchStatus::set_status(::falcon_antenna_msg::SwitchStatus_Status value) {
  assert(::falcon_antenna_msg::SwitchStatus_Status_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional .falcon_antenna_msg.SwitchStatus.Response cmdStatus = 6;
inline bool SwitchStatus::has_cmdstatus() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SwitchStatus::set_has_cmdstatus() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SwitchStatus::clear_has_cmdstatus() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SwitchStatus::clear_cmdstatus() {
  cmdstatus_ = -1;
  clear_has_cmdstatus();
}
inline ::falcon_antenna_msg::SwitchStatus_Response SwitchStatus::cmdstatus() const {
  return static_cast< ::falcon_antenna_msg::SwitchStatus_Response >(cmdstatus_);
}
inline void SwitchStatus::set_cmdstatus(::falcon_antenna_msg::SwitchStatus_Response value) {
  assert(::falcon_antenna_msg::SwitchStatus_Response_IsValid(value));
  set_has_cmdstatus();
  cmdstatus_ = value;
}

// optional string serialPort = 7;
inline bool SwitchStatus::has_serialport() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SwitchStatus::set_has_serialport() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SwitchStatus::clear_has_serialport() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SwitchStatus::clear_serialport() {
  if (serialport_ != &::google::protobuf::internal::kEmptyString) {
    serialport_->clear();
  }
  clear_has_serialport();
}
inline const ::std::string& SwitchStatus::serialport() const {
  return *serialport_;
}
inline void SwitchStatus::set_serialport(const ::std::string& value) {
  set_has_serialport();
  if (serialport_ == &::google::protobuf::internal::kEmptyString) {
    serialport_ = new ::std::string;
  }
  serialport_->assign(value);
}
inline void SwitchStatus::set_serialport(const char* value) {
  set_has_serialport();
  if (serialport_ == &::google::protobuf::internal::kEmptyString) {
    serialport_ = new ::std::string;
  }
  serialport_->assign(value);
}
inline void SwitchStatus::set_serialport(const char* value, size_t size) {
  set_has_serialport();
  if (serialport_ == &::google::protobuf::internal::kEmptyString) {
    serialport_ = new ::std::string;
  }
  serialport_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwitchStatus::mutable_serialport() {
  set_has_serialport();
  if (serialport_ == &::google::protobuf::internal::kEmptyString) {
    serialport_ = new ::std::string;
  }
  return serialport_;
}
inline ::std::string* SwitchStatus::release_serialport() {
  clear_has_serialport();
  if (serialport_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serialport_;
    serialport_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SwitchStatus::set_allocated_serialport(::std::string* serialport) {
  if (serialport_ != &::google::protobuf::internal::kEmptyString) {
    delete serialport_;
  }
  if (serialport) {
    set_has_serialport();
    serialport_ = serialport;
  } else {
    clear_has_serialport();
    serialport_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string state = 8;
inline int SwitchStatus::state_size() const {
  return state_.size();
}
inline void SwitchStatus::clear_state() {
  state_.Clear();
}
inline const ::std::string& SwitchStatus::state(int index) const {
  return state_.Get(index);
}
inline ::std::string* SwitchStatus::mutable_state(int index) {
  return state_.Mutable(index);
}
inline void SwitchStatus::set_state(int index, const ::std::string& value) {
  state_.Mutable(index)->assign(value);
}
inline void SwitchStatus::set_state(int index, const char* value) {
  state_.Mutable(index)->assign(value);
}
inline void SwitchStatus::set_state(int index, const char* value, size_t size) {
  state_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwitchStatus::add_state() {
  return state_.Add();
}
inline void SwitchStatus::add_state(const ::std::string& value) {
  state_.Add()->assign(value);
}
inline void SwitchStatus::add_state(const char* value) {
  state_.Add()->assign(value);
}
inline void SwitchStatus::add_state(const char* value, size_t size) {
  state_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SwitchStatus::state() const {
  return state_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SwitchStatus::mutable_state() {
  return &state_;
}

// -------------------------------------------------------------------

// SlaveAntWaitScan

// optional string msgName = 1 [default = "SLAVE_ANT_WAIT_SCAN"];
inline bool SlaveAntWaitScan::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveAntWaitScan::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveAntWaitScan::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveAntWaitScan::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SlaveAntWaitScan::msgname() const {
  return *msgname_;
}
inline void SlaveAntWaitScan::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SlaveAntWaitScan::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SlaveAntWaitScan::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveAntWaitScan::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SlaveAntWaitScan::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SlaveAntWaitScan::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional bool ScanState = 2;
inline bool SlaveAntWaitScan::has_scanstate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveAntWaitScan::set_has_scanstate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveAntWaitScan::clear_has_scanstate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveAntWaitScan::clear_scanstate() {
  scanstate_ = false;
  clear_has_scanstate();
}
inline bool SlaveAntWaitScan::scanstate() const {
  return scanstate_;
}
inline void SlaveAntWaitScan::set_scanstate(bool value) {
  set_has_scanstate();
  scanstate_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace falcon_antenna_msg

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_antenna_msg::RotorSlew_Type>() {
  return ::falcon_antenna_msg::RotorSlew_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_antenna_msg::AntennaTrack_Status>() {
  return ::falcon_antenna_msg::AntennaTrack_Status_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_antenna_msg::AntennaScan_ScanType>() {
  return ::falcon_antenna_msg::AntennaScan_ScanType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_antenna_msg::RotorPosition_Status>() {
  return ::falcon_antenna_msg::RotorPosition_Status_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_antenna_msg::RotorStatus_Status>() {
  return ::falcon_antenna_msg::RotorStatus_Status_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_antenna_msg::RotorStatus_CutoutStatus>() {
  return ::falcon_antenna_msg::RotorStatus_CutoutStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_antenna_msg::SwitchStatus_Status>() {
  return ::falcon_antenna_msg::SwitchStatus_Status_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_antenna_msg::SwitchStatus_Response>() {
  return ::falcon_antenna_msg::SwitchStatus_Response_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_FalconAntennaMessages_2eproto__INCLUDED
