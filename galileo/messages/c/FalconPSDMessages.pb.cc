// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FalconPSDMessages.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "FalconPSDMessages.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace falcon_psd {

namespace {

const ::google::protobuf::Descriptor* ClassificationHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClassificationHeader_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ClassificationHeader_ClassLevel_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ClassificationHeader_Compartment_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ClassificationHeader_Releasability_descriptor_ = NULL;
const ::google::protobuf::Descriptor* PSDHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PSDHeader_reflection_ = NULL;
const ::google::protobuf::Descriptor* PSD_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PSD_reflection_ = NULL;
const ::google::protobuf::Descriptor* DensePSD_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DensePSD_reflection_ = NULL;
const ::google::protobuf::Descriptor* BitFrameHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BitFrameHeader_reflection_ = NULL;
const ::google::protobuf::Descriptor* BitFrame_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BitFrame_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_FalconPSDMessages_2eproto() {
  protobuf_AddDesc_FalconPSDMessages_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "FalconPSDMessages.proto");
  GOOGLE_CHECK(file != NULL);
  ClassificationHeader_descriptor_ = file->message_type(0);
  static const int ClassificationHeader_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClassificationHeader, classification_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClassificationHeader, compartment_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClassificationHeader, rel_to_),
  };
  ClassificationHeader_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClassificationHeader_descriptor_,
      ClassificationHeader::default_instance_,
      ClassificationHeader_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClassificationHeader, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClassificationHeader, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClassificationHeader));
  ClassificationHeader_ClassLevel_descriptor_ = ClassificationHeader_descriptor_->enum_type(0);
  ClassificationHeader_Compartment_descriptor_ = ClassificationHeader_descriptor_->enum_type(1);
  ClassificationHeader_Releasability_descriptor_ = ClassificationHeader_descriptor_->enum_type(2);
  PSDHeader_descriptor_ = file->message_type(1);
  static const int PSDHeader_offsets_[12] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PSDHeader, uuid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PSDHeader, start_frequency_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PSDHeader, end_frequency_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PSDHeader, resolution_bandwidth_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PSDHeader, num_points_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PSDHeader, duration_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PSDHeader, channel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PSDHeader, highlight_start_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PSDHeader, highlight_end_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PSDHeader, saturation_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PSDHeader, psd_max_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PSDHeader, psd_min_),
  };
  PSDHeader_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PSDHeader_descriptor_,
      PSDHeader::default_instance_,
      PSDHeader_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PSDHeader, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PSDHeader, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PSDHeader));
  PSD_descriptor_ = file->message_type(2);
  static const int PSD_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PSD, msgname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PSD, classification_header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PSD, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PSD, uuid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PSD, psd_header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PSD, fft_data_),
  };
  PSD_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PSD_descriptor_,
      PSD::default_instance_,
      PSD_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PSD, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PSD, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PSD));
  DensePSD_descriptor_ = file->message_type(3);
  static const int DensePSD_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DensePSD, msgname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DensePSD, classification_header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DensePSD, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DensePSD, uuid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DensePSD, psd_header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DensePSD, min_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DensePSD, step_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DensePSD, fft_data_),
  };
  DensePSD_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DensePSD_descriptor_,
      DensePSD::default_instance_,
      DensePSD_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DensePSD, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DensePSD, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DensePSD));
  BitFrameHeader_descriptor_ = file->message_type(4);
  static const int BitFrameHeader_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BitFrameHeader, uuid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BitFrameHeader, num_points_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BitFrameHeader, duration_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BitFrameHeader, channel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BitFrameHeader, bit_max_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BitFrameHeader, bit_min_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BitFrameHeader, appname_),
  };
  BitFrameHeader_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BitFrameHeader_descriptor_,
      BitFrameHeader::default_instance_,
      BitFrameHeader_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BitFrameHeader, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BitFrameHeader, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BitFrameHeader));
  BitFrame_descriptor_ = file->message_type(5);
  static const int BitFrame_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BitFrame, msgname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BitFrame, classification_header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BitFrame, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BitFrame, uuid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BitFrame, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BitFrame, bit_data_),
  };
  BitFrame_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BitFrame_descriptor_,
      BitFrame::default_instance_,
      BitFrame_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BitFrame, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BitFrame, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BitFrame));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_FalconPSDMessages_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClassificationHeader_descriptor_, &ClassificationHeader::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PSDHeader_descriptor_, &PSDHeader::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PSD_descriptor_, &PSD::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DensePSD_descriptor_, &DensePSD::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BitFrameHeader_descriptor_, &BitFrameHeader::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BitFrame_descriptor_, &BitFrame::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_FalconPSDMessages_2eproto() {
  delete ClassificationHeader::default_instance_;
  delete ClassificationHeader_reflection_;
  delete PSDHeader::default_instance_;
  delete PSDHeader_reflection_;
  delete PSD::default_instance_;
  delete PSD_reflection_;
  delete PSD::_default_msgname_;
  delete DensePSD::default_instance_;
  delete DensePSD_reflection_;
  delete DensePSD::_default_msgname_;
  delete BitFrameHeader::default_instance_;
  delete BitFrameHeader_reflection_;
  delete BitFrame::default_instance_;
  delete BitFrame_reflection_;
  delete BitFrame::_default_msgname_;
}

void protobuf_AddDesc_FalconPSDMessages_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\027FalconPSDMessages.proto\022\nfalcon_psd\"\235\003"
    "\n\024ClassificationHeader\022C\n\016classification"
    "\030\001 \002(\0162+.falcon_psd.ClassificationHeader"
    ".ClassLevel\022A\n\013compartment\030\002 \001(\0162,.falco"
    "n_psd.ClassificationHeader.Compartment\022>"
    "\n\006rel_to\030\003 \001(\0162..falcon_psd.Classificati"
    "onHeader.Releasability\"K\n\nClassLevel\022\020\n\014"
    "UNCLASSIFIED\020\001\022\020\n\014CONFIDENTIAL\020\002\022\n\n\006SECR"
    "ET\020\003\022\r\n\tTOPSECRET\020\004\"\035\n\013Compartment\022\006\n\002SI"
    "\020\001\022\006\n\002TK\020\002\"Q\n\rReleasability\022\010\n\004FOUO\020\001\022\007\n"
    "\003ROK\020\002\022\007\n\003EY3\020\003\022\007\n\003EY4\020\004\022\007\n\003EY5\020\005\022\007\n\003EY9"
    "\020\006\022\t\n\005NOFOR\020\007\"\204\002\n\tPSDHeader\022\014\n\004uuid\030\001 \002("
    "\t\022\027\n\017start_frequency\030\002 \002(\001\022\025\n\rend_freque"
    "ncy\030\003 \002(\001\022\034\n\024resolution_bandwidth\030\004 \002(\001\022"
    "\022\n\nnum_points\030\005 \002(\005\022\020\n\010duration\030\006 \002(\001\022\017\n"
    "\007channel\030\007 \002(\005\022\027\n\017highlight_start\030\010 \001(\005\022"
    "\025\n\rhighlight_end\030\t \001(\005\022\022\n\nsaturation\030\n \001"
    "(\005\022\017\n\007psd_max\030\013 \001(\001\022\017\n\007psd_min\030\014 \001(\001\"\276\001\n"
    "\003PSD\022\024\n\007msgName\030\001 \001(\t:\003PSD\022\?\n\025classifica"
    "tion_header\030\002 \002(\0132 .falcon_psd.Classific"
    "ationHeader\022\021\n\ttimestamp\030\003 \002(\001\022\014\n\004uuid\030\004"
    " \002(\t\022)\n\npsd_header\030\005 \001(\0132\025.falcon_psd.PS"
    "DHeader\022\024\n\010fft_data\030\006 \003(\002B\002\020\001\"\340\001\n\010DenseP"
    "SD\022\032\n\007msgName\030\001 \001(\t:\tDENSE_PSD\022\?\n\025classi"
    "fication_header\030\002 \002(\0132 .falcon_psd.Class"
    "ificationHeader\022\021\n\ttimestamp\030\003 \002(\001\022\014\n\004uu"
    "id\030\004 \002(\t\022)\n\npsd_header\030\005 \001(\0132\025.falcon_ps"
    "d.PSDHeader\022\013\n\003min\030\006 \002(\002\022\014\n\004step\030\007 \002(\002\022\020"
    "\n\010fft_data\030\010 \003(\002\"\210\001\n\016BitFrameHeader\022\014\n\004u"
    "uid\030\001 \002(\t\022\022\n\nnum_points\030\002 \002(\005\022\020\n\010duratio"
    "n\030\003 \002(\001\022\017\n\007channel\030\004 \002(\005\022\017\n\007bit_max\030\005 \001("
    "\001\022\017\n\007bit_min\030\006 \001(\001\022\017\n\007appName\030\007 \001(\t\"\306\001\n\010"
    "BitFrame\022\032\n\007msgName\030\001 \001(\t:\tBIT_FRAME\022\?\n\025"
    "classification_header\030\002 \002(\0132 .falcon_psd"
    ".ClassificationHeader\022\021\n\ttimestamp\030\003 \002(\001"
    "\022\014\n\004uuid\030\004 \002(\t\022*\n\006header\030\005 \001(\0132\032.falcon_"
    "psd.BitFrameHeader\022\020\n\010bit_data\030\006 \003(\005B\025\n\023"
    "fv.protos.kepsvisor", 1499);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "FalconPSDMessages.proto", &protobuf_RegisterTypes);
  ClassificationHeader::default_instance_ = new ClassificationHeader();
  PSDHeader::default_instance_ = new PSDHeader();
  PSD::_default_msgname_ =
      new ::std::string("PSD", 3);
  PSD::default_instance_ = new PSD();
  DensePSD::_default_msgname_ =
      new ::std::string("DENSE_PSD", 9);
  DensePSD::default_instance_ = new DensePSD();
  BitFrameHeader::default_instance_ = new BitFrameHeader();
  BitFrame::_default_msgname_ =
      new ::std::string("BIT_FRAME", 9);
  BitFrame::default_instance_ = new BitFrame();
  ClassificationHeader::default_instance_->InitAsDefaultInstance();
  PSDHeader::default_instance_->InitAsDefaultInstance();
  PSD::default_instance_->InitAsDefaultInstance();
  DensePSD::default_instance_->InitAsDefaultInstance();
  BitFrameHeader::default_instance_->InitAsDefaultInstance();
  BitFrame::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_FalconPSDMessages_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_FalconPSDMessages_2eproto {
  StaticDescriptorInitializer_FalconPSDMessages_2eproto() {
    protobuf_AddDesc_FalconPSDMessages_2eproto();
  }
} static_descriptor_initializer_FalconPSDMessages_2eproto_;

// ===================================================================

const ::google::protobuf::EnumDescriptor* ClassificationHeader_ClassLevel_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClassificationHeader_ClassLevel_descriptor_;
}
bool ClassificationHeader_ClassLevel_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const ClassificationHeader_ClassLevel ClassificationHeader::UNCLASSIFIED;
const ClassificationHeader_ClassLevel ClassificationHeader::CONFIDENTIAL;
const ClassificationHeader_ClassLevel ClassificationHeader::SECRET;
const ClassificationHeader_ClassLevel ClassificationHeader::TOPSECRET;
const ClassificationHeader_ClassLevel ClassificationHeader::ClassLevel_MIN;
const ClassificationHeader_ClassLevel ClassificationHeader::ClassLevel_MAX;
const int ClassificationHeader::ClassLevel_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* ClassificationHeader_Compartment_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClassificationHeader_Compartment_descriptor_;
}
bool ClassificationHeader_Compartment_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const ClassificationHeader_Compartment ClassificationHeader::SI;
const ClassificationHeader_Compartment ClassificationHeader::TK;
const ClassificationHeader_Compartment ClassificationHeader::Compartment_MIN;
const ClassificationHeader_Compartment ClassificationHeader::Compartment_MAX;
const int ClassificationHeader::Compartment_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* ClassificationHeader_Releasability_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClassificationHeader_Releasability_descriptor_;
}
bool ClassificationHeader_Releasability_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const ClassificationHeader_Releasability ClassificationHeader::FOUO;
const ClassificationHeader_Releasability ClassificationHeader::ROK;
const ClassificationHeader_Releasability ClassificationHeader::EY3;
const ClassificationHeader_Releasability ClassificationHeader::EY4;
const ClassificationHeader_Releasability ClassificationHeader::EY5;
const ClassificationHeader_Releasability ClassificationHeader::EY9;
const ClassificationHeader_Releasability ClassificationHeader::NOFOR;
const ClassificationHeader_Releasability ClassificationHeader::Releasability_MIN;
const ClassificationHeader_Releasability ClassificationHeader::Releasability_MAX;
const int ClassificationHeader::Releasability_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int ClassificationHeader::kClassificationFieldNumber;
const int ClassificationHeader::kCompartmentFieldNumber;
const int ClassificationHeader::kRelToFieldNumber;
#endif  // !_MSC_VER

ClassificationHeader::ClassificationHeader()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClassificationHeader::InitAsDefaultInstance() {
}

ClassificationHeader::ClassificationHeader(const ClassificationHeader& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClassificationHeader::SharedCtor() {
  _cached_size_ = 0;
  classification_ = 1;
  compartment_ = 1;
  rel_to_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClassificationHeader::~ClassificationHeader() {
  SharedDtor();
}

void ClassificationHeader::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClassificationHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClassificationHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClassificationHeader_descriptor_;
}

const ClassificationHeader& ClassificationHeader::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_FalconPSDMessages_2eproto();
  return *default_instance_;
}

ClassificationHeader* ClassificationHeader::default_instance_ = NULL;

ClassificationHeader* ClassificationHeader::New() const {
  return new ClassificationHeader;
}

void ClassificationHeader::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    classification_ = 1;
    compartment_ = 1;
    rel_to_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClassificationHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .falcon_psd.ClassificationHeader.ClassLevel classification = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::falcon_psd::ClassificationHeader_ClassLevel_IsValid(value)) {
            set_classification(static_cast< ::falcon_psd::ClassificationHeader_ClassLevel >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_compartment;
        break;
      }

      // optional .falcon_psd.ClassificationHeader.Compartment compartment = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_compartment:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::falcon_psd::ClassificationHeader_Compartment_IsValid(value)) {
            set_compartment(static_cast< ::falcon_psd::ClassificationHeader_Compartment >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_rel_to;
        break;
      }

      // optional .falcon_psd.ClassificationHeader.Releasability rel_to = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rel_to:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::falcon_psd::ClassificationHeader_Releasability_IsValid(value)) {
            set_rel_to(static_cast< ::falcon_psd::ClassificationHeader_Releasability >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClassificationHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .falcon_psd.ClassificationHeader.ClassLevel classification = 1;
  if (has_classification()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->classification(), output);
  }

  // optional .falcon_psd.ClassificationHeader.Compartment compartment = 2;
  if (has_compartment()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->compartment(), output);
  }

  // optional .falcon_psd.ClassificationHeader.Releasability rel_to = 3;
  if (has_rel_to()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->rel_to(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClassificationHeader::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .falcon_psd.ClassificationHeader.ClassLevel classification = 1;
  if (has_classification()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->classification(), target);
  }

  // optional .falcon_psd.ClassificationHeader.Compartment compartment = 2;
  if (has_compartment()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->compartment(), target);
  }

  // optional .falcon_psd.ClassificationHeader.Releasability rel_to = 3;
  if (has_rel_to()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->rel_to(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClassificationHeader::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .falcon_psd.ClassificationHeader.ClassLevel classification = 1;
    if (has_classification()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->classification());
    }

    // optional .falcon_psd.ClassificationHeader.Compartment compartment = 2;
    if (has_compartment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->compartment());
    }

    // optional .falcon_psd.ClassificationHeader.Releasability rel_to = 3;
    if (has_rel_to()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->rel_to());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClassificationHeader::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClassificationHeader* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClassificationHeader*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClassificationHeader::MergeFrom(const ClassificationHeader& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_classification()) {
      set_classification(from.classification());
    }
    if (from.has_compartment()) {
      set_compartment(from.compartment());
    }
    if (from.has_rel_to()) {
      set_rel_to(from.rel_to());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClassificationHeader::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClassificationHeader::CopyFrom(const ClassificationHeader& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClassificationHeader::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClassificationHeader::Swap(ClassificationHeader* other) {
  if (other != this) {
    std::swap(classification_, other->classification_);
    std::swap(compartment_, other->compartment_);
    std::swap(rel_to_, other->rel_to_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClassificationHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClassificationHeader_descriptor_;
  metadata.reflection = ClassificationHeader_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PSDHeader::kUuidFieldNumber;
const int PSDHeader::kStartFrequencyFieldNumber;
const int PSDHeader::kEndFrequencyFieldNumber;
const int PSDHeader::kResolutionBandwidthFieldNumber;
const int PSDHeader::kNumPointsFieldNumber;
const int PSDHeader::kDurationFieldNumber;
const int PSDHeader::kChannelFieldNumber;
const int PSDHeader::kHighlightStartFieldNumber;
const int PSDHeader::kHighlightEndFieldNumber;
const int PSDHeader::kSaturationFieldNumber;
const int PSDHeader::kPsdMaxFieldNumber;
const int PSDHeader::kPsdMinFieldNumber;
#endif  // !_MSC_VER

PSDHeader::PSDHeader()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PSDHeader::InitAsDefaultInstance() {
}

PSDHeader::PSDHeader(const PSDHeader& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PSDHeader::SharedCtor() {
  _cached_size_ = 0;
  uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  start_frequency_ = 0;
  end_frequency_ = 0;
  resolution_bandwidth_ = 0;
  num_points_ = 0;
  duration_ = 0;
  channel_ = 0;
  highlight_start_ = 0;
  highlight_end_ = 0;
  saturation_ = 0;
  psd_max_ = 0;
  psd_min_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PSDHeader::~PSDHeader() {
  SharedDtor();
}

void PSDHeader::SharedDtor() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (this != default_instance_) {
  }
}

void PSDHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PSDHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PSDHeader_descriptor_;
}

const PSDHeader& PSDHeader::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_FalconPSDMessages_2eproto();
  return *default_instance_;
}

PSDHeader* PSDHeader::default_instance_ = NULL;

PSDHeader* PSDHeader::New() const {
  return new PSDHeader;
}

void PSDHeader::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_uuid()) {
      if (uuid_ != &::google::protobuf::internal::kEmptyString) {
        uuid_->clear();
      }
    }
    start_frequency_ = 0;
    end_frequency_ = 0;
    resolution_bandwidth_ = 0;
    num_points_ = 0;
    duration_ = 0;
    channel_ = 0;
    highlight_start_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    highlight_end_ = 0;
    saturation_ = 0;
    psd_max_ = 0;
    psd_min_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PSDHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string uuid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_uuid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->uuid().data(), this->uuid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(17)) goto parse_start_frequency;
        break;
      }

      // required double start_frequency = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_start_frequency:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &start_frequency_)));
          set_has_start_frequency();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_end_frequency;
        break;
      }

      // required double end_frequency = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_end_frequency:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &end_frequency_)));
          set_has_end_frequency();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(33)) goto parse_resolution_bandwidth;
        break;
      }

      // required double resolution_bandwidth = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_resolution_bandwidth:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &resolution_bandwidth_)));
          set_has_resolution_bandwidth();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_num_points;
        break;
      }

      // required int32 num_points = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_num_points:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_points_)));
          set_has_num_points();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(49)) goto parse_duration;
        break;
      }

      // required double duration = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_duration:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &duration_)));
          set_has_duration();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_channel;
        break;
      }

      // required int32 channel = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_channel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &channel_)));
          set_has_channel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_highlight_start;
        break;
      }

      // optional int32 highlight_start = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_highlight_start:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &highlight_start_)));
          set_has_highlight_start();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_highlight_end;
        break;
      }

      // optional int32 highlight_end = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_highlight_end:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &highlight_end_)));
          set_has_highlight_end();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_saturation;
        break;
      }

      // optional int32 saturation = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_saturation:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &saturation_)));
          set_has_saturation();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(89)) goto parse_psd_max;
        break;
      }

      // optional double psd_max = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_psd_max:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &psd_max_)));
          set_has_psd_max();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(97)) goto parse_psd_min;
        break;
      }

      // optional double psd_min = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_psd_min:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &psd_min_)));
          set_has_psd_min();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PSDHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string uuid = 1;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->uuid().data(), this->uuid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->uuid(), output);
  }

  // required double start_frequency = 2;
  if (has_start_frequency()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->start_frequency(), output);
  }

  // required double end_frequency = 3;
  if (has_end_frequency()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->end_frequency(), output);
  }

  // required double resolution_bandwidth = 4;
  if (has_resolution_bandwidth()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->resolution_bandwidth(), output);
  }

  // required int32 num_points = 5;
  if (has_num_points()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->num_points(), output);
  }

  // required double duration = 6;
  if (has_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->duration(), output);
  }

  // required int32 channel = 7;
  if (has_channel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->channel(), output);
  }

  // optional int32 highlight_start = 8;
  if (has_highlight_start()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->highlight_start(), output);
  }

  // optional int32 highlight_end = 9;
  if (has_highlight_end()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->highlight_end(), output);
  }

  // optional int32 saturation = 10;
  if (has_saturation()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->saturation(), output);
  }

  // optional double psd_max = 11;
  if (has_psd_max()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(11, this->psd_max(), output);
  }

  // optional double psd_min = 12;
  if (has_psd_min()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(12, this->psd_min(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PSDHeader::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string uuid = 1;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->uuid().data(), this->uuid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->uuid(), target);
  }

  // required double start_frequency = 2;
  if (has_start_frequency()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->start_frequency(), target);
  }

  // required double end_frequency = 3;
  if (has_end_frequency()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->end_frequency(), target);
  }

  // required double resolution_bandwidth = 4;
  if (has_resolution_bandwidth()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->resolution_bandwidth(), target);
  }

  // required int32 num_points = 5;
  if (has_num_points()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->num_points(), target);
  }

  // required double duration = 6;
  if (has_duration()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->duration(), target);
  }

  // required int32 channel = 7;
  if (has_channel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->channel(), target);
  }

  // optional int32 highlight_start = 8;
  if (has_highlight_start()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->highlight_start(), target);
  }

  // optional int32 highlight_end = 9;
  if (has_highlight_end()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->highlight_end(), target);
  }

  // optional int32 saturation = 10;
  if (has_saturation()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->saturation(), target);
  }

  // optional double psd_max = 11;
  if (has_psd_max()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(11, this->psd_max(), target);
  }

  // optional double psd_min = 12;
  if (has_psd_min()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(12, this->psd_min(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PSDHeader::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string uuid = 1;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->uuid());
    }

    // required double start_frequency = 2;
    if (has_start_frequency()) {
      total_size += 1 + 8;
    }

    // required double end_frequency = 3;
    if (has_end_frequency()) {
      total_size += 1 + 8;
    }

    // required double resolution_bandwidth = 4;
    if (has_resolution_bandwidth()) {
      total_size += 1 + 8;
    }

    // required int32 num_points = 5;
    if (has_num_points()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num_points());
    }

    // required double duration = 6;
    if (has_duration()) {
      total_size += 1 + 8;
    }

    // required int32 channel = 7;
    if (has_channel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->channel());
    }

    // optional int32 highlight_start = 8;
    if (has_highlight_start()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->highlight_start());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 highlight_end = 9;
    if (has_highlight_end()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->highlight_end());
    }

    // optional int32 saturation = 10;
    if (has_saturation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->saturation());
    }

    // optional double psd_max = 11;
    if (has_psd_max()) {
      total_size += 1 + 8;
    }

    // optional double psd_min = 12;
    if (has_psd_min()) {
      total_size += 1 + 8;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PSDHeader::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PSDHeader* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PSDHeader*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PSDHeader::MergeFrom(const PSDHeader& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
    if (from.has_start_frequency()) {
      set_start_frequency(from.start_frequency());
    }
    if (from.has_end_frequency()) {
      set_end_frequency(from.end_frequency());
    }
    if (from.has_resolution_bandwidth()) {
      set_resolution_bandwidth(from.resolution_bandwidth());
    }
    if (from.has_num_points()) {
      set_num_points(from.num_points());
    }
    if (from.has_duration()) {
      set_duration(from.duration());
    }
    if (from.has_channel()) {
      set_channel(from.channel());
    }
    if (from.has_highlight_start()) {
      set_highlight_start(from.highlight_start());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_highlight_end()) {
      set_highlight_end(from.highlight_end());
    }
    if (from.has_saturation()) {
      set_saturation(from.saturation());
    }
    if (from.has_psd_max()) {
      set_psd_max(from.psd_max());
    }
    if (from.has_psd_min()) {
      set_psd_min(from.psd_min());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PSDHeader::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PSDHeader::CopyFrom(const PSDHeader& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PSDHeader::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;

  return true;
}

void PSDHeader::Swap(PSDHeader* other) {
  if (other != this) {
    std::swap(uuid_, other->uuid_);
    std::swap(start_frequency_, other->start_frequency_);
    std::swap(end_frequency_, other->end_frequency_);
    std::swap(resolution_bandwidth_, other->resolution_bandwidth_);
    std::swap(num_points_, other->num_points_);
    std::swap(duration_, other->duration_);
    std::swap(channel_, other->channel_);
    std::swap(highlight_start_, other->highlight_start_);
    std::swap(highlight_end_, other->highlight_end_);
    std::swap(saturation_, other->saturation_);
    std::swap(psd_max_, other->psd_max_);
    std::swap(psd_min_, other->psd_min_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PSDHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PSDHeader_descriptor_;
  metadata.reflection = PSDHeader_reflection_;
  return metadata;
}


// ===================================================================

::std::string* PSD::_default_msgname_ = NULL;
#ifndef _MSC_VER
const int PSD::kMsgNameFieldNumber;
const int PSD::kClassificationHeaderFieldNumber;
const int PSD::kTimestampFieldNumber;
const int PSD::kUuidFieldNumber;
const int PSD::kPsdHeaderFieldNumber;
const int PSD::kFftDataFieldNumber;
#endif  // !_MSC_VER

PSD::PSD()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PSD::InitAsDefaultInstance() {
  classification_header_ = const_cast< ::falcon_psd::ClassificationHeader*>(&::falcon_psd::ClassificationHeader::default_instance());
  psd_header_ = const_cast< ::falcon_psd::PSDHeader*>(&::falcon_psd::PSDHeader::default_instance());
}

PSD::PSD(const PSD& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PSD::SharedCtor() {
  _cached_size_ = 0;
  msgname_ = const_cast< ::std::string*>(_default_msgname_);
  classification_header_ = NULL;
  timestamp_ = 0;
  uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  psd_header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PSD::~PSD() {
  SharedDtor();
}

void PSD::SharedDtor() {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (this != default_instance_) {
    delete classification_header_;
    delete psd_header_;
  }
}

void PSD::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PSD::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PSD_descriptor_;
}

const PSD& PSD::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_FalconPSDMessages_2eproto();
  return *default_instance_;
}

PSD* PSD::default_instance_ = NULL;

PSD* PSD::New() const {
  return new PSD;
}

void PSD::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_msgname()) {
      if (msgname_ != _default_msgname_) {
        msgname_->assign(*_default_msgname_);
      }
    }
    if (has_classification_header()) {
      if (classification_header_ != NULL) classification_header_->::falcon_psd::ClassificationHeader::Clear();
    }
    timestamp_ = 0;
    if (has_uuid()) {
      if (uuid_ != &::google::protobuf::internal::kEmptyString) {
        uuid_->clear();
      }
    }
    if (has_psd_header()) {
      if (psd_header_ != NULL) psd_header_->::falcon_psd::PSDHeader::Clear();
    }
  }
  fft_data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PSD::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string msgName = 1 [default = "PSD"];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_msgname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->msgname().data(), this->msgname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_classification_header;
        break;
      }

      // required .falcon_psd.ClassificationHeader classification_header = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_classification_header:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_classification_header()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_timestamp;
        break;
      }

      // required double timestamp = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_uuid;
        break;
      }

      // required string uuid = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_uuid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_uuid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->uuid().data(), this->uuid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_psd_header;
        break;
      }

      // optional .falcon_psd.PSDHeader psd_header = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_psd_header:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_psd_header()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_fft_data;
        break;
      }

      // repeated float fft_data = 6 [packed = true];
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_fft_data:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_fft_data())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 50, input, this->mutable_fft_data())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PSD::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string msgName = 1 [default = "PSD"];
  if (has_msgname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->msgname().data(), this->msgname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->msgname(), output);
  }

  // required .falcon_psd.ClassificationHeader classification_header = 2;
  if (has_classification_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->classification_header(), output);
  }

  // required double timestamp = 3;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->timestamp(), output);
  }

  // required string uuid = 4;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->uuid().data(), this->uuid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->uuid(), output);
  }

  // optional .falcon_psd.PSDHeader psd_header = 5;
  if (has_psd_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->psd_header(), output);
  }

  // repeated float fft_data = 6 [packed = true];
  if (this->fft_data_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(6, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_fft_data_cached_byte_size_);
  }
  for (int i = 0; i < this->fft_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloatNoTag(
      this->fft_data(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PSD::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string msgName = 1 [default = "PSD"];
  if (has_msgname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->msgname().data(), this->msgname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->msgname(), target);
  }

  // required .falcon_psd.ClassificationHeader classification_header = 2;
  if (has_classification_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->classification_header(), target);
  }

  // required double timestamp = 3;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->timestamp(), target);
  }

  // required string uuid = 4;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->uuid().data(), this->uuid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->uuid(), target);
  }

  // optional .falcon_psd.PSDHeader psd_header = 5;
  if (has_psd_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->psd_header(), target);
  }

  // repeated float fft_data = 6 [packed = true];
  if (this->fft_data_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      6,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _fft_data_cached_byte_size_, target);
  }
  for (int i = 0; i < this->fft_data_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatNoTagToArray(this->fft_data(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PSD::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string msgName = 1 [default = "PSD"];
    if (has_msgname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->msgname());
    }

    // required .falcon_psd.ClassificationHeader classification_header = 2;
    if (has_classification_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->classification_header());
    }

    // required double timestamp = 3;
    if (has_timestamp()) {
      total_size += 1 + 8;
    }

    // required string uuid = 4;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->uuid());
    }

    // optional .falcon_psd.PSDHeader psd_header = 5;
    if (has_psd_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->psd_header());
    }

  }
  // repeated float fft_data = 6 [packed = true];
  {
    int data_size = 0;
    data_size = 4 * this->fft_data_size();
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _fft_data_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PSD::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PSD* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PSD*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PSD::MergeFrom(const PSD& from) {
  GOOGLE_CHECK_NE(&from, this);
  fft_data_.MergeFrom(from.fft_data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_msgname()) {
      set_msgname(from.msgname());
    }
    if (from.has_classification_header()) {
      mutable_classification_header()->::falcon_psd::ClassificationHeader::MergeFrom(from.classification_header());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
    if (from.has_psd_header()) {
      mutable_psd_header()->::falcon_psd::PSDHeader::MergeFrom(from.psd_header());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PSD::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PSD::CopyFrom(const PSD& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PSD::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000e) != 0x0000000e) return false;

  if (has_classification_header()) {
    if (!this->classification_header().IsInitialized()) return false;
  }
  if (has_psd_header()) {
    if (!this->psd_header().IsInitialized()) return false;
  }
  return true;
}

void PSD::Swap(PSD* other) {
  if (other != this) {
    std::swap(msgname_, other->msgname_);
    std::swap(classification_header_, other->classification_header_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(uuid_, other->uuid_);
    std::swap(psd_header_, other->psd_header_);
    fft_data_.Swap(&other->fft_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PSD::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PSD_descriptor_;
  metadata.reflection = PSD_reflection_;
  return metadata;
}


// ===================================================================

::std::string* DensePSD::_default_msgname_ = NULL;
#ifndef _MSC_VER
const int DensePSD::kMsgNameFieldNumber;
const int DensePSD::kClassificationHeaderFieldNumber;
const int DensePSD::kTimestampFieldNumber;
const int DensePSD::kUuidFieldNumber;
const int DensePSD::kPsdHeaderFieldNumber;
const int DensePSD::kMinFieldNumber;
const int DensePSD::kStepFieldNumber;
const int DensePSD::kFftDataFieldNumber;
#endif  // !_MSC_VER

DensePSD::DensePSD()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DensePSD::InitAsDefaultInstance() {
  classification_header_ = const_cast< ::falcon_psd::ClassificationHeader*>(&::falcon_psd::ClassificationHeader::default_instance());
  psd_header_ = const_cast< ::falcon_psd::PSDHeader*>(&::falcon_psd::PSDHeader::default_instance());
}

DensePSD::DensePSD(const DensePSD& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DensePSD::SharedCtor() {
  _cached_size_ = 0;
  msgname_ = const_cast< ::std::string*>(_default_msgname_);
  classification_header_ = NULL;
  timestamp_ = 0;
  uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  psd_header_ = NULL;
  min_ = 0;
  step_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DensePSD::~DensePSD() {
  SharedDtor();
}

void DensePSD::SharedDtor() {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (this != default_instance_) {
    delete classification_header_;
    delete psd_header_;
  }
}

void DensePSD::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DensePSD::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DensePSD_descriptor_;
}

const DensePSD& DensePSD::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_FalconPSDMessages_2eproto();
  return *default_instance_;
}

DensePSD* DensePSD::default_instance_ = NULL;

DensePSD* DensePSD::New() const {
  return new DensePSD;
}

void DensePSD::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_msgname()) {
      if (msgname_ != _default_msgname_) {
        msgname_->assign(*_default_msgname_);
      }
    }
    if (has_classification_header()) {
      if (classification_header_ != NULL) classification_header_->::falcon_psd::ClassificationHeader::Clear();
    }
    timestamp_ = 0;
    if (has_uuid()) {
      if (uuid_ != &::google::protobuf::internal::kEmptyString) {
        uuid_->clear();
      }
    }
    if (has_psd_header()) {
      if (psd_header_ != NULL) psd_header_->::falcon_psd::PSDHeader::Clear();
    }
    min_ = 0;
    step_ = 0;
  }
  fft_data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DensePSD::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string msgName = 1 [default = "DENSE_PSD"];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_msgname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->msgname().data(), this->msgname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_classification_header;
        break;
      }

      // required .falcon_psd.ClassificationHeader classification_header = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_classification_header:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_classification_header()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_timestamp;
        break;
      }

      // required double timestamp = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_uuid;
        break;
      }

      // required string uuid = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_uuid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_uuid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->uuid().data(), this->uuid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_psd_header;
        break;
      }

      // optional .falcon_psd.PSDHeader psd_header = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_psd_header:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_psd_header()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_min;
        break;
      }

      // required float min = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_min:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &min_)));
          set_has_min();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(61)) goto parse_step;
        break;
      }

      // required float step = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_step:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &step_)));
          set_has_step();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(69)) goto parse_fft_data;
        break;
      }

      // repeated float fft_data = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_fft_data:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 69, input, this->mutable_fft_data())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_fft_data())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(69)) goto parse_fft_data;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DensePSD::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string msgName = 1 [default = "DENSE_PSD"];
  if (has_msgname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->msgname().data(), this->msgname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->msgname(), output);
  }

  // required .falcon_psd.ClassificationHeader classification_header = 2;
  if (has_classification_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->classification_header(), output);
  }

  // required double timestamp = 3;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->timestamp(), output);
  }

  // required string uuid = 4;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->uuid().data(), this->uuid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->uuid(), output);
  }

  // optional .falcon_psd.PSDHeader psd_header = 5;
  if (has_psd_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->psd_header(), output);
  }

  // required float min = 6;
  if (has_min()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->min(), output);
  }

  // required float step = 7;
  if (has_step()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->step(), output);
  }

  // repeated float fft_data = 8;
  for (int i = 0; i < this->fft_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      8, this->fft_data(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DensePSD::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string msgName = 1 [default = "DENSE_PSD"];
  if (has_msgname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->msgname().data(), this->msgname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->msgname(), target);
  }

  // required .falcon_psd.ClassificationHeader classification_header = 2;
  if (has_classification_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->classification_header(), target);
  }

  // required double timestamp = 3;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->timestamp(), target);
  }

  // required string uuid = 4;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->uuid().data(), this->uuid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->uuid(), target);
  }

  // optional .falcon_psd.PSDHeader psd_header = 5;
  if (has_psd_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->psd_header(), target);
  }

  // required float min = 6;
  if (has_min()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->min(), target);
  }

  // required float step = 7;
  if (has_step()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->step(), target);
  }

  // repeated float fft_data = 8;
  for (int i = 0; i < this->fft_data_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(8, this->fft_data(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DensePSD::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string msgName = 1 [default = "DENSE_PSD"];
    if (has_msgname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->msgname());
    }

    // required .falcon_psd.ClassificationHeader classification_header = 2;
    if (has_classification_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->classification_header());
    }

    // required double timestamp = 3;
    if (has_timestamp()) {
      total_size += 1 + 8;
    }

    // required string uuid = 4;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->uuid());
    }

    // optional .falcon_psd.PSDHeader psd_header = 5;
    if (has_psd_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->psd_header());
    }

    // required float min = 6;
    if (has_min()) {
      total_size += 1 + 4;
    }

    // required float step = 7;
    if (has_step()) {
      total_size += 1 + 4;
    }

  }
  // repeated float fft_data = 8;
  {
    int data_size = 0;
    data_size = 4 * this->fft_data_size();
    total_size += 1 * this->fft_data_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DensePSD::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DensePSD* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DensePSD*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DensePSD::MergeFrom(const DensePSD& from) {
  GOOGLE_CHECK_NE(&from, this);
  fft_data_.MergeFrom(from.fft_data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_msgname()) {
      set_msgname(from.msgname());
    }
    if (from.has_classification_header()) {
      mutable_classification_header()->::falcon_psd::ClassificationHeader::MergeFrom(from.classification_header());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
    if (from.has_psd_header()) {
      mutable_psd_header()->::falcon_psd::PSDHeader::MergeFrom(from.psd_header());
    }
    if (from.has_min()) {
      set_min(from.min());
    }
    if (from.has_step()) {
      set_step(from.step());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DensePSD::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DensePSD::CopyFrom(const DensePSD& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DensePSD::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000006e) != 0x0000006e) return false;

  if (has_classification_header()) {
    if (!this->classification_header().IsInitialized()) return false;
  }
  if (has_psd_header()) {
    if (!this->psd_header().IsInitialized()) return false;
  }
  return true;
}

void DensePSD::Swap(DensePSD* other) {
  if (other != this) {
    std::swap(msgname_, other->msgname_);
    std::swap(classification_header_, other->classification_header_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(uuid_, other->uuid_);
    std::swap(psd_header_, other->psd_header_);
    std::swap(min_, other->min_);
    std::swap(step_, other->step_);
    fft_data_.Swap(&other->fft_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DensePSD::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DensePSD_descriptor_;
  metadata.reflection = DensePSD_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BitFrameHeader::kUuidFieldNumber;
const int BitFrameHeader::kNumPointsFieldNumber;
const int BitFrameHeader::kDurationFieldNumber;
const int BitFrameHeader::kChannelFieldNumber;
const int BitFrameHeader::kBitMaxFieldNumber;
const int BitFrameHeader::kBitMinFieldNumber;
const int BitFrameHeader::kAppNameFieldNumber;
#endif  // !_MSC_VER

BitFrameHeader::BitFrameHeader()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BitFrameHeader::InitAsDefaultInstance() {
}

BitFrameHeader::BitFrameHeader(const BitFrameHeader& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BitFrameHeader::SharedCtor() {
  _cached_size_ = 0;
  uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  num_points_ = 0;
  duration_ = 0;
  channel_ = 0;
  bit_max_ = 0;
  bit_min_ = 0;
  appname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BitFrameHeader::~BitFrameHeader() {
  SharedDtor();
}

void BitFrameHeader::SharedDtor() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (appname_ != &::google::protobuf::internal::kEmptyString) {
    delete appname_;
  }
  if (this != default_instance_) {
  }
}

void BitFrameHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BitFrameHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BitFrameHeader_descriptor_;
}

const BitFrameHeader& BitFrameHeader::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_FalconPSDMessages_2eproto();
  return *default_instance_;
}

BitFrameHeader* BitFrameHeader::default_instance_ = NULL;

BitFrameHeader* BitFrameHeader::New() const {
  return new BitFrameHeader;
}

void BitFrameHeader::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_uuid()) {
      if (uuid_ != &::google::protobuf::internal::kEmptyString) {
        uuid_->clear();
      }
    }
    num_points_ = 0;
    duration_ = 0;
    channel_ = 0;
    bit_max_ = 0;
    bit_min_ = 0;
    if (has_appname()) {
      if (appname_ != &::google::protobuf::internal::kEmptyString) {
        appname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BitFrameHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string uuid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_uuid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->uuid().data(), this->uuid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_num_points;
        break;
      }

      // required int32 num_points = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_num_points:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_points_)));
          set_has_num_points();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_duration;
        break;
      }

      // required double duration = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_duration:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &duration_)));
          set_has_duration();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_channel;
        break;
      }

      // required int32 channel = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_channel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &channel_)));
          set_has_channel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(41)) goto parse_bit_max;
        break;
      }

      // optional double bit_max = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_bit_max:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &bit_max_)));
          set_has_bit_max();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(49)) goto parse_bit_min;
        break;
      }

      // optional double bit_min = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_bit_min:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &bit_min_)));
          set_has_bit_min();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_appName;
        break;
      }

      // optional string appName = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_appName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_appname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->appname().data(), this->appname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BitFrameHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string uuid = 1;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->uuid().data(), this->uuid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->uuid(), output);
  }

  // required int32 num_points = 2;
  if (has_num_points()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->num_points(), output);
  }

  // required double duration = 3;
  if (has_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->duration(), output);
  }

  // required int32 channel = 4;
  if (has_channel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->channel(), output);
  }

  // optional double bit_max = 5;
  if (has_bit_max()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->bit_max(), output);
  }

  // optional double bit_min = 6;
  if (has_bit_min()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->bit_min(), output);
  }

  // optional string appName = 7;
  if (has_appname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->appname().data(), this->appname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->appname(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BitFrameHeader::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string uuid = 1;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->uuid().data(), this->uuid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->uuid(), target);
  }

  // required int32 num_points = 2;
  if (has_num_points()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->num_points(), target);
  }

  // required double duration = 3;
  if (has_duration()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->duration(), target);
  }

  // required int32 channel = 4;
  if (has_channel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->channel(), target);
  }

  // optional double bit_max = 5;
  if (has_bit_max()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->bit_max(), target);
  }

  // optional double bit_min = 6;
  if (has_bit_min()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->bit_min(), target);
  }

  // optional string appName = 7;
  if (has_appname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->appname().data(), this->appname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->appname(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BitFrameHeader::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string uuid = 1;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->uuid());
    }

    // required int32 num_points = 2;
    if (has_num_points()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num_points());
    }

    // required double duration = 3;
    if (has_duration()) {
      total_size += 1 + 8;
    }

    // required int32 channel = 4;
    if (has_channel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->channel());
    }

    // optional double bit_max = 5;
    if (has_bit_max()) {
      total_size += 1 + 8;
    }

    // optional double bit_min = 6;
    if (has_bit_min()) {
      total_size += 1 + 8;
    }

    // optional string appName = 7;
    if (has_appname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->appname());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BitFrameHeader::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BitFrameHeader* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BitFrameHeader*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BitFrameHeader::MergeFrom(const BitFrameHeader& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
    if (from.has_num_points()) {
      set_num_points(from.num_points());
    }
    if (from.has_duration()) {
      set_duration(from.duration());
    }
    if (from.has_channel()) {
      set_channel(from.channel());
    }
    if (from.has_bit_max()) {
      set_bit_max(from.bit_max());
    }
    if (from.has_bit_min()) {
      set_bit_min(from.bit_min());
    }
    if (from.has_appname()) {
      set_appname(from.appname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BitFrameHeader::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BitFrameHeader::CopyFrom(const BitFrameHeader& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BitFrameHeader::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void BitFrameHeader::Swap(BitFrameHeader* other) {
  if (other != this) {
    std::swap(uuid_, other->uuid_);
    std::swap(num_points_, other->num_points_);
    std::swap(duration_, other->duration_);
    std::swap(channel_, other->channel_);
    std::swap(bit_max_, other->bit_max_);
    std::swap(bit_min_, other->bit_min_);
    std::swap(appname_, other->appname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BitFrameHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BitFrameHeader_descriptor_;
  metadata.reflection = BitFrameHeader_reflection_;
  return metadata;
}


// ===================================================================

::std::string* BitFrame::_default_msgname_ = NULL;
#ifndef _MSC_VER
const int BitFrame::kMsgNameFieldNumber;
const int BitFrame::kClassificationHeaderFieldNumber;
const int BitFrame::kTimestampFieldNumber;
const int BitFrame::kUuidFieldNumber;
const int BitFrame::kHeaderFieldNumber;
const int BitFrame::kBitDataFieldNumber;
#endif  // !_MSC_VER

BitFrame::BitFrame()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BitFrame::InitAsDefaultInstance() {
  classification_header_ = const_cast< ::falcon_psd::ClassificationHeader*>(&::falcon_psd::ClassificationHeader::default_instance());
  header_ = const_cast< ::falcon_psd::BitFrameHeader*>(&::falcon_psd::BitFrameHeader::default_instance());
}

BitFrame::BitFrame(const BitFrame& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BitFrame::SharedCtor() {
  _cached_size_ = 0;
  msgname_ = const_cast< ::std::string*>(_default_msgname_);
  classification_header_ = NULL;
  timestamp_ = 0;
  uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BitFrame::~BitFrame() {
  SharedDtor();
}

void BitFrame::SharedDtor() {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (this != default_instance_) {
    delete classification_header_;
    delete header_;
  }
}

void BitFrame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BitFrame::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BitFrame_descriptor_;
}

const BitFrame& BitFrame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_FalconPSDMessages_2eproto();
  return *default_instance_;
}

BitFrame* BitFrame::default_instance_ = NULL;

BitFrame* BitFrame::New() const {
  return new BitFrame;
}

void BitFrame::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_msgname()) {
      if (msgname_ != _default_msgname_) {
        msgname_->assign(*_default_msgname_);
      }
    }
    if (has_classification_header()) {
      if (classification_header_ != NULL) classification_header_->::falcon_psd::ClassificationHeader::Clear();
    }
    timestamp_ = 0;
    if (has_uuid()) {
      if (uuid_ != &::google::protobuf::internal::kEmptyString) {
        uuid_->clear();
      }
    }
    if (has_header()) {
      if (header_ != NULL) header_->::falcon_psd::BitFrameHeader::Clear();
    }
  }
  bit_data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BitFrame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string msgName = 1 [default = "BIT_FRAME"];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_msgname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->msgname().data(), this->msgname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_classification_header;
        break;
      }

      // required .falcon_psd.ClassificationHeader classification_header = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_classification_header:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_classification_header()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_timestamp;
        break;
      }

      // required double timestamp = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_uuid;
        break;
      }

      // required string uuid = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_uuid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_uuid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->uuid().data(), this->uuid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_header;
        break;
      }

      // optional .falcon_psd.BitFrameHeader header = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_header:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_bit_data;
        break;
      }

      // repeated int32 bit_data = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_bit_data:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 48, input, this->mutable_bit_data())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_bit_data())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_bit_data;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BitFrame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string msgName = 1 [default = "BIT_FRAME"];
  if (has_msgname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->msgname().data(), this->msgname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->msgname(), output);
  }

  // required .falcon_psd.ClassificationHeader classification_header = 2;
  if (has_classification_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->classification_header(), output);
  }

  // required double timestamp = 3;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->timestamp(), output);
  }

  // required string uuid = 4;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->uuid().data(), this->uuid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->uuid(), output);
  }

  // optional .falcon_psd.BitFrameHeader header = 5;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->header(), output);
  }

  // repeated int32 bit_data = 6;
  for (int i = 0; i < this->bit_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      6, this->bit_data(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BitFrame::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string msgName = 1 [default = "BIT_FRAME"];
  if (has_msgname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->msgname().data(), this->msgname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->msgname(), target);
  }

  // required .falcon_psd.ClassificationHeader classification_header = 2;
  if (has_classification_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->classification_header(), target);
  }

  // required double timestamp = 3;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->timestamp(), target);
  }

  // required string uuid = 4;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->uuid().data(), this->uuid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->uuid(), target);
  }

  // optional .falcon_psd.BitFrameHeader header = 5;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->header(), target);
  }

  // repeated int32 bit_data = 6;
  for (int i = 0; i < this->bit_data_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(6, this->bit_data(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BitFrame::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string msgName = 1 [default = "BIT_FRAME"];
    if (has_msgname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->msgname());
    }

    // required .falcon_psd.ClassificationHeader classification_header = 2;
    if (has_classification_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->classification_header());
    }

    // required double timestamp = 3;
    if (has_timestamp()) {
      total_size += 1 + 8;
    }

    // required string uuid = 4;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->uuid());
    }

    // optional .falcon_psd.BitFrameHeader header = 5;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }

  }
  // repeated int32 bit_data = 6;
  {
    int data_size = 0;
    for (int i = 0; i < this->bit_data_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->bit_data(i));
    }
    total_size += 1 * this->bit_data_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BitFrame::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BitFrame* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BitFrame*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BitFrame::MergeFrom(const BitFrame& from) {
  GOOGLE_CHECK_NE(&from, this);
  bit_data_.MergeFrom(from.bit_data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_msgname()) {
      set_msgname(from.msgname());
    }
    if (from.has_classification_header()) {
      mutable_classification_header()->::falcon_psd::ClassificationHeader::MergeFrom(from.classification_header());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
    if (from.has_header()) {
      mutable_header()->::falcon_psd::BitFrameHeader::MergeFrom(from.header());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BitFrame::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BitFrame::CopyFrom(const BitFrame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BitFrame::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000e) != 0x0000000e) return false;

  if (has_classification_header()) {
    if (!this->classification_header().IsInitialized()) return false;
  }
  if (has_header()) {
    if (!this->header().IsInitialized()) return false;
  }
  return true;
}

void BitFrame::Swap(BitFrame* other) {
  if (other != this) {
    std::swap(msgname_, other->msgname_);
    std::swap(classification_header_, other->classification_header_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(uuid_, other->uuid_);
    std::swap(header_, other->header_);
    bit_data_.Swap(&other->bit_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BitFrame::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BitFrame_descriptor_;
  metadata.reflection = BitFrame_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace falcon_psd

// @@protoc_insertion_point(global_scope)
