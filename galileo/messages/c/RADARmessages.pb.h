// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: RADARmessages.proto

#ifndef PROTOBUF_RADARmessages_2eproto__INCLUDED
#define PROTOBUF_RADARmessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "ServiceInfrastructureCommon.pb.h"
// @@protoc_insertion_point(includes)

namespace rdr_msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_RADARmessages_2eproto();
void protobuf_AssignDesc_RADARmessages_2eproto();
void protobuf_ShutdownFile_RADARmessages_2eproto();

class RadarTopic;
class GeodeticCoordinates;
class VelocityNED;
class Track;
class TrackEstimate;
class RadarMetaData;

// ===================================================================

class RadarTopic : public ::google::protobuf::Message {
 public:
  RadarTopic();
  virtual ~RadarTopic();

  RadarTopic(const RadarTopic& from);

  inline RadarTopic& operator=(const RadarTopic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RadarTopic& default_instance();

  void Swap(RadarTopic* other);

  // implements Message ----------------------------------------------

  RadarTopic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RadarTopic& from);
  void MergeFrom(const RadarTopic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 100;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 100;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional .rdr_msg.RadarMetaData radar_data = 1;
  inline bool has_radar_data() const;
  inline void clear_radar_data();
  static const int kRadarDataFieldNumber = 1;
  inline const ::rdr_msg::RadarMetaData& radar_data() const;
  inline ::rdr_msg::RadarMetaData* mutable_radar_data();
  inline ::rdr_msg::RadarMetaData* release_radar_data();
  inline void set_allocated_radar_data(::rdr_msg::RadarMetaData* radar_data);

  // @@protoc_insertion_point(class_scope:rdr_msg.RadarTopic)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_radar_data();
  inline void clear_has_radar_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::rdr_msg::RadarMetaData* radar_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_RADARmessages_2eproto();
  friend void protobuf_AssignDesc_RADARmessages_2eproto();
  friend void protobuf_ShutdownFile_RADARmessages_2eproto();

  void InitAsDefaultInstance();
  static RadarTopic* default_instance_;
};
// -------------------------------------------------------------------

class GeodeticCoordinates : public ::google::protobuf::Message {
 public:
  GeodeticCoordinates();
  virtual ~GeodeticCoordinates();

  GeodeticCoordinates(const GeodeticCoordinates& from);

  inline GeodeticCoordinates& operator=(const GeodeticCoordinates& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GeodeticCoordinates& default_instance();

  void Swap(GeodeticCoordinates* other);

  // implements Message ----------------------------------------------

  GeodeticCoordinates* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GeodeticCoordinates& from);
  void MergeFrom(const GeodeticCoordinates& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float latitude = 1;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 1;
  inline float latitude() const;
  inline void set_latitude(float value);

  // optional float longitude = 2;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 2;
  inline float longitude() const;
  inline void set_longitude(float value);

  // optional float altitude = 3;
  inline bool has_altitude() const;
  inline void clear_altitude();
  static const int kAltitudeFieldNumber = 3;
  inline float altitude() const;
  inline void set_altitude(float value);

  // @@protoc_insertion_point(class_scope:rdr_msg.GeodeticCoordinates)
 private:
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_altitude();
  inline void clear_has_altitude();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float latitude_;
  float longitude_;
  float altitude_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_RADARmessages_2eproto();
  friend void protobuf_AssignDesc_RADARmessages_2eproto();
  friend void protobuf_ShutdownFile_RADARmessages_2eproto();

  void InitAsDefaultInstance();
  static GeodeticCoordinates* default_instance_;
};
// -------------------------------------------------------------------

class VelocityNED : public ::google::protobuf::Message {
 public:
  VelocityNED();
  virtual ~VelocityNED();

  VelocityNED(const VelocityNED& from);

  inline VelocityNED& operator=(const VelocityNED& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VelocityNED& default_instance();

  void Swap(VelocityNED* other);

  // implements Message ----------------------------------------------

  VelocityNED* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VelocityNED& from);
  void MergeFrom(const VelocityNED& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float vnorth_mps = 1;
  inline bool has_vnorth_mps() const;
  inline void clear_vnorth_mps();
  static const int kVnorthMpsFieldNumber = 1;
  inline float vnorth_mps() const;
  inline void set_vnorth_mps(float value);

  // optional float veast_mps = 2;
  inline bool has_veast_mps() const;
  inline void clear_veast_mps();
  static const int kVeastMpsFieldNumber = 2;
  inline float veast_mps() const;
  inline void set_veast_mps(float value);

  // optional float vdown_mps = 3;
  inline bool has_vdown_mps() const;
  inline void clear_vdown_mps();
  static const int kVdownMpsFieldNumber = 3;
  inline float vdown_mps() const;
  inline void set_vdown_mps(float value);

  // @@protoc_insertion_point(class_scope:rdr_msg.VelocityNED)
 private:
  inline void set_has_vnorth_mps();
  inline void clear_has_vnorth_mps();
  inline void set_has_veast_mps();
  inline void clear_has_veast_mps();
  inline void set_has_vdown_mps();
  inline void clear_has_vdown_mps();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float vnorth_mps_;
  float veast_mps_;
  float vdown_mps_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_RADARmessages_2eproto();
  friend void protobuf_AssignDesc_RADARmessages_2eproto();
  friend void protobuf_ShutdownFile_RADARmessages_2eproto();

  void InitAsDefaultInstance();
  static VelocityNED* default_instance_;
};
// -------------------------------------------------------------------

class Track : public ::google::protobuf::Message {
 public:
  Track();
  virtual ~Track();

  Track(const Track& from);

  inline Track& operator=(const Track& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Track& default_instance();

  void Swap(Track* other);

  // implements Message ----------------------------------------------

  Track* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Track& from);
  void MergeFrom(const Track& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 trackId = 1;
  inline bool has_trackid() const;
  inline void clear_trackid();
  static const int kTrackIdFieldNumber = 1;
  inline ::google::protobuf::int64 trackid() const;
  inline void set_trackid(::google::protobuf::int64 value);

  // optional float rcsAvg = 2;
  inline bool has_rcsavg() const;
  inline void clear_rcsavg();
  static const int kRcsAvgFieldNumber = 2;
  inline float rcsavg() const;
  inline void set_rcsavg(float value);

  // optional float speedAvg = 3;
  inline bool has_speedavg() const;
  inline void clear_speedavg();
  static const int kSpeedAvgFieldNumber = 3;
  inline float speedavg() const;
  inline void set_speedavg(float value);

  // optional float rcsMin = 4;
  inline bool has_rcsmin() const;
  inline void clear_rcsmin();
  static const int kRcsMinFieldNumber = 4;
  inline float rcsmin() const;
  inline void set_rcsmin(float value);

  // optional float rcsMax = 5;
  inline bool has_rcsmax() const;
  inline void clear_rcsmax();
  static const int kRcsMaxFieldNumber = 5;
  inline float rcsmax() const;
  inline void set_rcsmax(float value);

  // optional float speedMin = 6;
  inline bool has_speedmin() const;
  inline void clear_speedmin();
  static const int kSpeedMinFieldNumber = 6;
  inline float speedmin() const;
  inline void set_speedmin(float value);

  // optional float speedMax = 7;
  inline bool has_speedmax() const;
  inline void clear_speedmax();
  static const int kSpeedMaxFieldNumber = 7;
  inline float speedmax() const;
  inline void set_speedmax(float value);

  // optional float duration = 8;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 8;
  inline float duration() const;
  inline void set_duration(float value);

  // optional int64 isActive = 9;
  inline bool has_isactive() const;
  inline void clear_isactive();
  static const int kIsActiveFieldNumber = 9;
  inline ::google::protobuf::int64 isactive() const;
  inline void set_isactive(::google::protobuf::int64 value);

  // optional float range = 10;
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 10;
  inline float range() const;
  inline void set_range(float value);

  // @@protoc_insertion_point(class_scope:rdr_msg.Track)
 private:
  inline void set_has_trackid();
  inline void clear_has_trackid();
  inline void set_has_rcsavg();
  inline void clear_has_rcsavg();
  inline void set_has_speedavg();
  inline void clear_has_speedavg();
  inline void set_has_rcsmin();
  inline void clear_has_rcsmin();
  inline void set_has_rcsmax();
  inline void clear_has_rcsmax();
  inline void set_has_speedmin();
  inline void clear_has_speedmin();
  inline void set_has_speedmax();
  inline void clear_has_speedmax();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_isactive();
  inline void clear_has_isactive();
  inline void set_has_range();
  inline void clear_has_range();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 trackid_;
  float rcsavg_;
  float speedavg_;
  float rcsmin_;
  float rcsmax_;
  float speedmin_;
  float speedmax_;
  ::google::protobuf::int64 isactive_;
  float duration_;
  float range_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_RADARmessages_2eproto();
  friend void protobuf_AssignDesc_RADARmessages_2eproto();
  friend void protobuf_ShutdownFile_RADARmessages_2eproto();

  void InitAsDefaultInstance();
  static Track* default_instance_;
};
// -------------------------------------------------------------------

class TrackEstimate : public ::google::protobuf::Message {
 public:
  TrackEstimate();
  virtual ~TrackEstimate();

  TrackEstimate(const TrackEstimate& from);

  inline TrackEstimate& operator=(const TrackEstimate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrackEstimate& default_instance();

  void Swap(TrackEstimate* other);

  // implements Message ----------------------------------------------

  TrackEstimate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrackEstimate& from);
  void MergeFrom(const TrackEstimate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float agl = 1;
  inline bool has_agl() const;
  inline void clear_agl();
  static const int kAglFieldNumber = 1;
  inline float agl() const;
  inline void set_agl(float value);

  // optional int64 gpsTime = 2;
  inline bool has_gpstime() const;
  inline void clear_gpstime();
  static const int kGpsTimeFieldNumber = 2;
  inline ::google::protobuf::int64 gpstime() const;
  inline void set_gpstime(::google::protobuf::int64 value);

  // optional float rcs = 3;
  inline bool has_rcs() const;
  inline void clear_rcs();
  static const int kRcsFieldNumber = 3;
  inline float rcs() const;
  inline void set_rcs(float value);

  // optional .rdr_msg.GeodeticCoordinates lla = 4;
  inline bool has_lla() const;
  inline void clear_lla();
  static const int kLlaFieldNumber = 4;
  inline const ::rdr_msg::GeodeticCoordinates& lla() const;
  inline ::rdr_msg::GeodeticCoordinates* mutable_lla();
  inline ::rdr_msg::GeodeticCoordinates* release_lla();
  inline void set_allocated_lla(::rdr_msg::GeodeticCoordinates* lla);

  // optional .rdr_msg.VelocityNED velNED = 5;
  inline bool has_velned() const;
  inline void clear_velned();
  static const int kVelNEDFieldNumber = 5;
  inline const ::rdr_msg::VelocityNED& velned() const;
  inline ::rdr_msg::VelocityNED* mutable_velned();
  inline ::rdr_msg::VelocityNED* release_velned();
  inline void set_allocated_velned(::rdr_msg::VelocityNED* velned);

  // optional float heading = 6;
  inline bool has_heading() const;
  inline void clear_heading();
  static const int kHeadingFieldNumber = 6;
  inline float heading() const;
  inline void set_heading(float value);

  // optional int64 ts = 7;
  inline bool has_ts() const;
  inline void clear_ts();
  static const int kTsFieldNumber = 7;
  inline ::google::protobuf::int64 ts() const;
  inline void set_ts(::google::protobuf::int64 value);

  // optional float speed = 8;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 8;
  inline float speed() const;
  inline void set_speed(float value);

  // @@protoc_insertion_point(class_scope:rdr_msg.TrackEstimate)
 private:
  inline void set_has_agl();
  inline void clear_has_agl();
  inline void set_has_gpstime();
  inline void clear_has_gpstime();
  inline void set_has_rcs();
  inline void clear_has_rcs();
  inline void set_has_lla();
  inline void clear_has_lla();
  inline void set_has_velned();
  inline void clear_has_velned();
  inline void set_has_heading();
  inline void clear_has_heading();
  inline void set_has_ts();
  inline void clear_has_ts();
  inline void set_has_speed();
  inline void clear_has_speed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 gpstime_;
  float agl_;
  float rcs_;
  ::rdr_msg::GeodeticCoordinates* lla_;
  ::rdr_msg::VelocityNED* velned_;
  ::google::protobuf::int64 ts_;
  float heading_;
  float speed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_RADARmessages_2eproto();
  friend void protobuf_AssignDesc_RADARmessages_2eproto();
  friend void protobuf_ShutdownFile_RADARmessages_2eproto();

  void InitAsDefaultInstance();
  static TrackEstimate* default_instance_;
};
// -------------------------------------------------------------------

class RadarMetaData : public ::google::protobuf::Message {
 public:
  RadarMetaData();
  virtual ~RadarMetaData();

  RadarMetaData(const RadarMetaData& from);

  inline RadarMetaData& operator=(const RadarMetaData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RadarMetaData& default_instance();

  void Swap(RadarMetaData* other);

  // implements Message ----------------------------------------------

  RadarMetaData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RadarMetaData& from);
  void MergeFrom(const RadarMetaData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "RADAR_DATA"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional .rdr_msg.Track track = 2;
  inline bool has_track() const;
  inline void clear_track();
  static const int kTrackFieldNumber = 2;
  inline const ::rdr_msg::Track& track() const;
  inline ::rdr_msg::Track* mutable_track();
  inline ::rdr_msg::Track* release_track();
  inline void set_allocated_track(::rdr_msg::Track* track);

  // optional .rdr_msg.TrackEstimate trackEst = 3;
  inline bool has_trackest() const;
  inline void clear_trackest();
  static const int kTrackEstFieldNumber = 3;
  inline const ::rdr_msg::TrackEstimate& trackest() const;
  inline ::rdr_msg::TrackEstimate* mutable_trackest();
  inline ::rdr_msg::TrackEstimate* release_trackest();
  inline void set_allocated_trackest(::rdr_msg::TrackEstimate* trackest);

  // @@protoc_insertion_point(class_scope:rdr_msg.RadarMetaData)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_track();
  inline void clear_has_track();
  inline void set_has_trackest();
  inline void clear_has_trackest();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::rdr_msg::Track* track_;
  ::rdr_msg::TrackEstimate* trackest_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_RADARmessages_2eproto();
  friend void protobuf_AssignDesc_RADARmessages_2eproto();
  friend void protobuf_ShutdownFile_RADARmessages_2eproto();

  void InitAsDefaultInstance();
  static RadarMetaData* default_instance_;
};
// ===================================================================


// ===================================================================

// RadarTopic

// optional .service_infrastructure.Header header = 100;
inline bool RadarTopic::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RadarTopic::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RadarTopic::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RadarTopic::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& RadarTopic::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* RadarTopic::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* RadarTopic::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void RadarTopic::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .rdr_msg.RadarMetaData radar_data = 1;
inline bool RadarTopic::has_radar_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RadarTopic::set_has_radar_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RadarTopic::clear_has_radar_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RadarTopic::clear_radar_data() {
  if (radar_data_ != NULL) radar_data_->::rdr_msg::RadarMetaData::Clear();
  clear_has_radar_data();
}
inline const ::rdr_msg::RadarMetaData& RadarTopic::radar_data() const {
  return radar_data_ != NULL ? *radar_data_ : *default_instance_->radar_data_;
}
inline ::rdr_msg::RadarMetaData* RadarTopic::mutable_radar_data() {
  set_has_radar_data();
  if (radar_data_ == NULL) radar_data_ = new ::rdr_msg::RadarMetaData;
  return radar_data_;
}
inline ::rdr_msg::RadarMetaData* RadarTopic::release_radar_data() {
  clear_has_radar_data();
  ::rdr_msg::RadarMetaData* temp = radar_data_;
  radar_data_ = NULL;
  return temp;
}
inline void RadarTopic::set_allocated_radar_data(::rdr_msg::RadarMetaData* radar_data) {
  delete radar_data_;
  radar_data_ = radar_data;
  if (radar_data) {
    set_has_radar_data();
  } else {
    clear_has_radar_data();
  }
}

// -------------------------------------------------------------------

// GeodeticCoordinates

// optional float latitude = 1;
inline bool GeodeticCoordinates::has_latitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GeodeticCoordinates::set_has_latitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GeodeticCoordinates::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GeodeticCoordinates::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline float GeodeticCoordinates::latitude() const {
  return latitude_;
}
inline void GeodeticCoordinates::set_latitude(float value) {
  set_has_latitude();
  latitude_ = value;
}

// optional float longitude = 2;
inline bool GeodeticCoordinates::has_longitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GeodeticCoordinates::set_has_longitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GeodeticCoordinates::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GeodeticCoordinates::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline float GeodeticCoordinates::longitude() const {
  return longitude_;
}
inline void GeodeticCoordinates::set_longitude(float value) {
  set_has_longitude();
  longitude_ = value;
}

// optional float altitude = 3;
inline bool GeodeticCoordinates::has_altitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GeodeticCoordinates::set_has_altitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GeodeticCoordinates::clear_has_altitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GeodeticCoordinates::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline float GeodeticCoordinates::altitude() const {
  return altitude_;
}
inline void GeodeticCoordinates::set_altitude(float value) {
  set_has_altitude();
  altitude_ = value;
}

// -------------------------------------------------------------------

// VelocityNED

// optional float vnorth_mps = 1;
inline bool VelocityNED::has_vnorth_mps() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VelocityNED::set_has_vnorth_mps() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VelocityNED::clear_has_vnorth_mps() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VelocityNED::clear_vnorth_mps() {
  vnorth_mps_ = 0;
  clear_has_vnorth_mps();
}
inline float VelocityNED::vnorth_mps() const {
  return vnorth_mps_;
}
inline void VelocityNED::set_vnorth_mps(float value) {
  set_has_vnorth_mps();
  vnorth_mps_ = value;
}

// optional float veast_mps = 2;
inline bool VelocityNED::has_veast_mps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VelocityNED::set_has_veast_mps() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VelocityNED::clear_has_veast_mps() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VelocityNED::clear_veast_mps() {
  veast_mps_ = 0;
  clear_has_veast_mps();
}
inline float VelocityNED::veast_mps() const {
  return veast_mps_;
}
inline void VelocityNED::set_veast_mps(float value) {
  set_has_veast_mps();
  veast_mps_ = value;
}

// optional float vdown_mps = 3;
inline bool VelocityNED::has_vdown_mps() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VelocityNED::set_has_vdown_mps() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VelocityNED::clear_has_vdown_mps() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VelocityNED::clear_vdown_mps() {
  vdown_mps_ = 0;
  clear_has_vdown_mps();
}
inline float VelocityNED::vdown_mps() const {
  return vdown_mps_;
}
inline void VelocityNED::set_vdown_mps(float value) {
  set_has_vdown_mps();
  vdown_mps_ = value;
}

// -------------------------------------------------------------------

// Track

// optional int64 trackId = 1;
inline bool Track::has_trackid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Track::set_has_trackid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Track::clear_has_trackid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Track::clear_trackid() {
  trackid_ = GOOGLE_LONGLONG(0);
  clear_has_trackid();
}
inline ::google::protobuf::int64 Track::trackid() const {
  return trackid_;
}
inline void Track::set_trackid(::google::protobuf::int64 value) {
  set_has_trackid();
  trackid_ = value;
}

// optional float rcsAvg = 2;
inline bool Track::has_rcsavg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Track::set_has_rcsavg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Track::clear_has_rcsavg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Track::clear_rcsavg() {
  rcsavg_ = 0;
  clear_has_rcsavg();
}
inline float Track::rcsavg() const {
  return rcsavg_;
}
inline void Track::set_rcsavg(float value) {
  set_has_rcsavg();
  rcsavg_ = value;
}

// optional float speedAvg = 3;
inline bool Track::has_speedavg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Track::set_has_speedavg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Track::clear_has_speedavg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Track::clear_speedavg() {
  speedavg_ = 0;
  clear_has_speedavg();
}
inline float Track::speedavg() const {
  return speedavg_;
}
inline void Track::set_speedavg(float value) {
  set_has_speedavg();
  speedavg_ = value;
}

// optional float rcsMin = 4;
inline bool Track::has_rcsmin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Track::set_has_rcsmin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Track::clear_has_rcsmin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Track::clear_rcsmin() {
  rcsmin_ = 0;
  clear_has_rcsmin();
}
inline float Track::rcsmin() const {
  return rcsmin_;
}
inline void Track::set_rcsmin(float value) {
  set_has_rcsmin();
  rcsmin_ = value;
}

// optional float rcsMax = 5;
inline bool Track::has_rcsmax() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Track::set_has_rcsmax() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Track::clear_has_rcsmax() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Track::clear_rcsmax() {
  rcsmax_ = 0;
  clear_has_rcsmax();
}
inline float Track::rcsmax() const {
  return rcsmax_;
}
inline void Track::set_rcsmax(float value) {
  set_has_rcsmax();
  rcsmax_ = value;
}

// optional float speedMin = 6;
inline bool Track::has_speedmin() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Track::set_has_speedmin() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Track::clear_has_speedmin() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Track::clear_speedmin() {
  speedmin_ = 0;
  clear_has_speedmin();
}
inline float Track::speedmin() const {
  return speedmin_;
}
inline void Track::set_speedmin(float value) {
  set_has_speedmin();
  speedmin_ = value;
}

// optional float speedMax = 7;
inline bool Track::has_speedmax() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Track::set_has_speedmax() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Track::clear_has_speedmax() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Track::clear_speedmax() {
  speedmax_ = 0;
  clear_has_speedmax();
}
inline float Track::speedmax() const {
  return speedmax_;
}
inline void Track::set_speedmax(float value) {
  set_has_speedmax();
  speedmax_ = value;
}

// optional float duration = 8;
inline bool Track::has_duration() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Track::set_has_duration() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Track::clear_has_duration() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Track::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline float Track::duration() const {
  return duration_;
}
inline void Track::set_duration(float value) {
  set_has_duration();
  duration_ = value;
}

// optional int64 isActive = 9;
inline bool Track::has_isactive() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Track::set_has_isactive() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Track::clear_has_isactive() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Track::clear_isactive() {
  isactive_ = GOOGLE_LONGLONG(0);
  clear_has_isactive();
}
inline ::google::protobuf::int64 Track::isactive() const {
  return isactive_;
}
inline void Track::set_isactive(::google::protobuf::int64 value) {
  set_has_isactive();
  isactive_ = value;
}

// optional float range = 10;
inline bool Track::has_range() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Track::set_has_range() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Track::clear_has_range() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Track::clear_range() {
  range_ = 0;
  clear_has_range();
}
inline float Track::range() const {
  return range_;
}
inline void Track::set_range(float value) {
  set_has_range();
  range_ = value;
}

// -------------------------------------------------------------------

// TrackEstimate

// optional float agl = 1;
inline bool TrackEstimate::has_agl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrackEstimate::set_has_agl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrackEstimate::clear_has_agl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrackEstimate::clear_agl() {
  agl_ = 0;
  clear_has_agl();
}
inline float TrackEstimate::agl() const {
  return agl_;
}
inline void TrackEstimate::set_agl(float value) {
  set_has_agl();
  agl_ = value;
}

// optional int64 gpsTime = 2;
inline bool TrackEstimate::has_gpstime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrackEstimate::set_has_gpstime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrackEstimate::clear_has_gpstime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrackEstimate::clear_gpstime() {
  gpstime_ = GOOGLE_LONGLONG(0);
  clear_has_gpstime();
}
inline ::google::protobuf::int64 TrackEstimate::gpstime() const {
  return gpstime_;
}
inline void TrackEstimate::set_gpstime(::google::protobuf::int64 value) {
  set_has_gpstime();
  gpstime_ = value;
}

// optional float rcs = 3;
inline bool TrackEstimate::has_rcs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrackEstimate::set_has_rcs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrackEstimate::clear_has_rcs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrackEstimate::clear_rcs() {
  rcs_ = 0;
  clear_has_rcs();
}
inline float TrackEstimate::rcs() const {
  return rcs_;
}
inline void TrackEstimate::set_rcs(float value) {
  set_has_rcs();
  rcs_ = value;
}

// optional .rdr_msg.GeodeticCoordinates lla = 4;
inline bool TrackEstimate::has_lla() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrackEstimate::set_has_lla() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrackEstimate::clear_has_lla() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrackEstimate::clear_lla() {
  if (lla_ != NULL) lla_->::rdr_msg::GeodeticCoordinates::Clear();
  clear_has_lla();
}
inline const ::rdr_msg::GeodeticCoordinates& TrackEstimate::lla() const {
  return lla_ != NULL ? *lla_ : *default_instance_->lla_;
}
inline ::rdr_msg::GeodeticCoordinates* TrackEstimate::mutable_lla() {
  set_has_lla();
  if (lla_ == NULL) lla_ = new ::rdr_msg::GeodeticCoordinates;
  return lla_;
}
inline ::rdr_msg::GeodeticCoordinates* TrackEstimate::release_lla() {
  clear_has_lla();
  ::rdr_msg::GeodeticCoordinates* temp = lla_;
  lla_ = NULL;
  return temp;
}
inline void TrackEstimate::set_allocated_lla(::rdr_msg::GeodeticCoordinates* lla) {
  delete lla_;
  lla_ = lla;
  if (lla) {
    set_has_lla();
  } else {
    clear_has_lla();
  }
}

// optional .rdr_msg.VelocityNED velNED = 5;
inline bool TrackEstimate::has_velned() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrackEstimate::set_has_velned() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrackEstimate::clear_has_velned() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrackEstimate::clear_velned() {
  if (velned_ != NULL) velned_->::rdr_msg::VelocityNED::Clear();
  clear_has_velned();
}
inline const ::rdr_msg::VelocityNED& TrackEstimate::velned() const {
  return velned_ != NULL ? *velned_ : *default_instance_->velned_;
}
inline ::rdr_msg::VelocityNED* TrackEstimate::mutable_velned() {
  set_has_velned();
  if (velned_ == NULL) velned_ = new ::rdr_msg::VelocityNED;
  return velned_;
}
inline ::rdr_msg::VelocityNED* TrackEstimate::release_velned() {
  clear_has_velned();
  ::rdr_msg::VelocityNED* temp = velned_;
  velned_ = NULL;
  return temp;
}
inline void TrackEstimate::set_allocated_velned(::rdr_msg::VelocityNED* velned) {
  delete velned_;
  velned_ = velned;
  if (velned) {
    set_has_velned();
  } else {
    clear_has_velned();
  }
}

// optional float heading = 6;
inline bool TrackEstimate::has_heading() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TrackEstimate::set_has_heading() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TrackEstimate::clear_has_heading() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TrackEstimate::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline float TrackEstimate::heading() const {
  return heading_;
}
inline void TrackEstimate::set_heading(float value) {
  set_has_heading();
  heading_ = value;
}

// optional int64 ts = 7;
inline bool TrackEstimate::has_ts() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TrackEstimate::set_has_ts() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TrackEstimate::clear_has_ts() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TrackEstimate::clear_ts() {
  ts_ = GOOGLE_LONGLONG(0);
  clear_has_ts();
}
inline ::google::protobuf::int64 TrackEstimate::ts() const {
  return ts_;
}
inline void TrackEstimate::set_ts(::google::protobuf::int64 value) {
  set_has_ts();
  ts_ = value;
}

// optional float speed = 8;
inline bool TrackEstimate::has_speed() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TrackEstimate::set_has_speed() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TrackEstimate::clear_has_speed() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TrackEstimate::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline float TrackEstimate::speed() const {
  return speed_;
}
inline void TrackEstimate::set_speed(float value) {
  set_has_speed();
  speed_ = value;
}

// -------------------------------------------------------------------

// RadarMetaData

// optional string msgName = 1 [default = "RADAR_DATA"];
inline bool RadarMetaData::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RadarMetaData::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RadarMetaData::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RadarMetaData::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& RadarMetaData::msgname() const {
  return *msgname_;
}
inline void RadarMetaData::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RadarMetaData::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RadarMetaData::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RadarMetaData::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* RadarMetaData::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void RadarMetaData::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional .rdr_msg.Track track = 2;
inline bool RadarMetaData::has_track() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RadarMetaData::set_has_track() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RadarMetaData::clear_has_track() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RadarMetaData::clear_track() {
  if (track_ != NULL) track_->::rdr_msg::Track::Clear();
  clear_has_track();
}
inline const ::rdr_msg::Track& RadarMetaData::track() const {
  return track_ != NULL ? *track_ : *default_instance_->track_;
}
inline ::rdr_msg::Track* RadarMetaData::mutable_track() {
  set_has_track();
  if (track_ == NULL) track_ = new ::rdr_msg::Track;
  return track_;
}
inline ::rdr_msg::Track* RadarMetaData::release_track() {
  clear_has_track();
  ::rdr_msg::Track* temp = track_;
  track_ = NULL;
  return temp;
}
inline void RadarMetaData::set_allocated_track(::rdr_msg::Track* track) {
  delete track_;
  track_ = track;
  if (track) {
    set_has_track();
  } else {
    clear_has_track();
  }
}

// optional .rdr_msg.TrackEstimate trackEst = 3;
inline bool RadarMetaData::has_trackest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RadarMetaData::set_has_trackest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RadarMetaData::clear_has_trackest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RadarMetaData::clear_trackest() {
  if (trackest_ != NULL) trackest_->::rdr_msg::TrackEstimate::Clear();
  clear_has_trackest();
}
inline const ::rdr_msg::TrackEstimate& RadarMetaData::trackest() const {
  return trackest_ != NULL ? *trackest_ : *default_instance_->trackest_;
}
inline ::rdr_msg::TrackEstimate* RadarMetaData::mutable_trackest() {
  set_has_trackest();
  if (trackest_ == NULL) trackest_ = new ::rdr_msg::TrackEstimate;
  return trackest_;
}
inline ::rdr_msg::TrackEstimate* RadarMetaData::release_trackest() {
  clear_has_trackest();
  ::rdr_msg::TrackEstimate* temp = trackest_;
  trackest_ = NULL;
  return temp;
}
inline void RadarMetaData::set_allocated_trackest(::rdr_msg::TrackEstimate* trackest) {
  delete trackest_;
  trackest_ = trackest;
  if (trackest) {
    set_has_trackest();
  } else {
    clear_has_trackest();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace rdr_msg

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_RADARmessages_2eproto__INCLUDED
