// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: KeplerUIConnectionMessages.proto

#ifndef PROTOBUF_KeplerUIConnectionMessages_2eproto__INCLUDED
#define PROTOBUF_KeplerUIConnectionMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "ServiceInfrastructureCommon.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_KeplerUIConnectionMessages_2eproto();
void protobuf_AssignDesc_KeplerUIConnectionMessages_2eproto();
void protobuf_ShutdownFile_KeplerUIConnectionMessages_2eproto();

class UItoKeplerMessage;
class KeplertoUIMessage;
class UIAck;
class UINack;
class ICDVersionRequest;
class DBVersionRequest;
class ICDVersionResponse;
class DBVersionResponse;
class DBCredentialsRequest;
class DBCredentialsResponse;
class UIConnectRequest;
class UIConnectResponse;
class UIDisconnect;
class UISignalEvent;
class UIVideoRequest;
class UIVideoResponse;
class UIGeoInformationRequest;
class UIGeoInformation;
class UICommandRequest;
class Parameter;
class UIOptionsRequest;
class UIOption;
class UIOptions;
class UIOptionDelete;
class UICeaseBuzzer;
class EWStatus;
class OutputChannelStatus;
class UISetDefaultSchedule;
class KeplerHeartBeat;

enum UINack_ErrorCode {
  UINack_ErrorCode_InvalidMsg = 0,
  UINack_ErrorCode_WrongSeqNum = 1,
  UINack_ErrorCode_UnrecognizedMsg = 2
};
bool UINack_ErrorCode_IsValid(int value);
const UINack_ErrorCode UINack_ErrorCode_ErrorCode_MIN = UINack_ErrorCode_InvalidMsg;
const UINack_ErrorCode UINack_ErrorCode_ErrorCode_MAX = UINack_ErrorCode_UnrecognizedMsg;
const int UINack_ErrorCode_ErrorCode_ARRAYSIZE = UINack_ErrorCode_ErrorCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* UINack_ErrorCode_descriptor();
inline const ::std::string& UINack_ErrorCode_Name(UINack_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    UINack_ErrorCode_descriptor(), value);
}
inline bool UINack_ErrorCode_Parse(
    const ::std::string& name, UINack_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UINack_ErrorCode>(
    UINack_ErrorCode_descriptor(), name, value);
}
enum UISignalEvent_Type {
  UISignalEvent_Type_SIGDET = 0,
  UISignalEvent_Type_SIGUP = 1,
  UISignalEvent_Type_SIGDOWN = 2,
  UISignalEvent_Type_SIGTIMEOUT = 3
};
bool UISignalEvent_Type_IsValid(int value);
const UISignalEvent_Type UISignalEvent_Type_Type_MIN = UISignalEvent_Type_SIGDET;
const UISignalEvent_Type UISignalEvent_Type_Type_MAX = UISignalEvent_Type_SIGTIMEOUT;
const int UISignalEvent_Type_Type_ARRAYSIZE = UISignalEvent_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* UISignalEvent_Type_descriptor();
inline const ::std::string& UISignalEvent_Type_Name(UISignalEvent_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    UISignalEvent_Type_descriptor(), value);
}
inline bool UISignalEvent_Type_Parse(
    const ::std::string& name, UISignalEvent_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UISignalEvent_Type>(
    UISignalEvent_Type_descriptor(), name, value);
}
enum UIOption_DetectionSource {
  UIOption_DetectionSource_EXTERNAL = 0,
  UIOption_DetectionSource_DETECTION = 1,
  UIOption_DetectionSource_EVENT = 2,
  UIOption_DetectionSource_THUNDERBIRD = 3
};
bool UIOption_DetectionSource_IsValid(int value);
const UIOption_DetectionSource UIOption_DetectionSource_DetectionSource_MIN = UIOption_DetectionSource_EXTERNAL;
const UIOption_DetectionSource UIOption_DetectionSource_DetectionSource_MAX = UIOption_DetectionSource_THUNDERBIRD;
const int UIOption_DetectionSource_DetectionSource_ARRAYSIZE = UIOption_DetectionSource_DetectionSource_MAX + 1;

const ::google::protobuf::EnumDescriptor* UIOption_DetectionSource_descriptor();
inline const ::std::string& UIOption_DetectionSource_Name(UIOption_DetectionSource value) {
  return ::google::protobuf::internal::NameOfEnum(
    UIOption_DetectionSource_descriptor(), value);
}
inline bool UIOption_DetectionSource_Parse(
    const ::std::string& name, UIOption_DetectionSource* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UIOption_DetectionSource>(
    UIOption_DetectionSource_descriptor(), name, value);
}
enum OutputChannelStatus_TransmitState {
  OutputChannelStatus_TransmitState_UNAVAILABLE = 0,
  OutputChannelStatus_TransmitState_PENDING = 1,
  OutputChannelStatus_TransmitState_AVAILABLE = 2
};
bool OutputChannelStatus_TransmitState_IsValid(int value);
const OutputChannelStatus_TransmitState OutputChannelStatus_TransmitState_TransmitState_MIN = OutputChannelStatus_TransmitState_UNAVAILABLE;
const OutputChannelStatus_TransmitState OutputChannelStatus_TransmitState_TransmitState_MAX = OutputChannelStatus_TransmitState_AVAILABLE;
const int OutputChannelStatus_TransmitState_TransmitState_ARRAYSIZE = OutputChannelStatus_TransmitState_TransmitState_MAX + 1;

const ::google::protobuf::EnumDescriptor* OutputChannelStatus_TransmitState_descriptor();
inline const ::std::string& OutputChannelStatus_TransmitState_Name(OutputChannelStatus_TransmitState value) {
  return ::google::protobuf::internal::NameOfEnum(
    OutputChannelStatus_TransmitState_descriptor(), value);
}
inline bool OutputChannelStatus_TransmitState_Parse(
    const ::std::string& name, OutputChannelStatus_TransmitState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OutputChannelStatus_TransmitState>(
    OutputChannelStatus_TransmitState_descriptor(), name, value);
}
// ===================================================================

class UItoKeplerMessage : public ::google::protobuf::Message {
 public:
  UItoKeplerMessage();
  virtual ~UItoKeplerMessage();

  UItoKeplerMessage(const UItoKeplerMessage& from);

  inline UItoKeplerMessage& operator=(const UItoKeplerMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UItoKeplerMessage& default_instance();

  void Swap(UItoKeplerMessage* other);

  // implements Message ----------------------------------------------

  UItoKeplerMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UItoKeplerMessage& from);
  void MergeFrom(const UItoKeplerMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 100;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 100;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional .UIAck msgUIAck = 4;
  inline bool has_msguiack() const;
  inline void clear_msguiack();
  static const int kMsgUIAckFieldNumber = 4;
  inline const ::UIAck& msguiack() const;
  inline ::UIAck* mutable_msguiack();
  inline ::UIAck* release_msguiack();
  inline void set_allocated_msguiack(::UIAck* msguiack);

  // optional .UINack msgUINack = 5;
  inline bool has_msguinack() const;
  inline void clear_msguinack();
  static const int kMsgUINackFieldNumber = 5;
  inline const ::UINack& msguinack() const;
  inline ::UINack* mutable_msguinack();
  inline ::UINack* release_msguinack();
  inline void set_allocated_msguinack(::UINack* msguinack);

  // optional .ICDVersionRequest msgICDVersionRequest = 6;
  inline bool has_msgicdversionrequest() const;
  inline void clear_msgicdversionrequest();
  static const int kMsgICDVersionRequestFieldNumber = 6;
  inline const ::ICDVersionRequest& msgicdversionrequest() const;
  inline ::ICDVersionRequest* mutable_msgicdversionrequest();
  inline ::ICDVersionRequest* release_msgicdversionrequest();
  inline void set_allocated_msgicdversionrequest(::ICDVersionRequest* msgicdversionrequest);

  // optional .DBVersionRequest msgDBVersionRequest = 7;
  inline bool has_msgdbversionrequest() const;
  inline void clear_msgdbversionrequest();
  static const int kMsgDBVersionRequestFieldNumber = 7;
  inline const ::DBVersionRequest& msgdbversionrequest() const;
  inline ::DBVersionRequest* mutable_msgdbversionrequest();
  inline ::DBVersionRequest* release_msgdbversionrequest();
  inline void set_allocated_msgdbversionrequest(::DBVersionRequest* msgdbversionrequest);

  // optional .DBCredentialsRequest msgDBCredentialsRequest = 8;
  inline bool has_msgdbcredentialsrequest() const;
  inline void clear_msgdbcredentialsrequest();
  static const int kMsgDBCredentialsRequestFieldNumber = 8;
  inline const ::DBCredentialsRequest& msgdbcredentialsrequest() const;
  inline ::DBCredentialsRequest* mutable_msgdbcredentialsrequest();
  inline ::DBCredentialsRequest* release_msgdbcredentialsrequest();
  inline void set_allocated_msgdbcredentialsrequest(::DBCredentialsRequest* msgdbcredentialsrequest);

  // optional .UIConnectRequest msgUIConnectRequest = 9;
  inline bool has_msguiconnectrequest() const;
  inline void clear_msguiconnectrequest();
  static const int kMsgUIConnectRequestFieldNumber = 9;
  inline const ::UIConnectRequest& msguiconnectrequest() const;
  inline ::UIConnectRequest* mutable_msguiconnectrequest();
  inline ::UIConnectRequest* release_msguiconnectrequest();
  inline void set_allocated_msguiconnectrequest(::UIConnectRequest* msguiconnectrequest);

  // optional .UIDisconnect msgUIDisconnect = 10;
  inline bool has_msguidisconnect() const;
  inline void clear_msguidisconnect();
  static const int kMsgUIDisconnectFieldNumber = 10;
  inline const ::UIDisconnect& msguidisconnect() const;
  inline ::UIDisconnect* mutable_msguidisconnect();
  inline ::UIDisconnect* release_msguidisconnect();
  inline void set_allocated_msguidisconnect(::UIDisconnect* msguidisconnect);

  // optional .UIVideoRequest msgUIVideoRequest = 11;
  inline bool has_msguivideorequest() const;
  inline void clear_msguivideorequest();
  static const int kMsgUIVideoRequestFieldNumber = 11;
  inline const ::UIVideoRequest& msguivideorequest() const;
  inline ::UIVideoRequest* mutable_msguivideorequest();
  inline ::UIVideoRequest* release_msguivideorequest();
  inline void set_allocated_msguivideorequest(::UIVideoRequest* msguivideorequest);

  // optional .UIGeoInformationRequest msgUIGeoInformationRequest = 12;
  inline bool has_msguigeoinformationrequest() const;
  inline void clear_msguigeoinformationrequest();
  static const int kMsgUIGeoInformationRequestFieldNumber = 12;
  inline const ::UIGeoInformationRequest& msguigeoinformationrequest() const;
  inline ::UIGeoInformationRequest* mutable_msguigeoinformationrequest();
  inline ::UIGeoInformationRequest* release_msguigeoinformationrequest();
  inline void set_allocated_msguigeoinformationrequest(::UIGeoInformationRequest* msguigeoinformationrequest);

  // optional .UICommandRequest msgUICommandRequest = 13;
  inline bool has_msguicommandrequest() const;
  inline void clear_msguicommandrequest();
  static const int kMsgUICommandRequestFieldNumber = 13;
  inline const ::UICommandRequest& msguicommandrequest() const;
  inline ::UICommandRequest* mutable_msguicommandrequest();
  inline ::UICommandRequest* release_msguicommandrequest();
  inline void set_allocated_msguicommandrequest(::UICommandRequest* msguicommandrequest);

  // optional .UICeaseBuzzer msgUICeaseBuzzer = 14;
  inline bool has_msguiceasebuzzer() const;
  inline void clear_msguiceasebuzzer();
  static const int kMsgUICeaseBuzzerFieldNumber = 14;
  inline const ::UICeaseBuzzer& msguiceasebuzzer() const;
  inline ::UICeaseBuzzer* mutable_msguiceasebuzzer();
  inline ::UICeaseBuzzer* release_msguiceasebuzzer();
  inline void set_allocated_msguiceasebuzzer(::UICeaseBuzzer* msguiceasebuzzer);

  // optional .UISetDefaultSchedule msgUISetDefaultSchedule = 15;
  inline bool has_msguisetdefaultschedule() const;
  inline void clear_msguisetdefaultschedule();
  static const int kMsgUISetDefaultScheduleFieldNumber = 15;
  inline const ::UISetDefaultSchedule& msguisetdefaultschedule() const;
  inline ::UISetDefaultSchedule* mutable_msguisetdefaultschedule();
  inline ::UISetDefaultSchedule* release_msguisetdefaultschedule();
  inline void set_allocated_msguisetdefaultschedule(::UISetDefaultSchedule* msguisetdefaultschedule);

  // optional .UIOptionsRequest msgUIOptionsRequest = 16;
  inline bool has_msguioptionsrequest() const;
  inline void clear_msguioptionsrequest();
  static const int kMsgUIOptionsRequestFieldNumber = 16;
  inline const ::UIOptionsRequest& msguioptionsrequest() const;
  inline ::UIOptionsRequest* mutable_msguioptionsrequest();
  inline ::UIOptionsRequest* release_msguioptionsrequest();
  inline void set_allocated_msguioptionsrequest(::UIOptionsRequest* msguioptionsrequest);

  // @@protoc_insertion_point(class_scope:UItoKeplerMessage)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_msguiack();
  inline void clear_has_msguiack();
  inline void set_has_msguinack();
  inline void clear_has_msguinack();
  inline void set_has_msgicdversionrequest();
  inline void clear_has_msgicdversionrequest();
  inline void set_has_msgdbversionrequest();
  inline void clear_has_msgdbversionrequest();
  inline void set_has_msgdbcredentialsrequest();
  inline void clear_has_msgdbcredentialsrequest();
  inline void set_has_msguiconnectrequest();
  inline void clear_has_msguiconnectrequest();
  inline void set_has_msguidisconnect();
  inline void clear_has_msguidisconnect();
  inline void set_has_msguivideorequest();
  inline void clear_has_msguivideorequest();
  inline void set_has_msguigeoinformationrequest();
  inline void clear_has_msguigeoinformationrequest();
  inline void set_has_msguicommandrequest();
  inline void clear_has_msguicommandrequest();
  inline void set_has_msguiceasebuzzer();
  inline void clear_has_msguiceasebuzzer();
  inline void set_has_msguisetdefaultschedule();
  inline void clear_has_msguisetdefaultschedule();
  inline void set_has_msguioptionsrequest();
  inline void clear_has_msguioptionsrequest();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::UIAck* msguiack_;
  ::UINack* msguinack_;
  ::ICDVersionRequest* msgicdversionrequest_;
  ::DBVersionRequest* msgdbversionrequest_;
  ::DBCredentialsRequest* msgdbcredentialsrequest_;
  ::UIConnectRequest* msguiconnectrequest_;
  ::UIDisconnect* msguidisconnect_;
  ::UIVideoRequest* msguivideorequest_;
  ::UIGeoInformationRequest* msguigeoinformationrequest_;
  ::UICommandRequest* msguicommandrequest_;
  ::UICeaseBuzzer* msguiceasebuzzer_;
  ::UISetDefaultSchedule* msguisetdefaultschedule_;
  ::UIOptionsRequest* msguioptionsrequest_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_AssignDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_ShutdownFile_KeplerUIConnectionMessages_2eproto();

  void InitAsDefaultInstance();
  static UItoKeplerMessage* default_instance_;
};
// -------------------------------------------------------------------

class KeplertoUIMessage : public ::google::protobuf::Message {
 public:
  KeplertoUIMessage();
  virtual ~KeplertoUIMessage();

  KeplertoUIMessage(const KeplertoUIMessage& from);

  inline KeplertoUIMessage& operator=(const KeplertoUIMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeplertoUIMessage& default_instance();

  void Swap(KeplertoUIMessage* other);

  // implements Message ----------------------------------------------

  KeplertoUIMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeplertoUIMessage& from);
  void MergeFrom(const KeplertoUIMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 100;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 100;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional .UIAck msgUIAck = 4;
  inline bool has_msguiack() const;
  inline void clear_msguiack();
  static const int kMsgUIAckFieldNumber = 4;
  inline const ::UIAck& msguiack() const;
  inline ::UIAck* mutable_msguiack();
  inline ::UIAck* release_msguiack();
  inline void set_allocated_msguiack(::UIAck* msguiack);

  // optional .UINack msgUINack = 5;
  inline bool has_msguinack() const;
  inline void clear_msguinack();
  static const int kMsgUINackFieldNumber = 5;
  inline const ::UINack& msguinack() const;
  inline ::UINack* mutable_msguinack();
  inline ::UINack* release_msguinack();
  inline void set_allocated_msguinack(::UINack* msguinack);

  // optional .ICDVersionResponse msgICDVersionResponse = 6;
  inline bool has_msgicdversionresponse() const;
  inline void clear_msgicdversionresponse();
  static const int kMsgICDVersionResponseFieldNumber = 6;
  inline const ::ICDVersionResponse& msgicdversionresponse() const;
  inline ::ICDVersionResponse* mutable_msgicdversionresponse();
  inline ::ICDVersionResponse* release_msgicdversionresponse();
  inline void set_allocated_msgicdversionresponse(::ICDVersionResponse* msgicdversionresponse);

  // optional .DBVersionResponse msgDBVersionResponse = 7;
  inline bool has_msgdbversionresponse() const;
  inline void clear_msgdbversionresponse();
  static const int kMsgDBVersionResponseFieldNumber = 7;
  inline const ::DBVersionResponse& msgdbversionresponse() const;
  inline ::DBVersionResponse* mutable_msgdbversionresponse();
  inline ::DBVersionResponse* release_msgdbversionresponse();
  inline void set_allocated_msgdbversionresponse(::DBVersionResponse* msgdbversionresponse);

  // optional .DBCredentialsResponse msgDBCredentialsResponse = 8;
  inline bool has_msgdbcredentialsresponse() const;
  inline void clear_msgdbcredentialsresponse();
  static const int kMsgDBCredentialsResponseFieldNumber = 8;
  inline const ::DBCredentialsResponse& msgdbcredentialsresponse() const;
  inline ::DBCredentialsResponse* mutable_msgdbcredentialsresponse();
  inline ::DBCredentialsResponse* release_msgdbcredentialsresponse();
  inline void set_allocated_msgdbcredentialsresponse(::DBCredentialsResponse* msgdbcredentialsresponse);

  // optional .UIConnectResponse msgUIConnectResponse = 9;
  inline bool has_msguiconnectresponse() const;
  inline void clear_msguiconnectresponse();
  static const int kMsgUIConnectResponseFieldNumber = 9;
  inline const ::UIConnectResponse& msguiconnectresponse() const;
  inline ::UIConnectResponse* mutable_msguiconnectresponse();
  inline ::UIConnectResponse* release_msguiconnectresponse();
  inline void set_allocated_msguiconnectresponse(::UIConnectResponse* msguiconnectresponse);

  // optional .UISignalEvent msgUISignalEvent = 10;
  inline bool has_msguisignalevent() const;
  inline void clear_msguisignalevent();
  static const int kMsgUISignalEventFieldNumber = 10;
  inline const ::UISignalEvent& msguisignalevent() const;
  inline ::UISignalEvent* mutable_msguisignalevent();
  inline ::UISignalEvent* release_msguisignalevent();
  inline void set_allocated_msguisignalevent(::UISignalEvent* msguisignalevent);

  // optional .UIVideoResponse msgUIVideoResponse = 11;
  inline bool has_msguivideoresponse() const;
  inline void clear_msguivideoresponse();
  static const int kMsgUIVideoResponseFieldNumber = 11;
  inline const ::UIVideoResponse& msguivideoresponse() const;
  inline ::UIVideoResponse* mutable_msguivideoresponse();
  inline ::UIVideoResponse* release_msguivideoresponse();
  inline void set_allocated_msguivideoresponse(::UIVideoResponse* msguivideoresponse);

  // optional .UIGeoInformation msgUIGeoInformation = 12;
  inline bool has_msguigeoinformation() const;
  inline void clear_msguigeoinformation();
  static const int kMsgUIGeoInformationFieldNumber = 12;
  inline const ::UIGeoInformation& msguigeoinformation() const;
  inline ::UIGeoInformation* mutable_msguigeoinformation();
  inline ::UIGeoInformation* release_msguigeoinformation();
  inline void set_allocated_msguigeoinformation(::UIGeoInformation* msguigeoinformation);

  // optional .UIOptions msgUIOptions = 13;
  inline bool has_msguioptions() const;
  inline void clear_msguioptions();
  static const int kMsgUIOptionsFieldNumber = 13;
  inline const ::UIOptions& msguioptions() const;
  inline ::UIOptions* mutable_msguioptions();
  inline ::UIOptions* release_msguioptions();
  inline void set_allocated_msguioptions(::UIOptions* msguioptions);

  // optional .UIOptionDelete msgUIOptionDelete = 14;
  inline bool has_msguioptiondelete() const;
  inline void clear_msguioptiondelete();
  static const int kMsgUIOptionDeleteFieldNumber = 14;
  inline const ::UIOptionDelete& msguioptiondelete() const;
  inline ::UIOptionDelete* mutable_msguioptiondelete();
  inline ::UIOptionDelete* release_msguioptiondelete();
  inline void set_allocated_msguioptiondelete(::UIOptionDelete* msguioptiondelete);

  // optional .EWStatus msgEWStatus = 15;
  inline bool has_msgewstatus() const;
  inline void clear_msgewstatus();
  static const int kMsgEWStatusFieldNumber = 15;
  inline const ::EWStatus& msgewstatus() const;
  inline ::EWStatus* mutable_msgewstatus();
  inline ::EWStatus* release_msgewstatus();
  inline void set_allocated_msgewstatus(::EWStatus* msgewstatus);

  // optional .KeplerHeartBeat msgKeplerHeartBeat = 16;
  inline bool has_msgkeplerheartbeat() const;
  inline void clear_msgkeplerheartbeat();
  static const int kMsgKeplerHeartBeatFieldNumber = 16;
  inline const ::KeplerHeartBeat& msgkeplerheartbeat() const;
  inline ::KeplerHeartBeat* mutable_msgkeplerheartbeat();
  inline ::KeplerHeartBeat* release_msgkeplerheartbeat();
  inline void set_allocated_msgkeplerheartbeat(::KeplerHeartBeat* msgkeplerheartbeat);

  // @@protoc_insertion_point(class_scope:KeplertoUIMessage)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_msguiack();
  inline void clear_has_msguiack();
  inline void set_has_msguinack();
  inline void clear_has_msguinack();
  inline void set_has_msgicdversionresponse();
  inline void clear_has_msgicdversionresponse();
  inline void set_has_msgdbversionresponse();
  inline void clear_has_msgdbversionresponse();
  inline void set_has_msgdbcredentialsresponse();
  inline void clear_has_msgdbcredentialsresponse();
  inline void set_has_msguiconnectresponse();
  inline void clear_has_msguiconnectresponse();
  inline void set_has_msguisignalevent();
  inline void clear_has_msguisignalevent();
  inline void set_has_msguivideoresponse();
  inline void clear_has_msguivideoresponse();
  inline void set_has_msguigeoinformation();
  inline void clear_has_msguigeoinformation();
  inline void set_has_msguioptions();
  inline void clear_has_msguioptions();
  inline void set_has_msguioptiondelete();
  inline void clear_has_msguioptiondelete();
  inline void set_has_msgewstatus();
  inline void clear_has_msgewstatus();
  inline void set_has_msgkeplerheartbeat();
  inline void clear_has_msgkeplerheartbeat();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::UIAck* msguiack_;
  ::UINack* msguinack_;
  ::ICDVersionResponse* msgicdversionresponse_;
  ::DBVersionResponse* msgdbversionresponse_;
  ::DBCredentialsResponse* msgdbcredentialsresponse_;
  ::UIConnectResponse* msguiconnectresponse_;
  ::UISignalEvent* msguisignalevent_;
  ::UIVideoResponse* msguivideoresponse_;
  ::UIGeoInformation* msguigeoinformation_;
  ::UIOptions* msguioptions_;
  ::UIOptionDelete* msguioptiondelete_;
  ::EWStatus* msgewstatus_;
  ::KeplerHeartBeat* msgkeplerheartbeat_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_AssignDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_ShutdownFile_KeplerUIConnectionMessages_2eproto();

  void InitAsDefaultInstance();
  static KeplertoUIMessage* default_instance_;
};
// -------------------------------------------------------------------

class UIAck : public ::google::protobuf::Message {
 public:
  UIAck();
  virtual ~UIAck();

  UIAck(const UIAck& from);

  inline UIAck& operator=(const UIAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIAck& default_instance();

  void Swap(UIAck* other);

  // implements Message ----------------------------------------------

  UIAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIAck& from);
  void MergeFrom(const UIAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "UIAck"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int64 seqNumber = 2;
  inline bool has_seqnumber() const;
  inline void clear_seqnumber();
  static const int kSeqNumberFieldNumber = 2;
  inline ::google::protobuf::int64 seqnumber() const;
  inline void set_seqnumber(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:UIAck)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_seqnumber();
  inline void clear_has_seqnumber();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int64 seqnumber_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_AssignDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_ShutdownFile_KeplerUIConnectionMessages_2eproto();

  void InitAsDefaultInstance();
  static UIAck* default_instance_;
};
// -------------------------------------------------------------------

class UINack : public ::google::protobuf::Message {
 public:
  UINack();
  virtual ~UINack();

  UINack(const UINack& from);

  inline UINack& operator=(const UINack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UINack& default_instance();

  void Swap(UINack* other);

  // implements Message ----------------------------------------------

  UINack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UINack& from);
  void MergeFrom(const UINack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef UINack_ErrorCode ErrorCode;
  static const ErrorCode InvalidMsg = UINack_ErrorCode_InvalidMsg;
  static const ErrorCode WrongSeqNum = UINack_ErrorCode_WrongSeqNum;
  static const ErrorCode UnrecognizedMsg = UINack_ErrorCode_UnrecognizedMsg;
  static inline bool ErrorCode_IsValid(int value) {
    return UINack_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    UINack_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    UINack_ErrorCode_ErrorCode_MAX;
  static const int ErrorCode_ARRAYSIZE =
    UINack_ErrorCode_ErrorCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorCode_descriptor() {
    return UINack_ErrorCode_descriptor();
  }
  static inline const ::std::string& ErrorCode_Name(ErrorCode value) {
    return UINack_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(const ::std::string& name,
      ErrorCode* value) {
    return UINack_ErrorCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "UINack"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 seqNumber = 2;
  inline bool has_seqnumber() const;
  inline void clear_seqnumber();
  static const int kSeqNumberFieldNumber = 2;
  inline ::google::protobuf::int32 seqnumber() const;
  inline void set_seqnumber(::google::protobuf::int32 value);

  // optional .UINack.ErrorCode errorCode = 3;
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 3;
  inline ::UINack_ErrorCode errorcode() const;
  inline void set_errorcode(::UINack_ErrorCode value);

  // optional string reason = 4;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 4;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const char* value, size_t size);
  inline ::std::string* mutable_reason();
  inline ::std::string* release_reason();
  inline void set_allocated_reason(::std::string* reason);

  // @@protoc_insertion_point(class_scope:UINack)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_seqnumber();
  inline void clear_has_seqnumber();
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_reason();
  inline void clear_has_reason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 seqnumber_;
  int errorcode_;
  ::std::string* reason_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_AssignDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_ShutdownFile_KeplerUIConnectionMessages_2eproto();

  void InitAsDefaultInstance();
  static UINack* default_instance_;
};
// -------------------------------------------------------------------

class ICDVersionRequest : public ::google::protobuf::Message {
 public:
  ICDVersionRequest();
  virtual ~ICDVersionRequest();

  ICDVersionRequest(const ICDVersionRequest& from);

  inline ICDVersionRequest& operator=(const ICDVersionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ICDVersionRequest& default_instance();

  void Swap(ICDVersionRequest* other);

  // implements Message ----------------------------------------------

  ICDVersionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ICDVersionRequest& from);
  void MergeFrom(const ICDVersionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ICDVersionRequest"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string senderName = 2;
  inline bool has_sendername() const;
  inline void clear_sendername();
  static const int kSenderNameFieldNumber = 2;
  inline const ::std::string& sendername() const;
  inline void set_sendername(const ::std::string& value);
  inline void set_sendername(const char* value);
  inline void set_sendername(const char* value, size_t size);
  inline ::std::string* mutable_sendername();
  inline ::std::string* release_sendername();
  inline void set_allocated_sendername(::std::string* sendername);

  // @@protoc_insertion_point(class_scope:ICDVersionRequest)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_sendername();
  inline void clear_has_sendername();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* sendername_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_AssignDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_ShutdownFile_KeplerUIConnectionMessages_2eproto();

  void InitAsDefaultInstance();
  static ICDVersionRequest* default_instance_;
};
// -------------------------------------------------------------------

class DBVersionRequest : public ::google::protobuf::Message {
 public:
  DBVersionRequest();
  virtual ~DBVersionRequest();

  DBVersionRequest(const DBVersionRequest& from);

  inline DBVersionRequest& operator=(const DBVersionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DBVersionRequest& default_instance();

  void Swap(DBVersionRequest* other);

  // implements Message ----------------------------------------------

  DBVersionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DBVersionRequest& from);
  void MergeFrom(const DBVersionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "DBVersionRequest"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string senderName = 2;
  inline bool has_sendername() const;
  inline void clear_sendername();
  static const int kSenderNameFieldNumber = 2;
  inline const ::std::string& sendername() const;
  inline void set_sendername(const ::std::string& value);
  inline void set_sendername(const char* value);
  inline void set_sendername(const char* value, size_t size);
  inline ::std::string* mutable_sendername();
  inline ::std::string* release_sendername();
  inline void set_allocated_sendername(::std::string* sendername);

  // @@protoc_insertion_point(class_scope:DBVersionRequest)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_sendername();
  inline void clear_has_sendername();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* sendername_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_AssignDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_ShutdownFile_KeplerUIConnectionMessages_2eproto();

  void InitAsDefaultInstance();
  static DBVersionRequest* default_instance_;
};
// -------------------------------------------------------------------

class ICDVersionResponse : public ::google::protobuf::Message {
 public:
  ICDVersionResponse();
  virtual ~ICDVersionResponse();

  ICDVersionResponse(const ICDVersionResponse& from);

  inline ICDVersionResponse& operator=(const ICDVersionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ICDVersionResponse& default_instance();

  void Swap(ICDVersionResponse* other);

  // implements Message ----------------------------------------------

  ICDVersionResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ICDVersionResponse& from);
  void MergeFrom(const ICDVersionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ICDVersionResponse"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int64 major = 2 [default = 0];
  inline bool has_major() const;
  inline void clear_major();
  static const int kMajorFieldNumber = 2;
  inline ::google::protobuf::int64 major() const;
  inline void set_major(::google::protobuf::int64 value);

  // optional int64 minor = 3 [default = 0];
  inline bool has_minor() const;
  inline void clear_minor();
  static const int kMinorFieldNumber = 3;
  inline ::google::protobuf::int64 minor() const;
  inline void set_minor(::google::protobuf::int64 value);

  // optional int64 patch = 4 [default = 1];
  inline bool has_patch() const;
  inline void clear_patch();
  static const int kPatchFieldNumber = 4;
  inline ::google::protobuf::int64 patch() const;
  inline void set_patch(::google::protobuf::int64 value);

  // optional string date = 5;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 5;
  inline const ::std::string& date() const;
  inline void set_date(const ::std::string& value);
  inline void set_date(const char* value);
  inline void set_date(const char* value, size_t size);
  inline ::std::string* mutable_date();
  inline ::std::string* release_date();
  inline void set_allocated_date(::std::string* date);

  // optional string info = 6;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 6;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const char* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  inline void set_allocated_info(::std::string* info);

  // @@protoc_insertion_point(class_scope:ICDVersionResponse)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_major();
  inline void clear_has_major();
  inline void set_has_minor();
  inline void clear_has_minor();
  inline void set_has_patch();
  inline void clear_has_patch();
  inline void set_has_date();
  inline void clear_has_date();
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int64 major_;
  ::google::protobuf::int64 minor_;
  ::google::protobuf::int64 patch_;
  ::std::string* date_;
  ::std::string* info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_AssignDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_ShutdownFile_KeplerUIConnectionMessages_2eproto();

  void InitAsDefaultInstance();
  static ICDVersionResponse* default_instance_;
};
// -------------------------------------------------------------------

class DBVersionResponse : public ::google::protobuf::Message {
 public:
  DBVersionResponse();
  virtual ~DBVersionResponse();

  DBVersionResponse(const DBVersionResponse& from);

  inline DBVersionResponse& operator=(const DBVersionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DBVersionResponse& default_instance();

  void Swap(DBVersionResponse* other);

  // implements Message ----------------------------------------------

  DBVersionResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DBVersionResponse& from);
  void MergeFrom(const DBVersionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "DBVersionResponse"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int64 major = 2 [default = 0];
  inline bool has_major() const;
  inline void clear_major();
  static const int kMajorFieldNumber = 2;
  inline ::google::protobuf::int64 major() const;
  inline void set_major(::google::protobuf::int64 value);

  // optional int64 minor = 3 [default = 0];
  inline bool has_minor() const;
  inline void clear_minor();
  static const int kMinorFieldNumber = 3;
  inline ::google::protobuf::int64 minor() const;
  inline void set_minor(::google::protobuf::int64 value);

  // optional int64 patch = 4 [default = 1];
  inline bool has_patch() const;
  inline void clear_patch();
  static const int kPatchFieldNumber = 4;
  inline ::google::protobuf::int64 patch() const;
  inline void set_patch(::google::protobuf::int64 value);

  // optional string date = 5;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 5;
  inline const ::std::string& date() const;
  inline void set_date(const ::std::string& value);
  inline void set_date(const char* value);
  inline void set_date(const char* value, size_t size);
  inline ::std::string* mutable_date();
  inline ::std::string* release_date();
  inline void set_allocated_date(::std::string* date);

  // optional string info = 6;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 6;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const char* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  inline void set_allocated_info(::std::string* info);

  // @@protoc_insertion_point(class_scope:DBVersionResponse)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_major();
  inline void clear_has_major();
  inline void set_has_minor();
  inline void clear_has_minor();
  inline void set_has_patch();
  inline void clear_has_patch();
  inline void set_has_date();
  inline void clear_has_date();
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int64 major_;
  ::google::protobuf::int64 minor_;
  ::google::protobuf::int64 patch_;
  ::std::string* date_;
  ::std::string* info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_AssignDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_ShutdownFile_KeplerUIConnectionMessages_2eproto();

  void InitAsDefaultInstance();
  static DBVersionResponse* default_instance_;
};
// -------------------------------------------------------------------

class DBCredentialsRequest : public ::google::protobuf::Message {
 public:
  DBCredentialsRequest();
  virtual ~DBCredentialsRequest();

  DBCredentialsRequest(const DBCredentialsRequest& from);

  inline DBCredentialsRequest& operator=(const DBCredentialsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DBCredentialsRequest& default_instance();

  void Swap(DBCredentialsRequest* other);

  // implements Message ----------------------------------------------

  DBCredentialsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DBCredentialsRequest& from);
  void MergeFrom(const DBCredentialsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "DBCredentialsRequest"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string senderName = 2;
  inline bool has_sendername() const;
  inline void clear_sendername();
  static const int kSenderNameFieldNumber = 2;
  inline const ::std::string& sendername() const;
  inline void set_sendername(const ::std::string& value);
  inline void set_sendername(const char* value);
  inline void set_sendername(const char* value, size_t size);
  inline ::std::string* mutable_sendername();
  inline ::std::string* release_sendername();
  inline void set_allocated_sendername(::std::string* sendername);

  // @@protoc_insertion_point(class_scope:DBCredentialsRequest)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_sendername();
  inline void clear_has_sendername();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* sendername_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_AssignDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_ShutdownFile_KeplerUIConnectionMessages_2eproto();

  void InitAsDefaultInstance();
  static DBCredentialsRequest* default_instance_;
};
// -------------------------------------------------------------------

class DBCredentialsResponse : public ::google::protobuf::Message {
 public:
  DBCredentialsResponse();
  virtual ~DBCredentialsResponse();

  DBCredentialsResponse(const DBCredentialsResponse& from);

  inline DBCredentialsResponse& operator=(const DBCredentialsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DBCredentialsResponse& default_instance();

  void Swap(DBCredentialsResponse* other);

  // implements Message ----------------------------------------------

  DBCredentialsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DBCredentialsResponse& from);
  void MergeFrom(const DBCredentialsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "DBCredentialsResponse"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string hostName = 2;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostNameFieldNumber = 2;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional string ip = 3;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 3;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional string dbName = 4;
  inline bool has_dbname() const;
  inline void clear_dbname();
  static const int kDbNameFieldNumber = 4;
  inline const ::std::string& dbname() const;
  inline void set_dbname(const ::std::string& value);
  inline void set_dbname(const char* value);
  inline void set_dbname(const char* value, size_t size);
  inline ::std::string* mutable_dbname();
  inline ::std::string* release_dbname();
  inline void set_allocated_dbname(::std::string* dbname);

  // optional string dbUser = 5;
  inline bool has_dbuser() const;
  inline void clear_dbuser();
  static const int kDbUserFieldNumber = 5;
  inline const ::std::string& dbuser() const;
  inline void set_dbuser(const ::std::string& value);
  inline void set_dbuser(const char* value);
  inline void set_dbuser(const char* value, size_t size);
  inline ::std::string* mutable_dbuser();
  inline ::std::string* release_dbuser();
  inline void set_allocated_dbuser(::std::string* dbuser);

  // optional string dbPassword = 6;
  inline bool has_dbpassword() const;
  inline void clear_dbpassword();
  static const int kDbPasswordFieldNumber = 6;
  inline const ::std::string& dbpassword() const;
  inline void set_dbpassword(const ::std::string& value);
  inline void set_dbpassword(const char* value);
  inline void set_dbpassword(const char* value, size_t size);
  inline ::std::string* mutable_dbpassword();
  inline ::std::string* release_dbpassword();
  inline void set_allocated_dbpassword(::std::string* dbpassword);

  // optional string dbPort = 7;
  inline bool has_dbport() const;
  inline void clear_dbport();
  static const int kDbPortFieldNumber = 7;
  inline const ::std::string& dbport() const;
  inline void set_dbport(const ::std::string& value);
  inline void set_dbport(const char* value);
  inline void set_dbport(const char* value, size_t size);
  inline ::std::string* mutable_dbport();
  inline ::std::string* release_dbport();
  inline void set_allocated_dbport(::std::string* dbport);

  // @@protoc_insertion_point(class_scope:DBCredentialsResponse)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_dbname();
  inline void clear_has_dbname();
  inline void set_has_dbuser();
  inline void clear_has_dbuser();
  inline void set_has_dbpassword();
  inline void clear_has_dbpassword();
  inline void set_has_dbport();
  inline void clear_has_dbport();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* hostname_;
  ::std::string* ip_;
  ::std::string* dbname_;
  ::std::string* dbuser_;
  ::std::string* dbpassword_;
  ::std::string* dbport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_AssignDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_ShutdownFile_KeplerUIConnectionMessages_2eproto();

  void InitAsDefaultInstance();
  static DBCredentialsResponse* default_instance_;
};
// -------------------------------------------------------------------

class UIConnectRequest : public ::google::protobuf::Message {
 public:
  UIConnectRequest();
  virtual ~UIConnectRequest();

  UIConnectRequest(const UIConnectRequest& from);

  inline UIConnectRequest& operator=(const UIConnectRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIConnectRequest& default_instance();

  void Swap(UIConnectRequest* other);

  // implements Message ----------------------------------------------

  UIConnectRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIConnectRequest& from);
  void MergeFrom(const UIConnectRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "UIConnectRequest"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string senderName = 2;
  inline bool has_sendername() const;
  inline void clear_sendername();
  static const int kSenderNameFieldNumber = 2;
  inline const ::std::string& sendername() const;
  inline void set_sendername(const ::std::string& value);
  inline void set_sendername(const char* value);
  inline void set_sendername(const char* value, size_t size);
  inline ::std::string* mutable_sendername();
  inline ::std::string* release_sendername();
  inline void set_allocated_sendername(::std::string* sendername);

  // @@protoc_insertion_point(class_scope:UIConnectRequest)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_sendername();
  inline void clear_has_sendername();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* sendername_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_AssignDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_ShutdownFile_KeplerUIConnectionMessages_2eproto();

  void InitAsDefaultInstance();
  static UIConnectRequest* default_instance_;
};
// -------------------------------------------------------------------

class UIConnectResponse : public ::google::protobuf::Message {
 public:
  UIConnectResponse();
  virtual ~UIConnectResponse();

  UIConnectResponse(const UIConnectResponse& from);

  inline UIConnectResponse& operator=(const UIConnectResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIConnectResponse& default_instance();

  void Swap(UIConnectResponse* other);

  // implements Message ----------------------------------------------

  UIConnectResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIConnectResponse& from);
  void MergeFrom(const UIConnectResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "UIConnectResponse"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string connectionID = 2 [default = "defaultConnectionID"];
  inline bool has_connectionid() const;
  inline void clear_connectionid();
  static const int kConnectionIDFieldNumber = 2;
  inline const ::std::string& connectionid() const;
  inline void set_connectionid(const ::std::string& value);
  inline void set_connectionid(const char* value);
  inline void set_connectionid(const char* value, size_t size);
  inline ::std::string* mutable_connectionid();
  inline ::std::string* release_connectionid();
  inline void set_allocated_connectionid(::std::string* connectionid);

  // @@protoc_insertion_point(class_scope:UIConnectResponse)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_connectionid();
  inline void clear_has_connectionid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* connectionid_;
  static ::std::string* _default_connectionid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_AssignDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_ShutdownFile_KeplerUIConnectionMessages_2eproto();

  void InitAsDefaultInstance();
  static UIConnectResponse* default_instance_;
};
// -------------------------------------------------------------------

class UIDisconnect : public ::google::protobuf::Message {
 public:
  UIDisconnect();
  virtual ~UIDisconnect();

  UIDisconnect(const UIDisconnect& from);

  inline UIDisconnect& operator=(const UIDisconnect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIDisconnect& default_instance();

  void Swap(UIDisconnect* other);

  // implements Message ----------------------------------------------

  UIDisconnect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIDisconnect& from);
  void MergeFrom(const UIDisconnect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "UIDisconnect"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string senderName = 2;
  inline bool has_sendername() const;
  inline void clear_sendername();
  static const int kSenderNameFieldNumber = 2;
  inline const ::std::string& sendername() const;
  inline void set_sendername(const ::std::string& value);
  inline void set_sendername(const char* value);
  inline void set_sendername(const char* value, size_t size);
  inline ::std::string* mutable_sendername();
  inline ::std::string* release_sendername();
  inline void set_allocated_sendername(::std::string* sendername);

  // optional string connectionID = 3 [default = "defaultConnectionID"];
  inline bool has_connectionid() const;
  inline void clear_connectionid();
  static const int kConnectionIDFieldNumber = 3;
  inline const ::std::string& connectionid() const;
  inline void set_connectionid(const ::std::string& value);
  inline void set_connectionid(const char* value);
  inline void set_connectionid(const char* value, size_t size);
  inline ::std::string* mutable_connectionid();
  inline ::std::string* release_connectionid();
  inline void set_allocated_connectionid(::std::string* connectionid);

  // optional string test = 4 [default = "testString"];
  inline bool has_test() const;
  inline void clear_test();
  static const int kTestFieldNumber = 4;
  inline const ::std::string& test() const;
  inline void set_test(const ::std::string& value);
  inline void set_test(const char* value);
  inline void set_test(const char* value, size_t size);
  inline ::std::string* mutable_test();
  inline ::std::string* release_test();
  inline void set_allocated_test(::std::string* test);

  // @@protoc_insertion_point(class_scope:UIDisconnect)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_sendername();
  inline void clear_has_sendername();
  inline void set_has_connectionid();
  inline void clear_has_connectionid();
  inline void set_has_test();
  inline void clear_has_test();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* sendername_;
  ::std::string* connectionid_;
  static ::std::string* _default_connectionid_;
  ::std::string* test_;
  static ::std::string* _default_test_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_AssignDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_ShutdownFile_KeplerUIConnectionMessages_2eproto();

  void InitAsDefaultInstance();
  static UIDisconnect* default_instance_;
};
// -------------------------------------------------------------------

class UISignalEvent : public ::google::protobuf::Message {
 public:
  UISignalEvent();
  virtual ~UISignalEvent();

  UISignalEvent(const UISignalEvent& from);

  inline UISignalEvent& operator=(const UISignalEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UISignalEvent& default_instance();

  void Swap(UISignalEvent* other);

  // implements Message ----------------------------------------------

  UISignalEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UISignalEvent& from);
  void MergeFrom(const UISignalEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef UISignalEvent_Type Type;
  static const Type SIGDET = UISignalEvent_Type_SIGDET;
  static const Type SIGUP = UISignalEvent_Type_SIGUP;
  static const Type SIGDOWN = UISignalEvent_Type_SIGDOWN;
  static const Type SIGTIMEOUT = UISignalEvent_Type_SIGTIMEOUT;
  static inline bool Type_IsValid(int value) {
    return UISignalEvent_Type_IsValid(value);
  }
  static const Type Type_MIN =
    UISignalEvent_Type_Type_MIN;
  static const Type Type_MAX =
    UISignalEvent_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    UISignalEvent_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return UISignalEvent_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return UISignalEvent_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return UISignalEvent_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "UISignalEvent"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional string eventID = 3;
  inline bool has_eventid() const;
  inline void clear_eventid();
  static const int kEventIDFieldNumber = 3;
  inline const ::std::string& eventid() const;
  inline void set_eventid(const ::std::string& value);
  inline void set_eventid(const char* value);
  inline void set_eventid(const char* value, size_t size);
  inline ::std::string* mutable_eventid();
  inline ::std::string* release_eventid();
  inline void set_allocated_eventid(::std::string* eventid);

  // optional string timestamp = 4;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  inline void set_allocated_timestamp(::std::string* timestamp);

  // optional string soiNum = 5;
  inline bool has_soinum() const;
  inline void clear_soinum();
  static const int kSoiNumFieldNumber = 5;
  inline const ::std::string& soinum() const;
  inline void set_soinum(const ::std::string& value);
  inline void set_soinum(const char* value);
  inline void set_soinum(const char* value, size_t size);
  inline ::std::string* mutable_soinum();
  inline ::std::string* release_soinum();
  inline void set_allocated_soinum(::std::string* soinum);

  // optional float rfMHz = 6;
  inline bool has_rfmhz() const;
  inline void clear_rfmhz();
  static const int kRfMHzFieldNumber = 6;
  inline float rfmhz() const;
  inline void set_rfmhz(float value);

  // optional float antAz = 7 [default = 0];
  inline bool has_antaz() const;
  inline void clear_antaz();
  static const int kAntAzFieldNumber = 7;
  inline float antaz() const;
  inline void set_antaz(float value);

  // optional float antEl = 8 [default = 0];
  inline bool has_antel() const;
  inline void clear_antel();
  static const int kAntElFieldNumber = 8;
  inline float antel() const;
  inline void set_antel(float value);

  // optional string globalId = 9;
  inline bool has_globalid() const;
  inline void clear_globalid();
  static const int kGlobalIdFieldNumber = 9;
  inline const ::std::string& globalid() const;
  inline void set_globalid(const ::std::string& value);
  inline void set_globalid(const char* value);
  inline void set_globalid(const char* value, size_t size);
  inline ::std::string* mutable_globalid();
  inline ::std::string* release_globalid();
  inline void set_allocated_globalid(::std::string* globalid);

  // optional .UISignalEvent.Type eventType = 10;
  inline bool has_eventtype() const;
  inline void clear_eventtype();
  static const int kEventTypeFieldNumber = 10;
  inline ::UISignalEvent_Type eventtype() const;
  inline void set_eventtype(::UISignalEvent_Type value);

  // optional string name = 11;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 11;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:UISignalEvent)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_eventid();
  inline void clear_has_eventid();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_soinum();
  inline void clear_has_soinum();
  inline void set_has_rfmhz();
  inline void clear_has_rfmhz();
  inline void set_has_antaz();
  inline void clear_has_antaz();
  inline void set_has_antel();
  inline void clear_has_antel();
  inline void set_has_globalid();
  inline void clear_has_globalid();
  inline void set_has_eventtype();
  inline void clear_has_eventtype();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* eventid_;
  ::std::string* timestamp_;
  ::google::protobuf::int32 channel_;
  float rfmhz_;
  ::std::string* soinum_;
  float antaz_;
  float antel_;
  ::std::string* globalid_;
  ::std::string* name_;
  int eventtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_AssignDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_ShutdownFile_KeplerUIConnectionMessages_2eproto();

  void InitAsDefaultInstance();
  static UISignalEvent* default_instance_;
};
// -------------------------------------------------------------------

class UIVideoRequest : public ::google::protobuf::Message {
 public:
  UIVideoRequest();
  virtual ~UIVideoRequest();

  UIVideoRequest(const UIVideoRequest& from);

  inline UIVideoRequest& operator=(const UIVideoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIVideoRequest& default_instance();

  void Swap(UIVideoRequest* other);

  // implements Message ----------------------------------------------

  UIVideoRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIVideoRequest& from);
  void MergeFrom(const UIVideoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "UIVideoRequest"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string eltex = 2;
  inline bool has_eltex() const;
  inline void clear_eltex();
  static const int kEltexFieldNumber = 2;
  inline const ::std::string& eltex() const;
  inline void set_eltex(const ::std::string& value);
  inline void set_eltex(const char* value);
  inline void set_eltex(const char* value, size_t size);
  inline ::std::string* mutable_eltex();
  inline ::std::string* release_eltex();
  inline void set_allocated_eltex(::std::string* eltex);

  // optional string connectionID = 3 [default = "defaultConnectionID"];
  inline bool has_connectionid() const;
  inline void clear_connectionid();
  static const int kConnectionIDFieldNumber = 3;
  inline const ::std::string& connectionid() const;
  inline void set_connectionid(const ::std::string& value);
  inline void set_connectionid(const char* value);
  inline void set_connectionid(const char* value, size_t size);
  inline ::std::string* mutable_connectionid();
  inline ::std::string* release_connectionid();
  inline void set_allocated_connectionid(::std::string* connectionid);

  // @@protoc_insertion_point(class_scope:UIVideoRequest)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_eltex();
  inline void clear_has_eltex();
  inline void set_has_connectionid();
  inline void clear_has_connectionid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* eltex_;
  ::std::string* connectionid_;
  static ::std::string* _default_connectionid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_AssignDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_ShutdownFile_KeplerUIConnectionMessages_2eproto();

  void InitAsDefaultInstance();
  static UIVideoRequest* default_instance_;
};
// -------------------------------------------------------------------

class UIVideoResponse : public ::google::protobuf::Message {
 public:
  UIVideoResponse();
  virtual ~UIVideoResponse();

  UIVideoResponse(const UIVideoResponse& from);

  inline UIVideoResponse& operator=(const UIVideoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIVideoResponse& default_instance();

  void Swap(UIVideoResponse* other);

  // implements Message ----------------------------------------------

  UIVideoResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIVideoResponse& from);
  void MergeFrom(const UIVideoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "UIVideoResponse"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string eltex = 2;
  inline bool has_eltex() const;
  inline void clear_eltex();
  static const int kEltexFieldNumber = 2;
  inline const ::std::string& eltex() const;
  inline void set_eltex(const ::std::string& value);
  inline void set_eltex(const char* value);
  inline void set_eltex(const char* value, size_t size);
  inline ::std::string* mutable_eltex();
  inline ::std::string* release_eltex();
  inline void set_allocated_eltex(::std::string* eltex);

  // optional int64 portNumber = 3;
  inline bool has_portnumber() const;
  inline void clear_portnumber();
  static const int kPortNumberFieldNumber = 3;
  inline ::google::protobuf::int64 portnumber() const;
  inline void set_portnumber(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:UIVideoResponse)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_eltex();
  inline void clear_has_eltex();
  inline void set_has_portnumber();
  inline void clear_has_portnumber();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* eltex_;
  ::google::protobuf::int64 portnumber_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_AssignDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_ShutdownFile_KeplerUIConnectionMessages_2eproto();

  void InitAsDefaultInstance();
  static UIVideoResponse* default_instance_;
};
// -------------------------------------------------------------------

class UIGeoInformationRequest : public ::google::protobuf::Message {
 public:
  UIGeoInformationRequest();
  virtual ~UIGeoInformationRequest();

  UIGeoInformationRequest(const UIGeoInformationRequest& from);

  inline UIGeoInformationRequest& operator=(const UIGeoInformationRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIGeoInformationRequest& default_instance();

  void Swap(UIGeoInformationRequest* other);

  // implements Message ----------------------------------------------

  UIGeoInformationRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIGeoInformationRequest& from);
  void MergeFrom(const UIGeoInformationRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "UIGeoInformationRequest"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string globalId = 2;
  inline bool has_globalid() const;
  inline void clear_globalid();
  static const int kGlobalIdFieldNumber = 2;
  inline const ::std::string& globalid() const;
  inline void set_globalid(const ::std::string& value);
  inline void set_globalid(const char* value);
  inline void set_globalid(const char* value, size_t size);
  inline ::std::string* mutable_globalid();
  inline ::std::string* release_globalid();
  inline void set_allocated_globalid(::std::string* globalid);

  // optional string connectionID = 3 [default = "defaultConnectionID"];
  inline bool has_connectionid() const;
  inline void clear_connectionid();
  static const int kConnectionIDFieldNumber = 3;
  inline const ::std::string& connectionid() const;
  inline void set_connectionid(const ::std::string& value);
  inline void set_connectionid(const char* value);
  inline void set_connectionid(const char* value, size_t size);
  inline ::std::string* mutable_connectionid();
  inline ::std::string* release_connectionid();
  inline void set_allocated_connectionid(::std::string* connectionid);

  // @@protoc_insertion_point(class_scope:UIGeoInformationRequest)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_globalid();
  inline void clear_has_globalid();
  inline void set_has_connectionid();
  inline void clear_has_connectionid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* globalid_;
  ::std::string* connectionid_;
  static ::std::string* _default_connectionid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_AssignDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_ShutdownFile_KeplerUIConnectionMessages_2eproto();

  void InitAsDefaultInstance();
  static UIGeoInformationRequest* default_instance_;
};
// -------------------------------------------------------------------

class UIGeoInformation : public ::google::protobuf::Message {
 public:
  UIGeoInformation();
  virtual ~UIGeoInformation();

  UIGeoInformation(const UIGeoInformation& from);

  inline UIGeoInformation& operator=(const UIGeoInformation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIGeoInformation& default_instance();

  void Swap(UIGeoInformation* other);

  // implements Message ----------------------------------------------

  UIGeoInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIGeoInformation& from);
  void MergeFrom(const UIGeoInformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "UIGeoInformation"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional double lat = 2;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 2;
  inline double lat() const;
  inline void set_lat(double value);

  // optional double lon = 3;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 3;
  inline double lon() const;
  inline void set_lon(double value);

  // optional double majoraxis = 4;
  inline bool has_majoraxis() const;
  inline void clear_majoraxis();
  static const int kMajoraxisFieldNumber = 4;
  inline double majoraxis() const;
  inline void set_majoraxis(double value);

  // optional double minoraxis = 5;
  inline bool has_minoraxis() const;
  inline void clear_minoraxis();
  static const int kMinoraxisFieldNumber = 5;
  inline double minoraxis() const;
  inline void set_minoraxis(double value);

  // optional double orientation = 6;
  inline bool has_orientation() const;
  inline void clear_orientation();
  static const int kOrientationFieldNumber = 6;
  inline double orientation() const;
  inline void set_orientation(double value);

  // optional double altitude = 7;
  inline bool has_altitude() const;
  inline void clear_altitude();
  static const int kAltitudeFieldNumber = 7;
  inline double altitude() const;
  inline void set_altitude(double value);

  // optional int32 altConf = 8;
  inline bool has_altconf() const;
  inline void clear_altconf();
  static const int kAltConfFieldNumber = 8;
  inline ::google::protobuf::int32 altconf() const;
  inline void set_altconf(::google::protobuf::int32 value);

  // optional double velocity = 9;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 9;
  inline double velocity() const;
  inline void set_velocity(double value);

  // optional int32 vConf = 10;
  inline bool has_vconf() const;
  inline void clear_vconf();
  static const int kVConfFieldNumber = 10;
  inline ::google::protobuf::int32 vconf() const;
  inline void set_vconf(::google::protobuf::int32 value);

  // optional double heading = 11;
  inline bool has_heading() const;
  inline void clear_heading();
  static const int kHeadingFieldNumber = 11;
  inline double heading() const;
  inline void set_heading(double value);

  // optional int32 headConf = 12;
  inline bool has_headconf() const;
  inline void clear_headconf();
  static const int kHeadConfFieldNumber = 12;
  inline ::google::protobuf::int32 headconf() const;
  inline void set_headconf(::google::protobuf::int32 value);

  // optional string covariance = 13;
  inline bool has_covariance() const;
  inline void clear_covariance();
  static const int kCovarianceFieldNumber = 13;
  inline const ::std::string& covariance() const;
  inline void set_covariance(const ::std::string& value);
  inline void set_covariance(const char* value);
  inline void set_covariance(const char* value, size_t size);
  inline ::std::string* mutable_covariance();
  inline ::std::string* release_covariance();
  inline void set_allocated_covariance(::std::string* covariance);

  // optional string globalId = 14;
  inline bool has_globalid() const;
  inline void clear_globalid();
  static const int kGlobalIdFieldNumber = 14;
  inline const ::std::string& globalid() const;
  inline void set_globalid(const ::std::string& value);
  inline void set_globalid(const char* value);
  inline void set_globalid(const char* value, size_t size);
  inline ::std::string* mutable_globalid();
  inline ::std::string* release_globalid();
  inline void set_allocated_globalid(::std::string* globalid);

  // optional string geoTime = 15;
  inline bool has_geotime() const;
  inline void clear_geotime();
  static const int kGeoTimeFieldNumber = 15;
  inline const ::std::string& geotime() const;
  inline void set_geotime(const ::std::string& value);
  inline void set_geotime(const char* value);
  inline void set_geotime(const char* value, size_t size);
  inline ::std::string* mutable_geotime();
  inline ::std::string* release_geotime();
  inline void set_allocated_geotime(::std::string* geotime);

  // optional string classification = 16 [default = ""];
  inline bool has_classification() const;
  inline void clear_classification();
  static const int kClassificationFieldNumber = 16;
  inline const ::std::string& classification() const;
  inline void set_classification(const ::std::string& value);
  inline void set_classification(const char* value);
  inline void set_classification(const char* value, size_t size);
  inline ::std::string* mutable_classification();
  inline ::std::string* release_classification();
  inline void set_allocated_classification(::std::string* classification);

  // @@protoc_insertion_point(class_scope:UIGeoInformation)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_majoraxis();
  inline void clear_has_majoraxis();
  inline void set_has_minoraxis();
  inline void clear_has_minoraxis();
  inline void set_has_orientation();
  inline void clear_has_orientation();
  inline void set_has_altitude();
  inline void clear_has_altitude();
  inline void set_has_altconf();
  inline void clear_has_altconf();
  inline void set_has_velocity();
  inline void clear_has_velocity();
  inline void set_has_vconf();
  inline void clear_has_vconf();
  inline void set_has_heading();
  inline void clear_has_heading();
  inline void set_has_headconf();
  inline void clear_has_headconf();
  inline void set_has_covariance();
  inline void clear_has_covariance();
  inline void set_has_globalid();
  inline void clear_has_globalid();
  inline void set_has_geotime();
  inline void clear_has_geotime();
  inline void set_has_classification();
  inline void clear_has_classification();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  double lat_;
  double lon_;
  double majoraxis_;
  double minoraxis_;
  double orientation_;
  double altitude_;
  double velocity_;
  ::google::protobuf::int32 altconf_;
  ::google::protobuf::int32 vconf_;
  double heading_;
  ::std::string* covariance_;
  ::std::string* globalid_;
  ::std::string* geotime_;
  ::std::string* classification_;
  ::google::protobuf::int32 headconf_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_AssignDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_ShutdownFile_KeplerUIConnectionMessages_2eproto();

  void InitAsDefaultInstance();
  static UIGeoInformation* default_instance_;
};
// -------------------------------------------------------------------

class UICommandRequest : public ::google::protobuf::Message {
 public:
  UICommandRequest();
  virtual ~UICommandRequest();

  UICommandRequest(const UICommandRequest& from);

  inline UICommandRequest& operator=(const UICommandRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UICommandRequest& default_instance();

  void Swap(UICommandRequest* other);

  // implements Message ----------------------------------------------

  UICommandRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UICommandRequest& from);
  void MergeFrom(const UICommandRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "UICommandRequest"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string globalId = 2;
  inline bool has_globalid() const;
  inline void clear_globalid();
  static const int kGlobalIdFieldNumber = 2;
  inline const ::std::string& globalid() const;
  inline void set_globalid(const ::std::string& value);
  inline void set_globalid(const char* value);
  inline void set_globalid(const char* value, size_t size);
  inline ::std::string* mutable_globalid();
  inline ::std::string* release_globalid();
  inline void set_allocated_globalid(::std::string* globalid);

  // required string effect = 3;
  inline bool has_effect() const;
  inline void clear_effect();
  static const int kEffectFieldNumber = 3;
  inline const ::std::string& effect() const;
  inline void set_effect(const ::std::string& value);
  inline void set_effect(const char* value);
  inline void set_effect(const char* value, size_t size);
  inline ::std::string* mutable_effect();
  inline ::std::string* release_effect();
  inline void set_allocated_effect(::std::string* effect);

  // repeated .Parameter parameter = 4;
  inline int parameter_size() const;
  inline void clear_parameter();
  static const int kParameterFieldNumber = 4;
  inline const ::Parameter& parameter(int index) const;
  inline ::Parameter* mutable_parameter(int index);
  inline ::Parameter* add_parameter();
  inline const ::google::protobuf::RepeatedPtrField< ::Parameter >&
      parameter() const;
  inline ::google::protobuf::RepeatedPtrField< ::Parameter >*
      mutable_parameter();

  // optional string antenna = 5;
  inline bool has_antenna() const;
  inline void clear_antenna();
  static const int kAntennaFieldNumber = 5;
  inline const ::std::string& antenna() const;
  inline void set_antenna(const ::std::string& value);
  inline void set_antenna(const char* value);
  inline void set_antenna(const char* value, size_t size);
  inline ::std::string* mutable_antenna();
  inline ::std::string* release_antenna();
  inline void set_allocated_antenna(::std::string* antenna);

  // optional bool active = 6;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 6;
  inline bool active() const;
  inline void set_active(bool value);

  // optional string resID = 7;
  inline bool has_resid() const;
  inline void clear_resid();
  static const int kResIDFieldNumber = 7;
  inline const ::std::string& resid() const;
  inline void set_resid(const ::std::string& value);
  inline void set_resid(const char* value);
  inline void set_resid(const char* value, size_t size);
  inline ::std::string* mutable_resid();
  inline ::std::string* release_resid();
  inline void set_allocated_resid(::std::string* resid);

  // optional string signalName = 8;
  inline bool has_signalname() const;
  inline void clear_signalname();
  static const int kSignalNameFieldNumber = 8;
  inline const ::std::string& signalname() const;
  inline void set_signalname(const ::std::string& value);
  inline void set_signalname(const char* value);
  inline void set_signalname(const char* value, size_t size);
  inline ::std::string* mutable_signalname();
  inline ::std::string* release_signalname();
  inline void set_allocated_signalname(::std::string* signalname);

  // optional string connectionID = 9 [default = "defaultConnectionID"];
  inline bool has_connectionid() const;
  inline void clear_connectionid();
  static const int kConnectionIDFieldNumber = 9;
  inline const ::std::string& connectionid() const;
  inline void set_connectionid(const ::std::string& value);
  inline void set_connectionid(const char* value);
  inline void set_connectionid(const char* value, size_t size);
  inline ::std::string* mutable_connectionid();
  inline ::std::string* release_connectionid();
  inline void set_allocated_connectionid(::std::string* connectionid);

  // @@protoc_insertion_point(class_scope:UICommandRequest)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_globalid();
  inline void clear_has_globalid();
  inline void set_has_effect();
  inline void clear_has_effect();
  inline void set_has_antenna();
  inline void clear_has_antenna();
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_resid();
  inline void clear_has_resid();
  inline void set_has_signalname();
  inline void clear_has_signalname();
  inline void set_has_connectionid();
  inline void clear_has_connectionid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* globalid_;
  ::std::string* effect_;
  ::google::protobuf::RepeatedPtrField< ::Parameter > parameter_;
  ::std::string* antenna_;
  ::std::string* resid_;
  ::std::string* signalname_;
  ::std::string* connectionid_;
  static ::std::string* _default_connectionid_;
  bool active_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_AssignDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_ShutdownFile_KeplerUIConnectionMessages_2eproto();

  void InitAsDefaultInstance();
  static UICommandRequest* default_instance_;
};
// -------------------------------------------------------------------

class Parameter : public ::google::protobuf::Message {
 public:
  Parameter();
  virtual ~Parameter();

  Parameter(const Parameter& from);

  inline Parameter& operator=(const Parameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Parameter& default_instance();

  void Swap(Parameter* other);

  // implements Message ----------------------------------------------

  Parameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parameter& from);
  void MergeFrom(const Parameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EW_PARAMETER"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:Parameter)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* name_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_AssignDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_ShutdownFile_KeplerUIConnectionMessages_2eproto();

  void InitAsDefaultInstance();
  static Parameter* default_instance_;
};
// -------------------------------------------------------------------

class UIOptionsRequest : public ::google::protobuf::Message {
 public:
  UIOptionsRequest();
  virtual ~UIOptionsRequest();

  UIOptionsRequest(const UIOptionsRequest& from);

  inline UIOptionsRequest& operator=(const UIOptionsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIOptionsRequest& default_instance();

  void Swap(UIOptionsRequest* other);

  // implements Message ----------------------------------------------

  UIOptionsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIOptionsRequest& from);
  void MergeFrom(const UIOptionsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "UIOptionsRequest"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string connectionID = 2 [default = "defaultConnectionID"];
  inline bool has_connectionid() const;
  inline void clear_connectionid();
  static const int kConnectionIDFieldNumber = 2;
  inline const ::std::string& connectionid() const;
  inline void set_connectionid(const ::std::string& value);
  inline void set_connectionid(const char* value);
  inline void set_connectionid(const char* value, size_t size);
  inline ::std::string* mutable_connectionid();
  inline ::std::string* release_connectionid();
  inline void set_allocated_connectionid(::std::string* connectionid);

  // @@protoc_insertion_point(class_scope:UIOptionsRequest)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_connectionid();
  inline void clear_has_connectionid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* connectionid_;
  static ::std::string* _default_connectionid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_AssignDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_ShutdownFile_KeplerUIConnectionMessages_2eproto();

  void InitAsDefaultInstance();
  static UIOptionsRequest* default_instance_;
};
// -------------------------------------------------------------------

class UIOption : public ::google::protobuf::Message {
 public:
  UIOption();
  virtual ~UIOption();

  UIOption(const UIOption& from);

  inline UIOption& operator=(const UIOption& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIOption& default_instance();

  void Swap(UIOption* other);

  // implements Message ----------------------------------------------

  UIOption* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIOption& from);
  void MergeFrom(const UIOption& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef UIOption_DetectionSource DetectionSource;
  static const DetectionSource EXTERNAL = UIOption_DetectionSource_EXTERNAL;
  static const DetectionSource DETECTION = UIOption_DetectionSource_DETECTION;
  static const DetectionSource EVENT = UIOption_DetectionSource_EVENT;
  static const DetectionSource THUNDERBIRD = UIOption_DetectionSource_THUNDERBIRD;
  static inline bool DetectionSource_IsValid(int value) {
    return UIOption_DetectionSource_IsValid(value);
  }
  static const DetectionSource DetectionSource_MIN =
    UIOption_DetectionSource_DetectionSource_MIN;
  static const DetectionSource DetectionSource_MAX =
    UIOption_DetectionSource_DetectionSource_MAX;
  static const int DetectionSource_ARRAYSIZE =
    UIOption_DetectionSource_DetectionSource_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DetectionSource_descriptor() {
    return UIOption_DetectionSource_descriptor();
  }
  static inline const ::std::string& DetectionSource_Name(DetectionSource value) {
    return UIOption_DetectionSource_Name(value);
  }
  static inline bool DetectionSource_Parse(const ::std::string& name,
      DetectionSource* value) {
    return UIOption_DetectionSource_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "UIOption"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string signalName = 2;
  inline bool has_signalname() const;
  inline void clear_signalname();
  static const int kSignalNameFieldNumber = 2;
  inline const ::std::string& signalname() const;
  inline void set_signalname(const ::std::string& value);
  inline void set_signalname(const char* value);
  inline void set_signalname(const char* value, size_t size);
  inline ::std::string* mutable_signalname();
  inline ::std::string* release_signalname();
  inline void set_allocated_signalname(::std::string* signalname);

  // repeated string effect = 3;
  inline int effect_size() const;
  inline void clear_effect();
  static const int kEffectFieldNumber = 3;
  inline const ::std::string& effect(int index) const;
  inline ::std::string* mutable_effect(int index);
  inline void set_effect(int index, const ::std::string& value);
  inline void set_effect(int index, const char* value);
  inline void set_effect(int index, const char* value, size_t size);
  inline ::std::string* add_effect();
  inline void add_effect(const ::std::string& value);
  inline void add_effect(const char* value);
  inline void add_effect(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& effect() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_effect();

  // optional .UIOption.DetectionSource detectionSource = 4;
  inline bool has_detectionsource() const;
  inline void clear_detectionsource();
  static const int kDetectionSourceFieldNumber = 4;
  inline ::UIOption_DetectionSource detectionsource() const;
  inline void set_detectionsource(::UIOption_DetectionSource value);

  // optional string globalId = 5;
  inline bool has_globalid() const;
  inline void clear_globalid();
  static const int kGlobalIdFieldNumber = 5;
  inline const ::std::string& globalid() const;
  inline void set_globalid(const ::std::string& value);
  inline void set_globalid(const char* value);
  inline void set_globalid(const char* value, size_t size);
  inline ::std::string* mutable_globalid();
  inline ::std::string* release_globalid();
  inline void set_allocated_globalid(::std::string* globalid);

  // @@protoc_insertion_point(class_scope:UIOption)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_signalname();
  inline void clear_has_signalname();
  inline void set_has_detectionsource();
  inline void clear_has_detectionsource();
  inline void set_has_globalid();
  inline void clear_has_globalid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* signalname_;
  ::google::protobuf::RepeatedPtrField< ::std::string> effect_;
  ::std::string* globalid_;
  int detectionsource_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_AssignDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_ShutdownFile_KeplerUIConnectionMessages_2eproto();

  void InitAsDefaultInstance();
  static UIOption* default_instance_;
};
// -------------------------------------------------------------------

class UIOptions : public ::google::protobuf::Message {
 public:
  UIOptions();
  virtual ~UIOptions();

  UIOptions(const UIOptions& from);

  inline UIOptions& operator=(const UIOptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIOptions& default_instance();

  void Swap(UIOptions* other);

  // implements Message ----------------------------------------------

  UIOptions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIOptions& from);
  void MergeFrom(const UIOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "UIOptions"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // repeated .UIOption uiopt = 2;
  inline int uiopt_size() const;
  inline void clear_uiopt();
  static const int kUioptFieldNumber = 2;
  inline const ::UIOption& uiopt(int index) const;
  inline ::UIOption* mutable_uiopt(int index);
  inline ::UIOption* add_uiopt();
  inline const ::google::protobuf::RepeatedPtrField< ::UIOption >&
      uiopt() const;
  inline ::google::protobuf::RepeatedPtrField< ::UIOption >*
      mutable_uiopt();

  // @@protoc_insertion_point(class_scope:UIOptions)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::RepeatedPtrField< ::UIOption > uiopt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_AssignDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_ShutdownFile_KeplerUIConnectionMessages_2eproto();

  void InitAsDefaultInstance();
  static UIOptions* default_instance_;
};
// -------------------------------------------------------------------

class UIOptionDelete : public ::google::protobuf::Message {
 public:
  UIOptionDelete();
  virtual ~UIOptionDelete();

  UIOptionDelete(const UIOptionDelete& from);

  inline UIOptionDelete& operator=(const UIOptionDelete& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UIOptionDelete& default_instance();

  void Swap(UIOptionDelete* other);

  // implements Message ----------------------------------------------

  UIOptionDelete* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UIOptionDelete& from);
  void MergeFrom(const UIOptionDelete& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "UIOptionDelete"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string globalId = 2;
  inline bool has_globalid() const;
  inline void clear_globalid();
  static const int kGlobalIdFieldNumber = 2;
  inline const ::std::string& globalid() const;
  inline void set_globalid(const ::std::string& value);
  inline void set_globalid(const char* value);
  inline void set_globalid(const char* value, size_t size);
  inline ::std::string* mutable_globalid();
  inline ::std::string* release_globalid();
  inline void set_allocated_globalid(::std::string* globalid);

  // @@protoc_insertion_point(class_scope:UIOptionDelete)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_globalid();
  inline void clear_has_globalid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* globalid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_AssignDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_ShutdownFile_KeplerUIConnectionMessages_2eproto();

  void InitAsDefaultInstance();
  static UIOptionDelete* default_instance_;
};
// -------------------------------------------------------------------

class UICeaseBuzzer : public ::google::protobuf::Message {
 public:
  UICeaseBuzzer();
  virtual ~UICeaseBuzzer();

  UICeaseBuzzer(const UICeaseBuzzer& from);

  inline UICeaseBuzzer& operator=(const UICeaseBuzzer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UICeaseBuzzer& default_instance();

  void Swap(UICeaseBuzzer* other);

  // implements Message ----------------------------------------------

  UICeaseBuzzer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UICeaseBuzzer& from);
  void MergeFrom(const UICeaseBuzzer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "UICeaseBuzzer"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string connectionID = 2 [default = "defaultConnectionID"];
  inline bool has_connectionid() const;
  inline void clear_connectionid();
  static const int kConnectionIDFieldNumber = 2;
  inline const ::std::string& connectionid() const;
  inline void set_connectionid(const ::std::string& value);
  inline void set_connectionid(const char* value);
  inline void set_connectionid(const char* value, size_t size);
  inline ::std::string* mutable_connectionid();
  inline ::std::string* release_connectionid();
  inline void set_allocated_connectionid(::std::string* connectionid);

  // @@protoc_insertion_point(class_scope:UICeaseBuzzer)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_connectionid();
  inline void clear_has_connectionid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* connectionid_;
  static ::std::string* _default_connectionid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_AssignDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_ShutdownFile_KeplerUIConnectionMessages_2eproto();

  void InitAsDefaultInstance();
  static UICeaseBuzzer* default_instance_;
};
// -------------------------------------------------------------------

class EWStatus : public ::google::protobuf::Message {
 public:
  EWStatus();
  virtual ~EWStatus();

  EWStatus(const EWStatus& from);

  inline EWStatus& operator=(const EWStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EWStatus& default_instance();

  void Swap(EWStatus* other);

  // implements Message ----------------------------------------------

  EWStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EWStatus& from);
  void MergeFrom(const EWStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EWStatus"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // repeated .OutputChannelStatus outputChannelStatus = 2;
  inline int outputchannelstatus_size() const;
  inline void clear_outputchannelstatus();
  static const int kOutputChannelStatusFieldNumber = 2;
  inline const ::OutputChannelStatus& outputchannelstatus(int index) const;
  inline ::OutputChannelStatus* mutable_outputchannelstatus(int index);
  inline ::OutputChannelStatus* add_outputchannelstatus();
  inline const ::google::protobuf::RepeatedPtrField< ::OutputChannelStatus >&
      outputchannelstatus() const;
  inline ::google::protobuf::RepeatedPtrField< ::OutputChannelStatus >*
      mutable_outputchannelstatus();

  // optional string timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  inline void set_allocated_timestamp(::std::string* timestamp);

  // @@protoc_insertion_point(class_scope:EWStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::RepeatedPtrField< ::OutputChannelStatus > outputchannelstatus_;
  ::std::string* timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_AssignDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_ShutdownFile_KeplerUIConnectionMessages_2eproto();

  void InitAsDefaultInstance();
  static EWStatus* default_instance_;
};
// -------------------------------------------------------------------

class OutputChannelStatus : public ::google::protobuf::Message {
 public:
  OutputChannelStatus();
  virtual ~OutputChannelStatus();

  OutputChannelStatus(const OutputChannelStatus& from);

  inline OutputChannelStatus& operator=(const OutputChannelStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OutputChannelStatus& default_instance();

  void Swap(OutputChannelStatus* other);

  // implements Message ----------------------------------------------

  OutputChannelStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OutputChannelStatus& from);
  void MergeFrom(const OutputChannelStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef OutputChannelStatus_TransmitState TransmitState;
  static const TransmitState UNAVAILABLE = OutputChannelStatus_TransmitState_UNAVAILABLE;
  static const TransmitState PENDING = OutputChannelStatus_TransmitState_PENDING;
  static const TransmitState AVAILABLE = OutputChannelStatus_TransmitState_AVAILABLE;
  static inline bool TransmitState_IsValid(int value) {
    return OutputChannelStatus_TransmitState_IsValid(value);
  }
  static const TransmitState TransmitState_MIN =
    OutputChannelStatus_TransmitState_TransmitState_MIN;
  static const TransmitState TransmitState_MAX =
    OutputChannelStatus_TransmitState_TransmitState_MAX;
  static const int TransmitState_ARRAYSIZE =
    OutputChannelStatus_TransmitState_TransmitState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TransmitState_descriptor() {
    return OutputChannelStatus_TransmitState_descriptor();
  }
  static inline const ::std::string& TransmitState_Name(TransmitState value) {
    return OutputChannelStatus_TransmitState_Name(value);
  }
  static inline bool TransmitState_Parse(const ::std::string& name,
      TransmitState* value) {
    return OutputChannelStatus_TransmitState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EW_OUTPUT_CHANNEL_STATUS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string effect = 2;
  inline bool has_effect() const;
  inline void clear_effect();
  static const int kEffectFieldNumber = 2;
  inline const ::std::string& effect() const;
  inline void set_effect(const ::std::string& value);
  inline void set_effect(const char* value);
  inline void set_effect(const char* value, size_t size);
  inline ::std::string* mutable_effect();
  inline ::std::string* release_effect();
  inline void set_allocated_effect(::std::string* effect);

  // optional double transmitFreq = 3;
  inline bool has_transmitfreq() const;
  inline void clear_transmitfreq();
  static const int kTransmitFreqFieldNumber = 3;
  inline double transmitfreq() const;
  inline void set_transmitfreq(double value);

  // optional string globalId = 4;
  inline bool has_globalid() const;
  inline void clear_globalid();
  static const int kGlobalIdFieldNumber = 4;
  inline const ::std::string& globalid() const;
  inline void set_globalid(const ::std::string& value);
  inline void set_globalid(const char* value);
  inline void set_globalid(const char* value, size_t size);
  inline ::std::string* mutable_globalid();
  inline ::std::string* release_globalid();
  inline void set_allocated_globalid(::std::string* globalid);

  // optional string antenna = 5;
  inline bool has_antenna() const;
  inline void clear_antenna();
  static const int kAntennaFieldNumber = 5;
  inline const ::std::string& antenna() const;
  inline void set_antenna(const ::std::string& value);
  inline void set_antenna(const char* value);
  inline void set_antenna(const char* value, size_t size);
  inline ::std::string* mutable_antenna();
  inline ::std::string* release_antenna();
  inline void set_allocated_antenna(::std::string* antenna);

  // optional .OutputChannelStatus.TransmitState state = 6;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 6;
  inline ::OutputChannelStatus_TransmitState state() const;
  inline void set_state(::OutputChannelStatus_TransmitState value);

  // optional double powerMeter = 7;
  inline bool has_powermeter() const;
  inline void clear_powermeter();
  static const int kPowerMeterFieldNumber = 7;
  inline double powermeter() const;
  inline void set_powermeter(double value);

  // optional string resID = 8;
  inline bool has_resid() const;
  inline void clear_resid();
  static const int kResIDFieldNumber = 8;
  inline const ::std::string& resid() const;
  inline void set_resid(const ::std::string& value);
  inline void set_resid(const char* value);
  inline void set_resid(const char* value, size_t size);
  inline ::std::string* mutable_resid();
  inline ::std::string* release_resid();
  inline void set_allocated_resid(::std::string* resid);

  // optional string signalName = 9;
  inline bool has_signalname() const;
  inline void clear_signalname();
  static const int kSignalNameFieldNumber = 9;
  inline const ::std::string& signalname() const;
  inline void set_signalname(const ::std::string& value);
  inline void set_signalname(const char* value);
  inline void set_signalname(const char* value, size_t size);
  inline ::std::string* mutable_signalname();
  inline ::std::string* release_signalname();
  inline void set_allocated_signalname(::std::string* signalname);

  // @@protoc_insertion_point(class_scope:OutputChannelStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_effect();
  inline void clear_has_effect();
  inline void set_has_transmitfreq();
  inline void clear_has_transmitfreq();
  inline void set_has_globalid();
  inline void clear_has_globalid();
  inline void set_has_antenna();
  inline void clear_has_antenna();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_powermeter();
  inline void clear_has_powermeter();
  inline void set_has_resid();
  inline void clear_has_resid();
  inline void set_has_signalname();
  inline void clear_has_signalname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* effect_;
  double transmitfreq_;
  ::std::string* globalid_;
  ::std::string* antenna_;
  double powermeter_;
  ::std::string* resid_;
  ::std::string* signalname_;
  int state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_AssignDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_ShutdownFile_KeplerUIConnectionMessages_2eproto();

  void InitAsDefaultInstance();
  static OutputChannelStatus* default_instance_;
};
// -------------------------------------------------------------------

class UISetDefaultSchedule : public ::google::protobuf::Message {
 public:
  UISetDefaultSchedule();
  virtual ~UISetDefaultSchedule();

  UISetDefaultSchedule(const UISetDefaultSchedule& from);

  inline UISetDefaultSchedule& operator=(const UISetDefaultSchedule& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UISetDefaultSchedule& default_instance();

  void Swap(UISetDefaultSchedule* other);

  // implements Message ----------------------------------------------

  UISetDefaultSchedule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UISetDefaultSchedule& from);
  void MergeFrom(const UISetDefaultSchedule& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "UISetDefaultSchedule"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 channelNum = 2;
  inline bool has_channelnum() const;
  inline void clear_channelnum();
  static const int kChannelNumFieldNumber = 2;
  inline ::google::protobuf::int32 channelnum() const;
  inline void set_channelnum(::google::protobuf::int32 value);

  // optional string fileName = 3;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 3;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional string connectionID = 4;
  inline bool has_connectionid() const;
  inline void clear_connectionid();
  static const int kConnectionIDFieldNumber = 4;
  inline const ::std::string& connectionid() const;
  inline void set_connectionid(const ::std::string& value);
  inline void set_connectionid(const char* value);
  inline void set_connectionid(const char* value, size_t size);
  inline ::std::string* mutable_connectionid();
  inline ::std::string* release_connectionid();
  inline void set_allocated_connectionid(::std::string* connectionid);

  // @@protoc_insertion_point(class_scope:UISetDefaultSchedule)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_channelnum();
  inline void clear_has_channelnum();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_connectionid();
  inline void clear_has_connectionid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* filename_;
  ::std::string* connectionid_;
  ::google::protobuf::int32 channelnum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_AssignDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_ShutdownFile_KeplerUIConnectionMessages_2eproto();

  void InitAsDefaultInstance();
  static UISetDefaultSchedule* default_instance_;
};
// -------------------------------------------------------------------

class KeplerHeartBeat : public ::google::protobuf::Message {
 public:
  KeplerHeartBeat();
  virtual ~KeplerHeartBeat();

  KeplerHeartBeat(const KeplerHeartBeat& from);

  inline KeplerHeartBeat& operator=(const KeplerHeartBeat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeplerHeartBeat& default_instance();

  void Swap(KeplerHeartBeat* other);

  // implements Message ----------------------------------------------

  KeplerHeartBeat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeplerHeartBeat& from);
  void MergeFrom(const KeplerHeartBeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "KeplerHeartBeat"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // @@protoc_insertion_point(class_scope:KeplerHeartBeat)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_AssignDesc_KeplerUIConnectionMessages_2eproto();
  friend void protobuf_ShutdownFile_KeplerUIConnectionMessages_2eproto();

  void InitAsDefaultInstance();
  static KeplerHeartBeat* default_instance_;
};
// ===================================================================


// ===================================================================

// UItoKeplerMessage

// optional .service_infrastructure.Header header = 100;
inline bool UItoKeplerMessage::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UItoKeplerMessage::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UItoKeplerMessage::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UItoKeplerMessage::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& UItoKeplerMessage::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* UItoKeplerMessage::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* UItoKeplerMessage::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void UItoKeplerMessage::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .UIAck msgUIAck = 4;
inline bool UItoKeplerMessage::has_msguiack() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UItoKeplerMessage::set_has_msguiack() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UItoKeplerMessage::clear_has_msguiack() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UItoKeplerMessage::clear_msguiack() {
  if (msguiack_ != NULL) msguiack_->::UIAck::Clear();
  clear_has_msguiack();
}
inline const ::UIAck& UItoKeplerMessage::msguiack() const {
  return msguiack_ != NULL ? *msguiack_ : *default_instance_->msguiack_;
}
inline ::UIAck* UItoKeplerMessage::mutable_msguiack() {
  set_has_msguiack();
  if (msguiack_ == NULL) msguiack_ = new ::UIAck;
  return msguiack_;
}
inline ::UIAck* UItoKeplerMessage::release_msguiack() {
  clear_has_msguiack();
  ::UIAck* temp = msguiack_;
  msguiack_ = NULL;
  return temp;
}
inline void UItoKeplerMessage::set_allocated_msguiack(::UIAck* msguiack) {
  delete msguiack_;
  msguiack_ = msguiack;
  if (msguiack) {
    set_has_msguiack();
  } else {
    clear_has_msguiack();
  }
}

// optional .UINack msgUINack = 5;
inline bool UItoKeplerMessage::has_msguinack() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UItoKeplerMessage::set_has_msguinack() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UItoKeplerMessage::clear_has_msguinack() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UItoKeplerMessage::clear_msguinack() {
  if (msguinack_ != NULL) msguinack_->::UINack::Clear();
  clear_has_msguinack();
}
inline const ::UINack& UItoKeplerMessage::msguinack() const {
  return msguinack_ != NULL ? *msguinack_ : *default_instance_->msguinack_;
}
inline ::UINack* UItoKeplerMessage::mutable_msguinack() {
  set_has_msguinack();
  if (msguinack_ == NULL) msguinack_ = new ::UINack;
  return msguinack_;
}
inline ::UINack* UItoKeplerMessage::release_msguinack() {
  clear_has_msguinack();
  ::UINack* temp = msguinack_;
  msguinack_ = NULL;
  return temp;
}
inline void UItoKeplerMessage::set_allocated_msguinack(::UINack* msguinack) {
  delete msguinack_;
  msguinack_ = msguinack;
  if (msguinack) {
    set_has_msguinack();
  } else {
    clear_has_msguinack();
  }
}

// optional .ICDVersionRequest msgICDVersionRequest = 6;
inline bool UItoKeplerMessage::has_msgicdversionrequest() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UItoKeplerMessage::set_has_msgicdversionrequest() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UItoKeplerMessage::clear_has_msgicdversionrequest() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UItoKeplerMessage::clear_msgicdversionrequest() {
  if (msgicdversionrequest_ != NULL) msgicdversionrequest_->::ICDVersionRequest::Clear();
  clear_has_msgicdversionrequest();
}
inline const ::ICDVersionRequest& UItoKeplerMessage::msgicdversionrequest() const {
  return msgicdversionrequest_ != NULL ? *msgicdversionrequest_ : *default_instance_->msgicdversionrequest_;
}
inline ::ICDVersionRequest* UItoKeplerMessage::mutable_msgicdversionrequest() {
  set_has_msgicdversionrequest();
  if (msgicdversionrequest_ == NULL) msgicdversionrequest_ = new ::ICDVersionRequest;
  return msgicdversionrequest_;
}
inline ::ICDVersionRequest* UItoKeplerMessage::release_msgicdversionrequest() {
  clear_has_msgicdversionrequest();
  ::ICDVersionRequest* temp = msgicdversionrequest_;
  msgicdversionrequest_ = NULL;
  return temp;
}
inline void UItoKeplerMessage::set_allocated_msgicdversionrequest(::ICDVersionRequest* msgicdversionrequest) {
  delete msgicdversionrequest_;
  msgicdversionrequest_ = msgicdversionrequest;
  if (msgicdversionrequest) {
    set_has_msgicdversionrequest();
  } else {
    clear_has_msgicdversionrequest();
  }
}

// optional .DBVersionRequest msgDBVersionRequest = 7;
inline bool UItoKeplerMessage::has_msgdbversionrequest() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UItoKeplerMessage::set_has_msgdbversionrequest() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UItoKeplerMessage::clear_has_msgdbversionrequest() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UItoKeplerMessage::clear_msgdbversionrequest() {
  if (msgdbversionrequest_ != NULL) msgdbversionrequest_->::DBVersionRequest::Clear();
  clear_has_msgdbversionrequest();
}
inline const ::DBVersionRequest& UItoKeplerMessage::msgdbversionrequest() const {
  return msgdbversionrequest_ != NULL ? *msgdbversionrequest_ : *default_instance_->msgdbversionrequest_;
}
inline ::DBVersionRequest* UItoKeplerMessage::mutable_msgdbversionrequest() {
  set_has_msgdbversionrequest();
  if (msgdbversionrequest_ == NULL) msgdbversionrequest_ = new ::DBVersionRequest;
  return msgdbversionrequest_;
}
inline ::DBVersionRequest* UItoKeplerMessage::release_msgdbversionrequest() {
  clear_has_msgdbversionrequest();
  ::DBVersionRequest* temp = msgdbversionrequest_;
  msgdbversionrequest_ = NULL;
  return temp;
}
inline void UItoKeplerMessage::set_allocated_msgdbversionrequest(::DBVersionRequest* msgdbversionrequest) {
  delete msgdbversionrequest_;
  msgdbversionrequest_ = msgdbversionrequest;
  if (msgdbversionrequest) {
    set_has_msgdbversionrequest();
  } else {
    clear_has_msgdbversionrequest();
  }
}

// optional .DBCredentialsRequest msgDBCredentialsRequest = 8;
inline bool UItoKeplerMessage::has_msgdbcredentialsrequest() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UItoKeplerMessage::set_has_msgdbcredentialsrequest() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UItoKeplerMessage::clear_has_msgdbcredentialsrequest() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UItoKeplerMessage::clear_msgdbcredentialsrequest() {
  if (msgdbcredentialsrequest_ != NULL) msgdbcredentialsrequest_->::DBCredentialsRequest::Clear();
  clear_has_msgdbcredentialsrequest();
}
inline const ::DBCredentialsRequest& UItoKeplerMessage::msgdbcredentialsrequest() const {
  return msgdbcredentialsrequest_ != NULL ? *msgdbcredentialsrequest_ : *default_instance_->msgdbcredentialsrequest_;
}
inline ::DBCredentialsRequest* UItoKeplerMessage::mutable_msgdbcredentialsrequest() {
  set_has_msgdbcredentialsrequest();
  if (msgdbcredentialsrequest_ == NULL) msgdbcredentialsrequest_ = new ::DBCredentialsRequest;
  return msgdbcredentialsrequest_;
}
inline ::DBCredentialsRequest* UItoKeplerMessage::release_msgdbcredentialsrequest() {
  clear_has_msgdbcredentialsrequest();
  ::DBCredentialsRequest* temp = msgdbcredentialsrequest_;
  msgdbcredentialsrequest_ = NULL;
  return temp;
}
inline void UItoKeplerMessage::set_allocated_msgdbcredentialsrequest(::DBCredentialsRequest* msgdbcredentialsrequest) {
  delete msgdbcredentialsrequest_;
  msgdbcredentialsrequest_ = msgdbcredentialsrequest;
  if (msgdbcredentialsrequest) {
    set_has_msgdbcredentialsrequest();
  } else {
    clear_has_msgdbcredentialsrequest();
  }
}

// optional .UIConnectRequest msgUIConnectRequest = 9;
inline bool UItoKeplerMessage::has_msguiconnectrequest() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UItoKeplerMessage::set_has_msguiconnectrequest() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UItoKeplerMessage::clear_has_msguiconnectrequest() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UItoKeplerMessage::clear_msguiconnectrequest() {
  if (msguiconnectrequest_ != NULL) msguiconnectrequest_->::UIConnectRequest::Clear();
  clear_has_msguiconnectrequest();
}
inline const ::UIConnectRequest& UItoKeplerMessage::msguiconnectrequest() const {
  return msguiconnectrequest_ != NULL ? *msguiconnectrequest_ : *default_instance_->msguiconnectrequest_;
}
inline ::UIConnectRequest* UItoKeplerMessage::mutable_msguiconnectrequest() {
  set_has_msguiconnectrequest();
  if (msguiconnectrequest_ == NULL) msguiconnectrequest_ = new ::UIConnectRequest;
  return msguiconnectrequest_;
}
inline ::UIConnectRequest* UItoKeplerMessage::release_msguiconnectrequest() {
  clear_has_msguiconnectrequest();
  ::UIConnectRequest* temp = msguiconnectrequest_;
  msguiconnectrequest_ = NULL;
  return temp;
}
inline void UItoKeplerMessage::set_allocated_msguiconnectrequest(::UIConnectRequest* msguiconnectrequest) {
  delete msguiconnectrequest_;
  msguiconnectrequest_ = msguiconnectrequest;
  if (msguiconnectrequest) {
    set_has_msguiconnectrequest();
  } else {
    clear_has_msguiconnectrequest();
  }
}

// optional .UIDisconnect msgUIDisconnect = 10;
inline bool UItoKeplerMessage::has_msguidisconnect() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UItoKeplerMessage::set_has_msguidisconnect() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UItoKeplerMessage::clear_has_msguidisconnect() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UItoKeplerMessage::clear_msguidisconnect() {
  if (msguidisconnect_ != NULL) msguidisconnect_->::UIDisconnect::Clear();
  clear_has_msguidisconnect();
}
inline const ::UIDisconnect& UItoKeplerMessage::msguidisconnect() const {
  return msguidisconnect_ != NULL ? *msguidisconnect_ : *default_instance_->msguidisconnect_;
}
inline ::UIDisconnect* UItoKeplerMessage::mutable_msguidisconnect() {
  set_has_msguidisconnect();
  if (msguidisconnect_ == NULL) msguidisconnect_ = new ::UIDisconnect;
  return msguidisconnect_;
}
inline ::UIDisconnect* UItoKeplerMessage::release_msguidisconnect() {
  clear_has_msguidisconnect();
  ::UIDisconnect* temp = msguidisconnect_;
  msguidisconnect_ = NULL;
  return temp;
}
inline void UItoKeplerMessage::set_allocated_msguidisconnect(::UIDisconnect* msguidisconnect) {
  delete msguidisconnect_;
  msguidisconnect_ = msguidisconnect;
  if (msguidisconnect) {
    set_has_msguidisconnect();
  } else {
    clear_has_msguidisconnect();
  }
}

// optional .UIVideoRequest msgUIVideoRequest = 11;
inline bool UItoKeplerMessage::has_msguivideorequest() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UItoKeplerMessage::set_has_msguivideorequest() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UItoKeplerMessage::clear_has_msguivideorequest() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UItoKeplerMessage::clear_msguivideorequest() {
  if (msguivideorequest_ != NULL) msguivideorequest_->::UIVideoRequest::Clear();
  clear_has_msguivideorequest();
}
inline const ::UIVideoRequest& UItoKeplerMessage::msguivideorequest() const {
  return msguivideorequest_ != NULL ? *msguivideorequest_ : *default_instance_->msguivideorequest_;
}
inline ::UIVideoRequest* UItoKeplerMessage::mutable_msguivideorequest() {
  set_has_msguivideorequest();
  if (msguivideorequest_ == NULL) msguivideorequest_ = new ::UIVideoRequest;
  return msguivideorequest_;
}
inline ::UIVideoRequest* UItoKeplerMessage::release_msguivideorequest() {
  clear_has_msguivideorequest();
  ::UIVideoRequest* temp = msguivideorequest_;
  msguivideorequest_ = NULL;
  return temp;
}
inline void UItoKeplerMessage::set_allocated_msguivideorequest(::UIVideoRequest* msguivideorequest) {
  delete msguivideorequest_;
  msguivideorequest_ = msguivideorequest;
  if (msguivideorequest) {
    set_has_msguivideorequest();
  } else {
    clear_has_msguivideorequest();
  }
}

// optional .UIGeoInformationRequest msgUIGeoInformationRequest = 12;
inline bool UItoKeplerMessage::has_msguigeoinformationrequest() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UItoKeplerMessage::set_has_msguigeoinformationrequest() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UItoKeplerMessage::clear_has_msguigeoinformationrequest() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UItoKeplerMessage::clear_msguigeoinformationrequest() {
  if (msguigeoinformationrequest_ != NULL) msguigeoinformationrequest_->::UIGeoInformationRequest::Clear();
  clear_has_msguigeoinformationrequest();
}
inline const ::UIGeoInformationRequest& UItoKeplerMessage::msguigeoinformationrequest() const {
  return msguigeoinformationrequest_ != NULL ? *msguigeoinformationrequest_ : *default_instance_->msguigeoinformationrequest_;
}
inline ::UIGeoInformationRequest* UItoKeplerMessage::mutable_msguigeoinformationrequest() {
  set_has_msguigeoinformationrequest();
  if (msguigeoinformationrequest_ == NULL) msguigeoinformationrequest_ = new ::UIGeoInformationRequest;
  return msguigeoinformationrequest_;
}
inline ::UIGeoInformationRequest* UItoKeplerMessage::release_msguigeoinformationrequest() {
  clear_has_msguigeoinformationrequest();
  ::UIGeoInformationRequest* temp = msguigeoinformationrequest_;
  msguigeoinformationrequest_ = NULL;
  return temp;
}
inline void UItoKeplerMessage::set_allocated_msguigeoinformationrequest(::UIGeoInformationRequest* msguigeoinformationrequest) {
  delete msguigeoinformationrequest_;
  msguigeoinformationrequest_ = msguigeoinformationrequest;
  if (msguigeoinformationrequest) {
    set_has_msguigeoinformationrequest();
  } else {
    clear_has_msguigeoinformationrequest();
  }
}

// optional .UICommandRequest msgUICommandRequest = 13;
inline bool UItoKeplerMessage::has_msguicommandrequest() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UItoKeplerMessage::set_has_msguicommandrequest() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UItoKeplerMessage::clear_has_msguicommandrequest() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UItoKeplerMessage::clear_msguicommandrequest() {
  if (msguicommandrequest_ != NULL) msguicommandrequest_->::UICommandRequest::Clear();
  clear_has_msguicommandrequest();
}
inline const ::UICommandRequest& UItoKeplerMessage::msguicommandrequest() const {
  return msguicommandrequest_ != NULL ? *msguicommandrequest_ : *default_instance_->msguicommandrequest_;
}
inline ::UICommandRequest* UItoKeplerMessage::mutable_msguicommandrequest() {
  set_has_msguicommandrequest();
  if (msguicommandrequest_ == NULL) msguicommandrequest_ = new ::UICommandRequest;
  return msguicommandrequest_;
}
inline ::UICommandRequest* UItoKeplerMessage::release_msguicommandrequest() {
  clear_has_msguicommandrequest();
  ::UICommandRequest* temp = msguicommandrequest_;
  msguicommandrequest_ = NULL;
  return temp;
}
inline void UItoKeplerMessage::set_allocated_msguicommandrequest(::UICommandRequest* msguicommandrequest) {
  delete msguicommandrequest_;
  msguicommandrequest_ = msguicommandrequest;
  if (msguicommandrequest) {
    set_has_msguicommandrequest();
  } else {
    clear_has_msguicommandrequest();
  }
}

// optional .UICeaseBuzzer msgUICeaseBuzzer = 14;
inline bool UItoKeplerMessage::has_msguiceasebuzzer() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UItoKeplerMessage::set_has_msguiceasebuzzer() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UItoKeplerMessage::clear_has_msguiceasebuzzer() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UItoKeplerMessage::clear_msguiceasebuzzer() {
  if (msguiceasebuzzer_ != NULL) msguiceasebuzzer_->::UICeaseBuzzer::Clear();
  clear_has_msguiceasebuzzer();
}
inline const ::UICeaseBuzzer& UItoKeplerMessage::msguiceasebuzzer() const {
  return msguiceasebuzzer_ != NULL ? *msguiceasebuzzer_ : *default_instance_->msguiceasebuzzer_;
}
inline ::UICeaseBuzzer* UItoKeplerMessage::mutable_msguiceasebuzzer() {
  set_has_msguiceasebuzzer();
  if (msguiceasebuzzer_ == NULL) msguiceasebuzzer_ = new ::UICeaseBuzzer;
  return msguiceasebuzzer_;
}
inline ::UICeaseBuzzer* UItoKeplerMessage::release_msguiceasebuzzer() {
  clear_has_msguiceasebuzzer();
  ::UICeaseBuzzer* temp = msguiceasebuzzer_;
  msguiceasebuzzer_ = NULL;
  return temp;
}
inline void UItoKeplerMessage::set_allocated_msguiceasebuzzer(::UICeaseBuzzer* msguiceasebuzzer) {
  delete msguiceasebuzzer_;
  msguiceasebuzzer_ = msguiceasebuzzer;
  if (msguiceasebuzzer) {
    set_has_msguiceasebuzzer();
  } else {
    clear_has_msguiceasebuzzer();
  }
}

// optional .UISetDefaultSchedule msgUISetDefaultSchedule = 15;
inline bool UItoKeplerMessage::has_msguisetdefaultschedule() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UItoKeplerMessage::set_has_msguisetdefaultschedule() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UItoKeplerMessage::clear_has_msguisetdefaultschedule() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UItoKeplerMessage::clear_msguisetdefaultschedule() {
  if (msguisetdefaultschedule_ != NULL) msguisetdefaultschedule_->::UISetDefaultSchedule::Clear();
  clear_has_msguisetdefaultschedule();
}
inline const ::UISetDefaultSchedule& UItoKeplerMessage::msguisetdefaultschedule() const {
  return msguisetdefaultschedule_ != NULL ? *msguisetdefaultschedule_ : *default_instance_->msguisetdefaultschedule_;
}
inline ::UISetDefaultSchedule* UItoKeplerMessage::mutable_msguisetdefaultschedule() {
  set_has_msguisetdefaultschedule();
  if (msguisetdefaultschedule_ == NULL) msguisetdefaultschedule_ = new ::UISetDefaultSchedule;
  return msguisetdefaultschedule_;
}
inline ::UISetDefaultSchedule* UItoKeplerMessage::release_msguisetdefaultschedule() {
  clear_has_msguisetdefaultschedule();
  ::UISetDefaultSchedule* temp = msguisetdefaultschedule_;
  msguisetdefaultschedule_ = NULL;
  return temp;
}
inline void UItoKeplerMessage::set_allocated_msguisetdefaultschedule(::UISetDefaultSchedule* msguisetdefaultschedule) {
  delete msguisetdefaultschedule_;
  msguisetdefaultschedule_ = msguisetdefaultschedule;
  if (msguisetdefaultschedule) {
    set_has_msguisetdefaultschedule();
  } else {
    clear_has_msguisetdefaultschedule();
  }
}

// optional .UIOptionsRequest msgUIOptionsRequest = 16;
inline bool UItoKeplerMessage::has_msguioptionsrequest() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UItoKeplerMessage::set_has_msguioptionsrequest() {
  _has_bits_[0] |= 0x00002000u;
}
inline void UItoKeplerMessage::clear_has_msguioptionsrequest() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void UItoKeplerMessage::clear_msguioptionsrequest() {
  if (msguioptionsrequest_ != NULL) msguioptionsrequest_->::UIOptionsRequest::Clear();
  clear_has_msguioptionsrequest();
}
inline const ::UIOptionsRequest& UItoKeplerMessage::msguioptionsrequest() const {
  return msguioptionsrequest_ != NULL ? *msguioptionsrequest_ : *default_instance_->msguioptionsrequest_;
}
inline ::UIOptionsRequest* UItoKeplerMessage::mutable_msguioptionsrequest() {
  set_has_msguioptionsrequest();
  if (msguioptionsrequest_ == NULL) msguioptionsrequest_ = new ::UIOptionsRequest;
  return msguioptionsrequest_;
}
inline ::UIOptionsRequest* UItoKeplerMessage::release_msguioptionsrequest() {
  clear_has_msguioptionsrequest();
  ::UIOptionsRequest* temp = msguioptionsrequest_;
  msguioptionsrequest_ = NULL;
  return temp;
}
inline void UItoKeplerMessage::set_allocated_msguioptionsrequest(::UIOptionsRequest* msguioptionsrequest) {
  delete msguioptionsrequest_;
  msguioptionsrequest_ = msguioptionsrequest;
  if (msguioptionsrequest) {
    set_has_msguioptionsrequest();
  } else {
    clear_has_msguioptionsrequest();
  }
}

// -------------------------------------------------------------------

// KeplertoUIMessage

// optional .service_infrastructure.Header header = 100;
inline bool KeplertoUIMessage::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeplertoUIMessage::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeplertoUIMessage::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeplertoUIMessage::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& KeplertoUIMessage::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* KeplertoUIMessage::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* KeplertoUIMessage::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void KeplertoUIMessage::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .UIAck msgUIAck = 4;
inline bool KeplertoUIMessage::has_msguiack() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeplertoUIMessage::set_has_msguiack() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeplertoUIMessage::clear_has_msguiack() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeplertoUIMessage::clear_msguiack() {
  if (msguiack_ != NULL) msguiack_->::UIAck::Clear();
  clear_has_msguiack();
}
inline const ::UIAck& KeplertoUIMessage::msguiack() const {
  return msguiack_ != NULL ? *msguiack_ : *default_instance_->msguiack_;
}
inline ::UIAck* KeplertoUIMessage::mutable_msguiack() {
  set_has_msguiack();
  if (msguiack_ == NULL) msguiack_ = new ::UIAck;
  return msguiack_;
}
inline ::UIAck* KeplertoUIMessage::release_msguiack() {
  clear_has_msguiack();
  ::UIAck* temp = msguiack_;
  msguiack_ = NULL;
  return temp;
}
inline void KeplertoUIMessage::set_allocated_msguiack(::UIAck* msguiack) {
  delete msguiack_;
  msguiack_ = msguiack;
  if (msguiack) {
    set_has_msguiack();
  } else {
    clear_has_msguiack();
  }
}

// optional .UINack msgUINack = 5;
inline bool KeplertoUIMessage::has_msguinack() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KeplertoUIMessage::set_has_msguinack() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KeplertoUIMessage::clear_has_msguinack() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KeplertoUIMessage::clear_msguinack() {
  if (msguinack_ != NULL) msguinack_->::UINack::Clear();
  clear_has_msguinack();
}
inline const ::UINack& KeplertoUIMessage::msguinack() const {
  return msguinack_ != NULL ? *msguinack_ : *default_instance_->msguinack_;
}
inline ::UINack* KeplertoUIMessage::mutable_msguinack() {
  set_has_msguinack();
  if (msguinack_ == NULL) msguinack_ = new ::UINack;
  return msguinack_;
}
inline ::UINack* KeplertoUIMessage::release_msguinack() {
  clear_has_msguinack();
  ::UINack* temp = msguinack_;
  msguinack_ = NULL;
  return temp;
}
inline void KeplertoUIMessage::set_allocated_msguinack(::UINack* msguinack) {
  delete msguinack_;
  msguinack_ = msguinack;
  if (msguinack) {
    set_has_msguinack();
  } else {
    clear_has_msguinack();
  }
}

// optional .ICDVersionResponse msgICDVersionResponse = 6;
inline bool KeplertoUIMessage::has_msgicdversionresponse() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KeplertoUIMessage::set_has_msgicdversionresponse() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KeplertoUIMessage::clear_has_msgicdversionresponse() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KeplertoUIMessage::clear_msgicdversionresponse() {
  if (msgicdversionresponse_ != NULL) msgicdversionresponse_->::ICDVersionResponse::Clear();
  clear_has_msgicdversionresponse();
}
inline const ::ICDVersionResponse& KeplertoUIMessage::msgicdversionresponse() const {
  return msgicdversionresponse_ != NULL ? *msgicdversionresponse_ : *default_instance_->msgicdversionresponse_;
}
inline ::ICDVersionResponse* KeplertoUIMessage::mutable_msgicdversionresponse() {
  set_has_msgicdversionresponse();
  if (msgicdversionresponse_ == NULL) msgicdversionresponse_ = new ::ICDVersionResponse;
  return msgicdversionresponse_;
}
inline ::ICDVersionResponse* KeplertoUIMessage::release_msgicdversionresponse() {
  clear_has_msgicdversionresponse();
  ::ICDVersionResponse* temp = msgicdversionresponse_;
  msgicdversionresponse_ = NULL;
  return temp;
}
inline void KeplertoUIMessage::set_allocated_msgicdversionresponse(::ICDVersionResponse* msgicdversionresponse) {
  delete msgicdversionresponse_;
  msgicdversionresponse_ = msgicdversionresponse;
  if (msgicdversionresponse) {
    set_has_msgicdversionresponse();
  } else {
    clear_has_msgicdversionresponse();
  }
}

// optional .DBVersionResponse msgDBVersionResponse = 7;
inline bool KeplertoUIMessage::has_msgdbversionresponse() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void KeplertoUIMessage::set_has_msgdbversionresponse() {
  _has_bits_[0] |= 0x00000010u;
}
inline void KeplertoUIMessage::clear_has_msgdbversionresponse() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void KeplertoUIMessage::clear_msgdbversionresponse() {
  if (msgdbversionresponse_ != NULL) msgdbversionresponse_->::DBVersionResponse::Clear();
  clear_has_msgdbversionresponse();
}
inline const ::DBVersionResponse& KeplertoUIMessage::msgdbversionresponse() const {
  return msgdbversionresponse_ != NULL ? *msgdbversionresponse_ : *default_instance_->msgdbversionresponse_;
}
inline ::DBVersionResponse* KeplertoUIMessage::mutable_msgdbversionresponse() {
  set_has_msgdbversionresponse();
  if (msgdbversionresponse_ == NULL) msgdbversionresponse_ = new ::DBVersionResponse;
  return msgdbversionresponse_;
}
inline ::DBVersionResponse* KeplertoUIMessage::release_msgdbversionresponse() {
  clear_has_msgdbversionresponse();
  ::DBVersionResponse* temp = msgdbversionresponse_;
  msgdbversionresponse_ = NULL;
  return temp;
}
inline void KeplertoUIMessage::set_allocated_msgdbversionresponse(::DBVersionResponse* msgdbversionresponse) {
  delete msgdbversionresponse_;
  msgdbversionresponse_ = msgdbversionresponse;
  if (msgdbversionresponse) {
    set_has_msgdbversionresponse();
  } else {
    clear_has_msgdbversionresponse();
  }
}

// optional .DBCredentialsResponse msgDBCredentialsResponse = 8;
inline bool KeplertoUIMessage::has_msgdbcredentialsresponse() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void KeplertoUIMessage::set_has_msgdbcredentialsresponse() {
  _has_bits_[0] |= 0x00000020u;
}
inline void KeplertoUIMessage::clear_has_msgdbcredentialsresponse() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void KeplertoUIMessage::clear_msgdbcredentialsresponse() {
  if (msgdbcredentialsresponse_ != NULL) msgdbcredentialsresponse_->::DBCredentialsResponse::Clear();
  clear_has_msgdbcredentialsresponse();
}
inline const ::DBCredentialsResponse& KeplertoUIMessage::msgdbcredentialsresponse() const {
  return msgdbcredentialsresponse_ != NULL ? *msgdbcredentialsresponse_ : *default_instance_->msgdbcredentialsresponse_;
}
inline ::DBCredentialsResponse* KeplertoUIMessage::mutable_msgdbcredentialsresponse() {
  set_has_msgdbcredentialsresponse();
  if (msgdbcredentialsresponse_ == NULL) msgdbcredentialsresponse_ = new ::DBCredentialsResponse;
  return msgdbcredentialsresponse_;
}
inline ::DBCredentialsResponse* KeplertoUIMessage::release_msgdbcredentialsresponse() {
  clear_has_msgdbcredentialsresponse();
  ::DBCredentialsResponse* temp = msgdbcredentialsresponse_;
  msgdbcredentialsresponse_ = NULL;
  return temp;
}
inline void KeplertoUIMessage::set_allocated_msgdbcredentialsresponse(::DBCredentialsResponse* msgdbcredentialsresponse) {
  delete msgdbcredentialsresponse_;
  msgdbcredentialsresponse_ = msgdbcredentialsresponse;
  if (msgdbcredentialsresponse) {
    set_has_msgdbcredentialsresponse();
  } else {
    clear_has_msgdbcredentialsresponse();
  }
}

// optional .UIConnectResponse msgUIConnectResponse = 9;
inline bool KeplertoUIMessage::has_msguiconnectresponse() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void KeplertoUIMessage::set_has_msguiconnectresponse() {
  _has_bits_[0] |= 0x00000040u;
}
inline void KeplertoUIMessage::clear_has_msguiconnectresponse() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void KeplertoUIMessage::clear_msguiconnectresponse() {
  if (msguiconnectresponse_ != NULL) msguiconnectresponse_->::UIConnectResponse::Clear();
  clear_has_msguiconnectresponse();
}
inline const ::UIConnectResponse& KeplertoUIMessage::msguiconnectresponse() const {
  return msguiconnectresponse_ != NULL ? *msguiconnectresponse_ : *default_instance_->msguiconnectresponse_;
}
inline ::UIConnectResponse* KeplertoUIMessage::mutable_msguiconnectresponse() {
  set_has_msguiconnectresponse();
  if (msguiconnectresponse_ == NULL) msguiconnectresponse_ = new ::UIConnectResponse;
  return msguiconnectresponse_;
}
inline ::UIConnectResponse* KeplertoUIMessage::release_msguiconnectresponse() {
  clear_has_msguiconnectresponse();
  ::UIConnectResponse* temp = msguiconnectresponse_;
  msguiconnectresponse_ = NULL;
  return temp;
}
inline void KeplertoUIMessage::set_allocated_msguiconnectresponse(::UIConnectResponse* msguiconnectresponse) {
  delete msguiconnectresponse_;
  msguiconnectresponse_ = msguiconnectresponse;
  if (msguiconnectresponse) {
    set_has_msguiconnectresponse();
  } else {
    clear_has_msguiconnectresponse();
  }
}

// optional .UISignalEvent msgUISignalEvent = 10;
inline bool KeplertoUIMessage::has_msguisignalevent() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void KeplertoUIMessage::set_has_msguisignalevent() {
  _has_bits_[0] |= 0x00000080u;
}
inline void KeplertoUIMessage::clear_has_msguisignalevent() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void KeplertoUIMessage::clear_msguisignalevent() {
  if (msguisignalevent_ != NULL) msguisignalevent_->::UISignalEvent::Clear();
  clear_has_msguisignalevent();
}
inline const ::UISignalEvent& KeplertoUIMessage::msguisignalevent() const {
  return msguisignalevent_ != NULL ? *msguisignalevent_ : *default_instance_->msguisignalevent_;
}
inline ::UISignalEvent* KeplertoUIMessage::mutable_msguisignalevent() {
  set_has_msguisignalevent();
  if (msguisignalevent_ == NULL) msguisignalevent_ = new ::UISignalEvent;
  return msguisignalevent_;
}
inline ::UISignalEvent* KeplertoUIMessage::release_msguisignalevent() {
  clear_has_msguisignalevent();
  ::UISignalEvent* temp = msguisignalevent_;
  msguisignalevent_ = NULL;
  return temp;
}
inline void KeplertoUIMessage::set_allocated_msguisignalevent(::UISignalEvent* msguisignalevent) {
  delete msguisignalevent_;
  msguisignalevent_ = msguisignalevent;
  if (msguisignalevent) {
    set_has_msguisignalevent();
  } else {
    clear_has_msguisignalevent();
  }
}

// optional .UIVideoResponse msgUIVideoResponse = 11;
inline bool KeplertoUIMessage::has_msguivideoresponse() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void KeplertoUIMessage::set_has_msguivideoresponse() {
  _has_bits_[0] |= 0x00000100u;
}
inline void KeplertoUIMessage::clear_has_msguivideoresponse() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void KeplertoUIMessage::clear_msguivideoresponse() {
  if (msguivideoresponse_ != NULL) msguivideoresponse_->::UIVideoResponse::Clear();
  clear_has_msguivideoresponse();
}
inline const ::UIVideoResponse& KeplertoUIMessage::msguivideoresponse() const {
  return msguivideoresponse_ != NULL ? *msguivideoresponse_ : *default_instance_->msguivideoresponse_;
}
inline ::UIVideoResponse* KeplertoUIMessage::mutable_msguivideoresponse() {
  set_has_msguivideoresponse();
  if (msguivideoresponse_ == NULL) msguivideoresponse_ = new ::UIVideoResponse;
  return msguivideoresponse_;
}
inline ::UIVideoResponse* KeplertoUIMessage::release_msguivideoresponse() {
  clear_has_msguivideoresponse();
  ::UIVideoResponse* temp = msguivideoresponse_;
  msguivideoresponse_ = NULL;
  return temp;
}
inline void KeplertoUIMessage::set_allocated_msguivideoresponse(::UIVideoResponse* msguivideoresponse) {
  delete msguivideoresponse_;
  msguivideoresponse_ = msguivideoresponse;
  if (msguivideoresponse) {
    set_has_msguivideoresponse();
  } else {
    clear_has_msguivideoresponse();
  }
}

// optional .UIGeoInformation msgUIGeoInformation = 12;
inline bool KeplertoUIMessage::has_msguigeoinformation() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void KeplertoUIMessage::set_has_msguigeoinformation() {
  _has_bits_[0] |= 0x00000200u;
}
inline void KeplertoUIMessage::clear_has_msguigeoinformation() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void KeplertoUIMessage::clear_msguigeoinformation() {
  if (msguigeoinformation_ != NULL) msguigeoinformation_->::UIGeoInformation::Clear();
  clear_has_msguigeoinformation();
}
inline const ::UIGeoInformation& KeplertoUIMessage::msguigeoinformation() const {
  return msguigeoinformation_ != NULL ? *msguigeoinformation_ : *default_instance_->msguigeoinformation_;
}
inline ::UIGeoInformation* KeplertoUIMessage::mutable_msguigeoinformation() {
  set_has_msguigeoinformation();
  if (msguigeoinformation_ == NULL) msguigeoinformation_ = new ::UIGeoInformation;
  return msguigeoinformation_;
}
inline ::UIGeoInformation* KeplertoUIMessage::release_msguigeoinformation() {
  clear_has_msguigeoinformation();
  ::UIGeoInformation* temp = msguigeoinformation_;
  msguigeoinformation_ = NULL;
  return temp;
}
inline void KeplertoUIMessage::set_allocated_msguigeoinformation(::UIGeoInformation* msguigeoinformation) {
  delete msguigeoinformation_;
  msguigeoinformation_ = msguigeoinformation;
  if (msguigeoinformation) {
    set_has_msguigeoinformation();
  } else {
    clear_has_msguigeoinformation();
  }
}

// optional .UIOptions msgUIOptions = 13;
inline bool KeplertoUIMessage::has_msguioptions() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void KeplertoUIMessage::set_has_msguioptions() {
  _has_bits_[0] |= 0x00000400u;
}
inline void KeplertoUIMessage::clear_has_msguioptions() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void KeplertoUIMessage::clear_msguioptions() {
  if (msguioptions_ != NULL) msguioptions_->::UIOptions::Clear();
  clear_has_msguioptions();
}
inline const ::UIOptions& KeplertoUIMessage::msguioptions() const {
  return msguioptions_ != NULL ? *msguioptions_ : *default_instance_->msguioptions_;
}
inline ::UIOptions* KeplertoUIMessage::mutable_msguioptions() {
  set_has_msguioptions();
  if (msguioptions_ == NULL) msguioptions_ = new ::UIOptions;
  return msguioptions_;
}
inline ::UIOptions* KeplertoUIMessage::release_msguioptions() {
  clear_has_msguioptions();
  ::UIOptions* temp = msguioptions_;
  msguioptions_ = NULL;
  return temp;
}
inline void KeplertoUIMessage::set_allocated_msguioptions(::UIOptions* msguioptions) {
  delete msguioptions_;
  msguioptions_ = msguioptions;
  if (msguioptions) {
    set_has_msguioptions();
  } else {
    clear_has_msguioptions();
  }
}

// optional .UIOptionDelete msgUIOptionDelete = 14;
inline bool KeplertoUIMessage::has_msguioptiondelete() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void KeplertoUIMessage::set_has_msguioptiondelete() {
  _has_bits_[0] |= 0x00000800u;
}
inline void KeplertoUIMessage::clear_has_msguioptiondelete() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void KeplertoUIMessage::clear_msguioptiondelete() {
  if (msguioptiondelete_ != NULL) msguioptiondelete_->::UIOptionDelete::Clear();
  clear_has_msguioptiondelete();
}
inline const ::UIOptionDelete& KeplertoUIMessage::msguioptiondelete() const {
  return msguioptiondelete_ != NULL ? *msguioptiondelete_ : *default_instance_->msguioptiondelete_;
}
inline ::UIOptionDelete* KeplertoUIMessage::mutable_msguioptiondelete() {
  set_has_msguioptiondelete();
  if (msguioptiondelete_ == NULL) msguioptiondelete_ = new ::UIOptionDelete;
  return msguioptiondelete_;
}
inline ::UIOptionDelete* KeplertoUIMessage::release_msguioptiondelete() {
  clear_has_msguioptiondelete();
  ::UIOptionDelete* temp = msguioptiondelete_;
  msguioptiondelete_ = NULL;
  return temp;
}
inline void KeplertoUIMessage::set_allocated_msguioptiondelete(::UIOptionDelete* msguioptiondelete) {
  delete msguioptiondelete_;
  msguioptiondelete_ = msguioptiondelete;
  if (msguioptiondelete) {
    set_has_msguioptiondelete();
  } else {
    clear_has_msguioptiondelete();
  }
}

// optional .EWStatus msgEWStatus = 15;
inline bool KeplertoUIMessage::has_msgewstatus() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void KeplertoUIMessage::set_has_msgewstatus() {
  _has_bits_[0] |= 0x00001000u;
}
inline void KeplertoUIMessage::clear_has_msgewstatus() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void KeplertoUIMessage::clear_msgewstatus() {
  if (msgewstatus_ != NULL) msgewstatus_->::EWStatus::Clear();
  clear_has_msgewstatus();
}
inline const ::EWStatus& KeplertoUIMessage::msgewstatus() const {
  return msgewstatus_ != NULL ? *msgewstatus_ : *default_instance_->msgewstatus_;
}
inline ::EWStatus* KeplertoUIMessage::mutable_msgewstatus() {
  set_has_msgewstatus();
  if (msgewstatus_ == NULL) msgewstatus_ = new ::EWStatus;
  return msgewstatus_;
}
inline ::EWStatus* KeplertoUIMessage::release_msgewstatus() {
  clear_has_msgewstatus();
  ::EWStatus* temp = msgewstatus_;
  msgewstatus_ = NULL;
  return temp;
}
inline void KeplertoUIMessage::set_allocated_msgewstatus(::EWStatus* msgewstatus) {
  delete msgewstatus_;
  msgewstatus_ = msgewstatus;
  if (msgewstatus) {
    set_has_msgewstatus();
  } else {
    clear_has_msgewstatus();
  }
}

// optional .KeplerHeartBeat msgKeplerHeartBeat = 16;
inline bool KeplertoUIMessage::has_msgkeplerheartbeat() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void KeplertoUIMessage::set_has_msgkeplerheartbeat() {
  _has_bits_[0] |= 0x00002000u;
}
inline void KeplertoUIMessage::clear_has_msgkeplerheartbeat() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void KeplertoUIMessage::clear_msgkeplerheartbeat() {
  if (msgkeplerheartbeat_ != NULL) msgkeplerheartbeat_->::KeplerHeartBeat::Clear();
  clear_has_msgkeplerheartbeat();
}
inline const ::KeplerHeartBeat& KeplertoUIMessage::msgkeplerheartbeat() const {
  return msgkeplerheartbeat_ != NULL ? *msgkeplerheartbeat_ : *default_instance_->msgkeplerheartbeat_;
}
inline ::KeplerHeartBeat* KeplertoUIMessage::mutable_msgkeplerheartbeat() {
  set_has_msgkeplerheartbeat();
  if (msgkeplerheartbeat_ == NULL) msgkeplerheartbeat_ = new ::KeplerHeartBeat;
  return msgkeplerheartbeat_;
}
inline ::KeplerHeartBeat* KeplertoUIMessage::release_msgkeplerheartbeat() {
  clear_has_msgkeplerheartbeat();
  ::KeplerHeartBeat* temp = msgkeplerheartbeat_;
  msgkeplerheartbeat_ = NULL;
  return temp;
}
inline void KeplertoUIMessage::set_allocated_msgkeplerheartbeat(::KeplerHeartBeat* msgkeplerheartbeat) {
  delete msgkeplerheartbeat_;
  msgkeplerheartbeat_ = msgkeplerheartbeat;
  if (msgkeplerheartbeat) {
    set_has_msgkeplerheartbeat();
  } else {
    clear_has_msgkeplerheartbeat();
  }
}

// -------------------------------------------------------------------

// UIAck

// optional string msgName = 1 [default = "UIAck"];
inline bool UIAck::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UIAck::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UIAck::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UIAck::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& UIAck::msgname() const {
  return *msgname_;
}
inline void UIAck::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UIAck::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UIAck::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIAck::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* UIAck::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void UIAck::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int64 seqNumber = 2;
inline bool UIAck::has_seqnumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UIAck::set_has_seqnumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UIAck::clear_has_seqnumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UIAck::clear_seqnumber() {
  seqnumber_ = GOOGLE_LONGLONG(0);
  clear_has_seqnumber();
}
inline ::google::protobuf::int64 UIAck::seqnumber() const {
  return seqnumber_;
}
inline void UIAck::set_seqnumber(::google::protobuf::int64 value) {
  set_has_seqnumber();
  seqnumber_ = value;
}

// -------------------------------------------------------------------

// UINack

// optional string msgName = 1 [default = "UINack"];
inline bool UINack::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UINack::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UINack::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UINack::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& UINack::msgname() const {
  return *msgname_;
}
inline void UINack::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UINack::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UINack::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UINack::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* UINack::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void UINack::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 seqNumber = 2;
inline bool UINack::has_seqnumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UINack::set_has_seqnumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UINack::clear_has_seqnumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UINack::clear_seqnumber() {
  seqnumber_ = 0;
  clear_has_seqnumber();
}
inline ::google::protobuf::int32 UINack::seqnumber() const {
  return seqnumber_;
}
inline void UINack::set_seqnumber(::google::protobuf::int32 value) {
  set_has_seqnumber();
  seqnumber_ = value;
}

// optional .UINack.ErrorCode errorCode = 3;
inline bool UINack::has_errorcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UINack::set_has_errorcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UINack::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UINack::clear_errorcode() {
  errorcode_ = 0;
  clear_has_errorcode();
}
inline ::UINack_ErrorCode UINack::errorcode() const {
  return static_cast< ::UINack_ErrorCode >(errorcode_);
}
inline void UINack::set_errorcode(::UINack_ErrorCode value) {
  assert(::UINack_ErrorCode_IsValid(value));
  set_has_errorcode();
  errorcode_ = value;
}

// optional string reason = 4;
inline bool UINack::has_reason() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UINack::set_has_reason() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UINack::clear_has_reason() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UINack::clear_reason() {
  if (reason_ != &::google::protobuf::internal::kEmptyString) {
    reason_->clear();
  }
  clear_has_reason();
}
inline const ::std::string& UINack::reason() const {
  return *reason_;
}
inline void UINack::set_reason(const ::std::string& value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void UINack::set_reason(const char* value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void UINack::set_reason(const char* value, size_t size) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UINack::mutable_reason() {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  return reason_;
}
inline ::std::string* UINack::release_reason() {
  clear_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reason_;
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UINack::set_allocated_reason(::std::string* reason) {
  if (reason_ != &::google::protobuf::internal::kEmptyString) {
    delete reason_;
  }
  if (reason) {
    set_has_reason();
    reason_ = reason;
  } else {
    clear_has_reason();
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ICDVersionRequest

// optional string msgName = 1 [default = "ICDVersionRequest"];
inline bool ICDVersionRequest::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ICDVersionRequest::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ICDVersionRequest::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ICDVersionRequest::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ICDVersionRequest::msgname() const {
  return *msgname_;
}
inline void ICDVersionRequest::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ICDVersionRequest::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ICDVersionRequest::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ICDVersionRequest::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ICDVersionRequest::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ICDVersionRequest::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string senderName = 2;
inline bool ICDVersionRequest::has_sendername() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ICDVersionRequest::set_has_sendername() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ICDVersionRequest::clear_has_sendername() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ICDVersionRequest::clear_sendername() {
  if (sendername_ != &::google::protobuf::internal::kEmptyString) {
    sendername_->clear();
  }
  clear_has_sendername();
}
inline const ::std::string& ICDVersionRequest::sendername() const {
  return *sendername_;
}
inline void ICDVersionRequest::set_sendername(const ::std::string& value) {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  sendername_->assign(value);
}
inline void ICDVersionRequest::set_sendername(const char* value) {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  sendername_->assign(value);
}
inline void ICDVersionRequest::set_sendername(const char* value, size_t size) {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  sendername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ICDVersionRequest::mutable_sendername() {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  return sendername_;
}
inline ::std::string* ICDVersionRequest::release_sendername() {
  clear_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sendername_;
    sendername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ICDVersionRequest::set_allocated_sendername(::std::string* sendername) {
  if (sendername_ != &::google::protobuf::internal::kEmptyString) {
    delete sendername_;
  }
  if (sendername) {
    set_has_sendername();
    sendername_ = sendername;
  } else {
    clear_has_sendername();
    sendername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DBVersionRequest

// optional string msgName = 1 [default = "DBVersionRequest"];
inline bool DBVersionRequest::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DBVersionRequest::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DBVersionRequest::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DBVersionRequest::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& DBVersionRequest::msgname() const {
  return *msgname_;
}
inline void DBVersionRequest::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void DBVersionRequest::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void DBVersionRequest::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBVersionRequest::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* DBVersionRequest::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void DBVersionRequest::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string senderName = 2;
inline bool DBVersionRequest::has_sendername() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DBVersionRequest::set_has_sendername() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DBVersionRequest::clear_has_sendername() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DBVersionRequest::clear_sendername() {
  if (sendername_ != &::google::protobuf::internal::kEmptyString) {
    sendername_->clear();
  }
  clear_has_sendername();
}
inline const ::std::string& DBVersionRequest::sendername() const {
  return *sendername_;
}
inline void DBVersionRequest::set_sendername(const ::std::string& value) {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  sendername_->assign(value);
}
inline void DBVersionRequest::set_sendername(const char* value) {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  sendername_->assign(value);
}
inline void DBVersionRequest::set_sendername(const char* value, size_t size) {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  sendername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBVersionRequest::mutable_sendername() {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  return sendername_;
}
inline ::std::string* DBVersionRequest::release_sendername() {
  clear_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sendername_;
    sendername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBVersionRequest::set_allocated_sendername(::std::string* sendername) {
  if (sendername_ != &::google::protobuf::internal::kEmptyString) {
    delete sendername_;
  }
  if (sendername) {
    set_has_sendername();
    sendername_ = sendername;
  } else {
    clear_has_sendername();
    sendername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ICDVersionResponse

// optional string msgName = 1 [default = "ICDVersionResponse"];
inline bool ICDVersionResponse::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ICDVersionResponse::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ICDVersionResponse::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ICDVersionResponse::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ICDVersionResponse::msgname() const {
  return *msgname_;
}
inline void ICDVersionResponse::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ICDVersionResponse::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ICDVersionResponse::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ICDVersionResponse::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ICDVersionResponse::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ICDVersionResponse::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int64 major = 2 [default = 0];
inline bool ICDVersionResponse::has_major() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ICDVersionResponse::set_has_major() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ICDVersionResponse::clear_has_major() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ICDVersionResponse::clear_major() {
  major_ = GOOGLE_LONGLONG(0);
  clear_has_major();
}
inline ::google::protobuf::int64 ICDVersionResponse::major() const {
  return major_;
}
inline void ICDVersionResponse::set_major(::google::protobuf::int64 value) {
  set_has_major();
  major_ = value;
}

// optional int64 minor = 3 [default = 0];
inline bool ICDVersionResponse::has_minor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ICDVersionResponse::set_has_minor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ICDVersionResponse::clear_has_minor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ICDVersionResponse::clear_minor() {
  minor_ = GOOGLE_LONGLONG(0);
  clear_has_minor();
}
inline ::google::protobuf::int64 ICDVersionResponse::minor() const {
  return minor_;
}
inline void ICDVersionResponse::set_minor(::google::protobuf::int64 value) {
  set_has_minor();
  minor_ = value;
}

// optional int64 patch = 4 [default = 1];
inline bool ICDVersionResponse::has_patch() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ICDVersionResponse::set_has_patch() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ICDVersionResponse::clear_has_patch() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ICDVersionResponse::clear_patch() {
  patch_ = GOOGLE_LONGLONG(1);
  clear_has_patch();
}
inline ::google::protobuf::int64 ICDVersionResponse::patch() const {
  return patch_;
}
inline void ICDVersionResponse::set_patch(::google::protobuf::int64 value) {
  set_has_patch();
  patch_ = value;
}

// optional string date = 5;
inline bool ICDVersionResponse::has_date() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ICDVersionResponse::set_has_date() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ICDVersionResponse::clear_has_date() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ICDVersionResponse::clear_date() {
  if (date_ != &::google::protobuf::internal::kEmptyString) {
    date_->clear();
  }
  clear_has_date();
}
inline const ::std::string& ICDVersionResponse::date() const {
  return *date_;
}
inline void ICDVersionResponse::set_date(const ::std::string& value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void ICDVersionResponse::set_date(const char* value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void ICDVersionResponse::set_date(const char* value, size_t size) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ICDVersionResponse::mutable_date() {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  return date_;
}
inline ::std::string* ICDVersionResponse::release_date() {
  clear_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = date_;
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ICDVersionResponse::set_allocated_date(::std::string* date) {
  if (date_ != &::google::protobuf::internal::kEmptyString) {
    delete date_;
  }
  if (date) {
    set_has_date();
    date_ = date;
  } else {
    clear_has_date();
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string info = 6;
inline bool ICDVersionResponse::has_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ICDVersionResponse::set_has_info() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ICDVersionResponse::clear_has_info() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ICDVersionResponse::clear_info() {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& ICDVersionResponse::info() const {
  return *info_;
}
inline void ICDVersionResponse::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void ICDVersionResponse::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void ICDVersionResponse::set_info(const char* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ICDVersionResponse::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  return info_;
}
inline ::std::string* ICDVersionResponse::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ICDVersionResponse::set_allocated_info(::std::string* info) {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    delete info_;
  }
  if (info) {
    set_has_info();
    info_ = info;
  } else {
    clear_has_info();
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DBVersionResponse

// optional string msgName = 1 [default = "DBVersionResponse"];
inline bool DBVersionResponse::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DBVersionResponse::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DBVersionResponse::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DBVersionResponse::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& DBVersionResponse::msgname() const {
  return *msgname_;
}
inline void DBVersionResponse::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void DBVersionResponse::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void DBVersionResponse::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBVersionResponse::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* DBVersionResponse::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void DBVersionResponse::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int64 major = 2 [default = 0];
inline bool DBVersionResponse::has_major() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DBVersionResponse::set_has_major() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DBVersionResponse::clear_has_major() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DBVersionResponse::clear_major() {
  major_ = GOOGLE_LONGLONG(0);
  clear_has_major();
}
inline ::google::protobuf::int64 DBVersionResponse::major() const {
  return major_;
}
inline void DBVersionResponse::set_major(::google::protobuf::int64 value) {
  set_has_major();
  major_ = value;
}

// optional int64 minor = 3 [default = 0];
inline bool DBVersionResponse::has_minor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DBVersionResponse::set_has_minor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DBVersionResponse::clear_has_minor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DBVersionResponse::clear_minor() {
  minor_ = GOOGLE_LONGLONG(0);
  clear_has_minor();
}
inline ::google::protobuf::int64 DBVersionResponse::minor() const {
  return minor_;
}
inline void DBVersionResponse::set_minor(::google::protobuf::int64 value) {
  set_has_minor();
  minor_ = value;
}

// optional int64 patch = 4 [default = 1];
inline bool DBVersionResponse::has_patch() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DBVersionResponse::set_has_patch() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DBVersionResponse::clear_has_patch() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DBVersionResponse::clear_patch() {
  patch_ = GOOGLE_LONGLONG(1);
  clear_has_patch();
}
inline ::google::protobuf::int64 DBVersionResponse::patch() const {
  return patch_;
}
inline void DBVersionResponse::set_patch(::google::protobuf::int64 value) {
  set_has_patch();
  patch_ = value;
}

// optional string date = 5;
inline bool DBVersionResponse::has_date() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DBVersionResponse::set_has_date() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DBVersionResponse::clear_has_date() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DBVersionResponse::clear_date() {
  if (date_ != &::google::protobuf::internal::kEmptyString) {
    date_->clear();
  }
  clear_has_date();
}
inline const ::std::string& DBVersionResponse::date() const {
  return *date_;
}
inline void DBVersionResponse::set_date(const ::std::string& value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void DBVersionResponse::set_date(const char* value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void DBVersionResponse::set_date(const char* value, size_t size) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBVersionResponse::mutable_date() {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  return date_;
}
inline ::std::string* DBVersionResponse::release_date() {
  clear_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = date_;
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBVersionResponse::set_allocated_date(::std::string* date) {
  if (date_ != &::google::protobuf::internal::kEmptyString) {
    delete date_;
  }
  if (date) {
    set_has_date();
    date_ = date;
  } else {
    clear_has_date();
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string info = 6;
inline bool DBVersionResponse::has_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DBVersionResponse::set_has_info() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DBVersionResponse::clear_has_info() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DBVersionResponse::clear_info() {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& DBVersionResponse::info() const {
  return *info_;
}
inline void DBVersionResponse::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void DBVersionResponse::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void DBVersionResponse::set_info(const char* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBVersionResponse::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  return info_;
}
inline ::std::string* DBVersionResponse::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBVersionResponse::set_allocated_info(::std::string* info) {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    delete info_;
  }
  if (info) {
    set_has_info();
    info_ = info;
  } else {
    clear_has_info();
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DBCredentialsRequest

// optional string msgName = 1 [default = "DBCredentialsRequest"];
inline bool DBCredentialsRequest::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DBCredentialsRequest::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DBCredentialsRequest::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DBCredentialsRequest::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& DBCredentialsRequest::msgname() const {
  return *msgname_;
}
inline void DBCredentialsRequest::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void DBCredentialsRequest::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void DBCredentialsRequest::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCredentialsRequest::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* DBCredentialsRequest::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void DBCredentialsRequest::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string senderName = 2;
inline bool DBCredentialsRequest::has_sendername() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DBCredentialsRequest::set_has_sendername() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DBCredentialsRequest::clear_has_sendername() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DBCredentialsRequest::clear_sendername() {
  if (sendername_ != &::google::protobuf::internal::kEmptyString) {
    sendername_->clear();
  }
  clear_has_sendername();
}
inline const ::std::string& DBCredentialsRequest::sendername() const {
  return *sendername_;
}
inline void DBCredentialsRequest::set_sendername(const ::std::string& value) {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  sendername_->assign(value);
}
inline void DBCredentialsRequest::set_sendername(const char* value) {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  sendername_->assign(value);
}
inline void DBCredentialsRequest::set_sendername(const char* value, size_t size) {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  sendername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCredentialsRequest::mutable_sendername() {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  return sendername_;
}
inline ::std::string* DBCredentialsRequest::release_sendername() {
  clear_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sendername_;
    sendername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBCredentialsRequest::set_allocated_sendername(::std::string* sendername) {
  if (sendername_ != &::google::protobuf::internal::kEmptyString) {
    delete sendername_;
  }
  if (sendername) {
    set_has_sendername();
    sendername_ = sendername;
  } else {
    clear_has_sendername();
    sendername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DBCredentialsResponse

// optional string msgName = 1 [default = "DBCredentialsResponse"];
inline bool DBCredentialsResponse::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DBCredentialsResponse::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DBCredentialsResponse::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DBCredentialsResponse::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& DBCredentialsResponse::msgname() const {
  return *msgname_;
}
inline void DBCredentialsResponse::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void DBCredentialsResponse::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void DBCredentialsResponse::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCredentialsResponse::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* DBCredentialsResponse::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void DBCredentialsResponse::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string hostName = 2;
inline bool DBCredentialsResponse::has_hostname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DBCredentialsResponse::set_has_hostname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DBCredentialsResponse::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DBCredentialsResponse::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& DBCredentialsResponse::hostname() const {
  return *hostname_;
}
inline void DBCredentialsResponse::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void DBCredentialsResponse::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void DBCredentialsResponse::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCredentialsResponse::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* DBCredentialsResponse::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBCredentialsResponse::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ip = 3;
inline bool DBCredentialsResponse::has_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DBCredentialsResponse::set_has_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DBCredentialsResponse::clear_has_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DBCredentialsResponse::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& DBCredentialsResponse::ip() const {
  return *ip_;
}
inline void DBCredentialsResponse::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void DBCredentialsResponse::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void DBCredentialsResponse::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCredentialsResponse::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* DBCredentialsResponse::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBCredentialsResponse::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dbName = 4;
inline bool DBCredentialsResponse::has_dbname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DBCredentialsResponse::set_has_dbname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DBCredentialsResponse::clear_has_dbname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DBCredentialsResponse::clear_dbname() {
  if (dbname_ != &::google::protobuf::internal::kEmptyString) {
    dbname_->clear();
  }
  clear_has_dbname();
}
inline const ::std::string& DBCredentialsResponse::dbname() const {
  return *dbname_;
}
inline void DBCredentialsResponse::set_dbname(const ::std::string& value) {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    dbname_ = new ::std::string;
  }
  dbname_->assign(value);
}
inline void DBCredentialsResponse::set_dbname(const char* value) {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    dbname_ = new ::std::string;
  }
  dbname_->assign(value);
}
inline void DBCredentialsResponse::set_dbname(const char* value, size_t size) {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    dbname_ = new ::std::string;
  }
  dbname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCredentialsResponse::mutable_dbname() {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    dbname_ = new ::std::string;
  }
  return dbname_;
}
inline ::std::string* DBCredentialsResponse::release_dbname() {
  clear_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dbname_;
    dbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBCredentialsResponse::set_allocated_dbname(::std::string* dbname) {
  if (dbname_ != &::google::protobuf::internal::kEmptyString) {
    delete dbname_;
  }
  if (dbname) {
    set_has_dbname();
    dbname_ = dbname;
  } else {
    clear_has_dbname();
    dbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dbUser = 5;
inline bool DBCredentialsResponse::has_dbuser() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DBCredentialsResponse::set_has_dbuser() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DBCredentialsResponse::clear_has_dbuser() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DBCredentialsResponse::clear_dbuser() {
  if (dbuser_ != &::google::protobuf::internal::kEmptyString) {
    dbuser_->clear();
  }
  clear_has_dbuser();
}
inline const ::std::string& DBCredentialsResponse::dbuser() const {
  return *dbuser_;
}
inline void DBCredentialsResponse::set_dbuser(const ::std::string& value) {
  set_has_dbuser();
  if (dbuser_ == &::google::protobuf::internal::kEmptyString) {
    dbuser_ = new ::std::string;
  }
  dbuser_->assign(value);
}
inline void DBCredentialsResponse::set_dbuser(const char* value) {
  set_has_dbuser();
  if (dbuser_ == &::google::protobuf::internal::kEmptyString) {
    dbuser_ = new ::std::string;
  }
  dbuser_->assign(value);
}
inline void DBCredentialsResponse::set_dbuser(const char* value, size_t size) {
  set_has_dbuser();
  if (dbuser_ == &::google::protobuf::internal::kEmptyString) {
    dbuser_ = new ::std::string;
  }
  dbuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCredentialsResponse::mutable_dbuser() {
  set_has_dbuser();
  if (dbuser_ == &::google::protobuf::internal::kEmptyString) {
    dbuser_ = new ::std::string;
  }
  return dbuser_;
}
inline ::std::string* DBCredentialsResponse::release_dbuser() {
  clear_has_dbuser();
  if (dbuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dbuser_;
    dbuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBCredentialsResponse::set_allocated_dbuser(::std::string* dbuser) {
  if (dbuser_ != &::google::protobuf::internal::kEmptyString) {
    delete dbuser_;
  }
  if (dbuser) {
    set_has_dbuser();
    dbuser_ = dbuser;
  } else {
    clear_has_dbuser();
    dbuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dbPassword = 6;
inline bool DBCredentialsResponse::has_dbpassword() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DBCredentialsResponse::set_has_dbpassword() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DBCredentialsResponse::clear_has_dbpassword() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DBCredentialsResponse::clear_dbpassword() {
  if (dbpassword_ != &::google::protobuf::internal::kEmptyString) {
    dbpassword_->clear();
  }
  clear_has_dbpassword();
}
inline const ::std::string& DBCredentialsResponse::dbpassword() const {
  return *dbpassword_;
}
inline void DBCredentialsResponse::set_dbpassword(const ::std::string& value) {
  set_has_dbpassword();
  if (dbpassword_ == &::google::protobuf::internal::kEmptyString) {
    dbpassword_ = new ::std::string;
  }
  dbpassword_->assign(value);
}
inline void DBCredentialsResponse::set_dbpassword(const char* value) {
  set_has_dbpassword();
  if (dbpassword_ == &::google::protobuf::internal::kEmptyString) {
    dbpassword_ = new ::std::string;
  }
  dbpassword_->assign(value);
}
inline void DBCredentialsResponse::set_dbpassword(const char* value, size_t size) {
  set_has_dbpassword();
  if (dbpassword_ == &::google::protobuf::internal::kEmptyString) {
    dbpassword_ = new ::std::string;
  }
  dbpassword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCredentialsResponse::mutable_dbpassword() {
  set_has_dbpassword();
  if (dbpassword_ == &::google::protobuf::internal::kEmptyString) {
    dbpassword_ = new ::std::string;
  }
  return dbpassword_;
}
inline ::std::string* DBCredentialsResponse::release_dbpassword() {
  clear_has_dbpassword();
  if (dbpassword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dbpassword_;
    dbpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBCredentialsResponse::set_allocated_dbpassword(::std::string* dbpassword) {
  if (dbpassword_ != &::google::protobuf::internal::kEmptyString) {
    delete dbpassword_;
  }
  if (dbpassword) {
    set_has_dbpassword();
    dbpassword_ = dbpassword;
  } else {
    clear_has_dbpassword();
    dbpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dbPort = 7;
inline bool DBCredentialsResponse::has_dbport() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DBCredentialsResponse::set_has_dbport() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DBCredentialsResponse::clear_has_dbport() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DBCredentialsResponse::clear_dbport() {
  if (dbport_ != &::google::protobuf::internal::kEmptyString) {
    dbport_->clear();
  }
  clear_has_dbport();
}
inline const ::std::string& DBCredentialsResponse::dbport() const {
  return *dbport_;
}
inline void DBCredentialsResponse::set_dbport(const ::std::string& value) {
  set_has_dbport();
  if (dbport_ == &::google::protobuf::internal::kEmptyString) {
    dbport_ = new ::std::string;
  }
  dbport_->assign(value);
}
inline void DBCredentialsResponse::set_dbport(const char* value) {
  set_has_dbport();
  if (dbport_ == &::google::protobuf::internal::kEmptyString) {
    dbport_ = new ::std::string;
  }
  dbport_->assign(value);
}
inline void DBCredentialsResponse::set_dbport(const char* value, size_t size) {
  set_has_dbport();
  if (dbport_ == &::google::protobuf::internal::kEmptyString) {
    dbport_ = new ::std::string;
  }
  dbport_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCredentialsResponse::mutable_dbport() {
  set_has_dbport();
  if (dbport_ == &::google::protobuf::internal::kEmptyString) {
    dbport_ = new ::std::string;
  }
  return dbport_;
}
inline ::std::string* DBCredentialsResponse::release_dbport() {
  clear_has_dbport();
  if (dbport_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dbport_;
    dbport_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBCredentialsResponse::set_allocated_dbport(::std::string* dbport) {
  if (dbport_ != &::google::protobuf::internal::kEmptyString) {
    delete dbport_;
  }
  if (dbport) {
    set_has_dbport();
    dbport_ = dbport;
  } else {
    clear_has_dbport();
    dbport_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UIConnectRequest

// optional string msgName = 1 [default = "UIConnectRequest"];
inline bool UIConnectRequest::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UIConnectRequest::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UIConnectRequest::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UIConnectRequest::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& UIConnectRequest::msgname() const {
  return *msgname_;
}
inline void UIConnectRequest::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UIConnectRequest::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UIConnectRequest::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIConnectRequest::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* UIConnectRequest::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void UIConnectRequest::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string senderName = 2;
inline bool UIConnectRequest::has_sendername() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UIConnectRequest::set_has_sendername() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UIConnectRequest::clear_has_sendername() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UIConnectRequest::clear_sendername() {
  if (sendername_ != &::google::protobuf::internal::kEmptyString) {
    sendername_->clear();
  }
  clear_has_sendername();
}
inline const ::std::string& UIConnectRequest::sendername() const {
  return *sendername_;
}
inline void UIConnectRequest::set_sendername(const ::std::string& value) {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  sendername_->assign(value);
}
inline void UIConnectRequest::set_sendername(const char* value) {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  sendername_->assign(value);
}
inline void UIConnectRequest::set_sendername(const char* value, size_t size) {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  sendername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIConnectRequest::mutable_sendername() {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  return sendername_;
}
inline ::std::string* UIConnectRequest::release_sendername() {
  clear_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sendername_;
    sendername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UIConnectRequest::set_allocated_sendername(::std::string* sendername) {
  if (sendername_ != &::google::protobuf::internal::kEmptyString) {
    delete sendername_;
  }
  if (sendername) {
    set_has_sendername();
    sendername_ = sendername;
  } else {
    clear_has_sendername();
    sendername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UIConnectResponse

// optional string msgName = 1 [default = "UIConnectResponse"];
inline bool UIConnectResponse::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UIConnectResponse::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UIConnectResponse::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UIConnectResponse::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& UIConnectResponse::msgname() const {
  return *msgname_;
}
inline void UIConnectResponse::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UIConnectResponse::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UIConnectResponse::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIConnectResponse::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* UIConnectResponse::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void UIConnectResponse::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string connectionID = 2 [default = "defaultConnectionID"];
inline bool UIConnectResponse::has_connectionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UIConnectResponse::set_has_connectionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UIConnectResponse::clear_has_connectionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UIConnectResponse::clear_connectionid() {
  if (connectionid_ != _default_connectionid_) {
    connectionid_->assign(*_default_connectionid_);
  }
  clear_has_connectionid();
}
inline const ::std::string& UIConnectResponse::connectionid() const {
  return *connectionid_;
}
inline void UIConnectResponse::set_connectionid(const ::std::string& value) {
  set_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(value);
}
inline void UIConnectResponse::set_connectionid(const char* value) {
  set_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(value);
}
inline void UIConnectResponse::set_connectionid(const char* value, size_t size) {
  set_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIConnectResponse::mutable_connectionid() {
  set_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    connectionid_ = new ::std::string(*_default_connectionid_);
  }
  return connectionid_;
}
inline ::std::string* UIConnectResponse::release_connectionid() {
  clear_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    return NULL;
  } else {
    ::std::string* temp = connectionid_;
    connectionid_ = const_cast< ::std::string*>(_default_connectionid_);
    return temp;
  }
}
inline void UIConnectResponse::set_allocated_connectionid(::std::string* connectionid) {
  if (connectionid_ != _default_connectionid_) {
    delete connectionid_;
  }
  if (connectionid) {
    set_has_connectionid();
    connectionid_ = connectionid;
  } else {
    clear_has_connectionid();
    connectionid_ = const_cast< ::std::string*>(_default_connectionid_);
  }
}

// -------------------------------------------------------------------

// UIDisconnect

// optional string msgName = 1 [default = "UIDisconnect"];
inline bool UIDisconnect::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UIDisconnect::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UIDisconnect::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UIDisconnect::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& UIDisconnect::msgname() const {
  return *msgname_;
}
inline void UIDisconnect::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UIDisconnect::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UIDisconnect::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIDisconnect::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* UIDisconnect::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void UIDisconnect::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string senderName = 2;
inline bool UIDisconnect::has_sendername() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UIDisconnect::set_has_sendername() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UIDisconnect::clear_has_sendername() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UIDisconnect::clear_sendername() {
  if (sendername_ != &::google::protobuf::internal::kEmptyString) {
    sendername_->clear();
  }
  clear_has_sendername();
}
inline const ::std::string& UIDisconnect::sendername() const {
  return *sendername_;
}
inline void UIDisconnect::set_sendername(const ::std::string& value) {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  sendername_->assign(value);
}
inline void UIDisconnect::set_sendername(const char* value) {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  sendername_->assign(value);
}
inline void UIDisconnect::set_sendername(const char* value, size_t size) {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  sendername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIDisconnect::mutable_sendername() {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  return sendername_;
}
inline ::std::string* UIDisconnect::release_sendername() {
  clear_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sendername_;
    sendername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UIDisconnect::set_allocated_sendername(::std::string* sendername) {
  if (sendername_ != &::google::protobuf::internal::kEmptyString) {
    delete sendername_;
  }
  if (sendername) {
    set_has_sendername();
    sendername_ = sendername;
  } else {
    clear_has_sendername();
    sendername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string connectionID = 3 [default = "defaultConnectionID"];
inline bool UIDisconnect::has_connectionid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UIDisconnect::set_has_connectionid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UIDisconnect::clear_has_connectionid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UIDisconnect::clear_connectionid() {
  if (connectionid_ != _default_connectionid_) {
    connectionid_->assign(*_default_connectionid_);
  }
  clear_has_connectionid();
}
inline const ::std::string& UIDisconnect::connectionid() const {
  return *connectionid_;
}
inline void UIDisconnect::set_connectionid(const ::std::string& value) {
  set_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(value);
}
inline void UIDisconnect::set_connectionid(const char* value) {
  set_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(value);
}
inline void UIDisconnect::set_connectionid(const char* value, size_t size) {
  set_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIDisconnect::mutable_connectionid() {
  set_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    connectionid_ = new ::std::string(*_default_connectionid_);
  }
  return connectionid_;
}
inline ::std::string* UIDisconnect::release_connectionid() {
  clear_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    return NULL;
  } else {
    ::std::string* temp = connectionid_;
    connectionid_ = const_cast< ::std::string*>(_default_connectionid_);
    return temp;
  }
}
inline void UIDisconnect::set_allocated_connectionid(::std::string* connectionid) {
  if (connectionid_ != _default_connectionid_) {
    delete connectionid_;
  }
  if (connectionid) {
    set_has_connectionid();
    connectionid_ = connectionid;
  } else {
    clear_has_connectionid();
    connectionid_ = const_cast< ::std::string*>(_default_connectionid_);
  }
}

// optional string test = 4 [default = "testString"];
inline bool UIDisconnect::has_test() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UIDisconnect::set_has_test() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UIDisconnect::clear_has_test() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UIDisconnect::clear_test() {
  if (test_ != _default_test_) {
    test_->assign(*_default_test_);
  }
  clear_has_test();
}
inline const ::std::string& UIDisconnect::test() const {
  return *test_;
}
inline void UIDisconnect::set_test(const ::std::string& value) {
  set_has_test();
  if (test_ == _default_test_) {
    test_ = new ::std::string;
  }
  test_->assign(value);
}
inline void UIDisconnect::set_test(const char* value) {
  set_has_test();
  if (test_ == _default_test_) {
    test_ = new ::std::string;
  }
  test_->assign(value);
}
inline void UIDisconnect::set_test(const char* value, size_t size) {
  set_has_test();
  if (test_ == _default_test_) {
    test_ = new ::std::string;
  }
  test_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIDisconnect::mutable_test() {
  set_has_test();
  if (test_ == _default_test_) {
    test_ = new ::std::string(*_default_test_);
  }
  return test_;
}
inline ::std::string* UIDisconnect::release_test() {
  clear_has_test();
  if (test_ == _default_test_) {
    return NULL;
  } else {
    ::std::string* temp = test_;
    test_ = const_cast< ::std::string*>(_default_test_);
    return temp;
  }
}
inline void UIDisconnect::set_allocated_test(::std::string* test) {
  if (test_ != _default_test_) {
    delete test_;
  }
  if (test) {
    set_has_test();
    test_ = test;
  } else {
    clear_has_test();
    test_ = const_cast< ::std::string*>(_default_test_);
  }
}

// -------------------------------------------------------------------

// UISignalEvent

// optional string msgName = 1 [default = "UISignalEvent"];
inline bool UISignalEvent::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UISignalEvent::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UISignalEvent::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UISignalEvent::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& UISignalEvent::msgname() const {
  return *msgname_;
}
inline void UISignalEvent::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UISignalEvent::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UISignalEvent::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UISignalEvent::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* UISignalEvent::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void UISignalEvent::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 channel = 2;
inline bool UISignalEvent::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UISignalEvent::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UISignalEvent::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UISignalEvent::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 UISignalEvent::channel() const {
  return channel_;
}
inline void UISignalEvent::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// optional string eventID = 3;
inline bool UISignalEvent::has_eventid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UISignalEvent::set_has_eventid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UISignalEvent::clear_has_eventid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UISignalEvent::clear_eventid() {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    eventid_->clear();
  }
  clear_has_eventid();
}
inline const ::std::string& UISignalEvent::eventid() const {
  return *eventid_;
}
inline void UISignalEvent::set_eventid(const ::std::string& value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void UISignalEvent::set_eventid(const char* value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void UISignalEvent::set_eventid(const char* value, size_t size) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UISignalEvent::mutable_eventid() {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  return eventid_;
}
inline ::std::string* UISignalEvent::release_eventid() {
  clear_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventid_;
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UISignalEvent::set_allocated_eventid(::std::string* eventid) {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    delete eventid_;
  }
  if (eventid) {
    set_has_eventid();
    eventid_ = eventid;
  } else {
    clear_has_eventid();
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string timestamp = 4;
inline bool UISignalEvent::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UISignalEvent::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UISignalEvent::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UISignalEvent::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& UISignalEvent::timestamp() const {
  return *timestamp_;
}
inline void UISignalEvent::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void UISignalEvent::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void UISignalEvent::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UISignalEvent::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* UISignalEvent::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UISignalEvent::set_allocated_timestamp(::std::string* timestamp) {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    delete timestamp_;
  }
  if (timestamp) {
    set_has_timestamp();
    timestamp_ = timestamp;
  } else {
    clear_has_timestamp();
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string soiNum = 5;
inline bool UISignalEvent::has_soinum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UISignalEvent::set_has_soinum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UISignalEvent::clear_has_soinum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UISignalEvent::clear_soinum() {
  if (soinum_ != &::google::protobuf::internal::kEmptyString) {
    soinum_->clear();
  }
  clear_has_soinum();
}
inline const ::std::string& UISignalEvent::soinum() const {
  return *soinum_;
}
inline void UISignalEvent::set_soinum(const ::std::string& value) {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  soinum_->assign(value);
}
inline void UISignalEvent::set_soinum(const char* value) {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  soinum_->assign(value);
}
inline void UISignalEvent::set_soinum(const char* value, size_t size) {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  soinum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UISignalEvent::mutable_soinum() {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  return soinum_;
}
inline ::std::string* UISignalEvent::release_soinum() {
  clear_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = soinum_;
    soinum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UISignalEvent::set_allocated_soinum(::std::string* soinum) {
  if (soinum_ != &::google::protobuf::internal::kEmptyString) {
    delete soinum_;
  }
  if (soinum) {
    set_has_soinum();
    soinum_ = soinum;
  } else {
    clear_has_soinum();
    soinum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float rfMHz = 6;
inline bool UISignalEvent::has_rfmhz() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UISignalEvent::set_has_rfmhz() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UISignalEvent::clear_has_rfmhz() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UISignalEvent::clear_rfmhz() {
  rfmhz_ = 0;
  clear_has_rfmhz();
}
inline float UISignalEvent::rfmhz() const {
  return rfmhz_;
}
inline void UISignalEvent::set_rfmhz(float value) {
  set_has_rfmhz();
  rfmhz_ = value;
}

// optional float antAz = 7 [default = 0];
inline bool UISignalEvent::has_antaz() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UISignalEvent::set_has_antaz() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UISignalEvent::clear_has_antaz() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UISignalEvent::clear_antaz() {
  antaz_ = 0;
  clear_has_antaz();
}
inline float UISignalEvent::antaz() const {
  return antaz_;
}
inline void UISignalEvent::set_antaz(float value) {
  set_has_antaz();
  antaz_ = value;
}

// optional float antEl = 8 [default = 0];
inline bool UISignalEvent::has_antel() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UISignalEvent::set_has_antel() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UISignalEvent::clear_has_antel() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UISignalEvent::clear_antel() {
  antel_ = 0;
  clear_has_antel();
}
inline float UISignalEvent::antel() const {
  return antel_;
}
inline void UISignalEvent::set_antel(float value) {
  set_has_antel();
  antel_ = value;
}

// optional string globalId = 9;
inline bool UISignalEvent::has_globalid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UISignalEvent::set_has_globalid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UISignalEvent::clear_has_globalid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UISignalEvent::clear_globalid() {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    globalid_->clear();
  }
  clear_has_globalid();
}
inline const ::std::string& UISignalEvent::globalid() const {
  return *globalid_;
}
inline void UISignalEvent::set_globalid(const ::std::string& value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void UISignalEvent::set_globalid(const char* value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void UISignalEvent::set_globalid(const char* value, size_t size) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UISignalEvent::mutable_globalid() {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  return globalid_;
}
inline ::std::string* UISignalEvent::release_globalid() {
  clear_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalid_;
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UISignalEvent::set_allocated_globalid(::std::string* globalid) {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    delete globalid_;
  }
  if (globalid) {
    set_has_globalid();
    globalid_ = globalid;
  } else {
    clear_has_globalid();
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .UISignalEvent.Type eventType = 10;
inline bool UISignalEvent::has_eventtype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UISignalEvent::set_has_eventtype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UISignalEvent::clear_has_eventtype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UISignalEvent::clear_eventtype() {
  eventtype_ = 0;
  clear_has_eventtype();
}
inline ::UISignalEvent_Type UISignalEvent::eventtype() const {
  return static_cast< ::UISignalEvent_Type >(eventtype_);
}
inline void UISignalEvent::set_eventtype(::UISignalEvent_Type value) {
  assert(::UISignalEvent_Type_IsValid(value));
  set_has_eventtype();
  eventtype_ = value;
}

// optional string name = 11;
inline bool UISignalEvent::has_name() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UISignalEvent::set_has_name() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UISignalEvent::clear_has_name() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UISignalEvent::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& UISignalEvent::name() const {
  return *name_;
}
inline void UISignalEvent::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UISignalEvent::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UISignalEvent::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UISignalEvent::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* UISignalEvent::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UISignalEvent::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UIVideoRequest

// optional string msgName = 1 [default = "UIVideoRequest"];
inline bool UIVideoRequest::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UIVideoRequest::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UIVideoRequest::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UIVideoRequest::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& UIVideoRequest::msgname() const {
  return *msgname_;
}
inline void UIVideoRequest::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UIVideoRequest::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UIVideoRequest::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIVideoRequest::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* UIVideoRequest::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void UIVideoRequest::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string eltex = 2;
inline bool UIVideoRequest::has_eltex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UIVideoRequest::set_has_eltex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UIVideoRequest::clear_has_eltex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UIVideoRequest::clear_eltex() {
  if (eltex_ != &::google::protobuf::internal::kEmptyString) {
    eltex_->clear();
  }
  clear_has_eltex();
}
inline const ::std::string& UIVideoRequest::eltex() const {
  return *eltex_;
}
inline void UIVideoRequest::set_eltex(const ::std::string& value) {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  eltex_->assign(value);
}
inline void UIVideoRequest::set_eltex(const char* value) {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  eltex_->assign(value);
}
inline void UIVideoRequest::set_eltex(const char* value, size_t size) {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  eltex_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIVideoRequest::mutable_eltex() {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  return eltex_;
}
inline ::std::string* UIVideoRequest::release_eltex() {
  clear_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eltex_;
    eltex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UIVideoRequest::set_allocated_eltex(::std::string* eltex) {
  if (eltex_ != &::google::protobuf::internal::kEmptyString) {
    delete eltex_;
  }
  if (eltex) {
    set_has_eltex();
    eltex_ = eltex;
  } else {
    clear_has_eltex();
    eltex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string connectionID = 3 [default = "defaultConnectionID"];
inline bool UIVideoRequest::has_connectionid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UIVideoRequest::set_has_connectionid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UIVideoRequest::clear_has_connectionid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UIVideoRequest::clear_connectionid() {
  if (connectionid_ != _default_connectionid_) {
    connectionid_->assign(*_default_connectionid_);
  }
  clear_has_connectionid();
}
inline const ::std::string& UIVideoRequest::connectionid() const {
  return *connectionid_;
}
inline void UIVideoRequest::set_connectionid(const ::std::string& value) {
  set_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(value);
}
inline void UIVideoRequest::set_connectionid(const char* value) {
  set_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(value);
}
inline void UIVideoRequest::set_connectionid(const char* value, size_t size) {
  set_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIVideoRequest::mutable_connectionid() {
  set_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    connectionid_ = new ::std::string(*_default_connectionid_);
  }
  return connectionid_;
}
inline ::std::string* UIVideoRequest::release_connectionid() {
  clear_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    return NULL;
  } else {
    ::std::string* temp = connectionid_;
    connectionid_ = const_cast< ::std::string*>(_default_connectionid_);
    return temp;
  }
}
inline void UIVideoRequest::set_allocated_connectionid(::std::string* connectionid) {
  if (connectionid_ != _default_connectionid_) {
    delete connectionid_;
  }
  if (connectionid) {
    set_has_connectionid();
    connectionid_ = connectionid;
  } else {
    clear_has_connectionid();
    connectionid_ = const_cast< ::std::string*>(_default_connectionid_);
  }
}

// -------------------------------------------------------------------

// UIVideoResponse

// optional string msgName = 1 [default = "UIVideoResponse"];
inline bool UIVideoResponse::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UIVideoResponse::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UIVideoResponse::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UIVideoResponse::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& UIVideoResponse::msgname() const {
  return *msgname_;
}
inline void UIVideoResponse::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UIVideoResponse::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UIVideoResponse::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIVideoResponse::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* UIVideoResponse::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void UIVideoResponse::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string eltex = 2;
inline bool UIVideoResponse::has_eltex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UIVideoResponse::set_has_eltex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UIVideoResponse::clear_has_eltex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UIVideoResponse::clear_eltex() {
  if (eltex_ != &::google::protobuf::internal::kEmptyString) {
    eltex_->clear();
  }
  clear_has_eltex();
}
inline const ::std::string& UIVideoResponse::eltex() const {
  return *eltex_;
}
inline void UIVideoResponse::set_eltex(const ::std::string& value) {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  eltex_->assign(value);
}
inline void UIVideoResponse::set_eltex(const char* value) {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  eltex_->assign(value);
}
inline void UIVideoResponse::set_eltex(const char* value, size_t size) {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  eltex_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIVideoResponse::mutable_eltex() {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  return eltex_;
}
inline ::std::string* UIVideoResponse::release_eltex() {
  clear_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eltex_;
    eltex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UIVideoResponse::set_allocated_eltex(::std::string* eltex) {
  if (eltex_ != &::google::protobuf::internal::kEmptyString) {
    delete eltex_;
  }
  if (eltex) {
    set_has_eltex();
    eltex_ = eltex;
  } else {
    clear_has_eltex();
    eltex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 portNumber = 3;
inline bool UIVideoResponse::has_portnumber() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UIVideoResponse::set_has_portnumber() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UIVideoResponse::clear_has_portnumber() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UIVideoResponse::clear_portnumber() {
  portnumber_ = GOOGLE_LONGLONG(0);
  clear_has_portnumber();
}
inline ::google::protobuf::int64 UIVideoResponse::portnumber() const {
  return portnumber_;
}
inline void UIVideoResponse::set_portnumber(::google::protobuf::int64 value) {
  set_has_portnumber();
  portnumber_ = value;
}

// -------------------------------------------------------------------

// UIGeoInformationRequest

// optional string msgName = 1 [default = "UIGeoInformationRequest"];
inline bool UIGeoInformationRequest::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UIGeoInformationRequest::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UIGeoInformationRequest::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UIGeoInformationRequest::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& UIGeoInformationRequest::msgname() const {
  return *msgname_;
}
inline void UIGeoInformationRequest::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UIGeoInformationRequest::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UIGeoInformationRequest::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIGeoInformationRequest::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* UIGeoInformationRequest::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void UIGeoInformationRequest::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string globalId = 2;
inline bool UIGeoInformationRequest::has_globalid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UIGeoInformationRequest::set_has_globalid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UIGeoInformationRequest::clear_has_globalid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UIGeoInformationRequest::clear_globalid() {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    globalid_->clear();
  }
  clear_has_globalid();
}
inline const ::std::string& UIGeoInformationRequest::globalid() const {
  return *globalid_;
}
inline void UIGeoInformationRequest::set_globalid(const ::std::string& value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void UIGeoInformationRequest::set_globalid(const char* value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void UIGeoInformationRequest::set_globalid(const char* value, size_t size) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIGeoInformationRequest::mutable_globalid() {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  return globalid_;
}
inline ::std::string* UIGeoInformationRequest::release_globalid() {
  clear_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalid_;
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UIGeoInformationRequest::set_allocated_globalid(::std::string* globalid) {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    delete globalid_;
  }
  if (globalid) {
    set_has_globalid();
    globalid_ = globalid;
  } else {
    clear_has_globalid();
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string connectionID = 3 [default = "defaultConnectionID"];
inline bool UIGeoInformationRequest::has_connectionid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UIGeoInformationRequest::set_has_connectionid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UIGeoInformationRequest::clear_has_connectionid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UIGeoInformationRequest::clear_connectionid() {
  if (connectionid_ != _default_connectionid_) {
    connectionid_->assign(*_default_connectionid_);
  }
  clear_has_connectionid();
}
inline const ::std::string& UIGeoInformationRequest::connectionid() const {
  return *connectionid_;
}
inline void UIGeoInformationRequest::set_connectionid(const ::std::string& value) {
  set_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(value);
}
inline void UIGeoInformationRequest::set_connectionid(const char* value) {
  set_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(value);
}
inline void UIGeoInformationRequest::set_connectionid(const char* value, size_t size) {
  set_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIGeoInformationRequest::mutable_connectionid() {
  set_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    connectionid_ = new ::std::string(*_default_connectionid_);
  }
  return connectionid_;
}
inline ::std::string* UIGeoInformationRequest::release_connectionid() {
  clear_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    return NULL;
  } else {
    ::std::string* temp = connectionid_;
    connectionid_ = const_cast< ::std::string*>(_default_connectionid_);
    return temp;
  }
}
inline void UIGeoInformationRequest::set_allocated_connectionid(::std::string* connectionid) {
  if (connectionid_ != _default_connectionid_) {
    delete connectionid_;
  }
  if (connectionid) {
    set_has_connectionid();
    connectionid_ = connectionid;
  } else {
    clear_has_connectionid();
    connectionid_ = const_cast< ::std::string*>(_default_connectionid_);
  }
}

// -------------------------------------------------------------------

// UIGeoInformation

// optional string msgName = 1 [default = "UIGeoInformation"];
inline bool UIGeoInformation::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UIGeoInformation::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UIGeoInformation::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UIGeoInformation::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& UIGeoInformation::msgname() const {
  return *msgname_;
}
inline void UIGeoInformation::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UIGeoInformation::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UIGeoInformation::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIGeoInformation::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* UIGeoInformation::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void UIGeoInformation::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional double lat = 2;
inline bool UIGeoInformation::has_lat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UIGeoInformation::set_has_lat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UIGeoInformation::clear_has_lat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UIGeoInformation::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline double UIGeoInformation::lat() const {
  return lat_;
}
inline void UIGeoInformation::set_lat(double value) {
  set_has_lat();
  lat_ = value;
}

// optional double lon = 3;
inline bool UIGeoInformation::has_lon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UIGeoInformation::set_has_lon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UIGeoInformation::clear_has_lon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UIGeoInformation::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline double UIGeoInformation::lon() const {
  return lon_;
}
inline void UIGeoInformation::set_lon(double value) {
  set_has_lon();
  lon_ = value;
}

// optional double majoraxis = 4;
inline bool UIGeoInformation::has_majoraxis() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UIGeoInformation::set_has_majoraxis() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UIGeoInformation::clear_has_majoraxis() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UIGeoInformation::clear_majoraxis() {
  majoraxis_ = 0;
  clear_has_majoraxis();
}
inline double UIGeoInformation::majoraxis() const {
  return majoraxis_;
}
inline void UIGeoInformation::set_majoraxis(double value) {
  set_has_majoraxis();
  majoraxis_ = value;
}

// optional double minoraxis = 5;
inline bool UIGeoInformation::has_minoraxis() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UIGeoInformation::set_has_minoraxis() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UIGeoInformation::clear_has_minoraxis() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UIGeoInformation::clear_minoraxis() {
  minoraxis_ = 0;
  clear_has_minoraxis();
}
inline double UIGeoInformation::minoraxis() const {
  return minoraxis_;
}
inline void UIGeoInformation::set_minoraxis(double value) {
  set_has_minoraxis();
  minoraxis_ = value;
}

// optional double orientation = 6;
inline bool UIGeoInformation::has_orientation() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UIGeoInformation::set_has_orientation() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UIGeoInformation::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UIGeoInformation::clear_orientation() {
  orientation_ = 0;
  clear_has_orientation();
}
inline double UIGeoInformation::orientation() const {
  return orientation_;
}
inline void UIGeoInformation::set_orientation(double value) {
  set_has_orientation();
  orientation_ = value;
}

// optional double altitude = 7;
inline bool UIGeoInformation::has_altitude() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UIGeoInformation::set_has_altitude() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UIGeoInformation::clear_has_altitude() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UIGeoInformation::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline double UIGeoInformation::altitude() const {
  return altitude_;
}
inline void UIGeoInformation::set_altitude(double value) {
  set_has_altitude();
  altitude_ = value;
}

// optional int32 altConf = 8;
inline bool UIGeoInformation::has_altconf() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UIGeoInformation::set_has_altconf() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UIGeoInformation::clear_has_altconf() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UIGeoInformation::clear_altconf() {
  altconf_ = 0;
  clear_has_altconf();
}
inline ::google::protobuf::int32 UIGeoInformation::altconf() const {
  return altconf_;
}
inline void UIGeoInformation::set_altconf(::google::protobuf::int32 value) {
  set_has_altconf();
  altconf_ = value;
}

// optional double velocity = 9;
inline bool UIGeoInformation::has_velocity() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UIGeoInformation::set_has_velocity() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UIGeoInformation::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UIGeoInformation::clear_velocity() {
  velocity_ = 0;
  clear_has_velocity();
}
inline double UIGeoInformation::velocity() const {
  return velocity_;
}
inline void UIGeoInformation::set_velocity(double value) {
  set_has_velocity();
  velocity_ = value;
}

// optional int32 vConf = 10;
inline bool UIGeoInformation::has_vconf() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UIGeoInformation::set_has_vconf() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UIGeoInformation::clear_has_vconf() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UIGeoInformation::clear_vconf() {
  vconf_ = 0;
  clear_has_vconf();
}
inline ::google::protobuf::int32 UIGeoInformation::vconf() const {
  return vconf_;
}
inline void UIGeoInformation::set_vconf(::google::protobuf::int32 value) {
  set_has_vconf();
  vconf_ = value;
}

// optional double heading = 11;
inline bool UIGeoInformation::has_heading() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UIGeoInformation::set_has_heading() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UIGeoInformation::clear_has_heading() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UIGeoInformation::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline double UIGeoInformation::heading() const {
  return heading_;
}
inline void UIGeoInformation::set_heading(double value) {
  set_has_heading();
  heading_ = value;
}

// optional int32 headConf = 12;
inline bool UIGeoInformation::has_headconf() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UIGeoInformation::set_has_headconf() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UIGeoInformation::clear_has_headconf() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UIGeoInformation::clear_headconf() {
  headconf_ = 0;
  clear_has_headconf();
}
inline ::google::protobuf::int32 UIGeoInformation::headconf() const {
  return headconf_;
}
inline void UIGeoInformation::set_headconf(::google::protobuf::int32 value) {
  set_has_headconf();
  headconf_ = value;
}

// optional string covariance = 13;
inline bool UIGeoInformation::has_covariance() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UIGeoInformation::set_has_covariance() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UIGeoInformation::clear_has_covariance() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UIGeoInformation::clear_covariance() {
  if (covariance_ != &::google::protobuf::internal::kEmptyString) {
    covariance_->clear();
  }
  clear_has_covariance();
}
inline const ::std::string& UIGeoInformation::covariance() const {
  return *covariance_;
}
inline void UIGeoInformation::set_covariance(const ::std::string& value) {
  set_has_covariance();
  if (covariance_ == &::google::protobuf::internal::kEmptyString) {
    covariance_ = new ::std::string;
  }
  covariance_->assign(value);
}
inline void UIGeoInformation::set_covariance(const char* value) {
  set_has_covariance();
  if (covariance_ == &::google::protobuf::internal::kEmptyString) {
    covariance_ = new ::std::string;
  }
  covariance_->assign(value);
}
inline void UIGeoInformation::set_covariance(const char* value, size_t size) {
  set_has_covariance();
  if (covariance_ == &::google::protobuf::internal::kEmptyString) {
    covariance_ = new ::std::string;
  }
  covariance_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIGeoInformation::mutable_covariance() {
  set_has_covariance();
  if (covariance_ == &::google::protobuf::internal::kEmptyString) {
    covariance_ = new ::std::string;
  }
  return covariance_;
}
inline ::std::string* UIGeoInformation::release_covariance() {
  clear_has_covariance();
  if (covariance_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = covariance_;
    covariance_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UIGeoInformation::set_allocated_covariance(::std::string* covariance) {
  if (covariance_ != &::google::protobuf::internal::kEmptyString) {
    delete covariance_;
  }
  if (covariance) {
    set_has_covariance();
    covariance_ = covariance;
  } else {
    clear_has_covariance();
    covariance_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string globalId = 14;
inline bool UIGeoInformation::has_globalid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UIGeoInformation::set_has_globalid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void UIGeoInformation::clear_has_globalid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void UIGeoInformation::clear_globalid() {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    globalid_->clear();
  }
  clear_has_globalid();
}
inline const ::std::string& UIGeoInformation::globalid() const {
  return *globalid_;
}
inline void UIGeoInformation::set_globalid(const ::std::string& value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void UIGeoInformation::set_globalid(const char* value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void UIGeoInformation::set_globalid(const char* value, size_t size) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIGeoInformation::mutable_globalid() {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  return globalid_;
}
inline ::std::string* UIGeoInformation::release_globalid() {
  clear_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalid_;
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UIGeoInformation::set_allocated_globalid(::std::string* globalid) {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    delete globalid_;
  }
  if (globalid) {
    set_has_globalid();
    globalid_ = globalid;
  } else {
    clear_has_globalid();
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string geoTime = 15;
inline bool UIGeoInformation::has_geotime() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void UIGeoInformation::set_has_geotime() {
  _has_bits_[0] |= 0x00004000u;
}
inline void UIGeoInformation::clear_has_geotime() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void UIGeoInformation::clear_geotime() {
  if (geotime_ != &::google::protobuf::internal::kEmptyString) {
    geotime_->clear();
  }
  clear_has_geotime();
}
inline const ::std::string& UIGeoInformation::geotime() const {
  return *geotime_;
}
inline void UIGeoInformation::set_geotime(const ::std::string& value) {
  set_has_geotime();
  if (geotime_ == &::google::protobuf::internal::kEmptyString) {
    geotime_ = new ::std::string;
  }
  geotime_->assign(value);
}
inline void UIGeoInformation::set_geotime(const char* value) {
  set_has_geotime();
  if (geotime_ == &::google::protobuf::internal::kEmptyString) {
    geotime_ = new ::std::string;
  }
  geotime_->assign(value);
}
inline void UIGeoInformation::set_geotime(const char* value, size_t size) {
  set_has_geotime();
  if (geotime_ == &::google::protobuf::internal::kEmptyString) {
    geotime_ = new ::std::string;
  }
  geotime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIGeoInformation::mutable_geotime() {
  set_has_geotime();
  if (geotime_ == &::google::protobuf::internal::kEmptyString) {
    geotime_ = new ::std::string;
  }
  return geotime_;
}
inline ::std::string* UIGeoInformation::release_geotime() {
  clear_has_geotime();
  if (geotime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = geotime_;
    geotime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UIGeoInformation::set_allocated_geotime(::std::string* geotime) {
  if (geotime_ != &::google::protobuf::internal::kEmptyString) {
    delete geotime_;
  }
  if (geotime) {
    set_has_geotime();
    geotime_ = geotime;
  } else {
    clear_has_geotime();
    geotime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string classification = 16 [default = ""];
inline bool UIGeoInformation::has_classification() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void UIGeoInformation::set_has_classification() {
  _has_bits_[0] |= 0x00008000u;
}
inline void UIGeoInformation::clear_has_classification() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void UIGeoInformation::clear_classification() {
  if (classification_ != &::google::protobuf::internal::kEmptyString) {
    classification_->clear();
  }
  clear_has_classification();
}
inline const ::std::string& UIGeoInformation::classification() const {
  return *classification_;
}
inline void UIGeoInformation::set_classification(const ::std::string& value) {
  set_has_classification();
  if (classification_ == &::google::protobuf::internal::kEmptyString) {
    classification_ = new ::std::string;
  }
  classification_->assign(value);
}
inline void UIGeoInformation::set_classification(const char* value) {
  set_has_classification();
  if (classification_ == &::google::protobuf::internal::kEmptyString) {
    classification_ = new ::std::string;
  }
  classification_->assign(value);
}
inline void UIGeoInformation::set_classification(const char* value, size_t size) {
  set_has_classification();
  if (classification_ == &::google::protobuf::internal::kEmptyString) {
    classification_ = new ::std::string;
  }
  classification_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIGeoInformation::mutable_classification() {
  set_has_classification();
  if (classification_ == &::google::protobuf::internal::kEmptyString) {
    classification_ = new ::std::string;
  }
  return classification_;
}
inline ::std::string* UIGeoInformation::release_classification() {
  clear_has_classification();
  if (classification_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classification_;
    classification_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UIGeoInformation::set_allocated_classification(::std::string* classification) {
  if (classification_ != &::google::protobuf::internal::kEmptyString) {
    delete classification_;
  }
  if (classification) {
    set_has_classification();
    classification_ = classification;
  } else {
    clear_has_classification();
    classification_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UICommandRequest

// optional string msgName = 1 [default = "UICommandRequest"];
inline bool UICommandRequest::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UICommandRequest::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UICommandRequest::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UICommandRequest::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& UICommandRequest::msgname() const {
  return *msgname_;
}
inline void UICommandRequest::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UICommandRequest::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UICommandRequest::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UICommandRequest::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* UICommandRequest::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void UICommandRequest::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string globalId = 2;
inline bool UICommandRequest::has_globalid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UICommandRequest::set_has_globalid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UICommandRequest::clear_has_globalid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UICommandRequest::clear_globalid() {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    globalid_->clear();
  }
  clear_has_globalid();
}
inline const ::std::string& UICommandRequest::globalid() const {
  return *globalid_;
}
inline void UICommandRequest::set_globalid(const ::std::string& value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void UICommandRequest::set_globalid(const char* value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void UICommandRequest::set_globalid(const char* value, size_t size) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UICommandRequest::mutable_globalid() {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  return globalid_;
}
inline ::std::string* UICommandRequest::release_globalid() {
  clear_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalid_;
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UICommandRequest::set_allocated_globalid(::std::string* globalid) {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    delete globalid_;
  }
  if (globalid) {
    set_has_globalid();
    globalid_ = globalid;
  } else {
    clear_has_globalid();
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string effect = 3;
inline bool UICommandRequest::has_effect() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UICommandRequest::set_has_effect() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UICommandRequest::clear_has_effect() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UICommandRequest::clear_effect() {
  if (effect_ != &::google::protobuf::internal::kEmptyString) {
    effect_->clear();
  }
  clear_has_effect();
}
inline const ::std::string& UICommandRequest::effect() const {
  return *effect_;
}
inline void UICommandRequest::set_effect(const ::std::string& value) {
  set_has_effect();
  if (effect_ == &::google::protobuf::internal::kEmptyString) {
    effect_ = new ::std::string;
  }
  effect_->assign(value);
}
inline void UICommandRequest::set_effect(const char* value) {
  set_has_effect();
  if (effect_ == &::google::protobuf::internal::kEmptyString) {
    effect_ = new ::std::string;
  }
  effect_->assign(value);
}
inline void UICommandRequest::set_effect(const char* value, size_t size) {
  set_has_effect();
  if (effect_ == &::google::protobuf::internal::kEmptyString) {
    effect_ = new ::std::string;
  }
  effect_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UICommandRequest::mutable_effect() {
  set_has_effect();
  if (effect_ == &::google::protobuf::internal::kEmptyString) {
    effect_ = new ::std::string;
  }
  return effect_;
}
inline ::std::string* UICommandRequest::release_effect() {
  clear_has_effect();
  if (effect_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = effect_;
    effect_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UICommandRequest::set_allocated_effect(::std::string* effect) {
  if (effect_ != &::google::protobuf::internal::kEmptyString) {
    delete effect_;
  }
  if (effect) {
    set_has_effect();
    effect_ = effect;
  } else {
    clear_has_effect();
    effect_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Parameter parameter = 4;
inline int UICommandRequest::parameter_size() const {
  return parameter_.size();
}
inline void UICommandRequest::clear_parameter() {
  parameter_.Clear();
}
inline const ::Parameter& UICommandRequest::parameter(int index) const {
  return parameter_.Get(index);
}
inline ::Parameter* UICommandRequest::mutable_parameter(int index) {
  return parameter_.Mutable(index);
}
inline ::Parameter* UICommandRequest::add_parameter() {
  return parameter_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Parameter >&
UICommandRequest::parameter() const {
  return parameter_;
}
inline ::google::protobuf::RepeatedPtrField< ::Parameter >*
UICommandRequest::mutable_parameter() {
  return &parameter_;
}

// optional string antenna = 5;
inline bool UICommandRequest::has_antenna() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UICommandRequest::set_has_antenna() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UICommandRequest::clear_has_antenna() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UICommandRequest::clear_antenna() {
  if (antenna_ != &::google::protobuf::internal::kEmptyString) {
    antenna_->clear();
  }
  clear_has_antenna();
}
inline const ::std::string& UICommandRequest::antenna() const {
  return *antenna_;
}
inline void UICommandRequest::set_antenna(const ::std::string& value) {
  set_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    antenna_ = new ::std::string;
  }
  antenna_->assign(value);
}
inline void UICommandRequest::set_antenna(const char* value) {
  set_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    antenna_ = new ::std::string;
  }
  antenna_->assign(value);
}
inline void UICommandRequest::set_antenna(const char* value, size_t size) {
  set_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    antenna_ = new ::std::string;
  }
  antenna_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UICommandRequest::mutable_antenna() {
  set_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    antenna_ = new ::std::string;
  }
  return antenna_;
}
inline ::std::string* UICommandRequest::release_antenna() {
  clear_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = antenna_;
    antenna_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UICommandRequest::set_allocated_antenna(::std::string* antenna) {
  if (antenna_ != &::google::protobuf::internal::kEmptyString) {
    delete antenna_;
  }
  if (antenna) {
    set_has_antenna();
    antenna_ = antenna;
  } else {
    clear_has_antenna();
    antenna_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool active = 6;
inline bool UICommandRequest::has_active() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UICommandRequest::set_has_active() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UICommandRequest::clear_has_active() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UICommandRequest::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool UICommandRequest::active() const {
  return active_;
}
inline void UICommandRequest::set_active(bool value) {
  set_has_active();
  active_ = value;
}

// optional string resID = 7;
inline bool UICommandRequest::has_resid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UICommandRequest::set_has_resid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UICommandRequest::clear_has_resid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UICommandRequest::clear_resid() {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    resid_->clear();
  }
  clear_has_resid();
}
inline const ::std::string& UICommandRequest::resid() const {
  return *resid_;
}
inline void UICommandRequest::set_resid(const ::std::string& value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void UICommandRequest::set_resid(const char* value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void UICommandRequest::set_resid(const char* value, size_t size) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UICommandRequest::mutable_resid() {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  return resid_;
}
inline ::std::string* UICommandRequest::release_resid() {
  clear_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resid_;
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UICommandRequest::set_allocated_resid(::std::string* resid) {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    delete resid_;
  }
  if (resid) {
    set_has_resid();
    resid_ = resid;
  } else {
    clear_has_resid();
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string signalName = 8;
inline bool UICommandRequest::has_signalname() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UICommandRequest::set_has_signalname() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UICommandRequest::clear_has_signalname() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UICommandRequest::clear_signalname() {
  if (signalname_ != &::google::protobuf::internal::kEmptyString) {
    signalname_->clear();
  }
  clear_has_signalname();
}
inline const ::std::string& UICommandRequest::signalname() const {
  return *signalname_;
}
inline void UICommandRequest::set_signalname(const ::std::string& value) {
  set_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    signalname_ = new ::std::string;
  }
  signalname_->assign(value);
}
inline void UICommandRequest::set_signalname(const char* value) {
  set_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    signalname_ = new ::std::string;
  }
  signalname_->assign(value);
}
inline void UICommandRequest::set_signalname(const char* value, size_t size) {
  set_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    signalname_ = new ::std::string;
  }
  signalname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UICommandRequest::mutable_signalname() {
  set_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    signalname_ = new ::std::string;
  }
  return signalname_;
}
inline ::std::string* UICommandRequest::release_signalname() {
  clear_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signalname_;
    signalname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UICommandRequest::set_allocated_signalname(::std::string* signalname) {
  if (signalname_ != &::google::protobuf::internal::kEmptyString) {
    delete signalname_;
  }
  if (signalname) {
    set_has_signalname();
    signalname_ = signalname;
  } else {
    clear_has_signalname();
    signalname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string connectionID = 9 [default = "defaultConnectionID"];
inline bool UICommandRequest::has_connectionid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UICommandRequest::set_has_connectionid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UICommandRequest::clear_has_connectionid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UICommandRequest::clear_connectionid() {
  if (connectionid_ != _default_connectionid_) {
    connectionid_->assign(*_default_connectionid_);
  }
  clear_has_connectionid();
}
inline const ::std::string& UICommandRequest::connectionid() const {
  return *connectionid_;
}
inline void UICommandRequest::set_connectionid(const ::std::string& value) {
  set_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(value);
}
inline void UICommandRequest::set_connectionid(const char* value) {
  set_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(value);
}
inline void UICommandRequest::set_connectionid(const char* value, size_t size) {
  set_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UICommandRequest::mutable_connectionid() {
  set_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    connectionid_ = new ::std::string(*_default_connectionid_);
  }
  return connectionid_;
}
inline ::std::string* UICommandRequest::release_connectionid() {
  clear_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    return NULL;
  } else {
    ::std::string* temp = connectionid_;
    connectionid_ = const_cast< ::std::string*>(_default_connectionid_);
    return temp;
  }
}
inline void UICommandRequest::set_allocated_connectionid(::std::string* connectionid) {
  if (connectionid_ != _default_connectionid_) {
    delete connectionid_;
  }
  if (connectionid) {
    set_has_connectionid();
    connectionid_ = connectionid;
  } else {
    clear_has_connectionid();
    connectionid_ = const_cast< ::std::string*>(_default_connectionid_);
  }
}

// -------------------------------------------------------------------

// Parameter

// optional string msgName = 1 [default = "EW_PARAMETER"];
inline bool Parameter::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Parameter::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Parameter::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Parameter::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& Parameter::msgname() const {
  return *msgname_;
}
inline void Parameter::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void Parameter::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void Parameter::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Parameter::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* Parameter::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void Parameter::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// required string name = 2;
inline bool Parameter::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Parameter::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Parameter::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Parameter::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Parameter::name() const {
  return *name_;
}
inline void Parameter::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Parameter::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Parameter::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Parameter::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Parameter::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Parameter::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 3;
inline bool Parameter::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Parameter::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Parameter::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Parameter::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Parameter::value() const {
  return *value_;
}
inline void Parameter::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Parameter::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Parameter::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Parameter::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Parameter::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Parameter::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UIOptionsRequest

// optional string msgName = 1 [default = "UIOptionsRequest"];
inline bool UIOptionsRequest::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UIOptionsRequest::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UIOptionsRequest::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UIOptionsRequest::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& UIOptionsRequest::msgname() const {
  return *msgname_;
}
inline void UIOptionsRequest::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UIOptionsRequest::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UIOptionsRequest::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIOptionsRequest::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* UIOptionsRequest::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void UIOptionsRequest::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string connectionID = 2 [default = "defaultConnectionID"];
inline bool UIOptionsRequest::has_connectionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UIOptionsRequest::set_has_connectionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UIOptionsRequest::clear_has_connectionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UIOptionsRequest::clear_connectionid() {
  if (connectionid_ != _default_connectionid_) {
    connectionid_->assign(*_default_connectionid_);
  }
  clear_has_connectionid();
}
inline const ::std::string& UIOptionsRequest::connectionid() const {
  return *connectionid_;
}
inline void UIOptionsRequest::set_connectionid(const ::std::string& value) {
  set_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(value);
}
inline void UIOptionsRequest::set_connectionid(const char* value) {
  set_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(value);
}
inline void UIOptionsRequest::set_connectionid(const char* value, size_t size) {
  set_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIOptionsRequest::mutable_connectionid() {
  set_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    connectionid_ = new ::std::string(*_default_connectionid_);
  }
  return connectionid_;
}
inline ::std::string* UIOptionsRequest::release_connectionid() {
  clear_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    return NULL;
  } else {
    ::std::string* temp = connectionid_;
    connectionid_ = const_cast< ::std::string*>(_default_connectionid_);
    return temp;
  }
}
inline void UIOptionsRequest::set_allocated_connectionid(::std::string* connectionid) {
  if (connectionid_ != _default_connectionid_) {
    delete connectionid_;
  }
  if (connectionid) {
    set_has_connectionid();
    connectionid_ = connectionid;
  } else {
    clear_has_connectionid();
    connectionid_ = const_cast< ::std::string*>(_default_connectionid_);
  }
}

// -------------------------------------------------------------------

// UIOption

// optional string msgName = 1 [default = "UIOption"];
inline bool UIOption::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UIOption::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UIOption::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UIOption::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& UIOption::msgname() const {
  return *msgname_;
}
inline void UIOption::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UIOption::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UIOption::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIOption::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* UIOption::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void UIOption::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string signalName = 2;
inline bool UIOption::has_signalname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UIOption::set_has_signalname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UIOption::clear_has_signalname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UIOption::clear_signalname() {
  if (signalname_ != &::google::protobuf::internal::kEmptyString) {
    signalname_->clear();
  }
  clear_has_signalname();
}
inline const ::std::string& UIOption::signalname() const {
  return *signalname_;
}
inline void UIOption::set_signalname(const ::std::string& value) {
  set_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    signalname_ = new ::std::string;
  }
  signalname_->assign(value);
}
inline void UIOption::set_signalname(const char* value) {
  set_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    signalname_ = new ::std::string;
  }
  signalname_->assign(value);
}
inline void UIOption::set_signalname(const char* value, size_t size) {
  set_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    signalname_ = new ::std::string;
  }
  signalname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIOption::mutable_signalname() {
  set_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    signalname_ = new ::std::string;
  }
  return signalname_;
}
inline ::std::string* UIOption::release_signalname() {
  clear_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signalname_;
    signalname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UIOption::set_allocated_signalname(::std::string* signalname) {
  if (signalname_ != &::google::protobuf::internal::kEmptyString) {
    delete signalname_;
  }
  if (signalname) {
    set_has_signalname();
    signalname_ = signalname;
  } else {
    clear_has_signalname();
    signalname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string effect = 3;
inline int UIOption::effect_size() const {
  return effect_.size();
}
inline void UIOption::clear_effect() {
  effect_.Clear();
}
inline const ::std::string& UIOption::effect(int index) const {
  return effect_.Get(index);
}
inline ::std::string* UIOption::mutable_effect(int index) {
  return effect_.Mutable(index);
}
inline void UIOption::set_effect(int index, const ::std::string& value) {
  effect_.Mutable(index)->assign(value);
}
inline void UIOption::set_effect(int index, const char* value) {
  effect_.Mutable(index)->assign(value);
}
inline void UIOption::set_effect(int index, const char* value, size_t size) {
  effect_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIOption::add_effect() {
  return effect_.Add();
}
inline void UIOption::add_effect(const ::std::string& value) {
  effect_.Add()->assign(value);
}
inline void UIOption::add_effect(const char* value) {
  effect_.Add()->assign(value);
}
inline void UIOption::add_effect(const char* value, size_t size) {
  effect_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
UIOption::effect() const {
  return effect_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
UIOption::mutable_effect() {
  return &effect_;
}

// optional .UIOption.DetectionSource detectionSource = 4;
inline bool UIOption::has_detectionsource() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UIOption::set_has_detectionsource() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UIOption::clear_has_detectionsource() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UIOption::clear_detectionsource() {
  detectionsource_ = 0;
  clear_has_detectionsource();
}
inline ::UIOption_DetectionSource UIOption::detectionsource() const {
  return static_cast< ::UIOption_DetectionSource >(detectionsource_);
}
inline void UIOption::set_detectionsource(::UIOption_DetectionSource value) {
  assert(::UIOption_DetectionSource_IsValid(value));
  set_has_detectionsource();
  detectionsource_ = value;
}

// optional string globalId = 5;
inline bool UIOption::has_globalid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UIOption::set_has_globalid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UIOption::clear_has_globalid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UIOption::clear_globalid() {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    globalid_->clear();
  }
  clear_has_globalid();
}
inline const ::std::string& UIOption::globalid() const {
  return *globalid_;
}
inline void UIOption::set_globalid(const ::std::string& value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void UIOption::set_globalid(const char* value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void UIOption::set_globalid(const char* value, size_t size) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIOption::mutable_globalid() {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  return globalid_;
}
inline ::std::string* UIOption::release_globalid() {
  clear_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalid_;
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UIOption::set_allocated_globalid(::std::string* globalid) {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    delete globalid_;
  }
  if (globalid) {
    set_has_globalid();
    globalid_ = globalid;
  } else {
    clear_has_globalid();
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UIOptions

// optional string msgName = 1 [default = "UIOptions"];
inline bool UIOptions::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UIOptions::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UIOptions::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UIOptions::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& UIOptions::msgname() const {
  return *msgname_;
}
inline void UIOptions::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UIOptions::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UIOptions::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIOptions::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* UIOptions::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void UIOptions::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// repeated .UIOption uiopt = 2;
inline int UIOptions::uiopt_size() const {
  return uiopt_.size();
}
inline void UIOptions::clear_uiopt() {
  uiopt_.Clear();
}
inline const ::UIOption& UIOptions::uiopt(int index) const {
  return uiopt_.Get(index);
}
inline ::UIOption* UIOptions::mutable_uiopt(int index) {
  return uiopt_.Mutable(index);
}
inline ::UIOption* UIOptions::add_uiopt() {
  return uiopt_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::UIOption >&
UIOptions::uiopt() const {
  return uiopt_;
}
inline ::google::protobuf::RepeatedPtrField< ::UIOption >*
UIOptions::mutable_uiopt() {
  return &uiopt_;
}

// -------------------------------------------------------------------

// UIOptionDelete

// optional string msgName = 1 [default = "UIOptionDelete"];
inline bool UIOptionDelete::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UIOptionDelete::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UIOptionDelete::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UIOptionDelete::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& UIOptionDelete::msgname() const {
  return *msgname_;
}
inline void UIOptionDelete::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UIOptionDelete::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UIOptionDelete::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIOptionDelete::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* UIOptionDelete::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void UIOptionDelete::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string globalId = 2;
inline bool UIOptionDelete::has_globalid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UIOptionDelete::set_has_globalid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UIOptionDelete::clear_has_globalid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UIOptionDelete::clear_globalid() {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    globalid_->clear();
  }
  clear_has_globalid();
}
inline const ::std::string& UIOptionDelete::globalid() const {
  return *globalid_;
}
inline void UIOptionDelete::set_globalid(const ::std::string& value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void UIOptionDelete::set_globalid(const char* value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void UIOptionDelete::set_globalid(const char* value, size_t size) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UIOptionDelete::mutable_globalid() {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  return globalid_;
}
inline ::std::string* UIOptionDelete::release_globalid() {
  clear_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalid_;
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UIOptionDelete::set_allocated_globalid(::std::string* globalid) {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    delete globalid_;
  }
  if (globalid) {
    set_has_globalid();
    globalid_ = globalid;
  } else {
    clear_has_globalid();
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UICeaseBuzzer

// optional string msgName = 1 [default = "UICeaseBuzzer"];
inline bool UICeaseBuzzer::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UICeaseBuzzer::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UICeaseBuzzer::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UICeaseBuzzer::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& UICeaseBuzzer::msgname() const {
  return *msgname_;
}
inline void UICeaseBuzzer::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UICeaseBuzzer::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UICeaseBuzzer::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UICeaseBuzzer::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* UICeaseBuzzer::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void UICeaseBuzzer::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string connectionID = 2 [default = "defaultConnectionID"];
inline bool UICeaseBuzzer::has_connectionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UICeaseBuzzer::set_has_connectionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UICeaseBuzzer::clear_has_connectionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UICeaseBuzzer::clear_connectionid() {
  if (connectionid_ != _default_connectionid_) {
    connectionid_->assign(*_default_connectionid_);
  }
  clear_has_connectionid();
}
inline const ::std::string& UICeaseBuzzer::connectionid() const {
  return *connectionid_;
}
inline void UICeaseBuzzer::set_connectionid(const ::std::string& value) {
  set_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(value);
}
inline void UICeaseBuzzer::set_connectionid(const char* value) {
  set_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(value);
}
inline void UICeaseBuzzer::set_connectionid(const char* value, size_t size) {
  set_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UICeaseBuzzer::mutable_connectionid() {
  set_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    connectionid_ = new ::std::string(*_default_connectionid_);
  }
  return connectionid_;
}
inline ::std::string* UICeaseBuzzer::release_connectionid() {
  clear_has_connectionid();
  if (connectionid_ == _default_connectionid_) {
    return NULL;
  } else {
    ::std::string* temp = connectionid_;
    connectionid_ = const_cast< ::std::string*>(_default_connectionid_);
    return temp;
  }
}
inline void UICeaseBuzzer::set_allocated_connectionid(::std::string* connectionid) {
  if (connectionid_ != _default_connectionid_) {
    delete connectionid_;
  }
  if (connectionid) {
    set_has_connectionid();
    connectionid_ = connectionid;
  } else {
    clear_has_connectionid();
    connectionid_ = const_cast< ::std::string*>(_default_connectionid_);
  }
}

// -------------------------------------------------------------------

// EWStatus

// optional string msgName = 1 [default = "EWStatus"];
inline bool EWStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EWStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EWStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EWStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& EWStatus::msgname() const {
  return *msgname_;
}
inline void EWStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EWStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* EWStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void EWStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// repeated .OutputChannelStatus outputChannelStatus = 2;
inline int EWStatus::outputchannelstatus_size() const {
  return outputchannelstatus_.size();
}
inline void EWStatus::clear_outputchannelstatus() {
  outputchannelstatus_.Clear();
}
inline const ::OutputChannelStatus& EWStatus::outputchannelstatus(int index) const {
  return outputchannelstatus_.Get(index);
}
inline ::OutputChannelStatus* EWStatus::mutable_outputchannelstatus(int index) {
  return outputchannelstatus_.Mutable(index);
}
inline ::OutputChannelStatus* EWStatus::add_outputchannelstatus() {
  return outputchannelstatus_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OutputChannelStatus >&
EWStatus::outputchannelstatus() const {
  return outputchannelstatus_;
}
inline ::google::protobuf::RepeatedPtrField< ::OutputChannelStatus >*
EWStatus::mutable_outputchannelstatus() {
  return &outputchannelstatus_;
}

// optional string timestamp = 3;
inline bool EWStatus::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EWStatus::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EWStatus::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EWStatus::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& EWStatus::timestamp() const {
  return *timestamp_;
}
inline void EWStatus::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void EWStatus::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void EWStatus::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EWStatus::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* EWStatus::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EWStatus::set_allocated_timestamp(::std::string* timestamp) {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    delete timestamp_;
  }
  if (timestamp) {
    set_has_timestamp();
    timestamp_ = timestamp;
  } else {
    clear_has_timestamp();
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// OutputChannelStatus

// optional string msgName = 1 [default = "EW_OUTPUT_CHANNEL_STATUS"];
inline bool OutputChannelStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OutputChannelStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OutputChannelStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OutputChannelStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& OutputChannelStatus::msgname() const {
  return *msgname_;
}
inline void OutputChannelStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void OutputChannelStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void OutputChannelStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OutputChannelStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* OutputChannelStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void OutputChannelStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string effect = 2;
inline bool OutputChannelStatus::has_effect() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OutputChannelStatus::set_has_effect() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OutputChannelStatus::clear_has_effect() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OutputChannelStatus::clear_effect() {
  if (effect_ != &::google::protobuf::internal::kEmptyString) {
    effect_->clear();
  }
  clear_has_effect();
}
inline const ::std::string& OutputChannelStatus::effect() const {
  return *effect_;
}
inline void OutputChannelStatus::set_effect(const ::std::string& value) {
  set_has_effect();
  if (effect_ == &::google::protobuf::internal::kEmptyString) {
    effect_ = new ::std::string;
  }
  effect_->assign(value);
}
inline void OutputChannelStatus::set_effect(const char* value) {
  set_has_effect();
  if (effect_ == &::google::protobuf::internal::kEmptyString) {
    effect_ = new ::std::string;
  }
  effect_->assign(value);
}
inline void OutputChannelStatus::set_effect(const char* value, size_t size) {
  set_has_effect();
  if (effect_ == &::google::protobuf::internal::kEmptyString) {
    effect_ = new ::std::string;
  }
  effect_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OutputChannelStatus::mutable_effect() {
  set_has_effect();
  if (effect_ == &::google::protobuf::internal::kEmptyString) {
    effect_ = new ::std::string;
  }
  return effect_;
}
inline ::std::string* OutputChannelStatus::release_effect() {
  clear_has_effect();
  if (effect_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = effect_;
    effect_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OutputChannelStatus::set_allocated_effect(::std::string* effect) {
  if (effect_ != &::google::protobuf::internal::kEmptyString) {
    delete effect_;
  }
  if (effect) {
    set_has_effect();
    effect_ = effect;
  } else {
    clear_has_effect();
    effect_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double transmitFreq = 3;
inline bool OutputChannelStatus::has_transmitfreq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OutputChannelStatus::set_has_transmitfreq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OutputChannelStatus::clear_has_transmitfreq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OutputChannelStatus::clear_transmitfreq() {
  transmitfreq_ = 0;
  clear_has_transmitfreq();
}
inline double OutputChannelStatus::transmitfreq() const {
  return transmitfreq_;
}
inline void OutputChannelStatus::set_transmitfreq(double value) {
  set_has_transmitfreq();
  transmitfreq_ = value;
}

// optional string globalId = 4;
inline bool OutputChannelStatus::has_globalid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OutputChannelStatus::set_has_globalid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OutputChannelStatus::clear_has_globalid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OutputChannelStatus::clear_globalid() {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    globalid_->clear();
  }
  clear_has_globalid();
}
inline const ::std::string& OutputChannelStatus::globalid() const {
  return *globalid_;
}
inline void OutputChannelStatus::set_globalid(const ::std::string& value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void OutputChannelStatus::set_globalid(const char* value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void OutputChannelStatus::set_globalid(const char* value, size_t size) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OutputChannelStatus::mutable_globalid() {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  return globalid_;
}
inline ::std::string* OutputChannelStatus::release_globalid() {
  clear_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalid_;
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OutputChannelStatus::set_allocated_globalid(::std::string* globalid) {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    delete globalid_;
  }
  if (globalid) {
    set_has_globalid();
    globalid_ = globalid;
  } else {
    clear_has_globalid();
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string antenna = 5;
inline bool OutputChannelStatus::has_antenna() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OutputChannelStatus::set_has_antenna() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OutputChannelStatus::clear_has_antenna() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OutputChannelStatus::clear_antenna() {
  if (antenna_ != &::google::protobuf::internal::kEmptyString) {
    antenna_->clear();
  }
  clear_has_antenna();
}
inline const ::std::string& OutputChannelStatus::antenna() const {
  return *antenna_;
}
inline void OutputChannelStatus::set_antenna(const ::std::string& value) {
  set_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    antenna_ = new ::std::string;
  }
  antenna_->assign(value);
}
inline void OutputChannelStatus::set_antenna(const char* value) {
  set_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    antenna_ = new ::std::string;
  }
  antenna_->assign(value);
}
inline void OutputChannelStatus::set_antenna(const char* value, size_t size) {
  set_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    antenna_ = new ::std::string;
  }
  antenna_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OutputChannelStatus::mutable_antenna() {
  set_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    antenna_ = new ::std::string;
  }
  return antenna_;
}
inline ::std::string* OutputChannelStatus::release_antenna() {
  clear_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = antenna_;
    antenna_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OutputChannelStatus::set_allocated_antenna(::std::string* antenna) {
  if (antenna_ != &::google::protobuf::internal::kEmptyString) {
    delete antenna_;
  }
  if (antenna) {
    set_has_antenna();
    antenna_ = antenna;
  } else {
    clear_has_antenna();
    antenna_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .OutputChannelStatus.TransmitState state = 6;
inline bool OutputChannelStatus::has_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OutputChannelStatus::set_has_state() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OutputChannelStatus::clear_has_state() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OutputChannelStatus::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::OutputChannelStatus_TransmitState OutputChannelStatus::state() const {
  return static_cast< ::OutputChannelStatus_TransmitState >(state_);
}
inline void OutputChannelStatus::set_state(::OutputChannelStatus_TransmitState value) {
  assert(::OutputChannelStatus_TransmitState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional double powerMeter = 7;
inline bool OutputChannelStatus::has_powermeter() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OutputChannelStatus::set_has_powermeter() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OutputChannelStatus::clear_has_powermeter() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OutputChannelStatus::clear_powermeter() {
  powermeter_ = 0;
  clear_has_powermeter();
}
inline double OutputChannelStatus::powermeter() const {
  return powermeter_;
}
inline void OutputChannelStatus::set_powermeter(double value) {
  set_has_powermeter();
  powermeter_ = value;
}

// optional string resID = 8;
inline bool OutputChannelStatus::has_resid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OutputChannelStatus::set_has_resid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OutputChannelStatus::clear_has_resid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OutputChannelStatus::clear_resid() {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    resid_->clear();
  }
  clear_has_resid();
}
inline const ::std::string& OutputChannelStatus::resid() const {
  return *resid_;
}
inline void OutputChannelStatus::set_resid(const ::std::string& value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void OutputChannelStatus::set_resid(const char* value) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(value);
}
inline void OutputChannelStatus::set_resid(const char* value, size_t size) {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  resid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OutputChannelStatus::mutable_resid() {
  set_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    resid_ = new ::std::string;
  }
  return resid_;
}
inline ::std::string* OutputChannelStatus::release_resid() {
  clear_has_resid();
  if (resid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resid_;
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OutputChannelStatus::set_allocated_resid(::std::string* resid) {
  if (resid_ != &::google::protobuf::internal::kEmptyString) {
    delete resid_;
  }
  if (resid) {
    set_has_resid();
    resid_ = resid;
  } else {
    clear_has_resid();
    resid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string signalName = 9;
inline bool OutputChannelStatus::has_signalname() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OutputChannelStatus::set_has_signalname() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OutputChannelStatus::clear_has_signalname() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OutputChannelStatus::clear_signalname() {
  if (signalname_ != &::google::protobuf::internal::kEmptyString) {
    signalname_->clear();
  }
  clear_has_signalname();
}
inline const ::std::string& OutputChannelStatus::signalname() const {
  return *signalname_;
}
inline void OutputChannelStatus::set_signalname(const ::std::string& value) {
  set_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    signalname_ = new ::std::string;
  }
  signalname_->assign(value);
}
inline void OutputChannelStatus::set_signalname(const char* value) {
  set_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    signalname_ = new ::std::string;
  }
  signalname_->assign(value);
}
inline void OutputChannelStatus::set_signalname(const char* value, size_t size) {
  set_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    signalname_ = new ::std::string;
  }
  signalname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OutputChannelStatus::mutable_signalname() {
  set_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    signalname_ = new ::std::string;
  }
  return signalname_;
}
inline ::std::string* OutputChannelStatus::release_signalname() {
  clear_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signalname_;
    signalname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OutputChannelStatus::set_allocated_signalname(::std::string* signalname) {
  if (signalname_ != &::google::protobuf::internal::kEmptyString) {
    delete signalname_;
  }
  if (signalname) {
    set_has_signalname();
    signalname_ = signalname;
  } else {
    clear_has_signalname();
    signalname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UISetDefaultSchedule

// optional string msgName = 1 [default = "UISetDefaultSchedule"];
inline bool UISetDefaultSchedule::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UISetDefaultSchedule::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UISetDefaultSchedule::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UISetDefaultSchedule::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& UISetDefaultSchedule::msgname() const {
  return *msgname_;
}
inline void UISetDefaultSchedule::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UISetDefaultSchedule::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void UISetDefaultSchedule::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UISetDefaultSchedule::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* UISetDefaultSchedule::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void UISetDefaultSchedule::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 channelNum = 2;
inline bool UISetDefaultSchedule::has_channelnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UISetDefaultSchedule::set_has_channelnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UISetDefaultSchedule::clear_has_channelnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UISetDefaultSchedule::clear_channelnum() {
  channelnum_ = 0;
  clear_has_channelnum();
}
inline ::google::protobuf::int32 UISetDefaultSchedule::channelnum() const {
  return channelnum_;
}
inline void UISetDefaultSchedule::set_channelnum(::google::protobuf::int32 value) {
  set_has_channelnum();
  channelnum_ = value;
}

// optional string fileName = 3;
inline bool UISetDefaultSchedule::has_filename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UISetDefaultSchedule::set_has_filename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UISetDefaultSchedule::clear_has_filename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UISetDefaultSchedule::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& UISetDefaultSchedule::filename() const {
  return *filename_;
}
inline void UISetDefaultSchedule::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void UISetDefaultSchedule::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void UISetDefaultSchedule::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UISetDefaultSchedule::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* UISetDefaultSchedule::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UISetDefaultSchedule::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string connectionID = 4;
inline bool UISetDefaultSchedule::has_connectionid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UISetDefaultSchedule::set_has_connectionid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UISetDefaultSchedule::clear_has_connectionid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UISetDefaultSchedule::clear_connectionid() {
  if (connectionid_ != &::google::protobuf::internal::kEmptyString) {
    connectionid_->clear();
  }
  clear_has_connectionid();
}
inline const ::std::string& UISetDefaultSchedule::connectionid() const {
  return *connectionid_;
}
inline void UISetDefaultSchedule::set_connectionid(const ::std::string& value) {
  set_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(value);
}
inline void UISetDefaultSchedule::set_connectionid(const char* value) {
  set_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(value);
}
inline void UISetDefaultSchedule::set_connectionid(const char* value, size_t size) {
  set_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    connectionid_ = new ::std::string;
  }
  connectionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UISetDefaultSchedule::mutable_connectionid() {
  set_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    connectionid_ = new ::std::string;
  }
  return connectionid_;
}
inline ::std::string* UISetDefaultSchedule::release_connectionid() {
  clear_has_connectionid();
  if (connectionid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = connectionid_;
    connectionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UISetDefaultSchedule::set_allocated_connectionid(::std::string* connectionid) {
  if (connectionid_ != &::google::protobuf::internal::kEmptyString) {
    delete connectionid_;
  }
  if (connectionid) {
    set_has_connectionid();
    connectionid_ = connectionid;
  } else {
    clear_has_connectionid();
    connectionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// KeplerHeartBeat

// optional string msgName = 1 [default = "KeplerHeartBeat"];
inline bool KeplerHeartBeat::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeplerHeartBeat::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeplerHeartBeat::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeplerHeartBeat::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& KeplerHeartBeat::msgname() const {
  return *msgname_;
}
inline void KeplerHeartBeat::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void KeplerHeartBeat::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void KeplerHeartBeat::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeplerHeartBeat::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* KeplerHeartBeat::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void KeplerHeartBeat::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::UINack_ErrorCode>() {
  return ::UINack_ErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::UISignalEvent_Type>() {
  return ::UISignalEvent_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::UIOption_DetectionSource>() {
  return ::UIOption_DetectionSource_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OutputChannelStatus_TransmitState>() {
  return ::OutputChannelStatus_TransmitState_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_KeplerUIConnectionMessages_2eproto__INCLUDED
