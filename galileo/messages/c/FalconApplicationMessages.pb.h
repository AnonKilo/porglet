// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FalconApplicationMessages.proto

#ifndef PROTOBUF_FalconApplicationMessages_2eproto__INCLUDED
#define PROTOBUF_FalconApplicationMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "FalconCommonMessages.pb.h"
// @@protoc_insertion_point(includes)

namespace falcon_app_msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_FalconApplicationMessages_2eproto();
void protobuf_AssignDesc_FalconApplicationMessages_2eproto();
void protobuf_ShutdownFile_FalconApplicationMessages_2eproto();

class MacroOptions;
class FastSearchConfig;
class FastSearchState;
class NewFastScan;
class MissionManConfig;
class ProcMacroConfig;
class WidebandRecordConfig;
class HealthCheckConfig;
class MmsHealthConfig;
class NoiseTestConfig;
class GpsHealthConfig;
class AntennaControlConfig;
class VcnConfig;
class GenericMacroConfig;
class SettingsConfig;
class KepSvisorConfig;
class ZMQPubDemoConfig;
class ZMQSubDemoConfig;
class WifiConfig;

enum MacroOptions_AutoControl {
  MacroOptions_AutoControl_HEADLESS = 0,
  MacroOptions_AutoControl_CONTROLLED = 1,
  MacroOptions_AutoControl_AUTO_MODE = 2
};
bool MacroOptions_AutoControl_IsValid(int value);
const MacroOptions_AutoControl MacroOptions_AutoControl_AutoControl_MIN = MacroOptions_AutoControl_HEADLESS;
const MacroOptions_AutoControl MacroOptions_AutoControl_AutoControl_MAX = MacroOptions_AutoControl_AUTO_MODE;
const int MacroOptions_AutoControl_AutoControl_ARRAYSIZE = MacroOptions_AutoControl_AutoControl_MAX + 1;

const ::google::protobuf::EnumDescriptor* MacroOptions_AutoControl_descriptor();
inline const ::std::string& MacroOptions_AutoControl_Name(MacroOptions_AutoControl value) {
  return ::google::protobuf::internal::NameOfEnum(
    MacroOptions_AutoControl_descriptor(), value);
}
inline bool MacroOptions_AutoControl_Parse(
    const ::std::string& name, MacroOptions_AutoControl* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MacroOptions_AutoControl>(
    MacroOptions_AutoControl_descriptor(), name, value);
}
enum MacroOptions_PPS {
  MacroOptions_PPS_PPS_OFF = 0,
  MacroOptions_PPS_PPS_ON = 1
};
bool MacroOptions_PPS_IsValid(int value);
const MacroOptions_PPS MacroOptions_PPS_PPS_MIN = MacroOptions_PPS_PPS_OFF;
const MacroOptions_PPS MacroOptions_PPS_PPS_MAX = MacroOptions_PPS_PPS_ON;
const int MacroOptions_PPS_PPS_ARRAYSIZE = MacroOptions_PPS_PPS_MAX + 1;

const ::google::protobuf::EnumDescriptor* MacroOptions_PPS_descriptor();
inline const ::std::string& MacroOptions_PPS_Name(MacroOptions_PPS value) {
  return ::google::protobuf::internal::NameOfEnum(
    MacroOptions_PPS_descriptor(), value);
}
inline bool MacroOptions_PPS_Parse(
    const ::std::string& name, MacroOptions_PPS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MacroOptions_PPS>(
    MacroOptions_PPS_descriptor(), name, value);
}
enum MacroOptions_Ref10m {
  MacroOptions_Ref10m_REF_OFF = 0,
  MacroOptions_Ref10m_REF_ON = 1
};
bool MacroOptions_Ref10m_IsValid(int value);
const MacroOptions_Ref10m MacroOptions_Ref10m_Ref10m_MIN = MacroOptions_Ref10m_REF_OFF;
const MacroOptions_Ref10m MacroOptions_Ref10m_Ref10m_MAX = MacroOptions_Ref10m_REF_ON;
const int MacroOptions_Ref10m_Ref10m_ARRAYSIZE = MacroOptions_Ref10m_Ref10m_MAX + 1;

const ::google::protobuf::EnumDescriptor* MacroOptions_Ref10m_descriptor();
inline const ::std::string& MacroOptions_Ref10m_Name(MacroOptions_Ref10m value) {
  return ::google::protobuf::internal::NameOfEnum(
    MacroOptions_Ref10m_descriptor(), value);
}
inline bool MacroOptions_Ref10m_Parse(
    const ::std::string& name, MacroOptions_Ref10m* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MacroOptions_Ref10m>(
    MacroOptions_Ref10m_descriptor(), name, value);
}
enum MacroOptions_ExportFlags {
  MacroOptions_ExportFlags_ENABLE_NONE = 0,
  MacroOptions_ExportFlags_ENABLE_VIDEO = 1,
  MacroOptions_ExportFlags_ENABLE_JPEGS = 2,
  MacroOptions_ExportFlags_ENABLE_PSD = 4,
  MacroOptions_ExportFlags_ENABLE_WORKSTATION = 8
};
bool MacroOptions_ExportFlags_IsValid(int value);
const MacroOptions_ExportFlags MacroOptions_ExportFlags_ExportFlags_MIN = MacroOptions_ExportFlags_ENABLE_NONE;
const MacroOptions_ExportFlags MacroOptions_ExportFlags_ExportFlags_MAX = MacroOptions_ExportFlags_ENABLE_WORKSTATION;
const int MacroOptions_ExportFlags_ExportFlags_ARRAYSIZE = MacroOptions_ExportFlags_ExportFlags_MAX + 1;

const ::google::protobuf::EnumDescriptor* MacroOptions_ExportFlags_descriptor();
inline const ::std::string& MacroOptions_ExportFlags_Name(MacroOptions_ExportFlags value) {
  return ::google::protobuf::internal::NameOfEnum(
    MacroOptions_ExportFlags_descriptor(), value);
}
inline bool MacroOptions_ExportFlags_Parse(
    const ::std::string& name, MacroOptions_ExportFlags* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MacroOptions_ExportFlags>(
    MacroOptions_ExportFlags_descriptor(), name, value);
}
enum ProcMacroConfig_SystemType {
  ProcMacroConfig_SystemType_SYSTEM_TYPE_UNK = 0,
  ProcMacroConfig_SystemType_SYSTEM_TYPE_SD = 1,
  ProcMacroConfig_SystemType_SYSTEM_TYPE_RF = 2,
  ProcMacroConfig_SystemType_SYSTEM_TYPE_VCN = 3,
  ProcMacroConfig_SystemType_SYSTEM_TYPE_BF = 4,
  ProcMacroConfig_SystemType_SYSTEM_TYPE_GF = 5
};
bool ProcMacroConfig_SystemType_IsValid(int value);
const ProcMacroConfig_SystemType ProcMacroConfig_SystemType_SystemType_MIN = ProcMacroConfig_SystemType_SYSTEM_TYPE_UNK;
const ProcMacroConfig_SystemType ProcMacroConfig_SystemType_SystemType_MAX = ProcMacroConfig_SystemType_SYSTEM_TYPE_GF;
const int ProcMacroConfig_SystemType_SystemType_ARRAYSIZE = ProcMacroConfig_SystemType_SystemType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProcMacroConfig_SystemType_descriptor();
inline const ::std::string& ProcMacroConfig_SystemType_Name(ProcMacroConfig_SystemType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProcMacroConfig_SystemType_descriptor(), value);
}
inline bool ProcMacroConfig_SystemType_Parse(
    const ::std::string& name, ProcMacroConfig_SystemType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProcMacroConfig_SystemType>(
    ProcMacroConfig_SystemType_descriptor(), name, value);
}
// ===================================================================

class MacroOptions : public ::google::protobuf::Message {
 public:
  MacroOptions();
  virtual ~MacroOptions();

  MacroOptions(const MacroOptions& from);

  inline MacroOptions& operator=(const MacroOptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MacroOptions& default_instance();

  void Swap(MacroOptions* other);

  // implements Message ----------------------------------------------

  MacroOptions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MacroOptions& from);
  void MergeFrom(const MacroOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MacroOptions_AutoControl AutoControl;
  static const AutoControl HEADLESS = MacroOptions_AutoControl_HEADLESS;
  static const AutoControl CONTROLLED = MacroOptions_AutoControl_CONTROLLED;
  static const AutoControl AUTO_MODE = MacroOptions_AutoControl_AUTO_MODE;
  static inline bool AutoControl_IsValid(int value) {
    return MacroOptions_AutoControl_IsValid(value);
  }
  static const AutoControl AutoControl_MIN =
    MacroOptions_AutoControl_AutoControl_MIN;
  static const AutoControl AutoControl_MAX =
    MacroOptions_AutoControl_AutoControl_MAX;
  static const int AutoControl_ARRAYSIZE =
    MacroOptions_AutoControl_AutoControl_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AutoControl_descriptor() {
    return MacroOptions_AutoControl_descriptor();
  }
  static inline const ::std::string& AutoControl_Name(AutoControl value) {
    return MacroOptions_AutoControl_Name(value);
  }
  static inline bool AutoControl_Parse(const ::std::string& name,
      AutoControl* value) {
    return MacroOptions_AutoControl_Parse(name, value);
  }

  typedef MacroOptions_PPS PPS;
  static const PPS PPS_OFF = MacroOptions_PPS_PPS_OFF;
  static const PPS PPS_ON = MacroOptions_PPS_PPS_ON;
  static inline bool PPS_IsValid(int value) {
    return MacroOptions_PPS_IsValid(value);
  }
  static const PPS PPS_MIN =
    MacroOptions_PPS_PPS_MIN;
  static const PPS PPS_MAX =
    MacroOptions_PPS_PPS_MAX;
  static const int PPS_ARRAYSIZE =
    MacroOptions_PPS_PPS_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PPS_descriptor() {
    return MacroOptions_PPS_descriptor();
  }
  static inline const ::std::string& PPS_Name(PPS value) {
    return MacroOptions_PPS_Name(value);
  }
  static inline bool PPS_Parse(const ::std::string& name,
      PPS* value) {
    return MacroOptions_PPS_Parse(name, value);
  }

  typedef MacroOptions_Ref10m Ref10m;
  static const Ref10m REF_OFF = MacroOptions_Ref10m_REF_OFF;
  static const Ref10m REF_ON = MacroOptions_Ref10m_REF_ON;
  static inline bool Ref10m_IsValid(int value) {
    return MacroOptions_Ref10m_IsValid(value);
  }
  static const Ref10m Ref10m_MIN =
    MacroOptions_Ref10m_Ref10m_MIN;
  static const Ref10m Ref10m_MAX =
    MacroOptions_Ref10m_Ref10m_MAX;
  static const int Ref10m_ARRAYSIZE =
    MacroOptions_Ref10m_Ref10m_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Ref10m_descriptor() {
    return MacroOptions_Ref10m_descriptor();
  }
  static inline const ::std::string& Ref10m_Name(Ref10m value) {
    return MacroOptions_Ref10m_Name(value);
  }
  static inline bool Ref10m_Parse(const ::std::string& name,
      Ref10m* value) {
    return MacroOptions_Ref10m_Parse(name, value);
  }

  typedef MacroOptions_ExportFlags ExportFlags;
  static const ExportFlags ENABLE_NONE = MacroOptions_ExportFlags_ENABLE_NONE;
  static const ExportFlags ENABLE_VIDEO = MacroOptions_ExportFlags_ENABLE_VIDEO;
  static const ExportFlags ENABLE_JPEGS = MacroOptions_ExportFlags_ENABLE_JPEGS;
  static const ExportFlags ENABLE_PSD = MacroOptions_ExportFlags_ENABLE_PSD;
  static const ExportFlags ENABLE_WORKSTATION = MacroOptions_ExportFlags_ENABLE_WORKSTATION;
  static inline bool ExportFlags_IsValid(int value) {
    return MacroOptions_ExportFlags_IsValid(value);
  }
  static const ExportFlags ExportFlags_MIN =
    MacroOptions_ExportFlags_ExportFlags_MIN;
  static const ExportFlags ExportFlags_MAX =
    MacroOptions_ExportFlags_ExportFlags_MAX;
  static const int ExportFlags_ARRAYSIZE =
    MacroOptions_ExportFlags_ExportFlags_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ExportFlags_descriptor() {
    return MacroOptions_ExportFlags_descriptor();
  }
  static inline const ::std::string& ExportFlags_Name(ExportFlags value) {
    return MacroOptions_ExportFlags_Name(value);
  }
  static inline bool ExportFlags_Parse(const ::std::string& name,
      ExportFlags* value) {
    return MacroOptions_ExportFlags_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .falcon_app_msg.MacroOptions.AutoControl autoControl = 1;
  inline bool has_autocontrol() const;
  inline void clear_autocontrol();
  static const int kAutoControlFieldNumber = 1;
  inline ::falcon_app_msg::MacroOptions_AutoControl autocontrol() const;
  inline void set_autocontrol(::falcon_app_msg::MacroOptions_AutoControl value);

  // optional .falcon_app_msg.MacroOptions.PPS ppsEnable = 2 [default = PPS_OFF];
  inline bool has_ppsenable() const;
  inline void clear_ppsenable();
  static const int kPpsEnableFieldNumber = 2;
  inline ::falcon_app_msg::MacroOptions_PPS ppsenable() const;
  inline void set_ppsenable(::falcon_app_msg::MacroOptions_PPS value);

  // optional .falcon_app_msg.MacroOptions.Ref10m refEnable = 3 [default = REF_OFF];
  inline bool has_refenable() const;
  inline void clear_refenable();
  static const int kRefEnableFieldNumber = 3;
  inline ::falcon_app_msg::MacroOptions_Ref10m refenable() const;
  inline void set_refenable(::falcon_app_msg::MacroOptions_Ref10m value);

  // optional double ifFrequency = 4 [default = 30000000];
  inline bool has_iffrequency() const;
  inline void clear_iffrequency();
  static const int kIfFrequencyFieldNumber = 4;
  inline double iffrequency() const;
  inline void set_iffrequency(double value);

  // optional int32 writeAux = 5 [default = 12];
  inline bool has_writeaux() const;
  inline void clear_writeaux();
  static const int kWriteAuxFieldNumber = 5;
  inline ::google::protobuf::int32 writeaux() const;
  inline void set_writeaux(::google::protobuf::int32 value);

  // optional int32 exportEnable = 6 [default = 0];
  inline bool has_exportenable() const;
  inline void clear_exportenable();
  static const int kExportEnableFieldNumber = 6;
  inline ::google::protobuf::int32 exportenable() const;
  inline void set_exportenable(::google::protobuf::int32 value);

  // optional int32 videoLength = 7 [default = 20];
  inline bool has_videolength() const;
  inline void clear_videolength();
  static const int kVideoLengthFieldNumber = 7;
  inline ::google::protobuf::int32 videolength() const;
  inline void set_videolength(::google::protobuf::int32 value);

  // optional string sensorName = 8 [default = "sensor"];
  inline bool has_sensorname() const;
  inline void clear_sensorname();
  static const int kSensorNameFieldNumber = 8;
  inline const ::std::string& sensorname() const;
  inline void set_sensorname(const ::std::string& value);
  inline void set_sensorname(const char* value);
  inline void set_sensorname(const char* value, size_t size);
  inline ::std::string* mutable_sensorname();
  inline ::std::string* release_sensorname();
  inline void set_allocated_sensorname(::std::string* sensorname);

  // optional string psdIPAddress = 9 [default = ""];
  inline bool has_psdipaddress() const;
  inline void clear_psdipaddress();
  static const int kPsdIPAddressFieldNumber = 9;
  inline const ::std::string& psdipaddress() const;
  inline void set_psdipaddress(const ::std::string& value);
  inline void set_psdipaddress(const char* value);
  inline void set_psdipaddress(const char* value, size_t size);
  inline ::std::string* mutable_psdipaddress();
  inline ::std::string* release_psdipaddress();
  inline void set_allocated_psdipaddress(::std::string* psdipaddress);

  // optional int32 psdPeriod = 10 [default = 200];
  inline bool has_psdperiod() const;
  inline void clear_psdperiod();
  static const int kPsdPeriodFieldNumber = 10;
  inline ::google::protobuf::int32 psdperiod() const;
  inline void set_psdperiod(::google::protobuf::int32 value);

  // optional int32 jpegPeriod = 11 [default = 50];
  inline bool has_jpegperiod() const;
  inline void clear_jpegperiod();
  static const int kJpegPeriodFieldNumber = 11;
  inline ::google::protobuf::int32 jpegperiod() const;
  inline void set_jpegperiod(::google::protobuf::int32 value);

  // optional int32 xmlPeriod = 12 [default = 5];
  inline bool has_xmlperiod() const;
  inline void clear_xmlperiod();
  static const int kXmlPeriodFieldNumber = 12;
  inline ::google::protobuf::int32 xmlperiod() const;
  inline void set_xmlperiod(::google::protobuf::int32 value);

  // optional int32 protectArch = 13 [default = 0];
  inline bool has_protectarch() const;
  inline void clear_protectarch();
  static const int kProtectArchFieldNumber = 13;
  inline ::google::protobuf::int32 protectarch() const;
  inline void set_protectarch(::google::protobuf::int32 value);

  // optional bool midasBundling = 14 [default = false];
  inline bool has_midasbundling() const;
  inline void clear_midasbundling();
  static const int kMidasBundlingFieldNumber = 14;
  inline bool midasbundling() const;
  inline void set_midasbundling(bool value);

  // optional int32 remoteThresh = 15 [default = 10];
  inline bool has_remotethresh() const;
  inline void clear_remotethresh();
  static const int kRemoteThreshFieldNumber = 15;
  inline ::google::protobuf::int32 remotethresh() const;
  inline void set_remotethresh(::google::protobuf::int32 value);

  // optional int32 psdMethod = 16 [default = -1];
  inline bool has_psdmethod() const;
  inline void clear_psdmethod();
  static const int kPsdMethodFieldNumber = 16;
  inline ::google::protobuf::int32 psdmethod() const;
  inline void set_psdmethod(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_app_msg.MacroOptions)
 private:
  inline void set_has_autocontrol();
  inline void clear_has_autocontrol();
  inline void set_has_ppsenable();
  inline void clear_has_ppsenable();
  inline void set_has_refenable();
  inline void clear_has_refenable();
  inline void set_has_iffrequency();
  inline void clear_has_iffrequency();
  inline void set_has_writeaux();
  inline void clear_has_writeaux();
  inline void set_has_exportenable();
  inline void clear_has_exportenable();
  inline void set_has_videolength();
  inline void clear_has_videolength();
  inline void set_has_sensorname();
  inline void clear_has_sensorname();
  inline void set_has_psdipaddress();
  inline void clear_has_psdipaddress();
  inline void set_has_psdperiod();
  inline void clear_has_psdperiod();
  inline void set_has_jpegperiod();
  inline void clear_has_jpegperiod();
  inline void set_has_xmlperiod();
  inline void clear_has_xmlperiod();
  inline void set_has_protectarch();
  inline void clear_has_protectarch();
  inline void set_has_midasbundling();
  inline void clear_has_midasbundling();
  inline void set_has_remotethresh();
  inline void clear_has_remotethresh();
  inline void set_has_psdmethod();
  inline void clear_has_psdmethod();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int autocontrol_;
  int ppsenable_;
  double iffrequency_;
  int refenable_;
  ::google::protobuf::int32 writeaux_;
  ::google::protobuf::int32 exportenable_;
  ::google::protobuf::int32 videolength_;
  ::std::string* sensorname_;
  static ::std::string* _default_sensorname_;
  ::std::string* psdipaddress_;
  ::google::protobuf::int32 psdperiod_;
  ::google::protobuf::int32 jpegperiod_;
  ::google::protobuf::int32 xmlperiod_;
  ::google::protobuf::int32 protectarch_;
  bool midasbundling_;
  ::google::protobuf::int32 remotethresh_;
  ::google::protobuf::int32 psdmethod_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_AssignDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconApplicationMessages_2eproto();

  void InitAsDefaultInstance();
  static MacroOptions* default_instance_;
};
// -------------------------------------------------------------------

class FastSearchConfig : public ::google::protobuf::Message {
 public:
  FastSearchConfig();
  virtual ~FastSearchConfig();

  FastSearchConfig(const FastSearchConfig& from);

  inline FastSearchConfig& operator=(const FastSearchConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FastSearchConfig& default_instance();

  void Swap(FastSearchConfig* other);

  // implements Message ----------------------------------------------

  FastSearchConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FastSearchConfig& from);
  void MergeFrom(const FastSearchConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "FAST_SEARCH_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional .falcon_app_msg.MacroOptions options = 2;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 2;
  inline const ::falcon_app_msg::MacroOptions& options() const;
  inline ::falcon_app_msg::MacroOptions* mutable_options();
  inline ::falcon_app_msg::MacroOptions* release_options();
  inline void set_allocated_options(::falcon_app_msg::MacroOptions* options);

  // optional string charManSvc = 3;
  inline bool has_charmansvc() const;
  inline void clear_charmansvc();
  static const int kCharManSvcFieldNumber = 3;
  inline const ::std::string& charmansvc() const;
  inline void set_charmansvc(const ::std::string& value);
  inline void set_charmansvc(const char* value);
  inline void set_charmansvc(const char* value, size_t size);
  inline ::std::string* mutable_charmansvc();
  inline ::std::string* release_charmansvc();
  inline void set_allocated_charmansvc(::std::string* charmansvc);

  // optional bool enableRemoting = 4 [default = true];
  inline bool has_enableremoting() const;
  inline void clear_enableremoting();
  static const int kEnableRemotingFieldNumber = 4;
  inline bool enableremoting() const;
  inline void set_enableremoting(bool value);

  // optional bool enableFastPSD = 5 [default = false];
  inline bool has_enablefastpsd() const;
  inline void clear_enablefastpsd();
  static const int kEnableFastPSDFieldNumber = 5;
  inline bool enablefastpsd() const;
  inline void set_enablefastpsd(bool value);

  // optional int32 fastPSDPeriod = 6;
  inline bool has_fastpsdperiod() const;
  inline void clear_fastpsdperiod();
  static const int kFastPSDPeriodFieldNumber = 6;
  inline ::google::protobuf::int32 fastpsdperiod() const;
  inline void set_fastpsdperiod(::google::protobuf::int32 value);

  // optional bool dbActive = 7;
  inline bool has_dbactive() const;
  inline void clear_dbactive();
  static const int kDbActiveFieldNumber = 7;
  inline bool dbactive() const;
  inline void set_dbactive(bool value);

  // optional string dbUser = 8;
  inline bool has_dbuser() const;
  inline void clear_dbuser();
  static const int kDbUserFieldNumber = 8;
  inline const ::std::string& dbuser() const;
  inline void set_dbuser(const ::std::string& value);
  inline void set_dbuser(const char* value);
  inline void set_dbuser(const char* value, size_t size);
  inline ::std::string* mutable_dbuser();
  inline ::std::string* release_dbuser();
  inline void set_allocated_dbuser(::std::string* dbuser);

  // optional string dbName = 9;
  inline bool has_dbname() const;
  inline void clear_dbname();
  static const int kDbNameFieldNumber = 9;
  inline const ::std::string& dbname() const;
  inline void set_dbname(const ::std::string& value);
  inline void set_dbname(const char* value);
  inline void set_dbname(const char* value, size_t size);
  inline ::std::string* mutable_dbname();
  inline ::std::string* release_dbname();
  inline void set_allocated_dbname(::std::string* dbname);

  // optional string dbHost = 10;
  inline bool has_dbhost() const;
  inline void clear_dbhost();
  static const int kDbHostFieldNumber = 10;
  inline const ::std::string& dbhost() const;
  inline void set_dbhost(const ::std::string& value);
  inline void set_dbhost(const char* value);
  inline void set_dbhost(const char* value, size_t size);
  inline ::std::string* mutable_dbhost();
  inline ::std::string* release_dbhost();
  inline void set_allocated_dbhost(::std::string* dbhost);

  // optional int32 archiveNumber = 11;
  inline bool has_archivenumber() const;
  inline void clear_archivenumber();
  static const int kArchiveNumberFieldNumber = 11;
  inline ::google::protobuf::int32 archivenumber() const;
  inline void set_archivenumber(::google::protobuf::int32 value);

  // optional string archiveSize = 12;
  inline bool has_archivesize() const;
  inline void clear_archivesize();
  static const int kArchiveSizeFieldNumber = 12;
  inline const ::std::string& archivesize() const;
  inline void set_archivesize(const ::std::string& value);
  inline void set_archivesize(const char* value);
  inline void set_archivesize(const char* value, size_t size);
  inline ::std::string* mutable_archivesize();
  inline ::std::string* release_archivesize();
  inline void set_allocated_archivesize(::std::string* archivesize);

  // optional string geo_enabled = 13 [default = "OFF"];
  inline bool has_geo_enabled() const;
  inline void clear_geo_enabled();
  static const int kGeoEnabledFieldNumber = 13;
  inline const ::std::string& geo_enabled() const;
  inline void set_geo_enabled(const ::std::string& value);
  inline void set_geo_enabled(const char* value);
  inline void set_geo_enabled(const char* value, size_t size);
  inline ::std::string* mutable_geo_enabled();
  inline ::std::string* release_geo_enabled();
  inline void set_allocated_geo_enabled(::std::string* geo_enabled);

  // optional string auto_process = 14 [default = "ON"];
  inline bool has_auto_process() const;
  inline void clear_auto_process();
  static const int kAutoProcessFieldNumber = 14;
  inline const ::std::string& auto_process() const;
  inline void set_auto_process(const ::std::string& value);
  inline void set_auto_process(const char* value);
  inline void set_auto_process(const char* value, size_t size);
  inline ::std::string* mutable_auto_process();
  inline ::std::string* release_auto_process();
  inline void set_allocated_auto_process(::std::string* auto_process);

  // @@protoc_insertion_point(class_scope:falcon_app_msg.FastSearchConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_options();
  inline void clear_has_options();
  inline void set_has_charmansvc();
  inline void clear_has_charmansvc();
  inline void set_has_enableremoting();
  inline void clear_has_enableremoting();
  inline void set_has_enablefastpsd();
  inline void clear_has_enablefastpsd();
  inline void set_has_fastpsdperiod();
  inline void clear_has_fastpsdperiod();
  inline void set_has_dbactive();
  inline void clear_has_dbactive();
  inline void set_has_dbuser();
  inline void clear_has_dbuser();
  inline void set_has_dbname();
  inline void clear_has_dbname();
  inline void set_has_dbhost();
  inline void clear_has_dbhost();
  inline void set_has_archivenumber();
  inline void clear_has_archivenumber();
  inline void set_has_archivesize();
  inline void clear_has_archivesize();
  inline void set_has_geo_enabled();
  inline void clear_has_geo_enabled();
  inline void set_has_auto_process();
  inline void clear_has_auto_process();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::falcon_app_msg::MacroOptions* options_;
  ::std::string* charmansvc_;
  bool enableremoting_;
  bool enablefastpsd_;
  bool dbactive_;
  ::google::protobuf::int32 fastpsdperiod_;
  ::std::string* dbuser_;
  ::std::string* dbname_;
  ::std::string* dbhost_;
  ::std::string* archivesize_;
  ::std::string* geo_enabled_;
  static ::std::string* _default_geo_enabled_;
  ::std::string* auto_process_;
  static ::std::string* _default_auto_process_;
  ::google::protobuf::int32 archivenumber_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_AssignDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconApplicationMessages_2eproto();

  void InitAsDefaultInstance();
  static FastSearchConfig* default_instance_;
};
// -------------------------------------------------------------------

class FastSearchState : public ::google::protobuf::Message {
 public:
  FastSearchState();
  virtual ~FastSearchState();

  FastSearchState(const FastSearchState& from);

  inline FastSearchState& operator=(const FastSearchState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FastSearchState& default_instance();

  void Swap(FastSearchState* other);

  // implements Message ----------------------------------------------

  FastSearchState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FastSearchState& from);
  void MergeFrom(const FastSearchState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "FAST_SEARCH_STATE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional bool search = 2 [default = true];
  inline bool has_search() const;
  inline void clear_search();
  static const int kSearchFieldNumber = 2;
  inline bool search() const;
  inline void set_search(bool value);

  // @@protoc_insertion_point(class_scope:falcon_app_msg.FastSearchState)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_search();
  inline void clear_has_search();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  bool search_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_AssignDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconApplicationMessages_2eproto();

  void InitAsDefaultInstance();
  static FastSearchState* default_instance_;
};
// -------------------------------------------------------------------

class NewFastScan : public ::google::protobuf::Message {
 public:
  NewFastScan();
  virtual ~NewFastScan();

  NewFastScan(const NewFastScan& from);

  inline NewFastScan& operator=(const NewFastScan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewFastScan& default_instance();

  void Swap(NewFastScan* other);

  // implements Message ----------------------------------------------

  NewFastScan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewFastScan& from);
  void MergeFrom(const NewFastScan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "NEW_FAST_SCAN"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional double j1970Time = 2;
  inline bool has_j1970time() const;
  inline void clear_j1970time();
  static const int kJ1970TimeFieldNumber = 2;
  inline double j1970time() const;
  inline void set_j1970time(double value);

  // optional int32 channel = 3;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 3;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_app_msg.NewFastScan)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_j1970time();
  inline void clear_has_j1970time();
  inline void set_has_channel();
  inline void clear_has_channel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  double j1970time_;
  ::google::protobuf::int32 channel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_AssignDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconApplicationMessages_2eproto();

  void InitAsDefaultInstance();
  static NewFastScan* default_instance_;
};
// -------------------------------------------------------------------

class MissionManConfig : public ::google::protobuf::Message {
 public:
  MissionManConfig();
  virtual ~MissionManConfig();

  MissionManConfig(const MissionManConfig& from);

  inline MissionManConfig& operator=(const MissionManConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MissionManConfig& default_instance();

  void Swap(MissionManConfig* other);

  // implements Message ----------------------------------------------

  MissionManConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MissionManConfig& from);
  void MergeFrom(const MissionManConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "MISSION_MAN_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string dbHost = 2;
  inline bool has_dbhost() const;
  inline void clear_dbhost();
  static const int kDbHostFieldNumber = 2;
  inline const ::std::string& dbhost() const;
  inline void set_dbhost(const ::std::string& value);
  inline void set_dbhost(const char* value);
  inline void set_dbhost(const char* value, size_t size);
  inline ::std::string* mutable_dbhost();
  inline ::std::string* release_dbhost();
  inline void set_allocated_dbhost(::std::string* dbhost);

  // optional string dbUser = 3;
  inline bool has_dbuser() const;
  inline void clear_dbuser();
  static const int kDbUserFieldNumber = 3;
  inline const ::std::string& dbuser() const;
  inline void set_dbuser(const ::std::string& value);
  inline void set_dbuser(const char* value);
  inline void set_dbuser(const char* value, size_t size);
  inline ::std::string* mutable_dbuser();
  inline ::std::string* release_dbuser();
  inline void set_allocated_dbuser(::std::string* dbuser);

  // optional string dbName = 4;
  inline bool has_dbname() const;
  inline void clear_dbname();
  static const int kDbNameFieldNumber = 4;
  inline const ::std::string& dbname() const;
  inline void set_dbname(const ::std::string& value);
  inline void set_dbname(const char* value);
  inline void set_dbname(const char* value, size_t size);
  inline ::std::string* mutable_dbname();
  inline ::std::string* release_dbname();
  inline void set_allocated_dbname(::std::string* dbname);

  // optional int32 dbPort = 5;
  inline bool has_dbport() const;
  inline void clear_dbport();
  static const int kDbPortFieldNumber = 5;
  inline ::google::protobuf::int32 dbport() const;
  inline void set_dbport(::google::protobuf::int32 value);

  // optional int32 starttunernum = 6 [default = 1];
  inline bool has_starttunernum() const;
  inline void clear_starttunernum();
  static const int kStarttunernumFieldNumber = 6;
  inline ::google::protobuf::int32 starttunernum() const;
  inline void set_starttunernum(::google::protobuf::int32 value);

  // optional int32 numarcs = 7;
  inline bool has_numarcs() const;
  inline void clear_numarcs();
  static const int kNumarcsFieldNumber = 7;
  inline ::google::protobuf::int32 numarcs() const;
  inline void set_numarcs(::google::protobuf::int32 value);

  // optional string arcspread = 8;
  inline bool has_arcspread() const;
  inline void clear_arcspread();
  static const int kArcspreadFieldNumber = 8;
  inline const ::std::string& arcspread() const;
  inline void set_arcspread(const ::std::string& value);
  inline void set_arcspread(const char* value);
  inline void set_arcspread(const char* value, size_t size);
  inline ::std::string* mutable_arcspread();
  inline ::std::string* release_arcspread();
  inline void set_allocated_arcspread(::std::string* arcspread);

  // @@protoc_insertion_point(class_scope:falcon_app_msg.MissionManConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_dbhost();
  inline void clear_has_dbhost();
  inline void set_has_dbuser();
  inline void clear_has_dbuser();
  inline void set_has_dbname();
  inline void clear_has_dbname();
  inline void set_has_dbport();
  inline void clear_has_dbport();
  inline void set_has_starttunernum();
  inline void clear_has_starttunernum();
  inline void set_has_numarcs();
  inline void clear_has_numarcs();
  inline void set_has_arcspread();
  inline void clear_has_arcspread();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* dbhost_;
  ::std::string* dbuser_;
  ::std::string* dbname_;
  ::google::protobuf::int32 dbport_;
  ::google::protobuf::int32 starttunernum_;
  ::std::string* arcspread_;
  ::google::protobuf::int32 numarcs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_AssignDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconApplicationMessages_2eproto();

  void InitAsDefaultInstance();
  static MissionManConfig* default_instance_;
};
// -------------------------------------------------------------------

class ProcMacroConfig : public ::google::protobuf::Message {
 public:
  ProcMacroConfig();
  virtual ~ProcMacroConfig();

  ProcMacroConfig(const ProcMacroConfig& from);

  inline ProcMacroConfig& operator=(const ProcMacroConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcMacroConfig& default_instance();

  void Swap(ProcMacroConfig* other);

  // implements Message ----------------------------------------------

  ProcMacroConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcMacroConfig& from);
  void MergeFrom(const ProcMacroConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ProcMacroConfig_SystemType SystemType;
  static const SystemType SYSTEM_TYPE_UNK = ProcMacroConfig_SystemType_SYSTEM_TYPE_UNK;
  static const SystemType SYSTEM_TYPE_SD = ProcMacroConfig_SystemType_SYSTEM_TYPE_SD;
  static const SystemType SYSTEM_TYPE_RF = ProcMacroConfig_SystemType_SYSTEM_TYPE_RF;
  static const SystemType SYSTEM_TYPE_VCN = ProcMacroConfig_SystemType_SYSTEM_TYPE_VCN;
  static const SystemType SYSTEM_TYPE_BF = ProcMacroConfig_SystemType_SYSTEM_TYPE_BF;
  static const SystemType SYSTEM_TYPE_GF = ProcMacroConfig_SystemType_SYSTEM_TYPE_GF;
  static inline bool SystemType_IsValid(int value) {
    return ProcMacroConfig_SystemType_IsValid(value);
  }
  static const SystemType SystemType_MIN =
    ProcMacroConfig_SystemType_SystemType_MIN;
  static const SystemType SystemType_MAX =
    ProcMacroConfig_SystemType_SystemType_MAX;
  static const int SystemType_ARRAYSIZE =
    ProcMacroConfig_SystemType_SystemType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SystemType_descriptor() {
    return ProcMacroConfig_SystemType_descriptor();
  }
  static inline const ::std::string& SystemType_Name(SystemType value) {
    return ProcMacroConfig_SystemType_Name(value);
  }
  static inline bool SystemType_Parse(const ::std::string& name,
      SystemType* value) {
    return ProcMacroConfig_SystemType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "PROC_MACRO_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional .falcon_app_msg.MacroOptions options = 2;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 2;
  inline const ::falcon_app_msg::MacroOptions& options() const;
  inline ::falcon_app_msg::MacroOptions* mutable_options();
  inline ::falcon_app_msg::MacroOptions* release_options();
  inline void set_allocated_options(::falcon_app_msg::MacroOptions* options);

  // optional .falcon_app_msg.ProcMacroConfig.SystemType sysType = 3 [default = SYSTEM_TYPE_RF];
  inline bool has_systype() const;
  inline void clear_systype();
  static const int kSysTypeFieldNumber = 3;
  inline ::falcon_app_msg::ProcMacroConfig_SystemType systype() const;
  inline void set_systype(::falcon_app_msg::ProcMacroConfig_SystemType value);

  // optional bool enableIC = 4 [default = false];
  inline bool has_enableic() const;
  inline void clear_enableic();
  static const int kEnableICFieldNumber = 4;
  inline bool enableic() const;
  inline void set_enableic(bool value);

  // optional int32 timeout = 5 [default = 40];
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 5;
  inline ::google::protobuf::int32 timeout() const;
  inline void set_timeout(::google::protobuf::int32 value);

  // optional int32 slaveTimeout = 6 [default = 300];
  inline bool has_slavetimeout() const;
  inline void clear_slavetimeout();
  static const int kSlaveTimeoutFieldNumber = 6;
  inline ::google::protobuf::int32 slavetimeout() const;
  inline void set_slavetimeout(::google::protobuf::int32 value);

  // optional string extraForkSvc = 7;
  inline bool has_extraforksvc() const;
  inline void clear_extraforksvc();
  static const int kExtraForkSvcFieldNumber = 7;
  inline const ::std::string& extraforksvc() const;
  inline void set_extraforksvc(const ::std::string& value);
  inline void set_extraforksvc(const char* value);
  inline void set_extraforksvc(const char* value, size_t size);
  inline ::std::string* mutable_extraforksvc();
  inline ::std::string* release_extraforksvc();
  inline void set_allocated_extraforksvc(::std::string* extraforksvc);

  // optional .falcon_common_msg.ExtraForkChannel extraForkChan = 8;
  inline bool has_extraforkchan() const;
  inline void clear_extraforkchan();
  static const int kExtraForkChanFieldNumber = 8;
  inline const ::falcon_common_msg::ExtraForkChannel& extraforkchan() const;
  inline ::falcon_common_msg::ExtraForkChannel* mutable_extraforkchan();
  inline ::falcon_common_msg::ExtraForkChannel* release_extraforkchan();
  inline void set_allocated_extraforkchan(::falcon_common_msg::ExtraForkChannel* extraforkchan);

  // optional bool healthRxPort = 9 [default = false];
  inline bool has_healthrxport() const;
  inline void clear_healthrxport();
  static const int kHealthRxPortFieldNumber = 9;
  inline bool healthrxport() const;
  inline void set_healthrxport(bool value);

  // optional string geo_enabled = 10 [default = "OFF"];
  inline bool has_geo_enabled() const;
  inline void clear_geo_enabled();
  static const int kGeoEnabledFieldNumber = 10;
  inline const ::std::string& geo_enabled() const;
  inline void set_geo_enabled(const ::std::string& value);
  inline void set_geo_enabled(const char* value);
  inline void set_geo_enabled(const char* value, size_t size);
  inline ::std::string* mutable_geo_enabled();
  inline ::std::string* release_geo_enabled();
  inline void set_allocated_geo_enabled(::std::string* geo_enabled);

  // repeated string soiNums = 11;
  inline int soinums_size() const;
  inline void clear_soinums();
  static const int kSoiNumsFieldNumber = 11;
  inline const ::std::string& soinums(int index) const;
  inline ::std::string* mutable_soinums(int index);
  inline void set_soinums(int index, const ::std::string& value);
  inline void set_soinums(int index, const char* value);
  inline void set_soinums(int index, const char* value, size_t size);
  inline ::std::string* add_soinums();
  inline void add_soinums(const ::std::string& value);
  inline void add_soinums(const char* value);
  inline void add_soinums(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& soinums() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_soinums();

  // repeated string associatedSOIs = 12;
  inline int associatedsois_size() const;
  inline void clear_associatedsois();
  static const int kAssociatedSOIsFieldNumber = 12;
  inline const ::std::string& associatedsois(int index) const;
  inline ::std::string* mutable_associatedsois(int index);
  inline void set_associatedsois(int index, const ::std::string& value);
  inline void set_associatedsois(int index, const char* value);
  inline void set_associatedsois(int index, const char* value, size_t size);
  inline ::std::string* add_associatedsois();
  inline void add_associatedsois(const ::std::string& value);
  inline void add_associatedsois(const char* value);
  inline void add_associatedsois(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& associatedsois() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_associatedsois();

  // optional int32 assocRepeatSec = 13 [default = 1800];
  inline bool has_assocrepeatsec() const;
  inline void clear_assocrepeatsec();
  static const int kAssocRepeatSecFieldNumber = 13;
  inline ::google::protobuf::int32 assocrepeatsec() const;
  inline void set_assocrepeatsec(::google::protobuf::int32 value);

  // optional bool procTimeoutEnabled = 14 [default = false];
  inline bool has_proctimeoutenabled() const;
  inline void clear_proctimeoutenabled();
  static const int kProcTimeoutEnabledFieldNumber = 14;
  inline bool proctimeoutenabled() const;
  inline void set_proctimeoutenabled(bool value);

  // optional int32 procTime = 15 [default = -1];
  inline bool has_proctime() const;
  inline void clear_proctime();
  static const int kProcTimeFieldNumber = 15;
  inline ::google::protobuf::int32 proctime() const;
  inline void set_proctime(::google::protobuf::int32 value);

  // optional int32 blacklistBW = 16;
  inline bool has_blacklistbw() const;
  inline void clear_blacklistbw();
  static const int kBlacklistBWFieldNumber = 16;
  inline ::google::protobuf::int32 blacklistbw() const;
  inline void set_blacklistbw(::google::protobuf::int32 value);

  // optional int32 blacklistTime = 17 [default = 0];
  inline bool has_blacklisttime() const;
  inline void clear_blacklisttime();
  static const int kBlacklistTimeFieldNumber = 17;
  inline ::google::protobuf::int32 blacklisttime() const;
  inline void set_blacklisttime(::google::protobuf::int32 value);

  // optional int32 initialTimeout = 18 [default = 600];
  inline bool has_initialtimeout() const;
  inline void clear_initialtimeout();
  static const int kInitialTimeoutFieldNumber = 18;
  inline ::google::protobuf::int32 initialtimeout() const;
  inline void set_initialtimeout(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_app_msg.ProcMacroConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_options();
  inline void clear_has_options();
  inline void set_has_systype();
  inline void clear_has_systype();
  inline void set_has_enableic();
  inline void clear_has_enableic();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_slavetimeout();
  inline void clear_has_slavetimeout();
  inline void set_has_extraforksvc();
  inline void clear_has_extraforksvc();
  inline void set_has_extraforkchan();
  inline void clear_has_extraforkchan();
  inline void set_has_healthrxport();
  inline void clear_has_healthrxport();
  inline void set_has_geo_enabled();
  inline void clear_has_geo_enabled();
  inline void set_has_assocrepeatsec();
  inline void clear_has_assocrepeatsec();
  inline void set_has_proctimeoutenabled();
  inline void clear_has_proctimeoutenabled();
  inline void set_has_proctime();
  inline void clear_has_proctime();
  inline void set_has_blacklistbw();
  inline void clear_has_blacklistbw();
  inline void set_has_blacklisttime();
  inline void clear_has_blacklisttime();
  inline void set_has_initialtimeout();
  inline void clear_has_initialtimeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::falcon_app_msg::MacroOptions* options_;
  int systype_;
  ::google::protobuf::int32 timeout_;
  ::std::string* extraforksvc_;
  ::falcon_common_msg::ExtraForkChannel* extraforkchan_;
  ::google::protobuf::int32 slavetimeout_;
  bool enableic_;
  bool healthrxport_;
  bool proctimeoutenabled_;
  ::std::string* geo_enabled_;
  static ::std::string* _default_geo_enabled_;
  ::google::protobuf::RepeatedPtrField< ::std::string> soinums_;
  ::google::protobuf::RepeatedPtrField< ::std::string> associatedsois_;
  ::google::protobuf::int32 assocrepeatsec_;
  ::google::protobuf::int32 proctime_;
  ::google::protobuf::int32 blacklistbw_;
  ::google::protobuf::int32 blacklisttime_;
  ::google::protobuf::int32 initialtimeout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void  protobuf_AddDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_AssignDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconApplicationMessages_2eproto();

  void InitAsDefaultInstance();
  static ProcMacroConfig* default_instance_;
};
// -------------------------------------------------------------------

class WidebandRecordConfig : public ::google::protobuf::Message {
 public:
  WidebandRecordConfig();
  virtual ~WidebandRecordConfig();

  WidebandRecordConfig(const WidebandRecordConfig& from);

  inline WidebandRecordConfig& operator=(const WidebandRecordConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WidebandRecordConfig& default_instance();

  void Swap(WidebandRecordConfig* other);

  // implements Message ----------------------------------------------

  WidebandRecordConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WidebandRecordConfig& from);
  void MergeFrom(const WidebandRecordConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "WIDEBAND_RECORD_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional .falcon_app_msg.MacroOptions options = 2;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 2;
  inline const ::falcon_app_msg::MacroOptions& options() const;
  inline ::falcon_app_msg::MacroOptions* mutable_options();
  inline ::falcon_app_msg::MacroOptions* release_options();
  inline void set_allocated_options(::falcon_app_msg::MacroOptions* options);

  // optional bool healthRxPort = 3 [default = false];
  inline bool has_healthrxport() const;
  inline void clear_healthrxport();
  static const int kHealthRxPortFieldNumber = 3;
  inline bool healthrxport() const;
  inline void set_healthrxport(bool value);

  // optional string geo_enabled = 4 [default = "OFF"];
  inline bool has_geo_enabled() const;
  inline void clear_geo_enabled();
  static const int kGeoEnabledFieldNumber = 4;
  inline const ::std::string& geo_enabled() const;
  inline void set_geo_enabled(const ::std::string& value);
  inline void set_geo_enabled(const char* value);
  inline void set_geo_enabled(const char* value, size_t size);
  inline ::std::string* mutable_geo_enabled();
  inline ::std::string* release_geo_enabled();
  inline void set_allocated_geo_enabled(::std::string* geo_enabled);

  // @@protoc_insertion_point(class_scope:falcon_app_msg.WidebandRecordConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_options();
  inline void clear_has_options();
  inline void set_has_healthrxport();
  inline void clear_has_healthrxport();
  inline void set_has_geo_enabled();
  inline void clear_has_geo_enabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::falcon_app_msg::MacroOptions* options_;
  ::std::string* geo_enabled_;
  static ::std::string* _default_geo_enabled_;
  bool healthrxport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_AssignDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconApplicationMessages_2eproto();

  void InitAsDefaultInstance();
  static WidebandRecordConfig* default_instance_;
};
// -------------------------------------------------------------------

class HealthCheckConfig : public ::google::protobuf::Message {
 public:
  HealthCheckConfig();
  virtual ~HealthCheckConfig();

  HealthCheckConfig(const HealthCheckConfig& from);

  inline HealthCheckConfig& operator=(const HealthCheckConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HealthCheckConfig& default_instance();

  void Swap(HealthCheckConfig* other);

  // implements Message ----------------------------------------------

  HealthCheckConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HealthCheckConfig& from);
  void MergeFrom(const HealthCheckConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "HEALTH_CHECK_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional .falcon_app_msg.MacroOptions options = 2;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 2;
  inline const ::falcon_app_msg::MacroOptions& options() const;
  inline ::falcon_app_msg::MacroOptions* mutable_options();
  inline ::falcon_app_msg::MacroOptions* release_options();
  inline void set_allocated_options(::falcon_app_msg::MacroOptions* options);

  // @@protoc_insertion_point(class_scope:falcon_app_msg.HealthCheckConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_options();
  inline void clear_has_options();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::falcon_app_msg::MacroOptions* options_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_AssignDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconApplicationMessages_2eproto();

  void InitAsDefaultInstance();
  static HealthCheckConfig* default_instance_;
};
// -------------------------------------------------------------------

class MmsHealthConfig : public ::google::protobuf::Message {
 public:
  MmsHealthConfig();
  virtual ~MmsHealthConfig();

  MmsHealthConfig(const MmsHealthConfig& from);

  inline MmsHealthConfig& operator=(const MmsHealthConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MmsHealthConfig& default_instance();

  void Swap(MmsHealthConfig* other);

  // implements Message ----------------------------------------------

  MmsHealthConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MmsHealthConfig& from);
  void MergeFrom(const MmsHealthConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "MMS_HEALTH_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional .falcon_app_msg.MacroOptions options = 2;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 2;
  inline const ::falcon_app_msg::MacroOptions& options() const;
  inline ::falcon_app_msg::MacroOptions* mutable_options();
  inline ::falcon_app_msg::MacroOptions* release_options();
  inline void set_allocated_options(::falcon_app_msg::MacroOptions* options);

  // @@protoc_insertion_point(class_scope:falcon_app_msg.MmsHealthConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_options();
  inline void clear_has_options();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::falcon_app_msg::MacroOptions* options_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_AssignDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconApplicationMessages_2eproto();

  void InitAsDefaultInstance();
  static MmsHealthConfig* default_instance_;
};
// -------------------------------------------------------------------

class NoiseTestConfig : public ::google::protobuf::Message {
 public:
  NoiseTestConfig();
  virtual ~NoiseTestConfig();

  NoiseTestConfig(const NoiseTestConfig& from);

  inline NoiseTestConfig& operator=(const NoiseTestConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NoiseTestConfig& default_instance();

  void Swap(NoiseTestConfig* other);

  // implements Message ----------------------------------------------

  NoiseTestConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NoiseTestConfig& from);
  void MergeFrom(const NoiseTestConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "NOISE_TEST_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional .falcon_app_msg.MacroOptions options = 2;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 2;
  inline const ::falcon_app_msg::MacroOptions& options() const;
  inline ::falcon_app_msg::MacroOptions* mutable_options();
  inline ::falcon_app_msg::MacroOptions* release_options();
  inline void set_allocated_options(::falcon_app_msg::MacroOptions* options);

  // @@protoc_insertion_point(class_scope:falcon_app_msg.NoiseTestConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_options();
  inline void clear_has_options();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::falcon_app_msg::MacroOptions* options_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_AssignDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconApplicationMessages_2eproto();

  void InitAsDefaultInstance();
  static NoiseTestConfig* default_instance_;
};
// -------------------------------------------------------------------

class GpsHealthConfig : public ::google::protobuf::Message {
 public:
  GpsHealthConfig();
  virtual ~GpsHealthConfig();

  GpsHealthConfig(const GpsHealthConfig& from);

  inline GpsHealthConfig& operator=(const GpsHealthConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GpsHealthConfig& default_instance();

  void Swap(GpsHealthConfig* other);

  // implements Message ----------------------------------------------

  GpsHealthConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GpsHealthConfig& from);
  void MergeFrom(const GpsHealthConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "GPS_HEALTH_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional .falcon_app_msg.MacroOptions options = 2;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 2;
  inline const ::falcon_app_msg::MacroOptions& options() const;
  inline ::falcon_app_msg::MacroOptions* mutable_options();
  inline ::falcon_app_msg::MacroOptions* release_options();
  inline void set_allocated_options(::falcon_app_msg::MacroOptions* options);

  // @@protoc_insertion_point(class_scope:falcon_app_msg.GpsHealthConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_options();
  inline void clear_has_options();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::falcon_app_msg::MacroOptions* options_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_AssignDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconApplicationMessages_2eproto();

  void InitAsDefaultInstance();
  static GpsHealthConfig* default_instance_;
};
// -------------------------------------------------------------------

class AntennaControlConfig : public ::google::protobuf::Message {
 public:
  AntennaControlConfig();
  virtual ~AntennaControlConfig();

  AntennaControlConfig(const AntennaControlConfig& from);

  inline AntennaControlConfig& operator=(const AntennaControlConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AntennaControlConfig& default_instance();

  void Swap(AntennaControlConfig* other);

  // implements Message ----------------------------------------------

  AntennaControlConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AntennaControlConfig& from);
  void MergeFrom(const AntennaControlConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ANTENNA_CONTROL"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // @@protoc_insertion_point(class_scope:falcon_app_msg.AntennaControlConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_AssignDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconApplicationMessages_2eproto();

  void InitAsDefaultInstance();
  static AntennaControlConfig* default_instance_;
};
// -------------------------------------------------------------------

class VcnConfig : public ::google::protobuf::Message {
 public:
  VcnConfig();
  virtual ~VcnConfig();

  VcnConfig(const VcnConfig& from);

  inline VcnConfig& operator=(const VcnConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VcnConfig& default_instance();

  void Swap(VcnConfig* other);

  // implements Message ----------------------------------------------

  VcnConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VcnConfig& from);
  void MergeFrom(const VcnConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "VCN_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // @@protoc_insertion_point(class_scope:falcon_app_msg.VcnConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_AssignDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconApplicationMessages_2eproto();

  void InitAsDefaultInstance();
  static VcnConfig* default_instance_;
};
// -------------------------------------------------------------------

class GenericMacroConfig : public ::google::protobuf::Message {
 public:
  GenericMacroConfig();
  virtual ~GenericMacroConfig();

  GenericMacroConfig(const GenericMacroConfig& from);

  inline GenericMacroConfig& operator=(const GenericMacroConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GenericMacroConfig& default_instance();

  void Swap(GenericMacroConfig* other);

  // implements Message ----------------------------------------------

  GenericMacroConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GenericMacroConfig& from);
  void MergeFrom(const GenericMacroConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "GENERIC_MACRO_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // @@protoc_insertion_point(class_scope:falcon_app_msg.GenericMacroConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_AssignDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconApplicationMessages_2eproto();

  void InitAsDefaultInstance();
  static GenericMacroConfig* default_instance_;
};
// -------------------------------------------------------------------

class SettingsConfig : public ::google::protobuf::Message {
 public:
  SettingsConfig();
  virtual ~SettingsConfig();

  SettingsConfig(const SettingsConfig& from);

  inline SettingsConfig& operator=(const SettingsConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SettingsConfig& default_instance();

  void Swap(SettingsConfig* other);

  // implements Message ----------------------------------------------

  SettingsConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SettingsConfig& from);
  void MergeFrom(const SettingsConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SETTINGS_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // @@protoc_insertion_point(class_scope:falcon_app_msg.SettingsConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_AssignDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconApplicationMessages_2eproto();

  void InitAsDefaultInstance();
  static SettingsConfig* default_instance_;
};
// -------------------------------------------------------------------

class KepSvisorConfig : public ::google::protobuf::Message {
 public:
  KepSvisorConfig();
  virtual ~KepSvisorConfig();

  KepSvisorConfig(const KepSvisorConfig& from);

  inline KepSvisorConfig& operator=(const KepSvisorConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KepSvisorConfig& default_instance();

  void Swap(KepSvisorConfig* other);

  // implements Message ----------------------------------------------

  KepSvisorConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KepSvisorConfig& from);
  void MergeFrom(const KepSvisorConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "KEP_SVISOR_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // @@protoc_insertion_point(class_scope:falcon_app_msg.KepSvisorConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_AssignDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconApplicationMessages_2eproto();

  void InitAsDefaultInstance();
  static KepSvisorConfig* default_instance_;
};
// -------------------------------------------------------------------

class ZMQPubDemoConfig : public ::google::protobuf::Message {
 public:
  ZMQPubDemoConfig();
  virtual ~ZMQPubDemoConfig();

  ZMQPubDemoConfig(const ZMQPubDemoConfig& from);

  inline ZMQPubDemoConfig& operator=(const ZMQPubDemoConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ZMQPubDemoConfig& default_instance();

  void Swap(ZMQPubDemoConfig* other);

  // implements Message ----------------------------------------------

  ZMQPubDemoConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ZMQPubDemoConfig& from);
  void MergeFrom(const ZMQPubDemoConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ZMQ_PUB_DEMO_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 maxRequests = 2 [default = 1];
  inline bool has_maxrequests() const;
  inline void clear_maxrequests();
  static const int kMaxRequestsFieldNumber = 2;
  inline ::google::protobuf::int32 maxrequests() const;
  inline void set_maxrequests(::google::protobuf::int32 value);

  // optional string address = 3 [default = ""];
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 3;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional .falcon_app_msg.MacroOptions options = 4;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 4;
  inline const ::falcon_app_msg::MacroOptions& options() const;
  inline ::falcon_app_msg::MacroOptions* mutable_options();
  inline ::falcon_app_msg::MacroOptions* release_options();
  inline void set_allocated_options(::falcon_app_msg::MacroOptions* options);

  // @@protoc_insertion_point(class_scope:falcon_app_msg.ZMQPubDemoConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_maxrequests();
  inline void clear_has_maxrequests();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_options();
  inline void clear_has_options();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* address_;
  ::falcon_app_msg::MacroOptions* options_;
  ::google::protobuf::int32 maxrequests_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_AssignDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconApplicationMessages_2eproto();

  void InitAsDefaultInstance();
  static ZMQPubDemoConfig* default_instance_;
};
// -------------------------------------------------------------------

class ZMQSubDemoConfig : public ::google::protobuf::Message {
 public:
  ZMQSubDemoConfig();
  virtual ~ZMQSubDemoConfig();

  ZMQSubDemoConfig(const ZMQSubDemoConfig& from);

  inline ZMQSubDemoConfig& operator=(const ZMQSubDemoConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ZMQSubDemoConfig& default_instance();

  void Swap(ZMQSubDemoConfig* other);

  // implements Message ----------------------------------------------

  ZMQSubDemoConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ZMQSubDemoConfig& from);
  void MergeFrom(const ZMQSubDemoConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ZMQ_SUB_DEMO_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 maxProducts = 2 [default = 1];
  inline bool has_maxproducts() const;
  inline void clear_maxproducts();
  static const int kMaxProductsFieldNumber = 2;
  inline ::google::protobuf::int32 maxproducts() const;
  inline void set_maxproducts(::google::protobuf::int32 value);

  // optional string address = 3 [default = ""];
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 3;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional .falcon_app_msg.MacroOptions options = 4;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 4;
  inline const ::falcon_app_msg::MacroOptions& options() const;
  inline ::falcon_app_msg::MacroOptions* mutable_options();
  inline ::falcon_app_msg::MacroOptions* release_options();
  inline void set_allocated_options(::falcon_app_msg::MacroOptions* options);

  // @@protoc_insertion_point(class_scope:falcon_app_msg.ZMQSubDemoConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_maxproducts();
  inline void clear_has_maxproducts();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_options();
  inline void clear_has_options();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* address_;
  ::falcon_app_msg::MacroOptions* options_;
  ::google::protobuf::int32 maxproducts_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_AssignDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconApplicationMessages_2eproto();

  void InitAsDefaultInstance();
  static ZMQSubDemoConfig* default_instance_;
};
// -------------------------------------------------------------------

class WifiConfig : public ::google::protobuf::Message {
 public:
  WifiConfig();
  virtual ~WifiConfig();

  WifiConfig(const WifiConfig& from);

  inline WifiConfig& operator=(const WifiConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WifiConfig& default_instance();

  void Swap(WifiConfig* other);

  // implements Message ----------------------------------------------

  WifiConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WifiConfig& from);
  void MergeFrom(const WifiConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "WIFI_CONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional .falcon_app_msg.MacroOptions options = 2;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 2;
  inline const ::falcon_app_msg::MacroOptions& options() const;
  inline ::falcon_app_msg::MacroOptions* mutable_options();
  inline ::falcon_app_msg::MacroOptions* release_options();
  inline void set_allocated_options(::falcon_app_msg::MacroOptions* options);

  // optional string geo_enabled = 3 [default = "OFF"];
  inline bool has_geo_enabled() const;
  inline void clear_geo_enabled();
  static const int kGeoEnabledFieldNumber = 3;
  inline const ::std::string& geo_enabled() const;
  inline void set_geo_enabled(const ::std::string& value);
  inline void set_geo_enabled(const char* value);
  inline void set_geo_enabled(const char* value, size_t size);
  inline ::std::string* mutable_geo_enabled();
  inline ::std::string* release_geo_enabled();
  inline void set_allocated_geo_enabled(::std::string* geo_enabled);

  // @@protoc_insertion_point(class_scope:falcon_app_msg.WifiConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_options();
  inline void clear_has_options();
  inline void set_has_geo_enabled();
  inline void clear_has_geo_enabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::falcon_app_msg::MacroOptions* options_;
  ::std::string* geo_enabled_;
  static ::std::string* _default_geo_enabled_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_AssignDesc_FalconApplicationMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconApplicationMessages_2eproto();

  void InitAsDefaultInstance();
  static WifiConfig* default_instance_;
};
// ===================================================================


// ===================================================================

// MacroOptions

// optional .falcon_app_msg.MacroOptions.AutoControl autoControl = 1;
inline bool MacroOptions::has_autocontrol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MacroOptions::set_has_autocontrol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MacroOptions::clear_has_autocontrol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MacroOptions::clear_autocontrol() {
  autocontrol_ = 0;
  clear_has_autocontrol();
}
inline ::falcon_app_msg::MacroOptions_AutoControl MacroOptions::autocontrol() const {
  return static_cast< ::falcon_app_msg::MacroOptions_AutoControl >(autocontrol_);
}
inline void MacroOptions::set_autocontrol(::falcon_app_msg::MacroOptions_AutoControl value) {
  assert(::falcon_app_msg::MacroOptions_AutoControl_IsValid(value));
  set_has_autocontrol();
  autocontrol_ = value;
}

// optional .falcon_app_msg.MacroOptions.PPS ppsEnable = 2 [default = PPS_OFF];
inline bool MacroOptions::has_ppsenable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MacroOptions::set_has_ppsenable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MacroOptions::clear_has_ppsenable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MacroOptions::clear_ppsenable() {
  ppsenable_ = 0;
  clear_has_ppsenable();
}
inline ::falcon_app_msg::MacroOptions_PPS MacroOptions::ppsenable() const {
  return static_cast< ::falcon_app_msg::MacroOptions_PPS >(ppsenable_);
}
inline void MacroOptions::set_ppsenable(::falcon_app_msg::MacroOptions_PPS value) {
  assert(::falcon_app_msg::MacroOptions_PPS_IsValid(value));
  set_has_ppsenable();
  ppsenable_ = value;
}

// optional .falcon_app_msg.MacroOptions.Ref10m refEnable = 3 [default = REF_OFF];
inline bool MacroOptions::has_refenable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MacroOptions::set_has_refenable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MacroOptions::clear_has_refenable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MacroOptions::clear_refenable() {
  refenable_ = 0;
  clear_has_refenable();
}
inline ::falcon_app_msg::MacroOptions_Ref10m MacroOptions::refenable() const {
  return static_cast< ::falcon_app_msg::MacroOptions_Ref10m >(refenable_);
}
inline void MacroOptions::set_refenable(::falcon_app_msg::MacroOptions_Ref10m value) {
  assert(::falcon_app_msg::MacroOptions_Ref10m_IsValid(value));
  set_has_refenable();
  refenable_ = value;
}

// optional double ifFrequency = 4 [default = 30000000];
inline bool MacroOptions::has_iffrequency() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MacroOptions::set_has_iffrequency() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MacroOptions::clear_has_iffrequency() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MacroOptions::clear_iffrequency() {
  iffrequency_ = 30000000;
  clear_has_iffrequency();
}
inline double MacroOptions::iffrequency() const {
  return iffrequency_;
}
inline void MacroOptions::set_iffrequency(double value) {
  set_has_iffrequency();
  iffrequency_ = value;
}

// optional int32 writeAux = 5 [default = 12];
inline bool MacroOptions::has_writeaux() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MacroOptions::set_has_writeaux() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MacroOptions::clear_has_writeaux() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MacroOptions::clear_writeaux() {
  writeaux_ = 12;
  clear_has_writeaux();
}
inline ::google::protobuf::int32 MacroOptions::writeaux() const {
  return writeaux_;
}
inline void MacroOptions::set_writeaux(::google::protobuf::int32 value) {
  set_has_writeaux();
  writeaux_ = value;
}

// optional int32 exportEnable = 6 [default = 0];
inline bool MacroOptions::has_exportenable() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MacroOptions::set_has_exportenable() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MacroOptions::clear_has_exportenable() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MacroOptions::clear_exportenable() {
  exportenable_ = 0;
  clear_has_exportenable();
}
inline ::google::protobuf::int32 MacroOptions::exportenable() const {
  return exportenable_;
}
inline void MacroOptions::set_exportenable(::google::protobuf::int32 value) {
  set_has_exportenable();
  exportenable_ = value;
}

// optional int32 videoLength = 7 [default = 20];
inline bool MacroOptions::has_videolength() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MacroOptions::set_has_videolength() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MacroOptions::clear_has_videolength() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MacroOptions::clear_videolength() {
  videolength_ = 20;
  clear_has_videolength();
}
inline ::google::protobuf::int32 MacroOptions::videolength() const {
  return videolength_;
}
inline void MacroOptions::set_videolength(::google::protobuf::int32 value) {
  set_has_videolength();
  videolength_ = value;
}

// optional string sensorName = 8 [default = "sensor"];
inline bool MacroOptions::has_sensorname() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MacroOptions::set_has_sensorname() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MacroOptions::clear_has_sensorname() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MacroOptions::clear_sensorname() {
  if (sensorname_ != _default_sensorname_) {
    sensorname_->assign(*_default_sensorname_);
  }
  clear_has_sensorname();
}
inline const ::std::string& MacroOptions::sensorname() const {
  return *sensorname_;
}
inline void MacroOptions::set_sensorname(const ::std::string& value) {
  set_has_sensorname();
  if (sensorname_ == _default_sensorname_) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void MacroOptions::set_sensorname(const char* value) {
  set_has_sensorname();
  if (sensorname_ == _default_sensorname_) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void MacroOptions::set_sensorname(const char* value, size_t size) {
  set_has_sensorname();
  if (sensorname_ == _default_sensorname_) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MacroOptions::mutable_sensorname() {
  set_has_sensorname();
  if (sensorname_ == _default_sensorname_) {
    sensorname_ = new ::std::string(*_default_sensorname_);
  }
  return sensorname_;
}
inline ::std::string* MacroOptions::release_sensorname() {
  clear_has_sensorname();
  if (sensorname_ == _default_sensorname_) {
    return NULL;
  } else {
    ::std::string* temp = sensorname_;
    sensorname_ = const_cast< ::std::string*>(_default_sensorname_);
    return temp;
  }
}
inline void MacroOptions::set_allocated_sensorname(::std::string* sensorname) {
  if (sensorname_ != _default_sensorname_) {
    delete sensorname_;
  }
  if (sensorname) {
    set_has_sensorname();
    sensorname_ = sensorname;
  } else {
    clear_has_sensorname();
    sensorname_ = const_cast< ::std::string*>(_default_sensorname_);
  }
}

// optional string psdIPAddress = 9 [default = ""];
inline bool MacroOptions::has_psdipaddress() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MacroOptions::set_has_psdipaddress() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MacroOptions::clear_has_psdipaddress() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MacroOptions::clear_psdipaddress() {
  if (psdipaddress_ != &::google::protobuf::internal::kEmptyString) {
    psdipaddress_->clear();
  }
  clear_has_psdipaddress();
}
inline const ::std::string& MacroOptions::psdipaddress() const {
  return *psdipaddress_;
}
inline void MacroOptions::set_psdipaddress(const ::std::string& value) {
  set_has_psdipaddress();
  if (psdipaddress_ == &::google::protobuf::internal::kEmptyString) {
    psdipaddress_ = new ::std::string;
  }
  psdipaddress_->assign(value);
}
inline void MacroOptions::set_psdipaddress(const char* value) {
  set_has_psdipaddress();
  if (psdipaddress_ == &::google::protobuf::internal::kEmptyString) {
    psdipaddress_ = new ::std::string;
  }
  psdipaddress_->assign(value);
}
inline void MacroOptions::set_psdipaddress(const char* value, size_t size) {
  set_has_psdipaddress();
  if (psdipaddress_ == &::google::protobuf::internal::kEmptyString) {
    psdipaddress_ = new ::std::string;
  }
  psdipaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MacroOptions::mutable_psdipaddress() {
  set_has_psdipaddress();
  if (psdipaddress_ == &::google::protobuf::internal::kEmptyString) {
    psdipaddress_ = new ::std::string;
  }
  return psdipaddress_;
}
inline ::std::string* MacroOptions::release_psdipaddress() {
  clear_has_psdipaddress();
  if (psdipaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = psdipaddress_;
    psdipaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MacroOptions::set_allocated_psdipaddress(::std::string* psdipaddress) {
  if (psdipaddress_ != &::google::protobuf::internal::kEmptyString) {
    delete psdipaddress_;
  }
  if (psdipaddress) {
    set_has_psdipaddress();
    psdipaddress_ = psdipaddress;
  } else {
    clear_has_psdipaddress();
    psdipaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 psdPeriod = 10 [default = 200];
inline bool MacroOptions::has_psdperiod() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MacroOptions::set_has_psdperiod() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MacroOptions::clear_has_psdperiod() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MacroOptions::clear_psdperiod() {
  psdperiod_ = 200;
  clear_has_psdperiod();
}
inline ::google::protobuf::int32 MacroOptions::psdperiod() const {
  return psdperiod_;
}
inline void MacroOptions::set_psdperiod(::google::protobuf::int32 value) {
  set_has_psdperiod();
  psdperiod_ = value;
}

// optional int32 jpegPeriod = 11 [default = 50];
inline bool MacroOptions::has_jpegperiod() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MacroOptions::set_has_jpegperiod() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MacroOptions::clear_has_jpegperiod() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MacroOptions::clear_jpegperiod() {
  jpegperiod_ = 50;
  clear_has_jpegperiod();
}
inline ::google::protobuf::int32 MacroOptions::jpegperiod() const {
  return jpegperiod_;
}
inline void MacroOptions::set_jpegperiod(::google::protobuf::int32 value) {
  set_has_jpegperiod();
  jpegperiod_ = value;
}

// optional int32 xmlPeriod = 12 [default = 5];
inline bool MacroOptions::has_xmlperiod() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MacroOptions::set_has_xmlperiod() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MacroOptions::clear_has_xmlperiod() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MacroOptions::clear_xmlperiod() {
  xmlperiod_ = 5;
  clear_has_xmlperiod();
}
inline ::google::protobuf::int32 MacroOptions::xmlperiod() const {
  return xmlperiod_;
}
inline void MacroOptions::set_xmlperiod(::google::protobuf::int32 value) {
  set_has_xmlperiod();
  xmlperiod_ = value;
}

// optional int32 protectArch = 13 [default = 0];
inline bool MacroOptions::has_protectarch() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MacroOptions::set_has_protectarch() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MacroOptions::clear_has_protectarch() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MacroOptions::clear_protectarch() {
  protectarch_ = 0;
  clear_has_protectarch();
}
inline ::google::protobuf::int32 MacroOptions::protectarch() const {
  return protectarch_;
}
inline void MacroOptions::set_protectarch(::google::protobuf::int32 value) {
  set_has_protectarch();
  protectarch_ = value;
}

// optional bool midasBundling = 14 [default = false];
inline bool MacroOptions::has_midasbundling() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MacroOptions::set_has_midasbundling() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MacroOptions::clear_has_midasbundling() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MacroOptions::clear_midasbundling() {
  midasbundling_ = false;
  clear_has_midasbundling();
}
inline bool MacroOptions::midasbundling() const {
  return midasbundling_;
}
inline void MacroOptions::set_midasbundling(bool value) {
  set_has_midasbundling();
  midasbundling_ = value;
}

// optional int32 remoteThresh = 15 [default = 10];
inline bool MacroOptions::has_remotethresh() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MacroOptions::set_has_remotethresh() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MacroOptions::clear_has_remotethresh() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MacroOptions::clear_remotethresh() {
  remotethresh_ = 10;
  clear_has_remotethresh();
}
inline ::google::protobuf::int32 MacroOptions::remotethresh() const {
  return remotethresh_;
}
inline void MacroOptions::set_remotethresh(::google::protobuf::int32 value) {
  set_has_remotethresh();
  remotethresh_ = value;
}

// optional int32 psdMethod = 16 [default = -1];
inline bool MacroOptions::has_psdmethod() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MacroOptions::set_has_psdmethod() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MacroOptions::clear_has_psdmethod() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MacroOptions::clear_psdmethod() {
  psdmethod_ = -1;
  clear_has_psdmethod();
}
inline ::google::protobuf::int32 MacroOptions::psdmethod() const {
  return psdmethod_;
}
inline void MacroOptions::set_psdmethod(::google::protobuf::int32 value) {
  set_has_psdmethod();
  psdmethod_ = value;
}

// -------------------------------------------------------------------

// FastSearchConfig

// optional string msgName = 1 [default = "FAST_SEARCH_CONFIG"];
inline bool FastSearchConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FastSearchConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FastSearchConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FastSearchConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& FastSearchConfig::msgname() const {
  return *msgname_;
}
inline void FastSearchConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void FastSearchConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void FastSearchConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FastSearchConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* FastSearchConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void FastSearchConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional .falcon_app_msg.MacroOptions options = 2;
inline bool FastSearchConfig::has_options() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FastSearchConfig::set_has_options() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FastSearchConfig::clear_has_options() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FastSearchConfig::clear_options() {
  if (options_ != NULL) options_->::falcon_app_msg::MacroOptions::Clear();
  clear_has_options();
}
inline const ::falcon_app_msg::MacroOptions& FastSearchConfig::options() const {
  return options_ != NULL ? *options_ : *default_instance_->options_;
}
inline ::falcon_app_msg::MacroOptions* FastSearchConfig::mutable_options() {
  set_has_options();
  if (options_ == NULL) options_ = new ::falcon_app_msg::MacroOptions;
  return options_;
}
inline ::falcon_app_msg::MacroOptions* FastSearchConfig::release_options() {
  clear_has_options();
  ::falcon_app_msg::MacroOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline void FastSearchConfig::set_allocated_options(::falcon_app_msg::MacroOptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
}

// optional string charManSvc = 3;
inline bool FastSearchConfig::has_charmansvc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FastSearchConfig::set_has_charmansvc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FastSearchConfig::clear_has_charmansvc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FastSearchConfig::clear_charmansvc() {
  if (charmansvc_ != &::google::protobuf::internal::kEmptyString) {
    charmansvc_->clear();
  }
  clear_has_charmansvc();
}
inline const ::std::string& FastSearchConfig::charmansvc() const {
  return *charmansvc_;
}
inline void FastSearchConfig::set_charmansvc(const ::std::string& value) {
  set_has_charmansvc();
  if (charmansvc_ == &::google::protobuf::internal::kEmptyString) {
    charmansvc_ = new ::std::string;
  }
  charmansvc_->assign(value);
}
inline void FastSearchConfig::set_charmansvc(const char* value) {
  set_has_charmansvc();
  if (charmansvc_ == &::google::protobuf::internal::kEmptyString) {
    charmansvc_ = new ::std::string;
  }
  charmansvc_->assign(value);
}
inline void FastSearchConfig::set_charmansvc(const char* value, size_t size) {
  set_has_charmansvc();
  if (charmansvc_ == &::google::protobuf::internal::kEmptyString) {
    charmansvc_ = new ::std::string;
  }
  charmansvc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FastSearchConfig::mutable_charmansvc() {
  set_has_charmansvc();
  if (charmansvc_ == &::google::protobuf::internal::kEmptyString) {
    charmansvc_ = new ::std::string;
  }
  return charmansvc_;
}
inline ::std::string* FastSearchConfig::release_charmansvc() {
  clear_has_charmansvc();
  if (charmansvc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = charmansvc_;
    charmansvc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FastSearchConfig::set_allocated_charmansvc(::std::string* charmansvc) {
  if (charmansvc_ != &::google::protobuf::internal::kEmptyString) {
    delete charmansvc_;
  }
  if (charmansvc) {
    set_has_charmansvc();
    charmansvc_ = charmansvc;
  } else {
    clear_has_charmansvc();
    charmansvc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool enableRemoting = 4 [default = true];
inline bool FastSearchConfig::has_enableremoting() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FastSearchConfig::set_has_enableremoting() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FastSearchConfig::clear_has_enableremoting() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FastSearchConfig::clear_enableremoting() {
  enableremoting_ = true;
  clear_has_enableremoting();
}
inline bool FastSearchConfig::enableremoting() const {
  return enableremoting_;
}
inline void FastSearchConfig::set_enableremoting(bool value) {
  set_has_enableremoting();
  enableremoting_ = value;
}

// optional bool enableFastPSD = 5 [default = false];
inline bool FastSearchConfig::has_enablefastpsd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FastSearchConfig::set_has_enablefastpsd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FastSearchConfig::clear_has_enablefastpsd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FastSearchConfig::clear_enablefastpsd() {
  enablefastpsd_ = false;
  clear_has_enablefastpsd();
}
inline bool FastSearchConfig::enablefastpsd() const {
  return enablefastpsd_;
}
inline void FastSearchConfig::set_enablefastpsd(bool value) {
  set_has_enablefastpsd();
  enablefastpsd_ = value;
}

// optional int32 fastPSDPeriod = 6;
inline bool FastSearchConfig::has_fastpsdperiod() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FastSearchConfig::set_has_fastpsdperiod() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FastSearchConfig::clear_has_fastpsdperiod() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FastSearchConfig::clear_fastpsdperiod() {
  fastpsdperiod_ = 0;
  clear_has_fastpsdperiod();
}
inline ::google::protobuf::int32 FastSearchConfig::fastpsdperiod() const {
  return fastpsdperiod_;
}
inline void FastSearchConfig::set_fastpsdperiod(::google::protobuf::int32 value) {
  set_has_fastpsdperiod();
  fastpsdperiod_ = value;
}

// optional bool dbActive = 7;
inline bool FastSearchConfig::has_dbactive() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FastSearchConfig::set_has_dbactive() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FastSearchConfig::clear_has_dbactive() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FastSearchConfig::clear_dbactive() {
  dbactive_ = false;
  clear_has_dbactive();
}
inline bool FastSearchConfig::dbactive() const {
  return dbactive_;
}
inline void FastSearchConfig::set_dbactive(bool value) {
  set_has_dbactive();
  dbactive_ = value;
}

// optional string dbUser = 8;
inline bool FastSearchConfig::has_dbuser() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FastSearchConfig::set_has_dbuser() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FastSearchConfig::clear_has_dbuser() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FastSearchConfig::clear_dbuser() {
  if (dbuser_ != &::google::protobuf::internal::kEmptyString) {
    dbuser_->clear();
  }
  clear_has_dbuser();
}
inline const ::std::string& FastSearchConfig::dbuser() const {
  return *dbuser_;
}
inline void FastSearchConfig::set_dbuser(const ::std::string& value) {
  set_has_dbuser();
  if (dbuser_ == &::google::protobuf::internal::kEmptyString) {
    dbuser_ = new ::std::string;
  }
  dbuser_->assign(value);
}
inline void FastSearchConfig::set_dbuser(const char* value) {
  set_has_dbuser();
  if (dbuser_ == &::google::protobuf::internal::kEmptyString) {
    dbuser_ = new ::std::string;
  }
  dbuser_->assign(value);
}
inline void FastSearchConfig::set_dbuser(const char* value, size_t size) {
  set_has_dbuser();
  if (dbuser_ == &::google::protobuf::internal::kEmptyString) {
    dbuser_ = new ::std::string;
  }
  dbuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FastSearchConfig::mutable_dbuser() {
  set_has_dbuser();
  if (dbuser_ == &::google::protobuf::internal::kEmptyString) {
    dbuser_ = new ::std::string;
  }
  return dbuser_;
}
inline ::std::string* FastSearchConfig::release_dbuser() {
  clear_has_dbuser();
  if (dbuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dbuser_;
    dbuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FastSearchConfig::set_allocated_dbuser(::std::string* dbuser) {
  if (dbuser_ != &::google::protobuf::internal::kEmptyString) {
    delete dbuser_;
  }
  if (dbuser) {
    set_has_dbuser();
    dbuser_ = dbuser;
  } else {
    clear_has_dbuser();
    dbuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dbName = 9;
inline bool FastSearchConfig::has_dbname() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FastSearchConfig::set_has_dbname() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FastSearchConfig::clear_has_dbname() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FastSearchConfig::clear_dbname() {
  if (dbname_ != &::google::protobuf::internal::kEmptyString) {
    dbname_->clear();
  }
  clear_has_dbname();
}
inline const ::std::string& FastSearchConfig::dbname() const {
  return *dbname_;
}
inline void FastSearchConfig::set_dbname(const ::std::string& value) {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    dbname_ = new ::std::string;
  }
  dbname_->assign(value);
}
inline void FastSearchConfig::set_dbname(const char* value) {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    dbname_ = new ::std::string;
  }
  dbname_->assign(value);
}
inline void FastSearchConfig::set_dbname(const char* value, size_t size) {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    dbname_ = new ::std::string;
  }
  dbname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FastSearchConfig::mutable_dbname() {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    dbname_ = new ::std::string;
  }
  return dbname_;
}
inline ::std::string* FastSearchConfig::release_dbname() {
  clear_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dbname_;
    dbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FastSearchConfig::set_allocated_dbname(::std::string* dbname) {
  if (dbname_ != &::google::protobuf::internal::kEmptyString) {
    delete dbname_;
  }
  if (dbname) {
    set_has_dbname();
    dbname_ = dbname;
  } else {
    clear_has_dbname();
    dbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dbHost = 10;
inline bool FastSearchConfig::has_dbhost() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FastSearchConfig::set_has_dbhost() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FastSearchConfig::clear_has_dbhost() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FastSearchConfig::clear_dbhost() {
  if (dbhost_ != &::google::protobuf::internal::kEmptyString) {
    dbhost_->clear();
  }
  clear_has_dbhost();
}
inline const ::std::string& FastSearchConfig::dbhost() const {
  return *dbhost_;
}
inline void FastSearchConfig::set_dbhost(const ::std::string& value) {
  set_has_dbhost();
  if (dbhost_ == &::google::protobuf::internal::kEmptyString) {
    dbhost_ = new ::std::string;
  }
  dbhost_->assign(value);
}
inline void FastSearchConfig::set_dbhost(const char* value) {
  set_has_dbhost();
  if (dbhost_ == &::google::protobuf::internal::kEmptyString) {
    dbhost_ = new ::std::string;
  }
  dbhost_->assign(value);
}
inline void FastSearchConfig::set_dbhost(const char* value, size_t size) {
  set_has_dbhost();
  if (dbhost_ == &::google::protobuf::internal::kEmptyString) {
    dbhost_ = new ::std::string;
  }
  dbhost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FastSearchConfig::mutable_dbhost() {
  set_has_dbhost();
  if (dbhost_ == &::google::protobuf::internal::kEmptyString) {
    dbhost_ = new ::std::string;
  }
  return dbhost_;
}
inline ::std::string* FastSearchConfig::release_dbhost() {
  clear_has_dbhost();
  if (dbhost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dbhost_;
    dbhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FastSearchConfig::set_allocated_dbhost(::std::string* dbhost) {
  if (dbhost_ != &::google::protobuf::internal::kEmptyString) {
    delete dbhost_;
  }
  if (dbhost) {
    set_has_dbhost();
    dbhost_ = dbhost;
  } else {
    clear_has_dbhost();
    dbhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 archiveNumber = 11;
inline bool FastSearchConfig::has_archivenumber() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void FastSearchConfig::set_has_archivenumber() {
  _has_bits_[0] |= 0x00000400u;
}
inline void FastSearchConfig::clear_has_archivenumber() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void FastSearchConfig::clear_archivenumber() {
  archivenumber_ = 0;
  clear_has_archivenumber();
}
inline ::google::protobuf::int32 FastSearchConfig::archivenumber() const {
  return archivenumber_;
}
inline void FastSearchConfig::set_archivenumber(::google::protobuf::int32 value) {
  set_has_archivenumber();
  archivenumber_ = value;
}

// optional string archiveSize = 12;
inline bool FastSearchConfig::has_archivesize() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void FastSearchConfig::set_has_archivesize() {
  _has_bits_[0] |= 0x00000800u;
}
inline void FastSearchConfig::clear_has_archivesize() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void FastSearchConfig::clear_archivesize() {
  if (archivesize_ != &::google::protobuf::internal::kEmptyString) {
    archivesize_->clear();
  }
  clear_has_archivesize();
}
inline const ::std::string& FastSearchConfig::archivesize() const {
  return *archivesize_;
}
inline void FastSearchConfig::set_archivesize(const ::std::string& value) {
  set_has_archivesize();
  if (archivesize_ == &::google::protobuf::internal::kEmptyString) {
    archivesize_ = new ::std::string;
  }
  archivesize_->assign(value);
}
inline void FastSearchConfig::set_archivesize(const char* value) {
  set_has_archivesize();
  if (archivesize_ == &::google::protobuf::internal::kEmptyString) {
    archivesize_ = new ::std::string;
  }
  archivesize_->assign(value);
}
inline void FastSearchConfig::set_archivesize(const char* value, size_t size) {
  set_has_archivesize();
  if (archivesize_ == &::google::protobuf::internal::kEmptyString) {
    archivesize_ = new ::std::string;
  }
  archivesize_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FastSearchConfig::mutable_archivesize() {
  set_has_archivesize();
  if (archivesize_ == &::google::protobuf::internal::kEmptyString) {
    archivesize_ = new ::std::string;
  }
  return archivesize_;
}
inline ::std::string* FastSearchConfig::release_archivesize() {
  clear_has_archivesize();
  if (archivesize_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = archivesize_;
    archivesize_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FastSearchConfig::set_allocated_archivesize(::std::string* archivesize) {
  if (archivesize_ != &::google::protobuf::internal::kEmptyString) {
    delete archivesize_;
  }
  if (archivesize) {
    set_has_archivesize();
    archivesize_ = archivesize;
  } else {
    clear_has_archivesize();
    archivesize_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string geo_enabled = 13 [default = "OFF"];
inline bool FastSearchConfig::has_geo_enabled() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void FastSearchConfig::set_has_geo_enabled() {
  _has_bits_[0] |= 0x00001000u;
}
inline void FastSearchConfig::clear_has_geo_enabled() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void FastSearchConfig::clear_geo_enabled() {
  if (geo_enabled_ != _default_geo_enabled_) {
    geo_enabled_->assign(*_default_geo_enabled_);
  }
  clear_has_geo_enabled();
}
inline const ::std::string& FastSearchConfig::geo_enabled() const {
  return *geo_enabled_;
}
inline void FastSearchConfig::set_geo_enabled(const ::std::string& value) {
  set_has_geo_enabled();
  if (geo_enabled_ == _default_geo_enabled_) {
    geo_enabled_ = new ::std::string;
  }
  geo_enabled_->assign(value);
}
inline void FastSearchConfig::set_geo_enabled(const char* value) {
  set_has_geo_enabled();
  if (geo_enabled_ == _default_geo_enabled_) {
    geo_enabled_ = new ::std::string;
  }
  geo_enabled_->assign(value);
}
inline void FastSearchConfig::set_geo_enabled(const char* value, size_t size) {
  set_has_geo_enabled();
  if (geo_enabled_ == _default_geo_enabled_) {
    geo_enabled_ = new ::std::string;
  }
  geo_enabled_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FastSearchConfig::mutable_geo_enabled() {
  set_has_geo_enabled();
  if (geo_enabled_ == _default_geo_enabled_) {
    geo_enabled_ = new ::std::string(*_default_geo_enabled_);
  }
  return geo_enabled_;
}
inline ::std::string* FastSearchConfig::release_geo_enabled() {
  clear_has_geo_enabled();
  if (geo_enabled_ == _default_geo_enabled_) {
    return NULL;
  } else {
    ::std::string* temp = geo_enabled_;
    geo_enabled_ = const_cast< ::std::string*>(_default_geo_enabled_);
    return temp;
  }
}
inline void FastSearchConfig::set_allocated_geo_enabled(::std::string* geo_enabled) {
  if (geo_enabled_ != _default_geo_enabled_) {
    delete geo_enabled_;
  }
  if (geo_enabled) {
    set_has_geo_enabled();
    geo_enabled_ = geo_enabled;
  } else {
    clear_has_geo_enabled();
    geo_enabled_ = const_cast< ::std::string*>(_default_geo_enabled_);
  }
}

// optional string auto_process = 14 [default = "ON"];
inline bool FastSearchConfig::has_auto_process() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void FastSearchConfig::set_has_auto_process() {
  _has_bits_[0] |= 0x00002000u;
}
inline void FastSearchConfig::clear_has_auto_process() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void FastSearchConfig::clear_auto_process() {
  if (auto_process_ != _default_auto_process_) {
    auto_process_->assign(*_default_auto_process_);
  }
  clear_has_auto_process();
}
inline const ::std::string& FastSearchConfig::auto_process() const {
  return *auto_process_;
}
inline void FastSearchConfig::set_auto_process(const ::std::string& value) {
  set_has_auto_process();
  if (auto_process_ == _default_auto_process_) {
    auto_process_ = new ::std::string;
  }
  auto_process_->assign(value);
}
inline void FastSearchConfig::set_auto_process(const char* value) {
  set_has_auto_process();
  if (auto_process_ == _default_auto_process_) {
    auto_process_ = new ::std::string;
  }
  auto_process_->assign(value);
}
inline void FastSearchConfig::set_auto_process(const char* value, size_t size) {
  set_has_auto_process();
  if (auto_process_ == _default_auto_process_) {
    auto_process_ = new ::std::string;
  }
  auto_process_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FastSearchConfig::mutable_auto_process() {
  set_has_auto_process();
  if (auto_process_ == _default_auto_process_) {
    auto_process_ = new ::std::string(*_default_auto_process_);
  }
  return auto_process_;
}
inline ::std::string* FastSearchConfig::release_auto_process() {
  clear_has_auto_process();
  if (auto_process_ == _default_auto_process_) {
    return NULL;
  } else {
    ::std::string* temp = auto_process_;
    auto_process_ = const_cast< ::std::string*>(_default_auto_process_);
    return temp;
  }
}
inline void FastSearchConfig::set_allocated_auto_process(::std::string* auto_process) {
  if (auto_process_ != _default_auto_process_) {
    delete auto_process_;
  }
  if (auto_process) {
    set_has_auto_process();
    auto_process_ = auto_process;
  } else {
    clear_has_auto_process();
    auto_process_ = const_cast< ::std::string*>(_default_auto_process_);
  }
}

// -------------------------------------------------------------------

// FastSearchState

// optional string msgName = 1 [default = "FAST_SEARCH_STATE"];
inline bool FastSearchState::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FastSearchState::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FastSearchState::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FastSearchState::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& FastSearchState::msgname() const {
  return *msgname_;
}
inline void FastSearchState::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void FastSearchState::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void FastSearchState::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FastSearchState::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* FastSearchState::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void FastSearchState::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional bool search = 2 [default = true];
inline bool FastSearchState::has_search() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FastSearchState::set_has_search() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FastSearchState::clear_has_search() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FastSearchState::clear_search() {
  search_ = true;
  clear_has_search();
}
inline bool FastSearchState::search() const {
  return search_;
}
inline void FastSearchState::set_search(bool value) {
  set_has_search();
  search_ = value;
}

// -------------------------------------------------------------------

// NewFastScan

// optional string msgName = 1 [default = "NEW_FAST_SCAN"];
inline bool NewFastScan::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewFastScan::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewFastScan::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewFastScan::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& NewFastScan::msgname() const {
  return *msgname_;
}
inline void NewFastScan::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void NewFastScan::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void NewFastScan::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewFastScan::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* NewFastScan::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void NewFastScan::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional double j1970Time = 2;
inline bool NewFastScan::has_j1970time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewFastScan::set_has_j1970time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewFastScan::clear_has_j1970time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewFastScan::clear_j1970time() {
  j1970time_ = 0;
  clear_has_j1970time();
}
inline double NewFastScan::j1970time() const {
  return j1970time_;
}
inline void NewFastScan::set_j1970time(double value) {
  set_has_j1970time();
  j1970time_ = value;
}

// optional int32 channel = 3;
inline bool NewFastScan::has_channel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewFastScan::set_has_channel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewFastScan::clear_has_channel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewFastScan::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 NewFastScan::channel() const {
  return channel_;
}
inline void NewFastScan::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// -------------------------------------------------------------------

// MissionManConfig

// optional string msgName = 1 [default = "MISSION_MAN_CONFIG"];
inline bool MissionManConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MissionManConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MissionManConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MissionManConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& MissionManConfig::msgname() const {
  return *msgname_;
}
inline void MissionManConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void MissionManConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void MissionManConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MissionManConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* MissionManConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void MissionManConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string dbHost = 2;
inline bool MissionManConfig::has_dbhost() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MissionManConfig::set_has_dbhost() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MissionManConfig::clear_has_dbhost() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MissionManConfig::clear_dbhost() {
  if (dbhost_ != &::google::protobuf::internal::kEmptyString) {
    dbhost_->clear();
  }
  clear_has_dbhost();
}
inline const ::std::string& MissionManConfig::dbhost() const {
  return *dbhost_;
}
inline void MissionManConfig::set_dbhost(const ::std::string& value) {
  set_has_dbhost();
  if (dbhost_ == &::google::protobuf::internal::kEmptyString) {
    dbhost_ = new ::std::string;
  }
  dbhost_->assign(value);
}
inline void MissionManConfig::set_dbhost(const char* value) {
  set_has_dbhost();
  if (dbhost_ == &::google::protobuf::internal::kEmptyString) {
    dbhost_ = new ::std::string;
  }
  dbhost_->assign(value);
}
inline void MissionManConfig::set_dbhost(const char* value, size_t size) {
  set_has_dbhost();
  if (dbhost_ == &::google::protobuf::internal::kEmptyString) {
    dbhost_ = new ::std::string;
  }
  dbhost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MissionManConfig::mutable_dbhost() {
  set_has_dbhost();
  if (dbhost_ == &::google::protobuf::internal::kEmptyString) {
    dbhost_ = new ::std::string;
  }
  return dbhost_;
}
inline ::std::string* MissionManConfig::release_dbhost() {
  clear_has_dbhost();
  if (dbhost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dbhost_;
    dbhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MissionManConfig::set_allocated_dbhost(::std::string* dbhost) {
  if (dbhost_ != &::google::protobuf::internal::kEmptyString) {
    delete dbhost_;
  }
  if (dbhost) {
    set_has_dbhost();
    dbhost_ = dbhost;
  } else {
    clear_has_dbhost();
    dbhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dbUser = 3;
inline bool MissionManConfig::has_dbuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MissionManConfig::set_has_dbuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MissionManConfig::clear_has_dbuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MissionManConfig::clear_dbuser() {
  if (dbuser_ != &::google::protobuf::internal::kEmptyString) {
    dbuser_->clear();
  }
  clear_has_dbuser();
}
inline const ::std::string& MissionManConfig::dbuser() const {
  return *dbuser_;
}
inline void MissionManConfig::set_dbuser(const ::std::string& value) {
  set_has_dbuser();
  if (dbuser_ == &::google::protobuf::internal::kEmptyString) {
    dbuser_ = new ::std::string;
  }
  dbuser_->assign(value);
}
inline void MissionManConfig::set_dbuser(const char* value) {
  set_has_dbuser();
  if (dbuser_ == &::google::protobuf::internal::kEmptyString) {
    dbuser_ = new ::std::string;
  }
  dbuser_->assign(value);
}
inline void MissionManConfig::set_dbuser(const char* value, size_t size) {
  set_has_dbuser();
  if (dbuser_ == &::google::protobuf::internal::kEmptyString) {
    dbuser_ = new ::std::string;
  }
  dbuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MissionManConfig::mutable_dbuser() {
  set_has_dbuser();
  if (dbuser_ == &::google::protobuf::internal::kEmptyString) {
    dbuser_ = new ::std::string;
  }
  return dbuser_;
}
inline ::std::string* MissionManConfig::release_dbuser() {
  clear_has_dbuser();
  if (dbuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dbuser_;
    dbuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MissionManConfig::set_allocated_dbuser(::std::string* dbuser) {
  if (dbuser_ != &::google::protobuf::internal::kEmptyString) {
    delete dbuser_;
  }
  if (dbuser) {
    set_has_dbuser();
    dbuser_ = dbuser;
  } else {
    clear_has_dbuser();
    dbuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dbName = 4;
inline bool MissionManConfig::has_dbname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MissionManConfig::set_has_dbname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MissionManConfig::clear_has_dbname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MissionManConfig::clear_dbname() {
  if (dbname_ != &::google::protobuf::internal::kEmptyString) {
    dbname_->clear();
  }
  clear_has_dbname();
}
inline const ::std::string& MissionManConfig::dbname() const {
  return *dbname_;
}
inline void MissionManConfig::set_dbname(const ::std::string& value) {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    dbname_ = new ::std::string;
  }
  dbname_->assign(value);
}
inline void MissionManConfig::set_dbname(const char* value) {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    dbname_ = new ::std::string;
  }
  dbname_->assign(value);
}
inline void MissionManConfig::set_dbname(const char* value, size_t size) {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    dbname_ = new ::std::string;
  }
  dbname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MissionManConfig::mutable_dbname() {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    dbname_ = new ::std::string;
  }
  return dbname_;
}
inline ::std::string* MissionManConfig::release_dbname() {
  clear_has_dbname();
  if (dbname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dbname_;
    dbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MissionManConfig::set_allocated_dbname(::std::string* dbname) {
  if (dbname_ != &::google::protobuf::internal::kEmptyString) {
    delete dbname_;
  }
  if (dbname) {
    set_has_dbname();
    dbname_ = dbname;
  } else {
    clear_has_dbname();
    dbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 dbPort = 5;
inline bool MissionManConfig::has_dbport() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MissionManConfig::set_has_dbport() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MissionManConfig::clear_has_dbport() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MissionManConfig::clear_dbport() {
  dbport_ = 0;
  clear_has_dbport();
}
inline ::google::protobuf::int32 MissionManConfig::dbport() const {
  return dbport_;
}
inline void MissionManConfig::set_dbport(::google::protobuf::int32 value) {
  set_has_dbport();
  dbport_ = value;
}

// optional int32 starttunernum = 6 [default = 1];
inline bool MissionManConfig::has_starttunernum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MissionManConfig::set_has_starttunernum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MissionManConfig::clear_has_starttunernum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MissionManConfig::clear_starttunernum() {
  starttunernum_ = 1;
  clear_has_starttunernum();
}
inline ::google::protobuf::int32 MissionManConfig::starttunernum() const {
  return starttunernum_;
}
inline void MissionManConfig::set_starttunernum(::google::protobuf::int32 value) {
  set_has_starttunernum();
  starttunernum_ = value;
}

// optional int32 numarcs = 7;
inline bool MissionManConfig::has_numarcs() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MissionManConfig::set_has_numarcs() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MissionManConfig::clear_has_numarcs() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MissionManConfig::clear_numarcs() {
  numarcs_ = 0;
  clear_has_numarcs();
}
inline ::google::protobuf::int32 MissionManConfig::numarcs() const {
  return numarcs_;
}
inline void MissionManConfig::set_numarcs(::google::protobuf::int32 value) {
  set_has_numarcs();
  numarcs_ = value;
}

// optional string arcspread = 8;
inline bool MissionManConfig::has_arcspread() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MissionManConfig::set_has_arcspread() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MissionManConfig::clear_has_arcspread() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MissionManConfig::clear_arcspread() {
  if (arcspread_ != &::google::protobuf::internal::kEmptyString) {
    arcspread_->clear();
  }
  clear_has_arcspread();
}
inline const ::std::string& MissionManConfig::arcspread() const {
  return *arcspread_;
}
inline void MissionManConfig::set_arcspread(const ::std::string& value) {
  set_has_arcspread();
  if (arcspread_ == &::google::protobuf::internal::kEmptyString) {
    arcspread_ = new ::std::string;
  }
  arcspread_->assign(value);
}
inline void MissionManConfig::set_arcspread(const char* value) {
  set_has_arcspread();
  if (arcspread_ == &::google::protobuf::internal::kEmptyString) {
    arcspread_ = new ::std::string;
  }
  arcspread_->assign(value);
}
inline void MissionManConfig::set_arcspread(const char* value, size_t size) {
  set_has_arcspread();
  if (arcspread_ == &::google::protobuf::internal::kEmptyString) {
    arcspread_ = new ::std::string;
  }
  arcspread_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MissionManConfig::mutable_arcspread() {
  set_has_arcspread();
  if (arcspread_ == &::google::protobuf::internal::kEmptyString) {
    arcspread_ = new ::std::string;
  }
  return arcspread_;
}
inline ::std::string* MissionManConfig::release_arcspread() {
  clear_has_arcspread();
  if (arcspread_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = arcspread_;
    arcspread_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MissionManConfig::set_allocated_arcspread(::std::string* arcspread) {
  if (arcspread_ != &::google::protobuf::internal::kEmptyString) {
    delete arcspread_;
  }
  if (arcspread) {
    set_has_arcspread();
    arcspread_ = arcspread;
  } else {
    clear_has_arcspread();
    arcspread_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ProcMacroConfig

// optional string msgName = 1 [default = "PROC_MACRO_CONFIG"];
inline bool ProcMacroConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProcMacroConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProcMacroConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProcMacroConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ProcMacroConfig::msgname() const {
  return *msgname_;
}
inline void ProcMacroConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ProcMacroConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ProcMacroConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcMacroConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ProcMacroConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ProcMacroConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional .falcon_app_msg.MacroOptions options = 2;
inline bool ProcMacroConfig::has_options() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProcMacroConfig::set_has_options() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProcMacroConfig::clear_has_options() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProcMacroConfig::clear_options() {
  if (options_ != NULL) options_->::falcon_app_msg::MacroOptions::Clear();
  clear_has_options();
}
inline const ::falcon_app_msg::MacroOptions& ProcMacroConfig::options() const {
  return options_ != NULL ? *options_ : *default_instance_->options_;
}
inline ::falcon_app_msg::MacroOptions* ProcMacroConfig::mutable_options() {
  set_has_options();
  if (options_ == NULL) options_ = new ::falcon_app_msg::MacroOptions;
  return options_;
}
inline ::falcon_app_msg::MacroOptions* ProcMacroConfig::release_options() {
  clear_has_options();
  ::falcon_app_msg::MacroOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline void ProcMacroConfig::set_allocated_options(::falcon_app_msg::MacroOptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
}

// optional .falcon_app_msg.ProcMacroConfig.SystemType sysType = 3 [default = SYSTEM_TYPE_RF];
inline bool ProcMacroConfig::has_systype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProcMacroConfig::set_has_systype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProcMacroConfig::clear_has_systype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProcMacroConfig::clear_systype() {
  systype_ = 2;
  clear_has_systype();
}
inline ::falcon_app_msg::ProcMacroConfig_SystemType ProcMacroConfig::systype() const {
  return static_cast< ::falcon_app_msg::ProcMacroConfig_SystemType >(systype_);
}
inline void ProcMacroConfig::set_systype(::falcon_app_msg::ProcMacroConfig_SystemType value) {
  assert(::falcon_app_msg::ProcMacroConfig_SystemType_IsValid(value));
  set_has_systype();
  systype_ = value;
}

// optional bool enableIC = 4 [default = false];
inline bool ProcMacroConfig::has_enableic() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProcMacroConfig::set_has_enableic() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProcMacroConfig::clear_has_enableic() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProcMacroConfig::clear_enableic() {
  enableic_ = false;
  clear_has_enableic();
}
inline bool ProcMacroConfig::enableic() const {
  return enableic_;
}
inline void ProcMacroConfig::set_enableic(bool value) {
  set_has_enableic();
  enableic_ = value;
}

// optional int32 timeout = 5 [default = 40];
inline bool ProcMacroConfig::has_timeout() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProcMacroConfig::set_has_timeout() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProcMacroConfig::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProcMacroConfig::clear_timeout() {
  timeout_ = 40;
  clear_has_timeout();
}
inline ::google::protobuf::int32 ProcMacroConfig::timeout() const {
  return timeout_;
}
inline void ProcMacroConfig::set_timeout(::google::protobuf::int32 value) {
  set_has_timeout();
  timeout_ = value;
}

// optional int32 slaveTimeout = 6 [default = 300];
inline bool ProcMacroConfig::has_slavetimeout() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProcMacroConfig::set_has_slavetimeout() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProcMacroConfig::clear_has_slavetimeout() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProcMacroConfig::clear_slavetimeout() {
  slavetimeout_ = 300;
  clear_has_slavetimeout();
}
inline ::google::protobuf::int32 ProcMacroConfig::slavetimeout() const {
  return slavetimeout_;
}
inline void ProcMacroConfig::set_slavetimeout(::google::protobuf::int32 value) {
  set_has_slavetimeout();
  slavetimeout_ = value;
}

// optional string extraForkSvc = 7;
inline bool ProcMacroConfig::has_extraforksvc() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ProcMacroConfig::set_has_extraforksvc() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ProcMacroConfig::clear_has_extraforksvc() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ProcMacroConfig::clear_extraforksvc() {
  if (extraforksvc_ != &::google::protobuf::internal::kEmptyString) {
    extraforksvc_->clear();
  }
  clear_has_extraforksvc();
}
inline const ::std::string& ProcMacroConfig::extraforksvc() const {
  return *extraforksvc_;
}
inline void ProcMacroConfig::set_extraforksvc(const ::std::string& value) {
  set_has_extraforksvc();
  if (extraforksvc_ == &::google::protobuf::internal::kEmptyString) {
    extraforksvc_ = new ::std::string;
  }
  extraforksvc_->assign(value);
}
inline void ProcMacroConfig::set_extraforksvc(const char* value) {
  set_has_extraforksvc();
  if (extraforksvc_ == &::google::protobuf::internal::kEmptyString) {
    extraforksvc_ = new ::std::string;
  }
  extraforksvc_->assign(value);
}
inline void ProcMacroConfig::set_extraforksvc(const char* value, size_t size) {
  set_has_extraforksvc();
  if (extraforksvc_ == &::google::protobuf::internal::kEmptyString) {
    extraforksvc_ = new ::std::string;
  }
  extraforksvc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcMacroConfig::mutable_extraforksvc() {
  set_has_extraforksvc();
  if (extraforksvc_ == &::google::protobuf::internal::kEmptyString) {
    extraforksvc_ = new ::std::string;
  }
  return extraforksvc_;
}
inline ::std::string* ProcMacroConfig::release_extraforksvc() {
  clear_has_extraforksvc();
  if (extraforksvc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extraforksvc_;
    extraforksvc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProcMacroConfig::set_allocated_extraforksvc(::std::string* extraforksvc) {
  if (extraforksvc_ != &::google::protobuf::internal::kEmptyString) {
    delete extraforksvc_;
  }
  if (extraforksvc) {
    set_has_extraforksvc();
    extraforksvc_ = extraforksvc;
  } else {
    clear_has_extraforksvc();
    extraforksvc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .falcon_common_msg.ExtraForkChannel extraForkChan = 8;
inline bool ProcMacroConfig::has_extraforkchan() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ProcMacroConfig::set_has_extraforkchan() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ProcMacroConfig::clear_has_extraforkchan() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ProcMacroConfig::clear_extraforkchan() {
  if (extraforkchan_ != NULL) extraforkchan_->::falcon_common_msg::ExtraForkChannel::Clear();
  clear_has_extraforkchan();
}
inline const ::falcon_common_msg::ExtraForkChannel& ProcMacroConfig::extraforkchan() const {
  return extraforkchan_ != NULL ? *extraforkchan_ : *default_instance_->extraforkchan_;
}
inline ::falcon_common_msg::ExtraForkChannel* ProcMacroConfig::mutable_extraforkchan() {
  set_has_extraforkchan();
  if (extraforkchan_ == NULL) extraforkchan_ = new ::falcon_common_msg::ExtraForkChannel;
  return extraforkchan_;
}
inline ::falcon_common_msg::ExtraForkChannel* ProcMacroConfig::release_extraforkchan() {
  clear_has_extraforkchan();
  ::falcon_common_msg::ExtraForkChannel* temp = extraforkchan_;
  extraforkchan_ = NULL;
  return temp;
}
inline void ProcMacroConfig::set_allocated_extraforkchan(::falcon_common_msg::ExtraForkChannel* extraforkchan) {
  delete extraforkchan_;
  extraforkchan_ = extraforkchan;
  if (extraforkchan) {
    set_has_extraforkchan();
  } else {
    clear_has_extraforkchan();
  }
}

// optional bool healthRxPort = 9 [default = false];
inline bool ProcMacroConfig::has_healthrxport() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ProcMacroConfig::set_has_healthrxport() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ProcMacroConfig::clear_has_healthrxport() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ProcMacroConfig::clear_healthrxport() {
  healthrxport_ = false;
  clear_has_healthrxport();
}
inline bool ProcMacroConfig::healthrxport() const {
  return healthrxport_;
}
inline void ProcMacroConfig::set_healthrxport(bool value) {
  set_has_healthrxport();
  healthrxport_ = value;
}

// optional string geo_enabled = 10 [default = "OFF"];
inline bool ProcMacroConfig::has_geo_enabled() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ProcMacroConfig::set_has_geo_enabled() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ProcMacroConfig::clear_has_geo_enabled() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ProcMacroConfig::clear_geo_enabled() {
  if (geo_enabled_ != _default_geo_enabled_) {
    geo_enabled_->assign(*_default_geo_enabled_);
  }
  clear_has_geo_enabled();
}
inline const ::std::string& ProcMacroConfig::geo_enabled() const {
  return *geo_enabled_;
}
inline void ProcMacroConfig::set_geo_enabled(const ::std::string& value) {
  set_has_geo_enabled();
  if (geo_enabled_ == _default_geo_enabled_) {
    geo_enabled_ = new ::std::string;
  }
  geo_enabled_->assign(value);
}
inline void ProcMacroConfig::set_geo_enabled(const char* value) {
  set_has_geo_enabled();
  if (geo_enabled_ == _default_geo_enabled_) {
    geo_enabled_ = new ::std::string;
  }
  geo_enabled_->assign(value);
}
inline void ProcMacroConfig::set_geo_enabled(const char* value, size_t size) {
  set_has_geo_enabled();
  if (geo_enabled_ == _default_geo_enabled_) {
    geo_enabled_ = new ::std::string;
  }
  geo_enabled_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcMacroConfig::mutable_geo_enabled() {
  set_has_geo_enabled();
  if (geo_enabled_ == _default_geo_enabled_) {
    geo_enabled_ = new ::std::string(*_default_geo_enabled_);
  }
  return geo_enabled_;
}
inline ::std::string* ProcMacroConfig::release_geo_enabled() {
  clear_has_geo_enabled();
  if (geo_enabled_ == _default_geo_enabled_) {
    return NULL;
  } else {
    ::std::string* temp = geo_enabled_;
    geo_enabled_ = const_cast< ::std::string*>(_default_geo_enabled_);
    return temp;
  }
}
inline void ProcMacroConfig::set_allocated_geo_enabled(::std::string* geo_enabled) {
  if (geo_enabled_ != _default_geo_enabled_) {
    delete geo_enabled_;
  }
  if (geo_enabled) {
    set_has_geo_enabled();
    geo_enabled_ = geo_enabled;
  } else {
    clear_has_geo_enabled();
    geo_enabled_ = const_cast< ::std::string*>(_default_geo_enabled_);
  }
}

// repeated string soiNums = 11;
inline int ProcMacroConfig::soinums_size() const {
  return soinums_.size();
}
inline void ProcMacroConfig::clear_soinums() {
  soinums_.Clear();
}
inline const ::std::string& ProcMacroConfig::soinums(int index) const {
  return soinums_.Get(index);
}
inline ::std::string* ProcMacroConfig::mutable_soinums(int index) {
  return soinums_.Mutable(index);
}
inline void ProcMacroConfig::set_soinums(int index, const ::std::string& value) {
  soinums_.Mutable(index)->assign(value);
}
inline void ProcMacroConfig::set_soinums(int index, const char* value) {
  soinums_.Mutable(index)->assign(value);
}
inline void ProcMacroConfig::set_soinums(int index, const char* value, size_t size) {
  soinums_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcMacroConfig::add_soinums() {
  return soinums_.Add();
}
inline void ProcMacroConfig::add_soinums(const ::std::string& value) {
  soinums_.Add()->assign(value);
}
inline void ProcMacroConfig::add_soinums(const char* value) {
  soinums_.Add()->assign(value);
}
inline void ProcMacroConfig::add_soinums(const char* value, size_t size) {
  soinums_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ProcMacroConfig::soinums() const {
  return soinums_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ProcMacroConfig::mutable_soinums() {
  return &soinums_;
}

// repeated string associatedSOIs = 12;
inline int ProcMacroConfig::associatedsois_size() const {
  return associatedsois_.size();
}
inline void ProcMacroConfig::clear_associatedsois() {
  associatedsois_.Clear();
}
inline const ::std::string& ProcMacroConfig::associatedsois(int index) const {
  return associatedsois_.Get(index);
}
inline ::std::string* ProcMacroConfig::mutable_associatedsois(int index) {
  return associatedsois_.Mutable(index);
}
inline void ProcMacroConfig::set_associatedsois(int index, const ::std::string& value) {
  associatedsois_.Mutable(index)->assign(value);
}
inline void ProcMacroConfig::set_associatedsois(int index, const char* value) {
  associatedsois_.Mutable(index)->assign(value);
}
inline void ProcMacroConfig::set_associatedsois(int index, const char* value, size_t size) {
  associatedsois_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcMacroConfig::add_associatedsois() {
  return associatedsois_.Add();
}
inline void ProcMacroConfig::add_associatedsois(const ::std::string& value) {
  associatedsois_.Add()->assign(value);
}
inline void ProcMacroConfig::add_associatedsois(const char* value) {
  associatedsois_.Add()->assign(value);
}
inline void ProcMacroConfig::add_associatedsois(const char* value, size_t size) {
  associatedsois_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ProcMacroConfig::associatedsois() const {
  return associatedsois_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ProcMacroConfig::mutable_associatedsois() {
  return &associatedsois_;
}

// optional int32 assocRepeatSec = 13 [default = 1800];
inline bool ProcMacroConfig::has_assocrepeatsec() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ProcMacroConfig::set_has_assocrepeatsec() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ProcMacroConfig::clear_has_assocrepeatsec() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ProcMacroConfig::clear_assocrepeatsec() {
  assocrepeatsec_ = 1800;
  clear_has_assocrepeatsec();
}
inline ::google::protobuf::int32 ProcMacroConfig::assocrepeatsec() const {
  return assocrepeatsec_;
}
inline void ProcMacroConfig::set_assocrepeatsec(::google::protobuf::int32 value) {
  set_has_assocrepeatsec();
  assocrepeatsec_ = value;
}

// optional bool procTimeoutEnabled = 14 [default = false];
inline bool ProcMacroConfig::has_proctimeoutenabled() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ProcMacroConfig::set_has_proctimeoutenabled() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ProcMacroConfig::clear_has_proctimeoutenabled() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ProcMacroConfig::clear_proctimeoutenabled() {
  proctimeoutenabled_ = false;
  clear_has_proctimeoutenabled();
}
inline bool ProcMacroConfig::proctimeoutenabled() const {
  return proctimeoutenabled_;
}
inline void ProcMacroConfig::set_proctimeoutenabled(bool value) {
  set_has_proctimeoutenabled();
  proctimeoutenabled_ = value;
}

// optional int32 procTime = 15 [default = -1];
inline bool ProcMacroConfig::has_proctime() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ProcMacroConfig::set_has_proctime() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ProcMacroConfig::clear_has_proctime() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ProcMacroConfig::clear_proctime() {
  proctime_ = -1;
  clear_has_proctime();
}
inline ::google::protobuf::int32 ProcMacroConfig::proctime() const {
  return proctime_;
}
inline void ProcMacroConfig::set_proctime(::google::protobuf::int32 value) {
  set_has_proctime();
  proctime_ = value;
}

// optional int32 blacklistBW = 16;
inline bool ProcMacroConfig::has_blacklistbw() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ProcMacroConfig::set_has_blacklistbw() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ProcMacroConfig::clear_has_blacklistbw() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ProcMacroConfig::clear_blacklistbw() {
  blacklistbw_ = 0;
  clear_has_blacklistbw();
}
inline ::google::protobuf::int32 ProcMacroConfig::blacklistbw() const {
  return blacklistbw_;
}
inline void ProcMacroConfig::set_blacklistbw(::google::protobuf::int32 value) {
  set_has_blacklistbw();
  blacklistbw_ = value;
}

// optional int32 blacklistTime = 17 [default = 0];
inline bool ProcMacroConfig::has_blacklisttime() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ProcMacroConfig::set_has_blacklisttime() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ProcMacroConfig::clear_has_blacklisttime() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ProcMacroConfig::clear_blacklisttime() {
  blacklisttime_ = 0;
  clear_has_blacklisttime();
}
inline ::google::protobuf::int32 ProcMacroConfig::blacklisttime() const {
  return blacklisttime_;
}
inline void ProcMacroConfig::set_blacklisttime(::google::protobuf::int32 value) {
  set_has_blacklisttime();
  blacklisttime_ = value;
}

// optional int32 initialTimeout = 18 [default = 600];
inline bool ProcMacroConfig::has_initialtimeout() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ProcMacroConfig::set_has_initialtimeout() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ProcMacroConfig::clear_has_initialtimeout() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ProcMacroConfig::clear_initialtimeout() {
  initialtimeout_ = 600;
  clear_has_initialtimeout();
}
inline ::google::protobuf::int32 ProcMacroConfig::initialtimeout() const {
  return initialtimeout_;
}
inline void ProcMacroConfig::set_initialtimeout(::google::protobuf::int32 value) {
  set_has_initialtimeout();
  initialtimeout_ = value;
}

// -------------------------------------------------------------------

// WidebandRecordConfig

// optional string msgName = 1 [default = "WIDEBAND_RECORD_CONFIG"];
inline bool WidebandRecordConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WidebandRecordConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WidebandRecordConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WidebandRecordConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& WidebandRecordConfig::msgname() const {
  return *msgname_;
}
inline void WidebandRecordConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void WidebandRecordConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void WidebandRecordConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WidebandRecordConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* WidebandRecordConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void WidebandRecordConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional .falcon_app_msg.MacroOptions options = 2;
inline bool WidebandRecordConfig::has_options() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WidebandRecordConfig::set_has_options() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WidebandRecordConfig::clear_has_options() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WidebandRecordConfig::clear_options() {
  if (options_ != NULL) options_->::falcon_app_msg::MacroOptions::Clear();
  clear_has_options();
}
inline const ::falcon_app_msg::MacroOptions& WidebandRecordConfig::options() const {
  return options_ != NULL ? *options_ : *default_instance_->options_;
}
inline ::falcon_app_msg::MacroOptions* WidebandRecordConfig::mutable_options() {
  set_has_options();
  if (options_ == NULL) options_ = new ::falcon_app_msg::MacroOptions;
  return options_;
}
inline ::falcon_app_msg::MacroOptions* WidebandRecordConfig::release_options() {
  clear_has_options();
  ::falcon_app_msg::MacroOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline void WidebandRecordConfig::set_allocated_options(::falcon_app_msg::MacroOptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
}

// optional bool healthRxPort = 3 [default = false];
inline bool WidebandRecordConfig::has_healthrxport() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WidebandRecordConfig::set_has_healthrxport() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WidebandRecordConfig::clear_has_healthrxport() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WidebandRecordConfig::clear_healthrxport() {
  healthrxport_ = false;
  clear_has_healthrxport();
}
inline bool WidebandRecordConfig::healthrxport() const {
  return healthrxport_;
}
inline void WidebandRecordConfig::set_healthrxport(bool value) {
  set_has_healthrxport();
  healthrxport_ = value;
}

// optional string geo_enabled = 4 [default = "OFF"];
inline bool WidebandRecordConfig::has_geo_enabled() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WidebandRecordConfig::set_has_geo_enabled() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WidebandRecordConfig::clear_has_geo_enabled() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WidebandRecordConfig::clear_geo_enabled() {
  if (geo_enabled_ != _default_geo_enabled_) {
    geo_enabled_->assign(*_default_geo_enabled_);
  }
  clear_has_geo_enabled();
}
inline const ::std::string& WidebandRecordConfig::geo_enabled() const {
  return *geo_enabled_;
}
inline void WidebandRecordConfig::set_geo_enabled(const ::std::string& value) {
  set_has_geo_enabled();
  if (geo_enabled_ == _default_geo_enabled_) {
    geo_enabled_ = new ::std::string;
  }
  geo_enabled_->assign(value);
}
inline void WidebandRecordConfig::set_geo_enabled(const char* value) {
  set_has_geo_enabled();
  if (geo_enabled_ == _default_geo_enabled_) {
    geo_enabled_ = new ::std::string;
  }
  geo_enabled_->assign(value);
}
inline void WidebandRecordConfig::set_geo_enabled(const char* value, size_t size) {
  set_has_geo_enabled();
  if (geo_enabled_ == _default_geo_enabled_) {
    geo_enabled_ = new ::std::string;
  }
  geo_enabled_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WidebandRecordConfig::mutable_geo_enabled() {
  set_has_geo_enabled();
  if (geo_enabled_ == _default_geo_enabled_) {
    geo_enabled_ = new ::std::string(*_default_geo_enabled_);
  }
  return geo_enabled_;
}
inline ::std::string* WidebandRecordConfig::release_geo_enabled() {
  clear_has_geo_enabled();
  if (geo_enabled_ == _default_geo_enabled_) {
    return NULL;
  } else {
    ::std::string* temp = geo_enabled_;
    geo_enabled_ = const_cast< ::std::string*>(_default_geo_enabled_);
    return temp;
  }
}
inline void WidebandRecordConfig::set_allocated_geo_enabled(::std::string* geo_enabled) {
  if (geo_enabled_ != _default_geo_enabled_) {
    delete geo_enabled_;
  }
  if (geo_enabled) {
    set_has_geo_enabled();
    geo_enabled_ = geo_enabled;
  } else {
    clear_has_geo_enabled();
    geo_enabled_ = const_cast< ::std::string*>(_default_geo_enabled_);
  }
}

// -------------------------------------------------------------------

// HealthCheckConfig

// optional string msgName = 1 [default = "HEALTH_CHECK_CONFIG"];
inline bool HealthCheckConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HealthCheckConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HealthCheckConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HealthCheckConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& HealthCheckConfig::msgname() const {
  return *msgname_;
}
inline void HealthCheckConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void HealthCheckConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void HealthCheckConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HealthCheckConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* HealthCheckConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void HealthCheckConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional .falcon_app_msg.MacroOptions options = 2;
inline bool HealthCheckConfig::has_options() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HealthCheckConfig::set_has_options() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HealthCheckConfig::clear_has_options() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HealthCheckConfig::clear_options() {
  if (options_ != NULL) options_->::falcon_app_msg::MacroOptions::Clear();
  clear_has_options();
}
inline const ::falcon_app_msg::MacroOptions& HealthCheckConfig::options() const {
  return options_ != NULL ? *options_ : *default_instance_->options_;
}
inline ::falcon_app_msg::MacroOptions* HealthCheckConfig::mutable_options() {
  set_has_options();
  if (options_ == NULL) options_ = new ::falcon_app_msg::MacroOptions;
  return options_;
}
inline ::falcon_app_msg::MacroOptions* HealthCheckConfig::release_options() {
  clear_has_options();
  ::falcon_app_msg::MacroOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline void HealthCheckConfig::set_allocated_options(::falcon_app_msg::MacroOptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
}

// -------------------------------------------------------------------

// MmsHealthConfig

// optional string msgName = 1 [default = "MMS_HEALTH_CONFIG"];
inline bool MmsHealthConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MmsHealthConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MmsHealthConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MmsHealthConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& MmsHealthConfig::msgname() const {
  return *msgname_;
}
inline void MmsHealthConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void MmsHealthConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void MmsHealthConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MmsHealthConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* MmsHealthConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void MmsHealthConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional .falcon_app_msg.MacroOptions options = 2;
inline bool MmsHealthConfig::has_options() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MmsHealthConfig::set_has_options() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MmsHealthConfig::clear_has_options() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MmsHealthConfig::clear_options() {
  if (options_ != NULL) options_->::falcon_app_msg::MacroOptions::Clear();
  clear_has_options();
}
inline const ::falcon_app_msg::MacroOptions& MmsHealthConfig::options() const {
  return options_ != NULL ? *options_ : *default_instance_->options_;
}
inline ::falcon_app_msg::MacroOptions* MmsHealthConfig::mutable_options() {
  set_has_options();
  if (options_ == NULL) options_ = new ::falcon_app_msg::MacroOptions;
  return options_;
}
inline ::falcon_app_msg::MacroOptions* MmsHealthConfig::release_options() {
  clear_has_options();
  ::falcon_app_msg::MacroOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline void MmsHealthConfig::set_allocated_options(::falcon_app_msg::MacroOptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
}

// -------------------------------------------------------------------

// NoiseTestConfig

// optional string msgName = 1 [default = "NOISE_TEST_CONFIG"];
inline bool NoiseTestConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NoiseTestConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NoiseTestConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NoiseTestConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& NoiseTestConfig::msgname() const {
  return *msgname_;
}
inline void NoiseTestConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void NoiseTestConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void NoiseTestConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NoiseTestConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* NoiseTestConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void NoiseTestConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional .falcon_app_msg.MacroOptions options = 2;
inline bool NoiseTestConfig::has_options() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NoiseTestConfig::set_has_options() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NoiseTestConfig::clear_has_options() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NoiseTestConfig::clear_options() {
  if (options_ != NULL) options_->::falcon_app_msg::MacroOptions::Clear();
  clear_has_options();
}
inline const ::falcon_app_msg::MacroOptions& NoiseTestConfig::options() const {
  return options_ != NULL ? *options_ : *default_instance_->options_;
}
inline ::falcon_app_msg::MacroOptions* NoiseTestConfig::mutable_options() {
  set_has_options();
  if (options_ == NULL) options_ = new ::falcon_app_msg::MacroOptions;
  return options_;
}
inline ::falcon_app_msg::MacroOptions* NoiseTestConfig::release_options() {
  clear_has_options();
  ::falcon_app_msg::MacroOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline void NoiseTestConfig::set_allocated_options(::falcon_app_msg::MacroOptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
}

// -------------------------------------------------------------------

// GpsHealthConfig

// optional string msgName = 1 [default = "GPS_HEALTH_CONFIG"];
inline bool GpsHealthConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GpsHealthConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GpsHealthConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GpsHealthConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& GpsHealthConfig::msgname() const {
  return *msgname_;
}
inline void GpsHealthConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GpsHealthConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GpsHealthConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GpsHealthConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* GpsHealthConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void GpsHealthConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional .falcon_app_msg.MacroOptions options = 2;
inline bool GpsHealthConfig::has_options() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GpsHealthConfig::set_has_options() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GpsHealthConfig::clear_has_options() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GpsHealthConfig::clear_options() {
  if (options_ != NULL) options_->::falcon_app_msg::MacroOptions::Clear();
  clear_has_options();
}
inline const ::falcon_app_msg::MacroOptions& GpsHealthConfig::options() const {
  return options_ != NULL ? *options_ : *default_instance_->options_;
}
inline ::falcon_app_msg::MacroOptions* GpsHealthConfig::mutable_options() {
  set_has_options();
  if (options_ == NULL) options_ = new ::falcon_app_msg::MacroOptions;
  return options_;
}
inline ::falcon_app_msg::MacroOptions* GpsHealthConfig::release_options() {
  clear_has_options();
  ::falcon_app_msg::MacroOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline void GpsHealthConfig::set_allocated_options(::falcon_app_msg::MacroOptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
}

// -------------------------------------------------------------------

// AntennaControlConfig

// optional string msgName = 1 [default = "ANTENNA_CONTROL"];
inline bool AntennaControlConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AntennaControlConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AntennaControlConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AntennaControlConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& AntennaControlConfig::msgname() const {
  return *msgname_;
}
inline void AntennaControlConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AntennaControlConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AntennaControlConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AntennaControlConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* AntennaControlConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void AntennaControlConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// -------------------------------------------------------------------

// VcnConfig

// optional string msgName = 1 [default = "VCN_CONFIG"];
inline bool VcnConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VcnConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VcnConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VcnConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& VcnConfig::msgname() const {
  return *msgname_;
}
inline void VcnConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void VcnConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void VcnConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VcnConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* VcnConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void VcnConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// -------------------------------------------------------------------

// GenericMacroConfig

// optional string msgName = 1 [default = "GENERIC_MACRO_CONFIG"];
inline bool GenericMacroConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GenericMacroConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GenericMacroConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GenericMacroConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& GenericMacroConfig::msgname() const {
  return *msgname_;
}
inline void GenericMacroConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GenericMacroConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GenericMacroConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GenericMacroConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* GenericMacroConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void GenericMacroConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// -------------------------------------------------------------------

// SettingsConfig

// optional string msgName = 1 [default = "SETTINGS_CONFIG"];
inline bool SettingsConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SettingsConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SettingsConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SettingsConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SettingsConfig::msgname() const {
  return *msgname_;
}
inline void SettingsConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SettingsConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SettingsConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SettingsConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SettingsConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SettingsConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// -------------------------------------------------------------------

// KepSvisorConfig

// optional string msgName = 1 [default = "KEP_SVISOR_CONFIG"];
inline bool KepSvisorConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KepSvisorConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KepSvisorConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KepSvisorConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& KepSvisorConfig::msgname() const {
  return *msgname_;
}
inline void KepSvisorConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void KepSvisorConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void KepSvisorConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KepSvisorConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* KepSvisorConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void KepSvisorConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// -------------------------------------------------------------------

// ZMQPubDemoConfig

// optional string msgName = 1 [default = "ZMQ_PUB_DEMO_CONFIG"];
inline bool ZMQPubDemoConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ZMQPubDemoConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ZMQPubDemoConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ZMQPubDemoConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ZMQPubDemoConfig::msgname() const {
  return *msgname_;
}
inline void ZMQPubDemoConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ZMQPubDemoConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ZMQPubDemoConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZMQPubDemoConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ZMQPubDemoConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ZMQPubDemoConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 maxRequests = 2 [default = 1];
inline bool ZMQPubDemoConfig::has_maxrequests() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ZMQPubDemoConfig::set_has_maxrequests() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ZMQPubDemoConfig::clear_has_maxrequests() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ZMQPubDemoConfig::clear_maxrequests() {
  maxrequests_ = 1;
  clear_has_maxrequests();
}
inline ::google::protobuf::int32 ZMQPubDemoConfig::maxrequests() const {
  return maxrequests_;
}
inline void ZMQPubDemoConfig::set_maxrequests(::google::protobuf::int32 value) {
  set_has_maxrequests();
  maxrequests_ = value;
}

// optional string address = 3 [default = ""];
inline bool ZMQPubDemoConfig::has_address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ZMQPubDemoConfig::set_has_address() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ZMQPubDemoConfig::clear_has_address() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ZMQPubDemoConfig::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& ZMQPubDemoConfig::address() const {
  return *address_;
}
inline void ZMQPubDemoConfig::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void ZMQPubDemoConfig::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void ZMQPubDemoConfig::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZMQPubDemoConfig::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* ZMQPubDemoConfig::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ZMQPubDemoConfig::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .falcon_app_msg.MacroOptions options = 4;
inline bool ZMQPubDemoConfig::has_options() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ZMQPubDemoConfig::set_has_options() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ZMQPubDemoConfig::clear_has_options() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ZMQPubDemoConfig::clear_options() {
  if (options_ != NULL) options_->::falcon_app_msg::MacroOptions::Clear();
  clear_has_options();
}
inline const ::falcon_app_msg::MacroOptions& ZMQPubDemoConfig::options() const {
  return options_ != NULL ? *options_ : *default_instance_->options_;
}
inline ::falcon_app_msg::MacroOptions* ZMQPubDemoConfig::mutable_options() {
  set_has_options();
  if (options_ == NULL) options_ = new ::falcon_app_msg::MacroOptions;
  return options_;
}
inline ::falcon_app_msg::MacroOptions* ZMQPubDemoConfig::release_options() {
  clear_has_options();
  ::falcon_app_msg::MacroOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline void ZMQPubDemoConfig::set_allocated_options(::falcon_app_msg::MacroOptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
}

// -------------------------------------------------------------------

// ZMQSubDemoConfig

// optional string msgName = 1 [default = "ZMQ_SUB_DEMO_CONFIG"];
inline bool ZMQSubDemoConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ZMQSubDemoConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ZMQSubDemoConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ZMQSubDemoConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ZMQSubDemoConfig::msgname() const {
  return *msgname_;
}
inline void ZMQSubDemoConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ZMQSubDemoConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ZMQSubDemoConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZMQSubDemoConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ZMQSubDemoConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ZMQSubDemoConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 maxProducts = 2 [default = 1];
inline bool ZMQSubDemoConfig::has_maxproducts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ZMQSubDemoConfig::set_has_maxproducts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ZMQSubDemoConfig::clear_has_maxproducts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ZMQSubDemoConfig::clear_maxproducts() {
  maxproducts_ = 1;
  clear_has_maxproducts();
}
inline ::google::protobuf::int32 ZMQSubDemoConfig::maxproducts() const {
  return maxproducts_;
}
inline void ZMQSubDemoConfig::set_maxproducts(::google::protobuf::int32 value) {
  set_has_maxproducts();
  maxproducts_ = value;
}

// optional string address = 3 [default = ""];
inline bool ZMQSubDemoConfig::has_address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ZMQSubDemoConfig::set_has_address() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ZMQSubDemoConfig::clear_has_address() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ZMQSubDemoConfig::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& ZMQSubDemoConfig::address() const {
  return *address_;
}
inline void ZMQSubDemoConfig::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void ZMQSubDemoConfig::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void ZMQSubDemoConfig::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZMQSubDemoConfig::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* ZMQSubDemoConfig::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ZMQSubDemoConfig::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .falcon_app_msg.MacroOptions options = 4;
inline bool ZMQSubDemoConfig::has_options() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ZMQSubDemoConfig::set_has_options() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ZMQSubDemoConfig::clear_has_options() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ZMQSubDemoConfig::clear_options() {
  if (options_ != NULL) options_->::falcon_app_msg::MacroOptions::Clear();
  clear_has_options();
}
inline const ::falcon_app_msg::MacroOptions& ZMQSubDemoConfig::options() const {
  return options_ != NULL ? *options_ : *default_instance_->options_;
}
inline ::falcon_app_msg::MacroOptions* ZMQSubDemoConfig::mutable_options() {
  set_has_options();
  if (options_ == NULL) options_ = new ::falcon_app_msg::MacroOptions;
  return options_;
}
inline ::falcon_app_msg::MacroOptions* ZMQSubDemoConfig::release_options() {
  clear_has_options();
  ::falcon_app_msg::MacroOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline void ZMQSubDemoConfig::set_allocated_options(::falcon_app_msg::MacroOptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
}

// -------------------------------------------------------------------

// WifiConfig

// optional string msgName = 1 [default = "WIFI_CONFIG"];
inline bool WifiConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WifiConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WifiConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WifiConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& WifiConfig::msgname() const {
  return *msgname_;
}
inline void WifiConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void WifiConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void WifiConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WifiConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* WifiConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void WifiConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional .falcon_app_msg.MacroOptions options = 2;
inline bool WifiConfig::has_options() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WifiConfig::set_has_options() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WifiConfig::clear_has_options() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WifiConfig::clear_options() {
  if (options_ != NULL) options_->::falcon_app_msg::MacroOptions::Clear();
  clear_has_options();
}
inline const ::falcon_app_msg::MacroOptions& WifiConfig::options() const {
  return options_ != NULL ? *options_ : *default_instance_->options_;
}
inline ::falcon_app_msg::MacroOptions* WifiConfig::mutable_options() {
  set_has_options();
  if (options_ == NULL) options_ = new ::falcon_app_msg::MacroOptions;
  return options_;
}
inline ::falcon_app_msg::MacroOptions* WifiConfig::release_options() {
  clear_has_options();
  ::falcon_app_msg::MacroOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline void WifiConfig::set_allocated_options(::falcon_app_msg::MacroOptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
}

// optional string geo_enabled = 3 [default = "OFF"];
inline bool WifiConfig::has_geo_enabled() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WifiConfig::set_has_geo_enabled() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WifiConfig::clear_has_geo_enabled() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WifiConfig::clear_geo_enabled() {
  if (geo_enabled_ != _default_geo_enabled_) {
    geo_enabled_->assign(*_default_geo_enabled_);
  }
  clear_has_geo_enabled();
}
inline const ::std::string& WifiConfig::geo_enabled() const {
  return *geo_enabled_;
}
inline void WifiConfig::set_geo_enabled(const ::std::string& value) {
  set_has_geo_enabled();
  if (geo_enabled_ == _default_geo_enabled_) {
    geo_enabled_ = new ::std::string;
  }
  geo_enabled_->assign(value);
}
inline void WifiConfig::set_geo_enabled(const char* value) {
  set_has_geo_enabled();
  if (geo_enabled_ == _default_geo_enabled_) {
    geo_enabled_ = new ::std::string;
  }
  geo_enabled_->assign(value);
}
inline void WifiConfig::set_geo_enabled(const char* value, size_t size) {
  set_has_geo_enabled();
  if (geo_enabled_ == _default_geo_enabled_) {
    geo_enabled_ = new ::std::string;
  }
  geo_enabled_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WifiConfig::mutable_geo_enabled() {
  set_has_geo_enabled();
  if (geo_enabled_ == _default_geo_enabled_) {
    geo_enabled_ = new ::std::string(*_default_geo_enabled_);
  }
  return geo_enabled_;
}
inline ::std::string* WifiConfig::release_geo_enabled() {
  clear_has_geo_enabled();
  if (geo_enabled_ == _default_geo_enabled_) {
    return NULL;
  } else {
    ::std::string* temp = geo_enabled_;
    geo_enabled_ = const_cast< ::std::string*>(_default_geo_enabled_);
    return temp;
  }
}
inline void WifiConfig::set_allocated_geo_enabled(::std::string* geo_enabled) {
  if (geo_enabled_ != _default_geo_enabled_) {
    delete geo_enabled_;
  }
  if (geo_enabled) {
    set_has_geo_enabled();
    geo_enabled_ = geo_enabled;
  } else {
    clear_has_geo_enabled();
    geo_enabled_ = const_cast< ::std::string*>(_default_geo_enabled_);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace falcon_app_msg

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_app_msg::MacroOptions_AutoControl>() {
  return ::falcon_app_msg::MacroOptions_AutoControl_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_app_msg::MacroOptions_PPS>() {
  return ::falcon_app_msg::MacroOptions_PPS_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_app_msg::MacroOptions_Ref10m>() {
  return ::falcon_app_msg::MacroOptions_Ref10m_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_app_msg::MacroOptions_ExportFlags>() {
  return ::falcon_app_msg::MacroOptions_ExportFlags_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_app_msg::ProcMacroConfig_SystemType>() {
  return ::falcon_app_msg::ProcMacroConfig_SystemType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_FalconApplicationMessages_2eproto__INCLUDED
