// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ServiceInfrastructureExclusive.proto

#ifndef PROTOBUF_ServiceInfrastructureExclusive_2eproto__INCLUDED
#define PROTOBUF_ServiceInfrastructureExclusive_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "FalconRemotingMessages.pb.h"
#include "TunerMessages.pb.h"
#include "ThunderbirdMessages.pb.h"
#include "FalconCommonMessages.pb.h"
#include "ServiceInfrastructureCommon.pb.h"
#include "Products.pb.h"
#include "VideoCompressionMessages.pb.h"
#include "RADARmessages.pb.h"
#include "DebugMessages.pb.h"
#include "SigFrameMessages.pb.h"
#include "RxCommandMessages.pb.h"
#include "FalconAntennaMessages.pb.h"
#include "ESProductMessages.pb.h"
#include "AutoKillMessages.pb.h"
// @@protoc_insertion_point(includes)

namespace service_infrastructure {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ServiceInfrastructureExclusive_2eproto();
void protobuf_AssignDesc_ServiceInfrastructureExclusive_2eproto();
void protobuf_ShutdownFile_ServiceInfrastructureExclusive_2eproto();

class ServiceEnvelope;
class EWResponseTopic;
class CapabilityResponseTopic;
class RadioControlRequestTopic;
class SignalEventTopic;
class ProductResponseTopic;
class VideoParameters;
class ESProductTopic;
class InfrastructureEnvelope;
class ProductRequestTopic;
class EWRequestTopic;
class CapabilityRequestTopic;
class TransmitterControlRequestTopic;
class RadioControlResponseTopic;
class DebugTopic;
class SigFramesTopic;
class RadioDataTopic;
class GeoTopic;
class SensorTopic;
class ImageRequest;
class VideoRequest;

// ===================================================================

class ServiceEnvelope : public ::google::protobuf::Message {
 public:
  ServiceEnvelope();
  virtual ~ServiceEnvelope();

  ServiceEnvelope(const ServiceEnvelope& from);

  inline ServiceEnvelope& operator=(const ServiceEnvelope& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceEnvelope& default_instance();

  void Swap(ServiceEnvelope* other);

  // implements Message ----------------------------------------------

  ServiceEnvelope* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceEnvelope& from);
  void MergeFrom(const ServiceEnvelope& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional .service_infrastructure.HandshakeTopic handshake = 2;
  inline bool has_handshake() const;
  inline void clear_handshake();
  static const int kHandshakeFieldNumber = 2;
  inline const ::service_infrastructure::HandshakeTopic& handshake() const;
  inline ::service_infrastructure::HandshakeTopic* mutable_handshake();
  inline ::service_infrastructure::HandshakeTopic* release_handshake();
  inline void set_allocated_handshake(::service_infrastructure::HandshakeTopic* handshake);

  // optional .service_infrastructure.EWResponseTopic ew_response = 3;
  inline bool has_ew_response() const;
  inline void clear_ew_response();
  static const int kEwResponseFieldNumber = 3;
  inline const ::service_infrastructure::EWResponseTopic& ew_response() const;
  inline ::service_infrastructure::EWResponseTopic* mutable_ew_response();
  inline ::service_infrastructure::EWResponseTopic* release_ew_response();
  inline void set_allocated_ew_response(::service_infrastructure::EWResponseTopic* ew_response);

  // optional .service_infrastructure.ProductResponseTopic product_response = 5;
  inline bool has_product_response() const;
  inline void clear_product_response();
  static const int kProductResponseFieldNumber = 5;
  inline const ::service_infrastructure::ProductResponseTopic& product_response() const;
  inline ::service_infrastructure::ProductResponseTopic* mutable_product_response();
  inline ::service_infrastructure::ProductResponseTopic* release_product_response();
  inline void set_allocated_product_response(::service_infrastructure::ProductResponseTopic* product_response);

  // optional .service_infrastructure.RadioControlRequestTopic radio_control_request = 6;
  inline bool has_radio_control_request() const;
  inline void clear_radio_control_request();
  static const int kRadioControlRequestFieldNumber = 6;
  inline const ::service_infrastructure::RadioControlRequestTopic& radio_control_request() const;
  inline ::service_infrastructure::RadioControlRequestTopic* mutable_radio_control_request();
  inline ::service_infrastructure::RadioControlRequestTopic* release_radio_control_request();
  inline void set_allocated_radio_control_request(::service_infrastructure::RadioControlRequestTopic* radio_control_request);

  // optional .service_infrastructure.SignalEventTopic signal_event = 7;
  inline bool has_signal_event() const;
  inline void clear_signal_event();
  static const int kSignalEventFieldNumber = 7;
  inline const ::service_infrastructure::SignalEventTopic& signal_event() const;
  inline ::service_infrastructure::SignalEventTopic* mutable_signal_event();
  inline ::service_infrastructure::SignalEventTopic* release_signal_event();
  inline void set_allocated_signal_event(::service_infrastructure::SignalEventTopic* signal_event);

  // @@protoc_insertion_point(class_scope:service_infrastructure.ServiceEnvelope)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_handshake();
  inline void clear_has_handshake();
  inline void set_has_ew_response();
  inline void clear_has_ew_response();
  inline void set_has_product_response();
  inline void clear_has_product_response();
  inline void set_has_radio_control_request();
  inline void clear_has_radio_control_request();
  inline void set_has_signal_event();
  inline void clear_has_signal_event();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::service_infrastructure::HandshakeTopic* handshake_;
  ::service_infrastructure::EWResponseTopic* ew_response_;
  ::service_infrastructure::ProductResponseTopic* product_response_;
  ::service_infrastructure::RadioControlRequestTopic* radio_control_request_;
  ::service_infrastructure::SignalEventTopic* signal_event_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureExclusive_2eproto();

  void InitAsDefaultInstance();
  static ServiceEnvelope* default_instance_;
};
// -------------------------------------------------------------------

class EWResponseTopic : public ::google::protobuf::Message {
 public:
  EWResponseTopic();
  virtual ~EWResponseTopic();

  EWResponseTopic(const EWResponseTopic& from);

  inline EWResponseTopic& operator=(const EWResponseTopic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EWResponseTopic& default_instance();

  void Swap(EWResponseTopic* other);

  // implements Message ----------------------------------------------

  EWResponseTopic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EWResponseTopic& from);
  void MergeFrom(const EWResponseTopic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 100;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 100;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional .service_infrastructure.NAck nack = 1;
  inline bool has_nack() const;
  inline void clear_nack();
  static const int kNackFieldNumber = 1;
  inline const ::service_infrastructure::NAck& nack() const;
  inline ::service_infrastructure::NAck* mutable_nack();
  inline ::service_infrastructure::NAck* release_nack();
  inline void set_allocated_nack(::service_infrastructure::NAck* nack);

  // optional .service_infrastructure.Ack ack = 2;
  inline bool has_ack() const;
  inline void clear_ack();
  static const int kAckFieldNumber = 2;
  inline const ::service_infrastructure::Ack& ack() const;
  inline ::service_infrastructure::Ack* mutable_ack();
  inline ::service_infrastructure::Ack* release_ack();
  inline void set_allocated_ack(::service_infrastructure::Ack* ack);

  // optional .fv.tb.protos.TBProtos.EWStatus ew_status = 3;
  inline bool has_ew_status() const;
  inline void clear_ew_status();
  static const int kEwStatusFieldNumber = 3;
  inline const ::fv::tb::protos::TBProtos::EWStatus& ew_status() const;
  inline ::fv::tb::protos::TBProtos::EWStatus* mutable_ew_status();
  inline ::fv::tb::protos::TBProtos::EWStatus* release_ew_status();
  inline void set_allocated_ew_status(::fv::tb::protos::TBProtos::EWStatus* ew_status);

  // optional .fv.tb.protos.TBProtos.EWOptions ew_options = 4;
  inline bool has_ew_options() const;
  inline void clear_ew_options();
  static const int kEwOptionsFieldNumber = 4;
  inline const ::fv::tb::protos::TBProtos::EWOptions& ew_options() const;
  inline ::fv::tb::protos::TBProtos::EWOptions* mutable_ew_options();
  inline ::fv::tb::protos::TBProtos::EWOptions* release_ew_options();
  inline void set_allocated_ew_options(::fv::tb::protos::TBProtos::EWOptions* ew_options);

  // optional .fv.tb.protos.TBProtos.EWOptionDelete ew_option_delete = 5;
  inline bool has_ew_option_delete() const;
  inline void clear_ew_option_delete();
  static const int kEwOptionDeleteFieldNumber = 5;
  inline const ::fv::tb::protos::TBProtos::EWOptionDelete& ew_option_delete() const;
  inline ::fv::tb::protos::TBProtos::EWOptionDelete* mutable_ew_option_delete();
  inline ::fv::tb::protos::TBProtos::EWOptionDelete* release_ew_option_delete();
  inline void set_allocated_ew_option_delete(::fv::tb::protos::TBProtos::EWOptionDelete* ew_option_delete);

  // optional .fv.tb.protos.TBProtos.RegisterResponse register_response = 6;
  inline bool has_register_response() const;
  inline void clear_register_response();
  static const int kRegisterResponseFieldNumber = 6;
  inline const ::fv::tb::protos::TBProtos::RegisterResponse& register_response() const;
  inline ::fv::tb::protos::TBProtos::RegisterResponse* mutable_register_response();
  inline ::fv::tb::protos::TBProtos::RegisterResponse* release_register_response();
  inline void set_allocated_register_response(::fv::tb::protos::TBProtos::RegisterResponse* register_response);

  // optional .fv.tb.protos.TBProtos.newSignalFrame new_signal_frame = 7;
  inline bool has_new_signal_frame() const;
  inline void clear_new_signal_frame();
  static const int kNewSignalFrameFieldNumber = 7;
  inline const ::fv::tb::protos::TBProtos::newSignalFrame& new_signal_frame() const;
  inline ::fv::tb::protos::TBProtos::newSignalFrame* mutable_new_signal_frame();
  inline ::fv::tb::protos::TBProtos::newSignalFrame* release_new_signal_frame();
  inline void set_allocated_new_signal_frame(::fv::tb::protos::TBProtos::newSignalFrame* new_signal_frame);

  // optional .fv.tb.protos.TBProtos.EWCapabilities ew_capabilities = 8;
  inline bool has_ew_capabilities() const;
  inline void clear_ew_capabilities();
  static const int kEwCapabilitiesFieldNumber = 8;
  inline const ::fv::tb::protos::TBProtos::EWCapabilities& ew_capabilities() const;
  inline ::fv::tb::protos::TBProtos::EWCapabilities* mutable_ew_capabilities();
  inline ::fv::tb::protos::TBProtos::EWCapabilities* release_ew_capabilities();
  inline void set_allocated_ew_capabilities(::fv::tb::protos::TBProtos::EWCapabilities* ew_capabilities);

  // optional .fv.tb.protos.TBProtos.EWTransmitting ew_transmitting = 9;
  inline bool has_ew_transmitting() const;
  inline void clear_ew_transmitting();
  static const int kEwTransmittingFieldNumber = 9;
  inline const ::fv::tb::protos::TBProtos::EWTransmitting& ew_transmitting() const;
  inline ::fv::tb::protos::TBProtos::EWTransmitting* mutable_ew_transmitting();
  inline ::fv::tb::protos::TBProtos::EWTransmitting* release_ew_transmitting();
  inline void set_allocated_ew_transmitting(::fv::tb::protos::TBProtos::EWTransmitting* ew_transmitting);

  // optional .fv.tb.protos.TBProtos.EWTechniqueDescriptions ew_technique_descriptions = 10;
  inline bool has_ew_technique_descriptions() const;
  inline void clear_ew_technique_descriptions();
  static const int kEwTechniqueDescriptionsFieldNumber = 10;
  inline const ::fv::tb::protos::TBProtos::EWTechniqueDescriptions& ew_technique_descriptions() const;
  inline ::fv::tb::protos::TBProtos::EWTechniqueDescriptions* mutable_ew_technique_descriptions();
  inline ::fv::tb::protos::TBProtos::EWTechniqueDescriptions* release_ew_technique_descriptions();
  inline void set_allocated_ew_technique_descriptions(::fv::tb::protos::TBProtos::EWTechniqueDescriptions* ew_technique_descriptions);

  // @@protoc_insertion_point(class_scope:service_infrastructure.EWResponseTopic)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_nack();
  inline void clear_has_nack();
  inline void set_has_ack();
  inline void clear_has_ack();
  inline void set_has_ew_status();
  inline void clear_has_ew_status();
  inline void set_has_ew_options();
  inline void clear_has_ew_options();
  inline void set_has_ew_option_delete();
  inline void clear_has_ew_option_delete();
  inline void set_has_register_response();
  inline void clear_has_register_response();
  inline void set_has_new_signal_frame();
  inline void clear_has_new_signal_frame();
  inline void set_has_ew_capabilities();
  inline void clear_has_ew_capabilities();
  inline void set_has_ew_transmitting();
  inline void clear_has_ew_transmitting();
  inline void set_has_ew_technique_descriptions();
  inline void clear_has_ew_technique_descriptions();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::service_infrastructure::NAck* nack_;
  ::service_infrastructure::Ack* ack_;
  ::fv::tb::protos::TBProtos::EWStatus* ew_status_;
  ::fv::tb::protos::TBProtos::EWOptions* ew_options_;
  ::fv::tb::protos::TBProtos::EWOptionDelete* ew_option_delete_;
  ::fv::tb::protos::TBProtos::RegisterResponse* register_response_;
  ::fv::tb::protos::TBProtos::newSignalFrame* new_signal_frame_;
  ::fv::tb::protos::TBProtos::EWCapabilities* ew_capabilities_;
  ::fv::tb::protos::TBProtos::EWTransmitting* ew_transmitting_;
  ::fv::tb::protos::TBProtos::EWTechniqueDescriptions* ew_technique_descriptions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureExclusive_2eproto();

  void InitAsDefaultInstance();
  static EWResponseTopic* default_instance_;
};
// -------------------------------------------------------------------

class CapabilityResponseTopic : public ::google::protobuf::Message {
 public:
  CapabilityResponseTopic();
  virtual ~CapabilityResponseTopic();

  CapabilityResponseTopic(const CapabilityResponseTopic& from);

  inline CapabilityResponseTopic& operator=(const CapabilityResponseTopic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CapabilityResponseTopic& default_instance();

  void Swap(CapabilityResponseTopic* other);

  // implements Message ----------------------------------------------

  CapabilityResponseTopic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CapabilityResponseTopic& from);
  void MergeFrom(const CapabilityResponseTopic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 100;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 100;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional .service_infrastructure.NAck nack = 1;
  inline bool has_nack() const;
  inline void clear_nack();
  static const int kNackFieldNumber = 1;
  inline const ::service_infrastructure::NAck& nack() const;
  inline ::service_infrastructure::NAck* mutable_nack();
  inline ::service_infrastructure::NAck* release_nack();
  inline void set_allocated_nack(::service_infrastructure::NAck* nack);

  // optional .service_infrastructure.Ack ack = 2;
  inline bool has_ack() const;
  inline void clear_ack();
  static const int kAckFieldNumber = 2;
  inline const ::service_infrastructure::Ack& ack() const;
  inline ::service_infrastructure::Ack* mutable_ack();
  inline ::service_infrastructure::Ack* release_ack();
  inline void set_allocated_ack(::service_infrastructure::Ack* ack);

  // optional .fv.tb.protos.TBProtos.EWCapability ew_capability = 10;
  inline bool has_ew_capability() const;
  inline void clear_ew_capability();
  static const int kEwCapabilityFieldNumber = 10;
  inline const ::fv::tb::protos::TBProtos::EWCapability& ew_capability() const;
  inline ::fv::tb::protos::TBProtos::EWCapability* mutable_ew_capability();
  inline ::fv::tb::protos::TBProtos::EWCapability* release_ew_capability();
  inline void set_allocated_ew_capability(::fv::tb::protos::TBProtos::EWCapability* ew_capability);

  // optional .fv.tb.protos.TBProtos.EWCapabilityUnregister ew_capability_unregister = 11;
  inline bool has_ew_capability_unregister() const;
  inline void clear_ew_capability_unregister();
  static const int kEwCapabilityUnregisterFieldNumber = 11;
  inline const ::fv::tb::protos::TBProtos::EWCapabilityUnregister& ew_capability_unregister() const;
  inline ::fv::tb::protos::TBProtos::EWCapabilityUnregister* mutable_ew_capability_unregister();
  inline ::fv::tb::protos::TBProtos::EWCapabilityUnregister* release_ew_capability_unregister();
  inline void set_allocated_ew_capability_unregister(::fv::tb::protos::TBProtos::EWCapabilityUnregister* ew_capability_unregister);

  // optional .fv.tb.protos.TBProtos.HopAttackStatus hop_attack_status = 12;
  inline bool has_hop_attack_status() const;
  inline void clear_hop_attack_status();
  static const int kHopAttackStatusFieldNumber = 12;
  inline const ::fv::tb::protos::TBProtos::HopAttackStatus& hop_attack_status() const;
  inline ::fv::tb::protos::TBProtos::HopAttackStatus* mutable_hop_attack_status();
  inline ::fv::tb::protos::TBProtos::HopAttackStatus* release_hop_attack_status();
  inline void set_allocated_hop_attack_status(::fv::tb::protos::TBProtos::HopAttackStatus* hop_attack_status);

  // optional .fv.tb.protos.TBProtos.EWCapabilityTransmitting ew_capability_transmitting = 13;
  inline bool has_ew_capability_transmitting() const;
  inline void clear_ew_capability_transmitting();
  static const int kEwCapabilityTransmittingFieldNumber = 13;
  inline const ::fv::tb::protos::TBProtos::EWCapabilityTransmitting& ew_capability_transmitting() const;
  inline ::fv::tb::protos::TBProtos::EWCapabilityTransmitting* mutable_ew_capability_transmitting();
  inline ::fv::tb::protos::TBProtos::EWCapabilityTransmitting* release_ew_capability_transmitting();
  inline void set_allocated_ew_capability_transmitting(::fv::tb::protos::TBProtos::EWCapabilityTransmitting* ew_capability_transmitting);

  // @@protoc_insertion_point(class_scope:service_infrastructure.CapabilityResponseTopic)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_nack();
  inline void clear_has_nack();
  inline void set_has_ack();
  inline void clear_has_ack();
  inline void set_has_ew_capability();
  inline void clear_has_ew_capability();
  inline void set_has_ew_capability_unregister();
  inline void clear_has_ew_capability_unregister();
  inline void set_has_hop_attack_status();
  inline void clear_has_hop_attack_status();
  inline void set_has_ew_capability_transmitting();
  inline void clear_has_ew_capability_transmitting();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::service_infrastructure::NAck* nack_;
  ::service_infrastructure::Ack* ack_;
  ::fv::tb::protos::TBProtos::EWCapability* ew_capability_;
  ::fv::tb::protos::TBProtos::EWCapabilityUnregister* ew_capability_unregister_;
  ::fv::tb::protos::TBProtos::HopAttackStatus* hop_attack_status_;
  ::fv::tb::protos::TBProtos::EWCapabilityTransmitting* ew_capability_transmitting_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureExclusive_2eproto();

  void InitAsDefaultInstance();
  static CapabilityResponseTopic* default_instance_;
};
// -------------------------------------------------------------------

class RadioControlRequestTopic : public ::google::protobuf::Message {
 public:
  RadioControlRequestTopic();
  virtual ~RadioControlRequestTopic();

  RadioControlRequestTopic(const RadioControlRequestTopic& from);

  inline RadioControlRequestTopic& operator=(const RadioControlRequestTopic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RadioControlRequestTopic& default_instance();

  void Swap(RadioControlRequestTopic* other);

  // implements Message ----------------------------------------------

  RadioControlRequestTopic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RadioControlRequestTopic& from);
  void MergeFrom(const RadioControlRequestTopic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 100;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 100;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional .tuner_msg.DwellScan dwell_scan = 1;
  inline bool has_dwell_scan() const;
  inline void clear_dwell_scan();
  static const int kDwellScanFieldNumber = 1;
  inline const ::tuner_msg::DwellScan& dwell_scan() const;
  inline ::tuner_msg::DwellScan* mutable_dwell_scan();
  inline ::tuner_msg::DwellScan* release_dwell_scan();
  inline void set_allocated_dwell_scan(::tuner_msg::DwellScan* dwell_scan);

  // optional .tuner_msg.QueryReceiverStatus rx_query = 2;
  inline bool has_rx_query() const;
  inline void clear_rx_query();
  static const int kRxQueryFieldNumber = 2;
  inline const ::tuner_msg::QueryReceiverStatus& rx_query() const;
  inline ::tuner_msg::QueryReceiverStatus* mutable_rx_query();
  inline ::tuner_msg::QueryReceiverStatus* release_rx_query();
  inline void set_allocated_rx_query(::tuner_msg::QueryReceiverStatus* rx_query);

  // optional .tuner_msg.ReceiverRequest receiver_request = 3;
  inline bool has_receiver_request() const;
  inline void clear_receiver_request();
  static const int kReceiverRequestFieldNumber = 3;
  inline const ::tuner_msg::ReceiverRequest& receiver_request() const;
  inline ::tuner_msg::ReceiverRequest* mutable_receiver_request();
  inline ::tuner_msg::ReceiverRequest* release_receiver_request();
  inline void set_allocated_receiver_request(::tuner_msg::ReceiverRequest* receiver_request);

  // optional .tuner_msg.ReceiverRelease receiver_release = 4;
  inline bool has_receiver_release() const;
  inline void clear_receiver_release();
  static const int kReceiverReleaseFieldNumber = 4;
  inline const ::tuner_msg::ReceiverRelease& receiver_release() const;
  inline ::tuner_msg::ReceiverRelease* mutable_receiver_release();
  inline ::tuner_msg::ReceiverRelease* release_receiver_release();
  inline void set_allocated_receiver_release(::tuner_msg::ReceiverRelease* receiver_release);

  // optional .rx_command_msg.RxCommandRequest rx_command_request = 5;
  inline bool has_rx_command_request() const;
  inline void clear_rx_command_request();
  static const int kRxCommandRequestFieldNumber = 5;
  inline const ::rx_command_msg::RxCommandRequest& rx_command_request() const;
  inline ::rx_command_msg::RxCommandRequest* mutable_rx_command_request();
  inline ::rx_command_msg::RxCommandRequest* release_rx_command_request();
  inline void set_allocated_rx_command_request(::rx_command_msg::RxCommandRequest* rx_command_request);

  // @@protoc_insertion_point(class_scope:service_infrastructure.RadioControlRequestTopic)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_dwell_scan();
  inline void clear_has_dwell_scan();
  inline void set_has_rx_query();
  inline void clear_has_rx_query();
  inline void set_has_receiver_request();
  inline void clear_has_receiver_request();
  inline void set_has_receiver_release();
  inline void clear_has_receiver_release();
  inline void set_has_rx_command_request();
  inline void clear_has_rx_command_request();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::tuner_msg::DwellScan* dwell_scan_;
  ::tuner_msg::QueryReceiverStatus* rx_query_;
  ::tuner_msg::ReceiverRequest* receiver_request_;
  ::tuner_msg::ReceiverRelease* receiver_release_;
  ::rx_command_msg::RxCommandRequest* rx_command_request_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureExclusive_2eproto();

  void InitAsDefaultInstance();
  static RadioControlRequestTopic* default_instance_;
};
// -------------------------------------------------------------------

class SignalEventTopic : public ::google::protobuf::Message {
 public:
  SignalEventTopic();
  virtual ~SignalEventTopic();

  SignalEventTopic(const SignalEventTopic& from);

  inline SignalEventTopic& operator=(const SignalEventTopic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignalEventTopic& default_instance();

  void Swap(SignalEventTopic* other);

  // implements Message ----------------------------------------------

  SignalEventTopic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignalEventTopic& from);
  void MergeFrom(const SignalEventTopic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 100;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 100;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional .falcon_remoting_msg.SignalEvent signal_event = 1;
  inline bool has_signal_event() const;
  inline void clear_signal_event();
  static const int kSignalEventFieldNumber = 1;
  inline const ::falcon_remoting_msg::SignalEvent& signal_event() const;
  inline ::falcon_remoting_msg::SignalEvent* mutable_signal_event();
  inline ::falcon_remoting_msg::SignalEvent* release_signal_event();
  inline void set_allocated_signal_event(::falcon_remoting_msg::SignalEvent* signal_event);

  // optional .falcon_remoting_msg.GPSPosition gps_position = 2;
  inline bool has_gps_position() const;
  inline void clear_gps_position();
  static const int kGpsPositionFieldNumber = 2;
  inline const ::falcon_remoting_msg::GPSPosition& gps_position() const;
  inline ::falcon_remoting_msg::GPSPosition* mutable_gps_position();
  inline ::falcon_remoting_msg::GPSPosition* release_gps_position();
  inline void set_allocated_gps_position(::falcon_remoting_msg::GPSPosition* gps_position);

  // @@protoc_insertion_point(class_scope:service_infrastructure.SignalEventTopic)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_signal_event();
  inline void clear_has_signal_event();
  inline void set_has_gps_position();
  inline void clear_has_gps_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::falcon_remoting_msg::SignalEvent* signal_event_;
  ::falcon_remoting_msg::GPSPosition* gps_position_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureExclusive_2eproto();

  void InitAsDefaultInstance();
  static SignalEventTopic* default_instance_;
};
// -------------------------------------------------------------------

class ProductResponseTopic : public ::google::protobuf::Message {
 public:
  ProductResponseTopic();
  virtual ~ProductResponseTopic();

  ProductResponseTopic(const ProductResponseTopic& from);

  inline ProductResponseTopic& operator=(const ProductResponseTopic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProductResponseTopic& default_instance();

  void Swap(ProductResponseTopic* other);

  // implements Message ----------------------------------------------

  ProductResponseTopic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProductResponseTopic& from);
  void MergeFrom(const ProductResponseTopic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 100;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 100;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional .video_compression_msg.ImageAvailable image_available = 1;
  inline bool has_image_available() const;
  inline void clear_image_available();
  static const int kImageAvailableFieldNumber = 1;
  inline const ::video_compression_msg::ImageAvailable& image_available() const;
  inline ::video_compression_msg::ImageAvailable* mutable_image_available();
  inline ::video_compression_msg::ImageAvailable* release_image_available();
  inline void set_allocated_image_available(::video_compression_msg::ImageAvailable* image_available);

  // optional .products.FisD fisd = 2;
  inline bool has_fisd() const;
  inline void clear_fisd();
  static const int kFisdFieldNumber = 2;
  inline const ::products::FisD& fisd() const;
  inline ::products::FisD* mutable_fisd();
  inline ::products::FisD* release_fisd();
  inline void set_allocated_fisd(::products::FisD* fisd);

  // optional .service_infrastructure.VideoParameters video_parameters = 3;
  inline bool has_video_parameters() const;
  inline void clear_video_parameters();
  static const int kVideoParametersFieldNumber = 3;
  inline const ::service_infrastructure::VideoParameters& video_parameters() const;
  inline ::service_infrastructure::VideoParameters* mutable_video_parameters();
  inline ::service_infrastructure::VideoParameters* release_video_parameters();
  inline void set_allocated_video_parameters(::service_infrastructure::VideoParameters* video_parameters);

  // optional .products.AudioAvailable audioavailable = 4;
  inline bool has_audioavailable() const;
  inline void clear_audioavailable();
  static const int kAudioavailableFieldNumber = 4;
  inline const ::products::AudioAvailable& audioavailable() const;
  inline ::products::AudioAvailable* mutable_audioavailable();
  inline ::products::AudioAvailable* release_audioavailable();
  inline void set_allocated_audioavailable(::products::AudioAvailable* audioavailable);

  // @@protoc_insertion_point(class_scope:service_infrastructure.ProductResponseTopic)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_image_available();
  inline void clear_has_image_available();
  inline void set_has_fisd();
  inline void clear_has_fisd();
  inline void set_has_video_parameters();
  inline void clear_has_video_parameters();
  inline void set_has_audioavailable();
  inline void clear_has_audioavailable();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::video_compression_msg::ImageAvailable* image_available_;
  ::products::FisD* fisd_;
  ::service_infrastructure::VideoParameters* video_parameters_;
  ::products::AudioAvailable* audioavailable_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureExclusive_2eproto();

  void InitAsDefaultInstance();
  static ProductResponseTopic* default_instance_;
};
// -------------------------------------------------------------------

class VideoParameters : public ::google::protobuf::Message {
 public:
  VideoParameters();
  virtual ~VideoParameters();

  VideoParameters(const VideoParameters& from);

  inline VideoParameters& operator=(const VideoParameters& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VideoParameters& default_instance();

  void Swap(VideoParameters* other);

  // implements Message ----------------------------------------------

  VideoParameters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VideoParameters& from);
  void MergeFrom(const VideoParameters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string eltex = 1;
  inline bool has_eltex() const;
  inline void clear_eltex();
  static const int kEltexFieldNumber = 1;
  inline const ::std::string& eltex() const;
  inline void set_eltex(const ::std::string& value);
  inline void set_eltex(const char* value);
  inline void set_eltex(const char* value, size_t size);
  inline ::std::string* mutable_eltex();
  inline ::std::string* release_eltex();
  inline void set_allocated_eltex(::std::string* eltex);

  // optional int32 instance = 2;
  inline bool has_instance() const;
  inline void clear_instance();
  static const int kInstanceFieldNumber = 2;
  inline ::google::protobuf::int32 instance() const;
  inline void set_instance(::google::protobuf::int32 value);

  // optional string protocol = 3;
  inline bool has_protocol() const;
  inline void clear_protocol();
  static const int kProtocolFieldNumber = 3;
  inline const ::std::string& protocol() const;
  inline void set_protocol(const ::std::string& value);
  inline void set_protocol(const char* value);
  inline void set_protocol(const char* value, size_t size);
  inline ::std::string* mutable_protocol();
  inline ::std::string* release_protocol();
  inline void set_allocated_protocol(::std::string* protocol);

  // optional string ipaddress = 4;
  inline bool has_ipaddress() const;
  inline void clear_ipaddress();
  static const int kIpaddressFieldNumber = 4;
  inline const ::std::string& ipaddress() const;
  inline void set_ipaddress(const ::std::string& value);
  inline void set_ipaddress(const char* value);
  inline void set_ipaddress(const char* value, size_t size);
  inline ::std::string* mutable_ipaddress();
  inline ::std::string* release_ipaddress();
  inline void set_allocated_ipaddress(::std::string* ipaddress);

  // optional int32 port = 5;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 5;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // optional string globalID = 6;
  inline bool has_globalid() const;
  inline void clear_globalid();
  static const int kGlobalIDFieldNumber = 6;
  inline const ::std::string& globalid() const;
  inline void set_globalid(const ::std::string& value);
  inline void set_globalid(const char* value);
  inline void set_globalid(const char* value, size_t size);
  inline ::std::string* mutable_globalid();
  inline ::std::string* release_globalid();
  inline void set_allocated_globalid(::std::string* globalid);

  // @@protoc_insertion_point(class_scope:service_infrastructure.VideoParameters)
 private:
  inline void set_has_eltex();
  inline void clear_has_eltex();
  inline void set_has_instance();
  inline void clear_has_instance();
  inline void set_has_protocol();
  inline void clear_has_protocol();
  inline void set_has_ipaddress();
  inline void clear_has_ipaddress();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_globalid();
  inline void clear_has_globalid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* eltex_;
  ::std::string* protocol_;
  ::google::protobuf::int32 instance_;
  ::google::protobuf::int32 port_;
  ::std::string* ipaddress_;
  ::std::string* globalid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureExclusive_2eproto();

  void InitAsDefaultInstance();
  static VideoParameters* default_instance_;
};
// -------------------------------------------------------------------

class ESProductTopic : public ::google::protobuf::Message {
 public:
  ESProductTopic();
  virtual ~ESProductTopic();

  ESProductTopic(const ESProductTopic& from);

  inline ESProductTopic& operator=(const ESProductTopic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ESProductTopic& default_instance();

  void Swap(ESProductTopic* other);

  // implements Message ----------------------------------------------

  ESProductTopic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ESProductTopic& from);
  void MergeFrom(const ESProductTopic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 100;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 100;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional .es_product_msg.ESObservablesRegister es_observables_register = 1;
  inline bool has_es_observables_register() const;
  inline void clear_es_observables_register();
  static const int kEsObservablesRegisterFieldNumber = 1;
  inline const ::es_product_msg::ESObservablesRegister& es_observables_register() const;
  inline ::es_product_msg::ESObservablesRegister* mutable_es_observables_register();
  inline ::es_product_msg::ESObservablesRegister* release_es_observables_register();
  inline void set_allocated_es_observables_register(::es_product_msg::ESObservablesRegister* es_observables_register);

  // optional .es_product_msg.ESObservablesUnregister es_observables_unregister = 2;
  inline bool has_es_observables_unregister() const;
  inline void clear_es_observables_unregister();
  static const int kEsObservablesUnregisterFieldNumber = 2;
  inline const ::es_product_msg::ESObservablesUnregister& es_observables_unregister() const;
  inline ::es_product_msg::ESObservablesUnregister* mutable_es_observables_unregister();
  inline ::es_product_msg::ESObservablesUnregister* release_es_observables_unregister();
  inline void set_allocated_es_observables_unregister(::es_product_msg::ESObservablesUnregister* es_observables_unregister);

  // optional .es_product_msg.ESObservables es_observables = 3;
  inline bool has_es_observables() const;
  inline void clear_es_observables();
  static const int kEsObservablesFieldNumber = 3;
  inline const ::es_product_msg::ESObservables& es_observables() const;
  inline ::es_product_msg::ESObservables* mutable_es_observables();
  inline ::es_product_msg::ESObservables* release_es_observables();
  inline void set_allocated_es_observables(::es_product_msg::ESObservables* es_observables);

  // optional .auto_kill_msg.StateResponse state_response = 4;
  inline bool has_state_response() const;
  inline void clear_state_response();
  static const int kStateResponseFieldNumber = 4;
  inline const ::auto_kill_msg::StateResponse& state_response() const;
  inline ::auto_kill_msg::StateResponse* mutable_state_response();
  inline ::auto_kill_msg::StateResponse* release_state_response();
  inline void set_allocated_state_response(::auto_kill_msg::StateResponse* state_response);

  // optional .auto_kill_msg.OverrideState override_state = 5;
  inline bool has_override_state() const;
  inline void clear_override_state();
  static const int kOverrideStateFieldNumber = 5;
  inline const ::auto_kill_msg::OverrideState& override_state() const;
  inline ::auto_kill_msg::OverrideState* mutable_override_state();
  inline ::auto_kill_msg::OverrideState* release_override_state();
  inline void set_allocated_override_state(::auto_kill_msg::OverrideState* override_state);

  // optional .auto_kill_msg.AutoKillGUI autokill_gui = 6;
  inline bool has_autokill_gui() const;
  inline void clear_autokill_gui();
  static const int kAutokillGuiFieldNumber = 6;
  inline const ::auto_kill_msg::AutoKillGUI& autokill_gui() const;
  inline ::auto_kill_msg::AutoKillGUI* mutable_autokill_gui();
  inline ::auto_kill_msg::AutoKillGUI* release_autokill_gui();
  inline void set_allocated_autokill_gui(::auto_kill_msg::AutoKillGUI* autokill_gui);

  // @@protoc_insertion_point(class_scope:service_infrastructure.ESProductTopic)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_es_observables_register();
  inline void clear_has_es_observables_register();
  inline void set_has_es_observables_unregister();
  inline void clear_has_es_observables_unregister();
  inline void set_has_es_observables();
  inline void clear_has_es_observables();
  inline void set_has_state_response();
  inline void clear_has_state_response();
  inline void set_has_override_state();
  inline void clear_has_override_state();
  inline void set_has_autokill_gui();
  inline void clear_has_autokill_gui();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::es_product_msg::ESObservablesRegister* es_observables_register_;
  ::es_product_msg::ESObservablesUnregister* es_observables_unregister_;
  ::es_product_msg::ESObservables* es_observables_;
  ::auto_kill_msg::StateResponse* state_response_;
  ::auto_kill_msg::OverrideState* override_state_;
  ::auto_kill_msg::AutoKillGUI* autokill_gui_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureExclusive_2eproto();

  void InitAsDefaultInstance();
  static ESProductTopic* default_instance_;
};
// -------------------------------------------------------------------

class InfrastructureEnvelope : public ::google::protobuf::Message {
 public:
  InfrastructureEnvelope();
  virtual ~InfrastructureEnvelope();

  InfrastructureEnvelope(const InfrastructureEnvelope& from);

  inline InfrastructureEnvelope& operator=(const InfrastructureEnvelope& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InfrastructureEnvelope& default_instance();

  void Swap(InfrastructureEnvelope* other);

  // implements Message ----------------------------------------------

  InfrastructureEnvelope* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InfrastructureEnvelope& from);
  void MergeFrom(const InfrastructureEnvelope& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional .service_infrastructure.HandshakeTopic handshake = 2;
  inline bool has_handshake() const;
  inline void clear_handshake();
  static const int kHandshakeFieldNumber = 2;
  inline const ::service_infrastructure::HandshakeTopic& handshake() const;
  inline ::service_infrastructure::HandshakeTopic* mutable_handshake();
  inline ::service_infrastructure::HandshakeTopic* release_handshake();
  inline void set_allocated_handshake(::service_infrastructure::HandshakeTopic* handshake);

  // optional .service_infrastructure.EWRequestTopic ew_request = 3;
  inline bool has_ew_request() const;
  inline void clear_ew_request();
  static const int kEwRequestFieldNumber = 3;
  inline const ::service_infrastructure::EWRequestTopic& ew_request() const;
  inline ::service_infrastructure::EWRequestTopic* mutable_ew_request();
  inline ::service_infrastructure::EWRequestTopic* release_ew_request();
  inline void set_allocated_ew_request(::service_infrastructure::EWRequestTopic* ew_request);

  // optional .service_infrastructure.ProductRequestTopic product_request = 5;
  inline bool has_product_request() const;
  inline void clear_product_request();
  static const int kProductRequestFieldNumber = 5;
  inline const ::service_infrastructure::ProductRequestTopic& product_request() const;
  inline ::service_infrastructure::ProductRequestTopic* mutable_product_request();
  inline ::service_infrastructure::ProductRequestTopic* release_product_request();
  inline void set_allocated_product_request(::service_infrastructure::ProductRequestTopic* product_request);

  // optional .service_infrastructure.RadioControlResponseTopic radio_control_response = 6;
  inline bool has_radio_control_response() const;
  inline void clear_radio_control_response();
  static const int kRadioControlResponseFieldNumber = 6;
  inline const ::service_infrastructure::RadioControlResponseTopic& radio_control_response() const;
  inline ::service_infrastructure::RadioControlResponseTopic* mutable_radio_control_response();
  inline ::service_infrastructure::RadioControlResponseTopic* release_radio_control_response();
  inline void set_allocated_radio_control_response(::service_infrastructure::RadioControlResponseTopic* radio_control_response);

  // optional .service_infrastructure.RadioDataTopic radio_data = 7;
  inline bool has_radio_data() const;
  inline void clear_radio_data();
  static const int kRadioDataFieldNumber = 7;
  inline const ::service_infrastructure::RadioDataTopic& radio_data() const;
  inline ::service_infrastructure::RadioDataTopic* mutable_radio_data();
  inline ::service_infrastructure::RadioDataTopic* release_radio_data();
  inline void set_allocated_radio_data(::service_infrastructure::RadioDataTopic* radio_data);

  // optional .service_infrastructure.DebugTopic debug_topic = 8;
  inline bool has_debug_topic() const;
  inline void clear_debug_topic();
  static const int kDebugTopicFieldNumber = 8;
  inline const ::service_infrastructure::DebugTopic& debug_topic() const;
  inline ::service_infrastructure::DebugTopic* mutable_debug_topic();
  inline ::service_infrastructure::DebugTopic* release_debug_topic();
  inline void set_allocated_debug_topic(::service_infrastructure::DebugTopic* debug_topic);

  // @@protoc_insertion_point(class_scope:service_infrastructure.InfrastructureEnvelope)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_handshake();
  inline void clear_has_handshake();
  inline void set_has_ew_request();
  inline void clear_has_ew_request();
  inline void set_has_product_request();
  inline void clear_has_product_request();
  inline void set_has_radio_control_response();
  inline void clear_has_radio_control_response();
  inline void set_has_radio_data();
  inline void clear_has_radio_data();
  inline void set_has_debug_topic();
  inline void clear_has_debug_topic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::service_infrastructure::HandshakeTopic* handshake_;
  ::service_infrastructure::EWRequestTopic* ew_request_;
  ::service_infrastructure::ProductRequestTopic* product_request_;
  ::service_infrastructure::RadioControlResponseTopic* radio_control_response_;
  ::service_infrastructure::RadioDataTopic* radio_data_;
  ::service_infrastructure::DebugTopic* debug_topic_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureExclusive_2eproto();

  void InitAsDefaultInstance();
  static InfrastructureEnvelope* default_instance_;
};
// -------------------------------------------------------------------

class ProductRequestTopic : public ::google::protobuf::Message {
 public:
  ProductRequestTopic();
  virtual ~ProductRequestTopic();

  ProductRequestTopic(const ProductRequestTopic& from);

  inline ProductRequestTopic& operator=(const ProductRequestTopic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProductRequestTopic& default_instance();

  void Swap(ProductRequestTopic* other);

  // implements Message ----------------------------------------------

  ProductRequestTopic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProductRequestTopic& from);
  void MergeFrom(const ProductRequestTopic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 100;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 100;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional .products.FisDRequest fisd = 1;
  inline bool has_fisd() const;
  inline void clear_fisd();
  static const int kFisdFieldNumber = 1;
  inline const ::products::FisDRequest& fisd() const;
  inline ::products::FisDRequest* mutable_fisd();
  inline ::products::FisDRequest* release_fisd();
  inline void set_allocated_fisd(::products::FisDRequest* fisd);

  // optional .service_infrastructure.ImageRequest image = 2;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 2;
  inline const ::service_infrastructure::ImageRequest& image() const;
  inline ::service_infrastructure::ImageRequest* mutable_image();
  inline ::service_infrastructure::ImageRequest* release_image();
  inline void set_allocated_image(::service_infrastructure::ImageRequest* image);

  // optional .service_infrastructure.VideoRequest video = 3;
  inline bool has_video() const;
  inline void clear_video();
  static const int kVideoFieldNumber = 3;
  inline const ::service_infrastructure::VideoRequest& video() const;
  inline ::service_infrastructure::VideoRequest* mutable_video();
  inline ::service_infrastructure::VideoRequest* release_video();
  inline void set_allocated_video(::service_infrastructure::VideoRequest* video);

  // optional .products.AudioRequest audio = 4;
  inline bool has_audio() const;
  inline void clear_audio();
  static const int kAudioFieldNumber = 4;
  inline const ::products::AudioRequest& audio() const;
  inline ::products::AudioRequest* mutable_audio();
  inline ::products::AudioRequest* release_audio();
  inline void set_allocated_audio(::products::AudioRequest* audio);

  // @@protoc_insertion_point(class_scope:service_infrastructure.ProductRequestTopic)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_fisd();
  inline void clear_has_fisd();
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_video();
  inline void clear_has_video();
  inline void set_has_audio();
  inline void clear_has_audio();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::products::FisDRequest* fisd_;
  ::service_infrastructure::ImageRequest* image_;
  ::service_infrastructure::VideoRequest* video_;
  ::products::AudioRequest* audio_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureExclusive_2eproto();

  void InitAsDefaultInstance();
  static ProductRequestTopic* default_instance_;
};
// -------------------------------------------------------------------

class EWRequestTopic : public ::google::protobuf::Message {
 public:
  EWRequestTopic();
  virtual ~EWRequestTopic();

  EWRequestTopic(const EWRequestTopic& from);

  inline EWRequestTopic& operator=(const EWRequestTopic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EWRequestTopic& default_instance();

  void Swap(EWRequestTopic* other);

  // implements Message ----------------------------------------------

  EWRequestTopic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EWRequestTopic& from);
  void MergeFrom(const EWRequestTopic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 100;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 100;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional .fv.tb.protos.TBProtos.EWCommandRequest ew_command_request = 1;
  inline bool has_ew_command_request() const;
  inline void clear_ew_command_request();
  static const int kEwCommandRequestFieldNumber = 1;
  inline const ::fv::tb::protos::TBProtos::EWCommandRequest& ew_command_request() const;
  inline ::fv::tb::protos::TBProtos::EWCommandRequest* mutable_ew_command_request();
  inline ::fv::tb::protos::TBProtos::EWCommandRequest* release_ew_command_request();
  inline void set_allocated_ew_command_request(::fv::tb::protos::TBProtos::EWCommandRequest* ew_command_request);

  // optional .fv.tb.protos.TBProtos.EWCeaseBuzzer ew_cease_buzzer = 2;
  inline bool has_ew_cease_buzzer() const;
  inline void clear_ew_cease_buzzer();
  static const int kEwCeaseBuzzerFieldNumber = 2;
  inline const ::fv::tb::protos::TBProtos::EWCeaseBuzzer& ew_cease_buzzer() const;
  inline ::fv::tb::protos::TBProtos::EWCeaseBuzzer* mutable_ew_cease_buzzer();
  inline ::fv::tb::protos::TBProtos::EWCeaseBuzzer* release_ew_cease_buzzer();
  inline void set_allocated_ew_cease_buzzer(::fv::tb::protos::TBProtos::EWCeaseBuzzer* ew_cease_buzzer);

  // optional .fv.tb.protos.TBProtos.EWStatusRequest ew_status_request = 4;
  inline bool has_ew_status_request() const;
  inline void clear_ew_status_request();
  static const int kEwStatusRequestFieldNumber = 4;
  inline const ::fv::tb::protos::TBProtos::EWStatusRequest& ew_status_request() const;
  inline ::fv::tb::protos::TBProtos::EWStatusRequest* mutable_ew_status_request();
  inline ::fv::tb::protos::TBProtos::EWStatusRequest* release_ew_status_request();
  inline void set_allocated_ew_status_request(::fv::tb::protos::TBProtos::EWStatusRequest* ew_status_request);

  // optional .fv.tb.protos.TBProtos.EWOptionsRequest ew_options_request = 5;
  inline bool has_ew_options_request() const;
  inline void clear_ew_options_request();
  static const int kEwOptionsRequestFieldNumber = 5;
  inline const ::fv::tb::protos::TBProtos::EWOptionsRequest& ew_options_request() const;
  inline ::fv::tb::protos::TBProtos::EWOptionsRequest* mutable_ew_options_request();
  inline ::fv::tb::protos::TBProtos::EWOptionsRequest* release_ew_options_request();
  inline void set_allocated_ew_options_request(::fv::tb::protos::TBProtos::EWOptionsRequest* ew_options_request);

  // optional .fv.tb.protos.TBProtos.RegisterRequest register_request = 6;
  inline bool has_register_request() const;
  inline void clear_register_request();
  static const int kRegisterRequestFieldNumber = 6;
  inline const ::fv::tb::protos::TBProtos::RegisterRequest& register_request() const;
  inline ::fv::tb::protos::TBProtos::RegisterRequest* mutable_register_request();
  inline ::fv::tb::protos::TBProtos::RegisterRequest* release_register_request();
  inline void set_allocated_register_request(::fv::tb::protos::TBProtos::RegisterRequest* register_request);

  // optional .fv.tb.protos.TBProtos.RegisterQuery register_query = 7;
  inline bool has_register_query() const;
  inline void clear_register_query();
  static const int kRegisterQueryFieldNumber = 7;
  inline const ::fv::tb::protos::TBProtos::RegisterQuery& register_query() const;
  inline ::fv::tb::protos::TBProtos::RegisterQuery* mutable_register_query();
  inline ::fv::tb::protos::TBProtos::RegisterQuery* release_register_query();
  inline void set_allocated_register_query(::fv::tb::protos::TBProtos::RegisterQuery* register_query);

  // optional .fv.tb.protos.TBProtos.EmergencyJam emergency_jam = 8;
  inline bool has_emergency_jam() const;
  inline void clear_emergency_jam();
  static const int kEmergencyJamFieldNumber = 8;
  inline const ::fv::tb::protos::TBProtos::EmergencyJam& emergency_jam() const;
  inline ::fv::tb::protos::TBProtos::EmergencyJam* mutable_emergency_jam();
  inline ::fv::tb::protos::TBProtos::EmergencyJam* release_emergency_jam();
  inline void set_allocated_emergency_jam(::fv::tb::protos::TBProtos::EmergencyJam* emergency_jam);

  // optional .fv.tb.protos.TBProtos.TxFreqRequest tx_freq_request = 9;
  inline bool has_tx_freq_request() const;
  inline void clear_tx_freq_request();
  static const int kTxFreqRequestFieldNumber = 9;
  inline const ::fv::tb::protos::TBProtos::TxFreqRequest& tx_freq_request() const;
  inline ::fv::tb::protos::TBProtos::TxFreqRequest* mutable_tx_freq_request();
  inline ::fv::tb::protos::TBProtos::TxFreqRequest* release_tx_freq_request();
  inline void set_allocated_tx_freq_request(::fv::tb::protos::TBProtos::TxFreqRequest* tx_freq_request);

  // optional .fv.tb.protos.TBProtos.EWCapabilitiesRequest ew_capabilities_request = 10;
  inline bool has_ew_capabilities_request() const;
  inline void clear_ew_capabilities_request();
  static const int kEwCapabilitiesRequestFieldNumber = 10;
  inline const ::fv::tb::protos::TBProtos::EWCapabilitiesRequest& ew_capabilities_request() const;
  inline ::fv::tb::protos::TBProtos::EWCapabilitiesRequest* mutable_ew_capabilities_request();
  inline ::fv::tb::protos::TBProtos::EWCapabilitiesRequest* release_ew_capabilities_request();
  inline void set_allocated_ew_capabilities_request(::fv::tb::protos::TBProtos::EWCapabilitiesRequest* ew_capabilities_request);

  // optional .fv.tb.protos.TBProtos.EWTransmittingRequest ew_transmitting_request = 11;
  inline bool has_ew_transmitting_request() const;
  inline void clear_ew_transmitting_request();
  static const int kEwTransmittingRequestFieldNumber = 11;
  inline const ::fv::tb::protos::TBProtos::EWTransmittingRequest& ew_transmitting_request() const;
  inline ::fv::tb::protos::TBProtos::EWTransmittingRequest* mutable_ew_transmitting_request();
  inline ::fv::tb::protos::TBProtos::EWTransmittingRequest* release_ew_transmitting_request();
  inline void set_allocated_ew_transmitting_request(::fv::tb::protos::TBProtos::EWTransmittingRequest* ew_transmitting_request);

  // optional .fv.tb.protos.TBProtos.CloseSelf close_self = 12;
  inline bool has_close_self() const;
  inline void clear_close_self();
  static const int kCloseSelfFieldNumber = 12;
  inline const ::fv::tb::protos::TBProtos::CloseSelf& close_self() const;
  inline ::fv::tb::protos::TBProtos::CloseSelf* mutable_close_self();
  inline ::fv::tb::protos::TBProtos::CloseSelf* release_close_self();
  inline void set_allocated_close_self(::fv::tb::protos::TBProtos::CloseSelf* close_self);

  // optional .fv.tb.protos.TBProtos.UnregisterRequest unregister_request = 13;
  inline bool has_unregister_request() const;
  inline void clear_unregister_request();
  static const int kUnregisterRequestFieldNumber = 13;
  inline const ::fv::tb::protos::TBProtos::UnregisterRequest& unregister_request() const;
  inline ::fv::tb::protos::TBProtos::UnregisterRequest* mutable_unregister_request();
  inline ::fv::tb::protos::TBProtos::UnregisterRequest* release_unregister_request();
  inline void set_allocated_unregister_request(::fv::tb::protos::TBProtos::UnregisterRequest* unregister_request);

  // optional .fv.tb.protos.TBProtos.EWTechniqueDescriptionsRequest ew_technique_descriptions_request = 14;
  inline bool has_ew_technique_descriptions_request() const;
  inline void clear_ew_technique_descriptions_request();
  static const int kEwTechniqueDescriptionsRequestFieldNumber = 14;
  inline const ::fv::tb::protos::TBProtos::EWTechniqueDescriptionsRequest& ew_technique_descriptions_request() const;
  inline ::fv::tb::protos::TBProtos::EWTechniqueDescriptionsRequest* mutable_ew_technique_descriptions_request();
  inline ::fv::tb::protos::TBProtos::EWTechniqueDescriptionsRequest* release_ew_technique_descriptions_request();
  inline void set_allocated_ew_technique_descriptions_request(::fv::tb::protos::TBProtos::EWTechniqueDescriptionsRequest* ew_technique_descriptions_request);

  // @@protoc_insertion_point(class_scope:service_infrastructure.EWRequestTopic)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_ew_command_request();
  inline void clear_has_ew_command_request();
  inline void set_has_ew_cease_buzzer();
  inline void clear_has_ew_cease_buzzer();
  inline void set_has_ew_status_request();
  inline void clear_has_ew_status_request();
  inline void set_has_ew_options_request();
  inline void clear_has_ew_options_request();
  inline void set_has_register_request();
  inline void clear_has_register_request();
  inline void set_has_register_query();
  inline void clear_has_register_query();
  inline void set_has_emergency_jam();
  inline void clear_has_emergency_jam();
  inline void set_has_tx_freq_request();
  inline void clear_has_tx_freq_request();
  inline void set_has_ew_capabilities_request();
  inline void clear_has_ew_capabilities_request();
  inline void set_has_ew_transmitting_request();
  inline void clear_has_ew_transmitting_request();
  inline void set_has_close_self();
  inline void clear_has_close_self();
  inline void set_has_unregister_request();
  inline void clear_has_unregister_request();
  inline void set_has_ew_technique_descriptions_request();
  inline void clear_has_ew_technique_descriptions_request();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::fv::tb::protos::TBProtos::EWCommandRequest* ew_command_request_;
  ::fv::tb::protos::TBProtos::EWCeaseBuzzer* ew_cease_buzzer_;
  ::fv::tb::protos::TBProtos::EWStatusRequest* ew_status_request_;
  ::fv::tb::protos::TBProtos::EWOptionsRequest* ew_options_request_;
  ::fv::tb::protos::TBProtos::RegisterRequest* register_request_;
  ::fv::tb::protos::TBProtos::RegisterQuery* register_query_;
  ::fv::tb::protos::TBProtos::EmergencyJam* emergency_jam_;
  ::fv::tb::protos::TBProtos::TxFreqRequest* tx_freq_request_;
  ::fv::tb::protos::TBProtos::EWCapabilitiesRequest* ew_capabilities_request_;
  ::fv::tb::protos::TBProtos::EWTransmittingRequest* ew_transmitting_request_;
  ::fv::tb::protos::TBProtos::CloseSelf* close_self_;
  ::fv::tb::protos::TBProtos::UnregisterRequest* unregister_request_;
  ::fv::tb::protos::TBProtos::EWTechniqueDescriptionsRequest* ew_technique_descriptions_request_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureExclusive_2eproto();

  void InitAsDefaultInstance();
  static EWRequestTopic* default_instance_;
};
// -------------------------------------------------------------------

class CapabilityRequestTopic : public ::google::protobuf::Message {
 public:
  CapabilityRequestTopic();
  virtual ~CapabilityRequestTopic();

  CapabilityRequestTopic(const CapabilityRequestTopic& from);

  inline CapabilityRequestTopic& operator=(const CapabilityRequestTopic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CapabilityRequestTopic& default_instance();

  void Swap(CapabilityRequestTopic* other);

  // implements Message ----------------------------------------------

  CapabilityRequestTopic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CapabilityRequestTopic& from);
  void MergeFrom(const CapabilityRequestTopic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 100;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 100;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional .fv.tb.protos.TBProtos.JamOff jam_off = 10;
  inline bool has_jam_off() const;
  inline void clear_jam_off();
  static const int kJamOffFieldNumber = 10;
  inline const ::fv::tb::protos::TBProtos::JamOff& jam_off() const;
  inline ::fv::tb::protos::TBProtos::JamOff* mutable_jam_off();
  inline ::fv::tb::protos::TBProtos::JamOff* release_jam_off();
  inline void set_allocated_jam_off(::fv::tb::protos::TBProtos::JamOff* jam_off);

  // optional .fv.tb.protos.TBProtos.techniqueCommand technique_command = 11;
  inline bool has_technique_command() const;
  inline void clear_technique_command();
  static const int kTechniqueCommandFieldNumber = 11;
  inline const ::fv::tb::protos::TBProtos::techniqueCommand& technique_command() const;
  inline ::fv::tb::protos::TBProtos::techniqueCommand* mutable_technique_command();
  inline ::fv::tb::protos::TBProtos::techniqueCommand* release_technique_command();
  inline void set_allocated_technique_command(::fv::tb::protos::TBProtos::techniqueCommand* technique_command);

  // @@protoc_insertion_point(class_scope:service_infrastructure.CapabilityRequestTopic)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_jam_off();
  inline void clear_has_jam_off();
  inline void set_has_technique_command();
  inline void clear_has_technique_command();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::fv::tb::protos::TBProtos::JamOff* jam_off_;
  ::fv::tb::protos::TBProtos::techniqueCommand* technique_command_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureExclusive_2eproto();

  void InitAsDefaultInstance();
  static CapabilityRequestTopic* default_instance_;
};
// -------------------------------------------------------------------

class TransmitterControlRequestTopic : public ::google::protobuf::Message {
 public:
  TransmitterControlRequestTopic();
  virtual ~TransmitterControlRequestTopic();

  TransmitterControlRequestTopic(const TransmitterControlRequestTopic& from);

  inline TransmitterControlRequestTopic& operator=(const TransmitterControlRequestTopic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransmitterControlRequestTopic& default_instance();

  void Swap(TransmitterControlRequestTopic* other);

  // implements Message ----------------------------------------------

  TransmitterControlRequestTopic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransmitterControlRequestTopic& from);
  void MergeFrom(const TransmitterControlRequestTopic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 100;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 100;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional .tuner_msg.TxTune txTune = 7;
  inline bool has_txtune() const;
  inline void clear_txtune();
  static const int kTxTuneFieldNumber = 7;
  inline const ::tuner_msg::TxTune& txtune() const;
  inline ::tuner_msg::TxTune* mutable_txtune();
  inline ::tuner_msg::TxTune* release_txtune();
  inline void set_allocated_txtune(::tuner_msg::TxTune* txtune);

  // optional .tuner_msg.ReactiveJam reactiveJam = 10;
  inline bool has_reactivejam() const;
  inline void clear_reactivejam();
  static const int kReactiveJamFieldNumber = 10;
  inline const ::tuner_msg::ReactiveJam& reactivejam() const;
  inline ::tuner_msg::ReactiveJam* mutable_reactivejam();
  inline ::tuner_msg::ReactiveJam* release_reactivejam();
  inline void set_allocated_reactivejam(::tuner_msg::ReactiveJam* reactivejam);

  // @@protoc_insertion_point(class_scope:service_infrastructure.TransmitterControlRequestTopic)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_txtune();
  inline void clear_has_txtune();
  inline void set_has_reactivejam();
  inline void clear_has_reactivejam();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::tuner_msg::TxTune* txtune_;
  ::tuner_msg::ReactiveJam* reactivejam_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureExclusive_2eproto();

  void InitAsDefaultInstance();
  static TransmitterControlRequestTopic* default_instance_;
};
// -------------------------------------------------------------------

class RadioControlResponseTopic : public ::google::protobuf::Message {
 public:
  RadioControlResponseTopic();
  virtual ~RadioControlResponseTopic();

  RadioControlResponseTopic(const RadioControlResponseTopic& from);

  inline RadioControlResponseTopic& operator=(const RadioControlResponseTopic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RadioControlResponseTopic& default_instance();

  void Swap(RadioControlResponseTopic* other);

  // implements Message ----------------------------------------------

  RadioControlResponseTopic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RadioControlResponseTopic& from);
  void MergeFrom(const RadioControlResponseTopic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 100;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 100;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional .service_infrastructure.Ack ack = 1;
  inline bool has_ack() const;
  inline void clear_ack();
  static const int kAckFieldNumber = 1;
  inline const ::service_infrastructure::Ack& ack() const;
  inline ::service_infrastructure::Ack* mutable_ack();
  inline ::service_infrastructure::Ack* release_ack();
  inline void set_allocated_ack(::service_infrastructure::Ack* ack);

  // optional .service_infrastructure.NAck nack = 2;
  inline bool has_nack() const;
  inline void clear_nack();
  static const int kNackFieldNumber = 2;
  inline const ::service_infrastructure::NAck& nack() const;
  inline ::service_infrastructure::NAck* mutable_nack();
  inline ::service_infrastructure::NAck* release_nack();
  inline void set_allocated_nack(::service_infrastructure::NAck* nack);

  // optional .tuner_msg.ReceiverStatus rx_status = 3;
  inline bool has_rx_status() const;
  inline void clear_rx_status();
  static const int kRxStatusFieldNumber = 3;
  inline const ::tuner_msg::ReceiverStatus& rx_status() const;
  inline ::tuner_msg::ReceiverStatus* mutable_rx_status();
  inline ::tuner_msg::ReceiverStatus* release_rx_status();
  inline void set_allocated_rx_status(::tuner_msg::ReceiverStatus* rx_status);

  // optional .tuner_msg.ReceiverAcquired receiver_acquired = 4;
  inline bool has_receiver_acquired() const;
  inline void clear_receiver_acquired();
  static const int kReceiverAcquiredFieldNumber = 4;
  inline const ::tuner_msg::ReceiverAcquired& receiver_acquired() const;
  inline ::tuner_msg::ReceiverAcquired* mutable_receiver_acquired();
  inline ::tuner_msg::ReceiverAcquired* release_receiver_acquired();
  inline void set_allocated_receiver_acquired(::tuner_msg::ReceiverAcquired* receiver_acquired);

  // optional .tuner_msg.ReceiverReleased receiver_released = 5;
  inline bool has_receiver_released() const;
  inline void clear_receiver_released();
  static const int kReceiverReleasedFieldNumber = 5;
  inline const ::tuner_msg::ReceiverReleased& receiver_released() const;
  inline ::tuner_msg::ReceiverReleased* mutable_receiver_released();
  inline ::tuner_msg::ReceiverReleased* release_receiver_released();
  inline void set_allocated_receiver_released(::tuner_msg::ReceiverReleased* receiver_released);

  // optional .rx_command_msg.RxCommandResponse rx_command_response = 6;
  inline bool has_rx_command_response() const;
  inline void clear_rx_command_response();
  static const int kRxCommandResponseFieldNumber = 6;
  inline const ::rx_command_msg::RxCommandResponse& rx_command_response() const;
  inline ::rx_command_msg::RxCommandResponse* mutable_rx_command_response();
  inline ::rx_command_msg::RxCommandResponse* release_rx_command_response();
  inline void set_allocated_rx_command_response(::rx_command_msg::RxCommandResponse* rx_command_response);

  // @@protoc_insertion_point(class_scope:service_infrastructure.RadioControlResponseTopic)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_ack();
  inline void clear_has_ack();
  inline void set_has_nack();
  inline void clear_has_nack();
  inline void set_has_rx_status();
  inline void clear_has_rx_status();
  inline void set_has_receiver_acquired();
  inline void clear_has_receiver_acquired();
  inline void set_has_receiver_released();
  inline void clear_has_receiver_released();
  inline void set_has_rx_command_response();
  inline void clear_has_rx_command_response();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::service_infrastructure::Ack* ack_;
  ::service_infrastructure::NAck* nack_;
  ::tuner_msg::ReceiverStatus* rx_status_;
  ::tuner_msg::ReceiverAcquired* receiver_acquired_;
  ::tuner_msg::ReceiverReleased* receiver_released_;
  ::rx_command_msg::RxCommandResponse* rx_command_response_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureExclusive_2eproto();

  void InitAsDefaultInstance();
  static RadioControlResponseTopic* default_instance_;
};
// -------------------------------------------------------------------

class DebugTopic : public ::google::protobuf::Message {
 public:
  DebugTopic();
  virtual ~DebugTopic();

  DebugTopic(const DebugTopic& from);

  inline DebugTopic& operator=(const DebugTopic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugTopic& default_instance();

  void Swap(DebugTopic* other);

  // implements Message ----------------------------------------------

  DebugTopic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DebugTopic& from);
  void MergeFrom(const DebugTopic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 100;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 100;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional .falcon_debug_msg.Info info = 1;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::falcon_debug_msg::Info& info() const;
  inline ::falcon_debug_msg::Info* mutable_info();
  inline ::falcon_debug_msg::Info* release_info();
  inline void set_allocated_info(::falcon_debug_msg::Info* info);

  // optional .falcon_debug_msg.Info hostname = 10;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 10;
  inline const ::falcon_debug_msg::Info& hostname() const;
  inline ::falcon_debug_msg::Info* mutable_hostname();
  inline ::falcon_debug_msg::Info* release_hostname();
  inline void set_allocated_hostname(::falcon_debug_msg::Info* hostname);

  // optional .falcon_debug_msg.Warning warning = 2;
  inline bool has_warning() const;
  inline void clear_warning();
  static const int kWarningFieldNumber = 2;
  inline const ::falcon_debug_msg::Warning& warning() const;
  inline ::falcon_debug_msg::Warning* mutable_warning();
  inline ::falcon_debug_msg::Warning* release_warning();
  inline void set_allocated_warning(::falcon_debug_msg::Warning* warning);

  // optional .falcon_debug_msg.Error error = 3;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 3;
  inline const ::falcon_debug_msg::Error& error() const;
  inline ::falcon_debug_msg::Error* mutable_error();
  inline ::falcon_debug_msg::Error* release_error();
  inline void set_allocated_error(::falcon_debug_msg::Error* error);

  // @@protoc_insertion_point(class_scope:service_infrastructure.DebugTopic)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_warning();
  inline void clear_has_warning();
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::falcon_debug_msg::Info* info_;
  ::falcon_debug_msg::Info* hostname_;
  ::falcon_debug_msg::Warning* warning_;
  ::falcon_debug_msg::Error* error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureExclusive_2eproto();

  void InitAsDefaultInstance();
  static DebugTopic* default_instance_;
};
// -------------------------------------------------------------------

class SigFramesTopic : public ::google::protobuf::Message {
 public:
  SigFramesTopic();
  virtual ~SigFramesTopic();

  SigFramesTopic(const SigFramesTopic& from);

  inline SigFramesTopic& operator=(const SigFramesTopic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SigFramesTopic& default_instance();

  void Swap(SigFramesTopic* other);

  // implements Message ----------------------------------------------

  SigFramesTopic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SigFramesTopic& from);
  void MergeFrom(const SigFramesTopic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 100;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 100;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional .fv.sf.protos.SFProtos.SIGFrame sigframe = 1;
  inline bool has_sigframe() const;
  inline void clear_sigframe();
  static const int kSigframeFieldNumber = 1;
  inline const ::fv::sf::protos::SFProtos::SIGFrame& sigframe() const;
  inline ::fv::sf::protos::SFProtos::SIGFrame* mutable_sigframe();
  inline ::fv::sf::protos::SFProtos::SIGFrame* release_sigframe();
  inline void set_allocated_sigframe(::fv::sf::protos::SFProtos::SIGFrame* sigframe);

  // @@protoc_insertion_point(class_scope:service_infrastructure.SigFramesTopic)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_sigframe();
  inline void clear_has_sigframe();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::fv::sf::protos::SFProtos::SIGFrame* sigframe_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureExclusive_2eproto();

  void InitAsDefaultInstance();
  static SigFramesTopic* default_instance_;
};
// -------------------------------------------------------------------

class RadioDataTopic : public ::google::protobuf::Message {
 public:
  RadioDataTopic();
  virtual ~RadioDataTopic();

  RadioDataTopic(const RadioDataTopic& from);

  inline RadioDataTopic& operator=(const RadioDataTopic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RadioDataTopic& default_instance();

  void Swap(RadioDataTopic* other);

  // implements Message ----------------------------------------------

  RadioDataTopic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RadioDataTopic& from);
  void MergeFrom(const RadioDataTopic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 100;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 100;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional .tuner_msg.SnapInfo snap_info = 1;
  inline bool has_snap_info() const;
  inline void clear_snap_info();
  static const int kSnapInfoFieldNumber = 1;
  inline const ::tuner_msg::SnapInfo& snap_info() const;
  inline ::tuner_msg::SnapInfo* mutable_snap_info();
  inline ::tuner_msg::SnapInfo* release_snap_info();
  inline void set_allocated_snap_info(::tuner_msg::SnapInfo* snap_info);

  // @@protoc_insertion_point(class_scope:service_infrastructure.RadioDataTopic)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_snap_info();
  inline void clear_has_snap_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::tuner_msg::SnapInfo* snap_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureExclusive_2eproto();

  void InitAsDefaultInstance();
  static RadioDataTopic* default_instance_;
};
// -------------------------------------------------------------------

class GeoTopic : public ::google::protobuf::Message {
 public:
  GeoTopic();
  virtual ~GeoTopic();

  GeoTopic(const GeoTopic& from);

  inline GeoTopic& operator=(const GeoTopic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GeoTopic& default_instance();

  void Swap(GeoTopic* other);

  // implements Message ----------------------------------------------

  GeoTopic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GeoTopic& from);
  void MergeFrom(const GeoTopic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 100;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 100;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional .falcon_common_msg.GeoTip geo_tip = 1;
  inline bool has_geo_tip() const;
  inline void clear_geo_tip();
  static const int kGeoTipFieldNumber = 1;
  inline const ::falcon_common_msg::GeoTip& geo_tip() const;
  inline ::falcon_common_msg::GeoTip* mutable_geo_tip();
  inline ::falcon_common_msg::GeoTip* release_geo_tip();
  inline void set_allocated_geo_tip(::falcon_common_msg::GeoTip* geo_tip);

  // optional .falcon_common_msg.GeoResult geo_result = 2;
  inline bool has_geo_result() const;
  inline void clear_geo_result();
  static const int kGeoResultFieldNumber = 2;
  inline const ::falcon_common_msg::GeoResult& geo_result() const;
  inline ::falcon_common_msg::GeoResult* mutable_geo_result();
  inline ::falcon_common_msg::GeoResult* release_geo_result();
  inline void set_allocated_geo_result(::falcon_common_msg::GeoResult* geo_result);

  // optional .falcon_common_msg.DetectionTip detection_tip = 3;
  inline bool has_detection_tip() const;
  inline void clear_detection_tip();
  static const int kDetectionTipFieldNumber = 3;
  inline const ::falcon_common_msg::DetectionTip& detection_tip() const;
  inline ::falcon_common_msg::DetectionTip* mutable_detection_tip();
  inline ::falcon_common_msg::DetectionTip* release_detection_tip();
  inline void set_allocated_detection_tip(::falcon_common_msg::DetectionTip* detection_tip);

  // @@protoc_insertion_point(class_scope:service_infrastructure.GeoTopic)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_geo_tip();
  inline void clear_has_geo_tip();
  inline void set_has_geo_result();
  inline void clear_has_geo_result();
  inline void set_has_detection_tip();
  inline void clear_has_detection_tip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::falcon_common_msg::GeoTip* geo_tip_;
  ::falcon_common_msg::GeoResult* geo_result_;
  ::falcon_common_msg::DetectionTip* detection_tip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureExclusive_2eproto();

  void InitAsDefaultInstance();
  static GeoTopic* default_instance_;
};
// -------------------------------------------------------------------

class SensorTopic : public ::google::protobuf::Message {
 public:
  SensorTopic();
  virtual ~SensorTopic();

  SensorTopic(const SensorTopic& from);

  inline SensorTopic& operator=(const SensorTopic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorTopic& default_instance();

  void Swap(SensorTopic* other);

  // implements Message ----------------------------------------------

  SensorTopic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SensorTopic& from);
  void MergeFrom(const SensorTopic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 100;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 100;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional .falcon_remoting_msg.HardwareStatus hardware_status = 1;
  inline bool has_hardware_status() const;
  inline void clear_hardware_status();
  static const int kHardwareStatusFieldNumber = 1;
  inline const ::falcon_remoting_msg::HardwareStatus& hardware_status() const;
  inline ::falcon_remoting_msg::HardwareStatus* mutable_hardware_status();
  inline ::falcon_remoting_msg::HardwareStatus* release_hardware_status();
  inline void set_allocated_hardware_status(::falcon_remoting_msg::HardwareStatus* hardware_status);

  // optional .falcon_remoting_msg.SensorPosition sensor_position = 2;
  inline bool has_sensor_position() const;
  inline void clear_sensor_position();
  static const int kSensorPositionFieldNumber = 2;
  inline const ::falcon_remoting_msg::SensorPosition& sensor_position() const;
  inline ::falcon_remoting_msg::SensorPosition* mutable_sensor_position();
  inline ::falcon_remoting_msg::SensorPosition* release_sensor_position();
  inline void set_allocated_sensor_position(::falcon_remoting_msg::SensorPosition* sensor_position);

  // optional .falcon_antenna_msg.SwitchStatus switch_status = 3;
  inline bool has_switch_status() const;
  inline void clear_switch_status();
  static const int kSwitchStatusFieldNumber = 3;
  inline const ::falcon_antenna_msg::SwitchStatus& switch_status() const;
  inline ::falcon_antenna_msg::SwitchStatus* mutable_switch_status();
  inline ::falcon_antenna_msg::SwitchStatus* release_switch_status();
  inline void set_allocated_switch_status(::falcon_antenna_msg::SwitchStatus* switch_status);

  // optional .falcon_remoting_msg.SensorStatus sensor_status = 4;
  inline bool has_sensor_status() const;
  inline void clear_sensor_status();
  static const int kSensorStatusFieldNumber = 4;
  inline const ::falcon_remoting_msg::SensorStatus& sensor_status() const;
  inline ::falcon_remoting_msg::SensorStatus* mutable_sensor_status();
  inline ::falcon_remoting_msg::SensorStatus* release_sensor_status();
  inline void set_allocated_sensor_status(::falcon_remoting_msg::SensorStatus* sensor_status);

  // @@protoc_insertion_point(class_scope:service_infrastructure.SensorTopic)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_hardware_status();
  inline void clear_has_hardware_status();
  inline void set_has_sensor_position();
  inline void clear_has_sensor_position();
  inline void set_has_switch_status();
  inline void clear_has_switch_status();
  inline void set_has_sensor_status();
  inline void clear_has_sensor_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::falcon_remoting_msg::HardwareStatus* hardware_status_;
  ::falcon_remoting_msg::SensorPosition* sensor_position_;
  ::falcon_antenna_msg::SwitchStatus* switch_status_;
  ::falcon_remoting_msg::SensorStatus* sensor_status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureExclusive_2eproto();

  void InitAsDefaultInstance();
  static SensorTopic* default_instance_;
};
// -------------------------------------------------------------------

class ImageRequest : public ::google::protobuf::Message {
 public:
  ImageRequest();
  virtual ~ImageRequest();

  ImageRequest(const ImageRequest& from);

  inline ImageRequest& operator=(const ImageRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageRequest& default_instance();

  void Swap(ImageRequest* other);

  // implements Message ----------------------------------------------

  ImageRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImageRequest& from);
  void MergeFrom(const ImageRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 100;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 100;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional string eltex = 1;
  inline bool has_eltex() const;
  inline void clear_eltex();
  static const int kEltexFieldNumber = 1;
  inline const ::std::string& eltex() const;
  inline void set_eltex(const ::std::string& value);
  inline void set_eltex(const char* value);
  inline void set_eltex(const char* value, size_t size);
  inline ::std::string* mutable_eltex();
  inline ::std::string* release_eltex();
  inline void set_allocated_eltex(::std::string* eltex);

  // optional string connection_id = 2;
  inline bool has_connection_id() const;
  inline void clear_connection_id();
  static const int kConnectionIdFieldNumber = 2;
  inline const ::std::string& connection_id() const;
  inline void set_connection_id(const ::std::string& value);
  inline void set_connection_id(const char* value);
  inline void set_connection_id(const char* value, size_t size);
  inline ::std::string* mutable_connection_id();
  inline ::std::string* release_connection_id();
  inline void set_allocated_connection_id(::std::string* connection_id);

  // @@protoc_insertion_point(class_scope:service_infrastructure.ImageRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_eltex();
  inline void clear_has_eltex();
  inline void set_has_connection_id();
  inline void clear_has_connection_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::std::string* eltex_;
  ::std::string* connection_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureExclusive_2eproto();

  void InitAsDefaultInstance();
  static ImageRequest* default_instance_;
};
// -------------------------------------------------------------------

class VideoRequest : public ::google::protobuf::Message {
 public:
  VideoRequest();
  virtual ~VideoRequest();

  VideoRequest(const VideoRequest& from);

  inline VideoRequest& operator=(const VideoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VideoRequest& default_instance();

  void Swap(VideoRequest* other);

  // implements Message ----------------------------------------------

  VideoRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VideoRequest& from);
  void MergeFrom(const VideoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .service_infrastructure.Header header = 100;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 100;
  inline const ::service_infrastructure::Header& header() const;
  inline ::service_infrastructure::Header* mutable_header();
  inline ::service_infrastructure::Header* release_header();
  inline void set_allocated_header(::service_infrastructure::Header* header);

  // optional string eltex = 1;
  inline bool has_eltex() const;
  inline void clear_eltex();
  static const int kEltexFieldNumber = 1;
  inline const ::std::string& eltex() const;
  inline void set_eltex(const ::std::string& value);
  inline void set_eltex(const char* value);
  inline void set_eltex(const char* value, size_t size);
  inline ::std::string* mutable_eltex();
  inline ::std::string* release_eltex();
  inline void set_allocated_eltex(::std::string* eltex);

  // optional string connection_id = 2;
  inline bool has_connection_id() const;
  inline void clear_connection_id();
  static const int kConnectionIdFieldNumber = 2;
  inline const ::std::string& connection_id() const;
  inline void set_connection_id(const ::std::string& value);
  inline void set_connection_id(const char* value);
  inline void set_connection_id(const char* value, size_t size);
  inline ::std::string* mutable_connection_id();
  inline ::std::string* release_connection_id();
  inline void set_allocated_connection_id(::std::string* connection_id);

  // @@protoc_insertion_point(class_scope:service_infrastructure.VideoRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_eltex();
  inline void clear_has_eltex();
  inline void set_has_connection_id();
  inline void clear_has_connection_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::service_infrastructure::Header* header_;
  ::std::string* eltex_;
  ::std::string* connection_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_AssignDesc_ServiceInfrastructureExclusive_2eproto();
  friend void protobuf_ShutdownFile_ServiceInfrastructureExclusive_2eproto();

  void InitAsDefaultInstance();
  static VideoRequest* default_instance_;
};
// ===================================================================


// ===================================================================

// ServiceEnvelope

// optional .service_infrastructure.Header header = 1;
inline bool ServiceEnvelope::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceEnvelope::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceEnvelope::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceEnvelope::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& ServiceEnvelope::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* ServiceEnvelope::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* ServiceEnvelope::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ServiceEnvelope::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .service_infrastructure.HandshakeTopic handshake = 2;
inline bool ServiceEnvelope::has_handshake() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceEnvelope::set_has_handshake() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceEnvelope::clear_has_handshake() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceEnvelope::clear_handshake() {
  if (handshake_ != NULL) handshake_->::service_infrastructure::HandshakeTopic::Clear();
  clear_has_handshake();
}
inline const ::service_infrastructure::HandshakeTopic& ServiceEnvelope::handshake() const {
  return handshake_ != NULL ? *handshake_ : *default_instance_->handshake_;
}
inline ::service_infrastructure::HandshakeTopic* ServiceEnvelope::mutable_handshake() {
  set_has_handshake();
  if (handshake_ == NULL) handshake_ = new ::service_infrastructure::HandshakeTopic;
  return handshake_;
}
inline ::service_infrastructure::HandshakeTopic* ServiceEnvelope::release_handshake() {
  clear_has_handshake();
  ::service_infrastructure::HandshakeTopic* temp = handshake_;
  handshake_ = NULL;
  return temp;
}
inline void ServiceEnvelope::set_allocated_handshake(::service_infrastructure::HandshakeTopic* handshake) {
  delete handshake_;
  handshake_ = handshake;
  if (handshake) {
    set_has_handshake();
  } else {
    clear_has_handshake();
  }
}

// optional .service_infrastructure.EWResponseTopic ew_response = 3;
inline bool ServiceEnvelope::has_ew_response() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServiceEnvelope::set_has_ew_response() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServiceEnvelope::clear_has_ew_response() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServiceEnvelope::clear_ew_response() {
  if (ew_response_ != NULL) ew_response_->::service_infrastructure::EWResponseTopic::Clear();
  clear_has_ew_response();
}
inline const ::service_infrastructure::EWResponseTopic& ServiceEnvelope::ew_response() const {
  return ew_response_ != NULL ? *ew_response_ : *default_instance_->ew_response_;
}
inline ::service_infrastructure::EWResponseTopic* ServiceEnvelope::mutable_ew_response() {
  set_has_ew_response();
  if (ew_response_ == NULL) ew_response_ = new ::service_infrastructure::EWResponseTopic;
  return ew_response_;
}
inline ::service_infrastructure::EWResponseTopic* ServiceEnvelope::release_ew_response() {
  clear_has_ew_response();
  ::service_infrastructure::EWResponseTopic* temp = ew_response_;
  ew_response_ = NULL;
  return temp;
}
inline void ServiceEnvelope::set_allocated_ew_response(::service_infrastructure::EWResponseTopic* ew_response) {
  delete ew_response_;
  ew_response_ = ew_response;
  if (ew_response) {
    set_has_ew_response();
  } else {
    clear_has_ew_response();
  }
}

// optional .service_infrastructure.ProductResponseTopic product_response = 5;
inline bool ServiceEnvelope::has_product_response() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServiceEnvelope::set_has_product_response() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServiceEnvelope::clear_has_product_response() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServiceEnvelope::clear_product_response() {
  if (product_response_ != NULL) product_response_->::service_infrastructure::ProductResponseTopic::Clear();
  clear_has_product_response();
}
inline const ::service_infrastructure::ProductResponseTopic& ServiceEnvelope::product_response() const {
  return product_response_ != NULL ? *product_response_ : *default_instance_->product_response_;
}
inline ::service_infrastructure::ProductResponseTopic* ServiceEnvelope::mutable_product_response() {
  set_has_product_response();
  if (product_response_ == NULL) product_response_ = new ::service_infrastructure::ProductResponseTopic;
  return product_response_;
}
inline ::service_infrastructure::ProductResponseTopic* ServiceEnvelope::release_product_response() {
  clear_has_product_response();
  ::service_infrastructure::ProductResponseTopic* temp = product_response_;
  product_response_ = NULL;
  return temp;
}
inline void ServiceEnvelope::set_allocated_product_response(::service_infrastructure::ProductResponseTopic* product_response) {
  delete product_response_;
  product_response_ = product_response;
  if (product_response) {
    set_has_product_response();
  } else {
    clear_has_product_response();
  }
}

// optional .service_infrastructure.RadioControlRequestTopic radio_control_request = 6;
inline bool ServiceEnvelope::has_radio_control_request() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServiceEnvelope::set_has_radio_control_request() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServiceEnvelope::clear_has_radio_control_request() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServiceEnvelope::clear_radio_control_request() {
  if (radio_control_request_ != NULL) radio_control_request_->::service_infrastructure::RadioControlRequestTopic::Clear();
  clear_has_radio_control_request();
}
inline const ::service_infrastructure::RadioControlRequestTopic& ServiceEnvelope::radio_control_request() const {
  return radio_control_request_ != NULL ? *radio_control_request_ : *default_instance_->radio_control_request_;
}
inline ::service_infrastructure::RadioControlRequestTopic* ServiceEnvelope::mutable_radio_control_request() {
  set_has_radio_control_request();
  if (radio_control_request_ == NULL) radio_control_request_ = new ::service_infrastructure::RadioControlRequestTopic;
  return radio_control_request_;
}
inline ::service_infrastructure::RadioControlRequestTopic* ServiceEnvelope::release_radio_control_request() {
  clear_has_radio_control_request();
  ::service_infrastructure::RadioControlRequestTopic* temp = radio_control_request_;
  radio_control_request_ = NULL;
  return temp;
}
inline void ServiceEnvelope::set_allocated_radio_control_request(::service_infrastructure::RadioControlRequestTopic* radio_control_request) {
  delete radio_control_request_;
  radio_control_request_ = radio_control_request;
  if (radio_control_request) {
    set_has_radio_control_request();
  } else {
    clear_has_radio_control_request();
  }
}

// optional .service_infrastructure.SignalEventTopic signal_event = 7;
inline bool ServiceEnvelope::has_signal_event() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServiceEnvelope::set_has_signal_event() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServiceEnvelope::clear_has_signal_event() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServiceEnvelope::clear_signal_event() {
  if (signal_event_ != NULL) signal_event_->::service_infrastructure::SignalEventTopic::Clear();
  clear_has_signal_event();
}
inline const ::service_infrastructure::SignalEventTopic& ServiceEnvelope::signal_event() const {
  return signal_event_ != NULL ? *signal_event_ : *default_instance_->signal_event_;
}
inline ::service_infrastructure::SignalEventTopic* ServiceEnvelope::mutable_signal_event() {
  set_has_signal_event();
  if (signal_event_ == NULL) signal_event_ = new ::service_infrastructure::SignalEventTopic;
  return signal_event_;
}
inline ::service_infrastructure::SignalEventTopic* ServiceEnvelope::release_signal_event() {
  clear_has_signal_event();
  ::service_infrastructure::SignalEventTopic* temp = signal_event_;
  signal_event_ = NULL;
  return temp;
}
inline void ServiceEnvelope::set_allocated_signal_event(::service_infrastructure::SignalEventTopic* signal_event) {
  delete signal_event_;
  signal_event_ = signal_event;
  if (signal_event) {
    set_has_signal_event();
  } else {
    clear_has_signal_event();
  }
}

// -------------------------------------------------------------------

// EWResponseTopic

// optional .service_infrastructure.Header header = 100;
inline bool EWResponseTopic::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EWResponseTopic::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EWResponseTopic::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EWResponseTopic::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& EWResponseTopic::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* EWResponseTopic::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* EWResponseTopic::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void EWResponseTopic::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .service_infrastructure.NAck nack = 1;
inline bool EWResponseTopic::has_nack() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EWResponseTopic::set_has_nack() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EWResponseTopic::clear_has_nack() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EWResponseTopic::clear_nack() {
  if (nack_ != NULL) nack_->::service_infrastructure::NAck::Clear();
  clear_has_nack();
}
inline const ::service_infrastructure::NAck& EWResponseTopic::nack() const {
  return nack_ != NULL ? *nack_ : *default_instance_->nack_;
}
inline ::service_infrastructure::NAck* EWResponseTopic::mutable_nack() {
  set_has_nack();
  if (nack_ == NULL) nack_ = new ::service_infrastructure::NAck;
  return nack_;
}
inline ::service_infrastructure::NAck* EWResponseTopic::release_nack() {
  clear_has_nack();
  ::service_infrastructure::NAck* temp = nack_;
  nack_ = NULL;
  return temp;
}
inline void EWResponseTopic::set_allocated_nack(::service_infrastructure::NAck* nack) {
  delete nack_;
  nack_ = nack;
  if (nack) {
    set_has_nack();
  } else {
    clear_has_nack();
  }
}

// optional .service_infrastructure.Ack ack = 2;
inline bool EWResponseTopic::has_ack() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EWResponseTopic::set_has_ack() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EWResponseTopic::clear_has_ack() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EWResponseTopic::clear_ack() {
  if (ack_ != NULL) ack_->::service_infrastructure::Ack::Clear();
  clear_has_ack();
}
inline const ::service_infrastructure::Ack& EWResponseTopic::ack() const {
  return ack_ != NULL ? *ack_ : *default_instance_->ack_;
}
inline ::service_infrastructure::Ack* EWResponseTopic::mutable_ack() {
  set_has_ack();
  if (ack_ == NULL) ack_ = new ::service_infrastructure::Ack;
  return ack_;
}
inline ::service_infrastructure::Ack* EWResponseTopic::release_ack() {
  clear_has_ack();
  ::service_infrastructure::Ack* temp = ack_;
  ack_ = NULL;
  return temp;
}
inline void EWResponseTopic::set_allocated_ack(::service_infrastructure::Ack* ack) {
  delete ack_;
  ack_ = ack;
  if (ack) {
    set_has_ack();
  } else {
    clear_has_ack();
  }
}

// optional .fv.tb.protos.TBProtos.EWStatus ew_status = 3;
inline bool EWResponseTopic::has_ew_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EWResponseTopic::set_has_ew_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EWResponseTopic::clear_has_ew_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EWResponseTopic::clear_ew_status() {
  if (ew_status_ != NULL) ew_status_->::fv::tb::protos::TBProtos::EWStatus::Clear();
  clear_has_ew_status();
}
inline const ::fv::tb::protos::TBProtos::EWStatus& EWResponseTopic::ew_status() const {
  return ew_status_ != NULL ? *ew_status_ : *default_instance_->ew_status_;
}
inline ::fv::tb::protos::TBProtos::EWStatus* EWResponseTopic::mutable_ew_status() {
  set_has_ew_status();
  if (ew_status_ == NULL) ew_status_ = new ::fv::tb::protos::TBProtos::EWStatus;
  return ew_status_;
}
inline ::fv::tb::protos::TBProtos::EWStatus* EWResponseTopic::release_ew_status() {
  clear_has_ew_status();
  ::fv::tb::protos::TBProtos::EWStatus* temp = ew_status_;
  ew_status_ = NULL;
  return temp;
}
inline void EWResponseTopic::set_allocated_ew_status(::fv::tb::protos::TBProtos::EWStatus* ew_status) {
  delete ew_status_;
  ew_status_ = ew_status;
  if (ew_status) {
    set_has_ew_status();
  } else {
    clear_has_ew_status();
  }
}

// optional .fv.tb.protos.TBProtos.EWOptions ew_options = 4;
inline bool EWResponseTopic::has_ew_options() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EWResponseTopic::set_has_ew_options() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EWResponseTopic::clear_has_ew_options() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EWResponseTopic::clear_ew_options() {
  if (ew_options_ != NULL) ew_options_->::fv::tb::protos::TBProtos::EWOptions::Clear();
  clear_has_ew_options();
}
inline const ::fv::tb::protos::TBProtos::EWOptions& EWResponseTopic::ew_options() const {
  return ew_options_ != NULL ? *ew_options_ : *default_instance_->ew_options_;
}
inline ::fv::tb::protos::TBProtos::EWOptions* EWResponseTopic::mutable_ew_options() {
  set_has_ew_options();
  if (ew_options_ == NULL) ew_options_ = new ::fv::tb::protos::TBProtos::EWOptions;
  return ew_options_;
}
inline ::fv::tb::protos::TBProtos::EWOptions* EWResponseTopic::release_ew_options() {
  clear_has_ew_options();
  ::fv::tb::protos::TBProtos::EWOptions* temp = ew_options_;
  ew_options_ = NULL;
  return temp;
}
inline void EWResponseTopic::set_allocated_ew_options(::fv::tb::protos::TBProtos::EWOptions* ew_options) {
  delete ew_options_;
  ew_options_ = ew_options;
  if (ew_options) {
    set_has_ew_options();
  } else {
    clear_has_ew_options();
  }
}

// optional .fv.tb.protos.TBProtos.EWOptionDelete ew_option_delete = 5;
inline bool EWResponseTopic::has_ew_option_delete() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EWResponseTopic::set_has_ew_option_delete() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EWResponseTopic::clear_has_ew_option_delete() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EWResponseTopic::clear_ew_option_delete() {
  if (ew_option_delete_ != NULL) ew_option_delete_->::fv::tb::protos::TBProtos::EWOptionDelete::Clear();
  clear_has_ew_option_delete();
}
inline const ::fv::tb::protos::TBProtos::EWOptionDelete& EWResponseTopic::ew_option_delete() const {
  return ew_option_delete_ != NULL ? *ew_option_delete_ : *default_instance_->ew_option_delete_;
}
inline ::fv::tb::protos::TBProtos::EWOptionDelete* EWResponseTopic::mutable_ew_option_delete() {
  set_has_ew_option_delete();
  if (ew_option_delete_ == NULL) ew_option_delete_ = new ::fv::tb::protos::TBProtos::EWOptionDelete;
  return ew_option_delete_;
}
inline ::fv::tb::protos::TBProtos::EWOptionDelete* EWResponseTopic::release_ew_option_delete() {
  clear_has_ew_option_delete();
  ::fv::tb::protos::TBProtos::EWOptionDelete* temp = ew_option_delete_;
  ew_option_delete_ = NULL;
  return temp;
}
inline void EWResponseTopic::set_allocated_ew_option_delete(::fv::tb::protos::TBProtos::EWOptionDelete* ew_option_delete) {
  delete ew_option_delete_;
  ew_option_delete_ = ew_option_delete;
  if (ew_option_delete) {
    set_has_ew_option_delete();
  } else {
    clear_has_ew_option_delete();
  }
}

// optional .fv.tb.protos.TBProtos.RegisterResponse register_response = 6;
inline bool EWResponseTopic::has_register_response() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EWResponseTopic::set_has_register_response() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EWResponseTopic::clear_has_register_response() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EWResponseTopic::clear_register_response() {
  if (register_response_ != NULL) register_response_->::fv::tb::protos::TBProtos::RegisterResponse::Clear();
  clear_has_register_response();
}
inline const ::fv::tb::protos::TBProtos::RegisterResponse& EWResponseTopic::register_response() const {
  return register_response_ != NULL ? *register_response_ : *default_instance_->register_response_;
}
inline ::fv::tb::protos::TBProtos::RegisterResponse* EWResponseTopic::mutable_register_response() {
  set_has_register_response();
  if (register_response_ == NULL) register_response_ = new ::fv::tb::protos::TBProtos::RegisterResponse;
  return register_response_;
}
inline ::fv::tb::protos::TBProtos::RegisterResponse* EWResponseTopic::release_register_response() {
  clear_has_register_response();
  ::fv::tb::protos::TBProtos::RegisterResponse* temp = register_response_;
  register_response_ = NULL;
  return temp;
}
inline void EWResponseTopic::set_allocated_register_response(::fv::tb::protos::TBProtos::RegisterResponse* register_response) {
  delete register_response_;
  register_response_ = register_response;
  if (register_response) {
    set_has_register_response();
  } else {
    clear_has_register_response();
  }
}

// optional .fv.tb.protos.TBProtos.newSignalFrame new_signal_frame = 7;
inline bool EWResponseTopic::has_new_signal_frame() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EWResponseTopic::set_has_new_signal_frame() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EWResponseTopic::clear_has_new_signal_frame() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EWResponseTopic::clear_new_signal_frame() {
  if (new_signal_frame_ != NULL) new_signal_frame_->::fv::tb::protos::TBProtos::newSignalFrame::Clear();
  clear_has_new_signal_frame();
}
inline const ::fv::tb::protos::TBProtos::newSignalFrame& EWResponseTopic::new_signal_frame() const {
  return new_signal_frame_ != NULL ? *new_signal_frame_ : *default_instance_->new_signal_frame_;
}
inline ::fv::tb::protos::TBProtos::newSignalFrame* EWResponseTopic::mutable_new_signal_frame() {
  set_has_new_signal_frame();
  if (new_signal_frame_ == NULL) new_signal_frame_ = new ::fv::tb::protos::TBProtos::newSignalFrame;
  return new_signal_frame_;
}
inline ::fv::tb::protos::TBProtos::newSignalFrame* EWResponseTopic::release_new_signal_frame() {
  clear_has_new_signal_frame();
  ::fv::tb::protos::TBProtos::newSignalFrame* temp = new_signal_frame_;
  new_signal_frame_ = NULL;
  return temp;
}
inline void EWResponseTopic::set_allocated_new_signal_frame(::fv::tb::protos::TBProtos::newSignalFrame* new_signal_frame) {
  delete new_signal_frame_;
  new_signal_frame_ = new_signal_frame;
  if (new_signal_frame) {
    set_has_new_signal_frame();
  } else {
    clear_has_new_signal_frame();
  }
}

// optional .fv.tb.protos.TBProtos.EWCapabilities ew_capabilities = 8;
inline bool EWResponseTopic::has_ew_capabilities() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EWResponseTopic::set_has_ew_capabilities() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EWResponseTopic::clear_has_ew_capabilities() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EWResponseTopic::clear_ew_capabilities() {
  if (ew_capabilities_ != NULL) ew_capabilities_->::fv::tb::protos::TBProtos::EWCapabilities::Clear();
  clear_has_ew_capabilities();
}
inline const ::fv::tb::protos::TBProtos::EWCapabilities& EWResponseTopic::ew_capabilities() const {
  return ew_capabilities_ != NULL ? *ew_capabilities_ : *default_instance_->ew_capabilities_;
}
inline ::fv::tb::protos::TBProtos::EWCapabilities* EWResponseTopic::mutable_ew_capabilities() {
  set_has_ew_capabilities();
  if (ew_capabilities_ == NULL) ew_capabilities_ = new ::fv::tb::protos::TBProtos::EWCapabilities;
  return ew_capabilities_;
}
inline ::fv::tb::protos::TBProtos::EWCapabilities* EWResponseTopic::release_ew_capabilities() {
  clear_has_ew_capabilities();
  ::fv::tb::protos::TBProtos::EWCapabilities* temp = ew_capabilities_;
  ew_capabilities_ = NULL;
  return temp;
}
inline void EWResponseTopic::set_allocated_ew_capabilities(::fv::tb::protos::TBProtos::EWCapabilities* ew_capabilities) {
  delete ew_capabilities_;
  ew_capabilities_ = ew_capabilities;
  if (ew_capabilities) {
    set_has_ew_capabilities();
  } else {
    clear_has_ew_capabilities();
  }
}

// optional .fv.tb.protos.TBProtos.EWTransmitting ew_transmitting = 9;
inline bool EWResponseTopic::has_ew_transmitting() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EWResponseTopic::set_has_ew_transmitting() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EWResponseTopic::clear_has_ew_transmitting() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EWResponseTopic::clear_ew_transmitting() {
  if (ew_transmitting_ != NULL) ew_transmitting_->::fv::tb::protos::TBProtos::EWTransmitting::Clear();
  clear_has_ew_transmitting();
}
inline const ::fv::tb::protos::TBProtos::EWTransmitting& EWResponseTopic::ew_transmitting() const {
  return ew_transmitting_ != NULL ? *ew_transmitting_ : *default_instance_->ew_transmitting_;
}
inline ::fv::tb::protos::TBProtos::EWTransmitting* EWResponseTopic::mutable_ew_transmitting() {
  set_has_ew_transmitting();
  if (ew_transmitting_ == NULL) ew_transmitting_ = new ::fv::tb::protos::TBProtos::EWTransmitting;
  return ew_transmitting_;
}
inline ::fv::tb::protos::TBProtos::EWTransmitting* EWResponseTopic::release_ew_transmitting() {
  clear_has_ew_transmitting();
  ::fv::tb::protos::TBProtos::EWTransmitting* temp = ew_transmitting_;
  ew_transmitting_ = NULL;
  return temp;
}
inline void EWResponseTopic::set_allocated_ew_transmitting(::fv::tb::protos::TBProtos::EWTransmitting* ew_transmitting) {
  delete ew_transmitting_;
  ew_transmitting_ = ew_transmitting;
  if (ew_transmitting) {
    set_has_ew_transmitting();
  } else {
    clear_has_ew_transmitting();
  }
}

// optional .fv.tb.protos.TBProtos.EWTechniqueDescriptions ew_technique_descriptions = 10;
inline bool EWResponseTopic::has_ew_technique_descriptions() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void EWResponseTopic::set_has_ew_technique_descriptions() {
  _has_bits_[0] |= 0x00000400u;
}
inline void EWResponseTopic::clear_has_ew_technique_descriptions() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void EWResponseTopic::clear_ew_technique_descriptions() {
  if (ew_technique_descriptions_ != NULL) ew_technique_descriptions_->::fv::tb::protos::TBProtos::EWTechniqueDescriptions::Clear();
  clear_has_ew_technique_descriptions();
}
inline const ::fv::tb::protos::TBProtos::EWTechniqueDescriptions& EWResponseTopic::ew_technique_descriptions() const {
  return ew_technique_descriptions_ != NULL ? *ew_technique_descriptions_ : *default_instance_->ew_technique_descriptions_;
}
inline ::fv::tb::protos::TBProtos::EWTechniqueDescriptions* EWResponseTopic::mutable_ew_technique_descriptions() {
  set_has_ew_technique_descriptions();
  if (ew_technique_descriptions_ == NULL) ew_technique_descriptions_ = new ::fv::tb::protos::TBProtos::EWTechniqueDescriptions;
  return ew_technique_descriptions_;
}
inline ::fv::tb::protos::TBProtos::EWTechniqueDescriptions* EWResponseTopic::release_ew_technique_descriptions() {
  clear_has_ew_technique_descriptions();
  ::fv::tb::protos::TBProtos::EWTechniqueDescriptions* temp = ew_technique_descriptions_;
  ew_technique_descriptions_ = NULL;
  return temp;
}
inline void EWResponseTopic::set_allocated_ew_technique_descriptions(::fv::tb::protos::TBProtos::EWTechniqueDescriptions* ew_technique_descriptions) {
  delete ew_technique_descriptions_;
  ew_technique_descriptions_ = ew_technique_descriptions;
  if (ew_technique_descriptions) {
    set_has_ew_technique_descriptions();
  } else {
    clear_has_ew_technique_descriptions();
  }
}

// -------------------------------------------------------------------

// CapabilityResponseTopic

// optional .service_infrastructure.Header header = 100;
inline bool CapabilityResponseTopic::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CapabilityResponseTopic::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CapabilityResponseTopic::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CapabilityResponseTopic::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& CapabilityResponseTopic::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* CapabilityResponseTopic::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* CapabilityResponseTopic::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void CapabilityResponseTopic::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .service_infrastructure.NAck nack = 1;
inline bool CapabilityResponseTopic::has_nack() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CapabilityResponseTopic::set_has_nack() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CapabilityResponseTopic::clear_has_nack() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CapabilityResponseTopic::clear_nack() {
  if (nack_ != NULL) nack_->::service_infrastructure::NAck::Clear();
  clear_has_nack();
}
inline const ::service_infrastructure::NAck& CapabilityResponseTopic::nack() const {
  return nack_ != NULL ? *nack_ : *default_instance_->nack_;
}
inline ::service_infrastructure::NAck* CapabilityResponseTopic::mutable_nack() {
  set_has_nack();
  if (nack_ == NULL) nack_ = new ::service_infrastructure::NAck;
  return nack_;
}
inline ::service_infrastructure::NAck* CapabilityResponseTopic::release_nack() {
  clear_has_nack();
  ::service_infrastructure::NAck* temp = nack_;
  nack_ = NULL;
  return temp;
}
inline void CapabilityResponseTopic::set_allocated_nack(::service_infrastructure::NAck* nack) {
  delete nack_;
  nack_ = nack;
  if (nack) {
    set_has_nack();
  } else {
    clear_has_nack();
  }
}

// optional .service_infrastructure.Ack ack = 2;
inline bool CapabilityResponseTopic::has_ack() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CapabilityResponseTopic::set_has_ack() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CapabilityResponseTopic::clear_has_ack() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CapabilityResponseTopic::clear_ack() {
  if (ack_ != NULL) ack_->::service_infrastructure::Ack::Clear();
  clear_has_ack();
}
inline const ::service_infrastructure::Ack& CapabilityResponseTopic::ack() const {
  return ack_ != NULL ? *ack_ : *default_instance_->ack_;
}
inline ::service_infrastructure::Ack* CapabilityResponseTopic::mutable_ack() {
  set_has_ack();
  if (ack_ == NULL) ack_ = new ::service_infrastructure::Ack;
  return ack_;
}
inline ::service_infrastructure::Ack* CapabilityResponseTopic::release_ack() {
  clear_has_ack();
  ::service_infrastructure::Ack* temp = ack_;
  ack_ = NULL;
  return temp;
}
inline void CapabilityResponseTopic::set_allocated_ack(::service_infrastructure::Ack* ack) {
  delete ack_;
  ack_ = ack;
  if (ack) {
    set_has_ack();
  } else {
    clear_has_ack();
  }
}

// optional .fv.tb.protos.TBProtos.EWCapability ew_capability = 10;
inline bool CapabilityResponseTopic::has_ew_capability() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CapabilityResponseTopic::set_has_ew_capability() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CapabilityResponseTopic::clear_has_ew_capability() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CapabilityResponseTopic::clear_ew_capability() {
  if (ew_capability_ != NULL) ew_capability_->::fv::tb::protos::TBProtos::EWCapability::Clear();
  clear_has_ew_capability();
}
inline const ::fv::tb::protos::TBProtos::EWCapability& CapabilityResponseTopic::ew_capability() const {
  return ew_capability_ != NULL ? *ew_capability_ : *default_instance_->ew_capability_;
}
inline ::fv::tb::protos::TBProtos::EWCapability* CapabilityResponseTopic::mutable_ew_capability() {
  set_has_ew_capability();
  if (ew_capability_ == NULL) ew_capability_ = new ::fv::tb::protos::TBProtos::EWCapability;
  return ew_capability_;
}
inline ::fv::tb::protos::TBProtos::EWCapability* CapabilityResponseTopic::release_ew_capability() {
  clear_has_ew_capability();
  ::fv::tb::protos::TBProtos::EWCapability* temp = ew_capability_;
  ew_capability_ = NULL;
  return temp;
}
inline void CapabilityResponseTopic::set_allocated_ew_capability(::fv::tb::protos::TBProtos::EWCapability* ew_capability) {
  delete ew_capability_;
  ew_capability_ = ew_capability;
  if (ew_capability) {
    set_has_ew_capability();
  } else {
    clear_has_ew_capability();
  }
}

// optional .fv.tb.protos.TBProtos.EWCapabilityUnregister ew_capability_unregister = 11;
inline bool CapabilityResponseTopic::has_ew_capability_unregister() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CapabilityResponseTopic::set_has_ew_capability_unregister() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CapabilityResponseTopic::clear_has_ew_capability_unregister() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CapabilityResponseTopic::clear_ew_capability_unregister() {
  if (ew_capability_unregister_ != NULL) ew_capability_unregister_->::fv::tb::protos::TBProtos::EWCapabilityUnregister::Clear();
  clear_has_ew_capability_unregister();
}
inline const ::fv::tb::protos::TBProtos::EWCapabilityUnregister& CapabilityResponseTopic::ew_capability_unregister() const {
  return ew_capability_unregister_ != NULL ? *ew_capability_unregister_ : *default_instance_->ew_capability_unregister_;
}
inline ::fv::tb::protos::TBProtos::EWCapabilityUnregister* CapabilityResponseTopic::mutable_ew_capability_unregister() {
  set_has_ew_capability_unregister();
  if (ew_capability_unregister_ == NULL) ew_capability_unregister_ = new ::fv::tb::protos::TBProtos::EWCapabilityUnregister;
  return ew_capability_unregister_;
}
inline ::fv::tb::protos::TBProtos::EWCapabilityUnregister* CapabilityResponseTopic::release_ew_capability_unregister() {
  clear_has_ew_capability_unregister();
  ::fv::tb::protos::TBProtos::EWCapabilityUnregister* temp = ew_capability_unregister_;
  ew_capability_unregister_ = NULL;
  return temp;
}
inline void CapabilityResponseTopic::set_allocated_ew_capability_unregister(::fv::tb::protos::TBProtos::EWCapabilityUnregister* ew_capability_unregister) {
  delete ew_capability_unregister_;
  ew_capability_unregister_ = ew_capability_unregister;
  if (ew_capability_unregister) {
    set_has_ew_capability_unregister();
  } else {
    clear_has_ew_capability_unregister();
  }
}

// optional .fv.tb.protos.TBProtos.HopAttackStatus hop_attack_status = 12;
inline bool CapabilityResponseTopic::has_hop_attack_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CapabilityResponseTopic::set_has_hop_attack_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CapabilityResponseTopic::clear_has_hop_attack_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CapabilityResponseTopic::clear_hop_attack_status() {
  if (hop_attack_status_ != NULL) hop_attack_status_->::fv::tb::protos::TBProtos::HopAttackStatus::Clear();
  clear_has_hop_attack_status();
}
inline const ::fv::tb::protos::TBProtos::HopAttackStatus& CapabilityResponseTopic::hop_attack_status() const {
  return hop_attack_status_ != NULL ? *hop_attack_status_ : *default_instance_->hop_attack_status_;
}
inline ::fv::tb::protos::TBProtos::HopAttackStatus* CapabilityResponseTopic::mutable_hop_attack_status() {
  set_has_hop_attack_status();
  if (hop_attack_status_ == NULL) hop_attack_status_ = new ::fv::tb::protos::TBProtos::HopAttackStatus;
  return hop_attack_status_;
}
inline ::fv::tb::protos::TBProtos::HopAttackStatus* CapabilityResponseTopic::release_hop_attack_status() {
  clear_has_hop_attack_status();
  ::fv::tb::protos::TBProtos::HopAttackStatus* temp = hop_attack_status_;
  hop_attack_status_ = NULL;
  return temp;
}
inline void CapabilityResponseTopic::set_allocated_hop_attack_status(::fv::tb::protos::TBProtos::HopAttackStatus* hop_attack_status) {
  delete hop_attack_status_;
  hop_attack_status_ = hop_attack_status;
  if (hop_attack_status) {
    set_has_hop_attack_status();
  } else {
    clear_has_hop_attack_status();
  }
}

// optional .fv.tb.protos.TBProtos.EWCapabilityTransmitting ew_capability_transmitting = 13;
inline bool CapabilityResponseTopic::has_ew_capability_transmitting() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CapabilityResponseTopic::set_has_ew_capability_transmitting() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CapabilityResponseTopic::clear_has_ew_capability_transmitting() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CapabilityResponseTopic::clear_ew_capability_transmitting() {
  if (ew_capability_transmitting_ != NULL) ew_capability_transmitting_->::fv::tb::protos::TBProtos::EWCapabilityTransmitting::Clear();
  clear_has_ew_capability_transmitting();
}
inline const ::fv::tb::protos::TBProtos::EWCapabilityTransmitting& CapabilityResponseTopic::ew_capability_transmitting() const {
  return ew_capability_transmitting_ != NULL ? *ew_capability_transmitting_ : *default_instance_->ew_capability_transmitting_;
}
inline ::fv::tb::protos::TBProtos::EWCapabilityTransmitting* CapabilityResponseTopic::mutable_ew_capability_transmitting() {
  set_has_ew_capability_transmitting();
  if (ew_capability_transmitting_ == NULL) ew_capability_transmitting_ = new ::fv::tb::protos::TBProtos::EWCapabilityTransmitting;
  return ew_capability_transmitting_;
}
inline ::fv::tb::protos::TBProtos::EWCapabilityTransmitting* CapabilityResponseTopic::release_ew_capability_transmitting() {
  clear_has_ew_capability_transmitting();
  ::fv::tb::protos::TBProtos::EWCapabilityTransmitting* temp = ew_capability_transmitting_;
  ew_capability_transmitting_ = NULL;
  return temp;
}
inline void CapabilityResponseTopic::set_allocated_ew_capability_transmitting(::fv::tb::protos::TBProtos::EWCapabilityTransmitting* ew_capability_transmitting) {
  delete ew_capability_transmitting_;
  ew_capability_transmitting_ = ew_capability_transmitting;
  if (ew_capability_transmitting) {
    set_has_ew_capability_transmitting();
  } else {
    clear_has_ew_capability_transmitting();
  }
}

// -------------------------------------------------------------------

// RadioControlRequestTopic

// optional .service_infrastructure.Header header = 100;
inline bool RadioControlRequestTopic::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RadioControlRequestTopic::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RadioControlRequestTopic::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RadioControlRequestTopic::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& RadioControlRequestTopic::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* RadioControlRequestTopic::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* RadioControlRequestTopic::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void RadioControlRequestTopic::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .tuner_msg.DwellScan dwell_scan = 1;
inline bool RadioControlRequestTopic::has_dwell_scan() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RadioControlRequestTopic::set_has_dwell_scan() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RadioControlRequestTopic::clear_has_dwell_scan() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RadioControlRequestTopic::clear_dwell_scan() {
  if (dwell_scan_ != NULL) dwell_scan_->::tuner_msg::DwellScan::Clear();
  clear_has_dwell_scan();
}
inline const ::tuner_msg::DwellScan& RadioControlRequestTopic::dwell_scan() const {
  return dwell_scan_ != NULL ? *dwell_scan_ : *default_instance_->dwell_scan_;
}
inline ::tuner_msg::DwellScan* RadioControlRequestTopic::mutable_dwell_scan() {
  set_has_dwell_scan();
  if (dwell_scan_ == NULL) dwell_scan_ = new ::tuner_msg::DwellScan;
  return dwell_scan_;
}
inline ::tuner_msg::DwellScan* RadioControlRequestTopic::release_dwell_scan() {
  clear_has_dwell_scan();
  ::tuner_msg::DwellScan* temp = dwell_scan_;
  dwell_scan_ = NULL;
  return temp;
}
inline void RadioControlRequestTopic::set_allocated_dwell_scan(::tuner_msg::DwellScan* dwell_scan) {
  delete dwell_scan_;
  dwell_scan_ = dwell_scan;
  if (dwell_scan) {
    set_has_dwell_scan();
  } else {
    clear_has_dwell_scan();
  }
}

// optional .tuner_msg.QueryReceiverStatus rx_query = 2;
inline bool RadioControlRequestTopic::has_rx_query() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RadioControlRequestTopic::set_has_rx_query() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RadioControlRequestTopic::clear_has_rx_query() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RadioControlRequestTopic::clear_rx_query() {
  if (rx_query_ != NULL) rx_query_->::tuner_msg::QueryReceiverStatus::Clear();
  clear_has_rx_query();
}
inline const ::tuner_msg::QueryReceiverStatus& RadioControlRequestTopic::rx_query() const {
  return rx_query_ != NULL ? *rx_query_ : *default_instance_->rx_query_;
}
inline ::tuner_msg::QueryReceiverStatus* RadioControlRequestTopic::mutable_rx_query() {
  set_has_rx_query();
  if (rx_query_ == NULL) rx_query_ = new ::tuner_msg::QueryReceiverStatus;
  return rx_query_;
}
inline ::tuner_msg::QueryReceiverStatus* RadioControlRequestTopic::release_rx_query() {
  clear_has_rx_query();
  ::tuner_msg::QueryReceiverStatus* temp = rx_query_;
  rx_query_ = NULL;
  return temp;
}
inline void RadioControlRequestTopic::set_allocated_rx_query(::tuner_msg::QueryReceiverStatus* rx_query) {
  delete rx_query_;
  rx_query_ = rx_query;
  if (rx_query) {
    set_has_rx_query();
  } else {
    clear_has_rx_query();
  }
}

// optional .tuner_msg.ReceiverRequest receiver_request = 3;
inline bool RadioControlRequestTopic::has_receiver_request() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RadioControlRequestTopic::set_has_receiver_request() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RadioControlRequestTopic::clear_has_receiver_request() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RadioControlRequestTopic::clear_receiver_request() {
  if (receiver_request_ != NULL) receiver_request_->::tuner_msg::ReceiverRequest::Clear();
  clear_has_receiver_request();
}
inline const ::tuner_msg::ReceiverRequest& RadioControlRequestTopic::receiver_request() const {
  return receiver_request_ != NULL ? *receiver_request_ : *default_instance_->receiver_request_;
}
inline ::tuner_msg::ReceiverRequest* RadioControlRequestTopic::mutable_receiver_request() {
  set_has_receiver_request();
  if (receiver_request_ == NULL) receiver_request_ = new ::tuner_msg::ReceiverRequest;
  return receiver_request_;
}
inline ::tuner_msg::ReceiverRequest* RadioControlRequestTopic::release_receiver_request() {
  clear_has_receiver_request();
  ::tuner_msg::ReceiverRequest* temp = receiver_request_;
  receiver_request_ = NULL;
  return temp;
}
inline void RadioControlRequestTopic::set_allocated_receiver_request(::tuner_msg::ReceiverRequest* receiver_request) {
  delete receiver_request_;
  receiver_request_ = receiver_request;
  if (receiver_request) {
    set_has_receiver_request();
  } else {
    clear_has_receiver_request();
  }
}

// optional .tuner_msg.ReceiverRelease receiver_release = 4;
inline bool RadioControlRequestTopic::has_receiver_release() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RadioControlRequestTopic::set_has_receiver_release() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RadioControlRequestTopic::clear_has_receiver_release() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RadioControlRequestTopic::clear_receiver_release() {
  if (receiver_release_ != NULL) receiver_release_->::tuner_msg::ReceiverRelease::Clear();
  clear_has_receiver_release();
}
inline const ::tuner_msg::ReceiverRelease& RadioControlRequestTopic::receiver_release() const {
  return receiver_release_ != NULL ? *receiver_release_ : *default_instance_->receiver_release_;
}
inline ::tuner_msg::ReceiverRelease* RadioControlRequestTopic::mutable_receiver_release() {
  set_has_receiver_release();
  if (receiver_release_ == NULL) receiver_release_ = new ::tuner_msg::ReceiverRelease;
  return receiver_release_;
}
inline ::tuner_msg::ReceiverRelease* RadioControlRequestTopic::release_receiver_release() {
  clear_has_receiver_release();
  ::tuner_msg::ReceiverRelease* temp = receiver_release_;
  receiver_release_ = NULL;
  return temp;
}
inline void RadioControlRequestTopic::set_allocated_receiver_release(::tuner_msg::ReceiverRelease* receiver_release) {
  delete receiver_release_;
  receiver_release_ = receiver_release;
  if (receiver_release) {
    set_has_receiver_release();
  } else {
    clear_has_receiver_release();
  }
}

// optional .rx_command_msg.RxCommandRequest rx_command_request = 5;
inline bool RadioControlRequestTopic::has_rx_command_request() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RadioControlRequestTopic::set_has_rx_command_request() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RadioControlRequestTopic::clear_has_rx_command_request() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RadioControlRequestTopic::clear_rx_command_request() {
  if (rx_command_request_ != NULL) rx_command_request_->::rx_command_msg::RxCommandRequest::Clear();
  clear_has_rx_command_request();
}
inline const ::rx_command_msg::RxCommandRequest& RadioControlRequestTopic::rx_command_request() const {
  return rx_command_request_ != NULL ? *rx_command_request_ : *default_instance_->rx_command_request_;
}
inline ::rx_command_msg::RxCommandRequest* RadioControlRequestTopic::mutable_rx_command_request() {
  set_has_rx_command_request();
  if (rx_command_request_ == NULL) rx_command_request_ = new ::rx_command_msg::RxCommandRequest;
  return rx_command_request_;
}
inline ::rx_command_msg::RxCommandRequest* RadioControlRequestTopic::release_rx_command_request() {
  clear_has_rx_command_request();
  ::rx_command_msg::RxCommandRequest* temp = rx_command_request_;
  rx_command_request_ = NULL;
  return temp;
}
inline void RadioControlRequestTopic::set_allocated_rx_command_request(::rx_command_msg::RxCommandRequest* rx_command_request) {
  delete rx_command_request_;
  rx_command_request_ = rx_command_request;
  if (rx_command_request) {
    set_has_rx_command_request();
  } else {
    clear_has_rx_command_request();
  }
}

// -------------------------------------------------------------------

// SignalEventTopic

// optional .service_infrastructure.Header header = 100;
inline bool SignalEventTopic::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignalEventTopic::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignalEventTopic::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignalEventTopic::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& SignalEventTopic::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* SignalEventTopic::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* SignalEventTopic::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void SignalEventTopic::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .falcon_remoting_msg.SignalEvent signal_event = 1;
inline bool SignalEventTopic::has_signal_event() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignalEventTopic::set_has_signal_event() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignalEventTopic::clear_has_signal_event() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignalEventTopic::clear_signal_event() {
  if (signal_event_ != NULL) signal_event_->::falcon_remoting_msg::SignalEvent::Clear();
  clear_has_signal_event();
}
inline const ::falcon_remoting_msg::SignalEvent& SignalEventTopic::signal_event() const {
  return signal_event_ != NULL ? *signal_event_ : *default_instance_->signal_event_;
}
inline ::falcon_remoting_msg::SignalEvent* SignalEventTopic::mutable_signal_event() {
  set_has_signal_event();
  if (signal_event_ == NULL) signal_event_ = new ::falcon_remoting_msg::SignalEvent;
  return signal_event_;
}
inline ::falcon_remoting_msg::SignalEvent* SignalEventTopic::release_signal_event() {
  clear_has_signal_event();
  ::falcon_remoting_msg::SignalEvent* temp = signal_event_;
  signal_event_ = NULL;
  return temp;
}
inline void SignalEventTopic::set_allocated_signal_event(::falcon_remoting_msg::SignalEvent* signal_event) {
  delete signal_event_;
  signal_event_ = signal_event;
  if (signal_event) {
    set_has_signal_event();
  } else {
    clear_has_signal_event();
  }
}

// optional .falcon_remoting_msg.GPSPosition gps_position = 2;
inline bool SignalEventTopic::has_gps_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignalEventTopic::set_has_gps_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignalEventTopic::clear_has_gps_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignalEventTopic::clear_gps_position() {
  if (gps_position_ != NULL) gps_position_->::falcon_remoting_msg::GPSPosition::Clear();
  clear_has_gps_position();
}
inline const ::falcon_remoting_msg::GPSPosition& SignalEventTopic::gps_position() const {
  return gps_position_ != NULL ? *gps_position_ : *default_instance_->gps_position_;
}
inline ::falcon_remoting_msg::GPSPosition* SignalEventTopic::mutable_gps_position() {
  set_has_gps_position();
  if (gps_position_ == NULL) gps_position_ = new ::falcon_remoting_msg::GPSPosition;
  return gps_position_;
}
inline ::falcon_remoting_msg::GPSPosition* SignalEventTopic::release_gps_position() {
  clear_has_gps_position();
  ::falcon_remoting_msg::GPSPosition* temp = gps_position_;
  gps_position_ = NULL;
  return temp;
}
inline void SignalEventTopic::set_allocated_gps_position(::falcon_remoting_msg::GPSPosition* gps_position) {
  delete gps_position_;
  gps_position_ = gps_position;
  if (gps_position) {
    set_has_gps_position();
  } else {
    clear_has_gps_position();
  }
}

// -------------------------------------------------------------------

// ProductResponseTopic

// optional .service_infrastructure.Header header = 100;
inline bool ProductResponseTopic::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProductResponseTopic::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProductResponseTopic::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProductResponseTopic::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& ProductResponseTopic::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* ProductResponseTopic::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* ProductResponseTopic::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ProductResponseTopic::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .video_compression_msg.ImageAvailable image_available = 1;
inline bool ProductResponseTopic::has_image_available() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProductResponseTopic::set_has_image_available() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProductResponseTopic::clear_has_image_available() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProductResponseTopic::clear_image_available() {
  if (image_available_ != NULL) image_available_->::video_compression_msg::ImageAvailable::Clear();
  clear_has_image_available();
}
inline const ::video_compression_msg::ImageAvailable& ProductResponseTopic::image_available() const {
  return image_available_ != NULL ? *image_available_ : *default_instance_->image_available_;
}
inline ::video_compression_msg::ImageAvailable* ProductResponseTopic::mutable_image_available() {
  set_has_image_available();
  if (image_available_ == NULL) image_available_ = new ::video_compression_msg::ImageAvailable;
  return image_available_;
}
inline ::video_compression_msg::ImageAvailable* ProductResponseTopic::release_image_available() {
  clear_has_image_available();
  ::video_compression_msg::ImageAvailable* temp = image_available_;
  image_available_ = NULL;
  return temp;
}
inline void ProductResponseTopic::set_allocated_image_available(::video_compression_msg::ImageAvailable* image_available) {
  delete image_available_;
  image_available_ = image_available;
  if (image_available) {
    set_has_image_available();
  } else {
    clear_has_image_available();
  }
}

// optional .products.FisD fisd = 2;
inline bool ProductResponseTopic::has_fisd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProductResponseTopic::set_has_fisd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProductResponseTopic::clear_has_fisd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProductResponseTopic::clear_fisd() {
  if (fisd_ != NULL) fisd_->::products::FisD::Clear();
  clear_has_fisd();
}
inline const ::products::FisD& ProductResponseTopic::fisd() const {
  return fisd_ != NULL ? *fisd_ : *default_instance_->fisd_;
}
inline ::products::FisD* ProductResponseTopic::mutable_fisd() {
  set_has_fisd();
  if (fisd_ == NULL) fisd_ = new ::products::FisD;
  return fisd_;
}
inline ::products::FisD* ProductResponseTopic::release_fisd() {
  clear_has_fisd();
  ::products::FisD* temp = fisd_;
  fisd_ = NULL;
  return temp;
}
inline void ProductResponseTopic::set_allocated_fisd(::products::FisD* fisd) {
  delete fisd_;
  fisd_ = fisd;
  if (fisd) {
    set_has_fisd();
  } else {
    clear_has_fisd();
  }
}

// optional .service_infrastructure.VideoParameters video_parameters = 3;
inline bool ProductResponseTopic::has_video_parameters() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProductResponseTopic::set_has_video_parameters() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProductResponseTopic::clear_has_video_parameters() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProductResponseTopic::clear_video_parameters() {
  if (video_parameters_ != NULL) video_parameters_->::service_infrastructure::VideoParameters::Clear();
  clear_has_video_parameters();
}
inline const ::service_infrastructure::VideoParameters& ProductResponseTopic::video_parameters() const {
  return video_parameters_ != NULL ? *video_parameters_ : *default_instance_->video_parameters_;
}
inline ::service_infrastructure::VideoParameters* ProductResponseTopic::mutable_video_parameters() {
  set_has_video_parameters();
  if (video_parameters_ == NULL) video_parameters_ = new ::service_infrastructure::VideoParameters;
  return video_parameters_;
}
inline ::service_infrastructure::VideoParameters* ProductResponseTopic::release_video_parameters() {
  clear_has_video_parameters();
  ::service_infrastructure::VideoParameters* temp = video_parameters_;
  video_parameters_ = NULL;
  return temp;
}
inline void ProductResponseTopic::set_allocated_video_parameters(::service_infrastructure::VideoParameters* video_parameters) {
  delete video_parameters_;
  video_parameters_ = video_parameters;
  if (video_parameters) {
    set_has_video_parameters();
  } else {
    clear_has_video_parameters();
  }
}

// optional .products.AudioAvailable audioavailable = 4;
inline bool ProductResponseTopic::has_audioavailable() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProductResponseTopic::set_has_audioavailable() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProductResponseTopic::clear_has_audioavailable() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProductResponseTopic::clear_audioavailable() {
  if (audioavailable_ != NULL) audioavailable_->::products::AudioAvailable::Clear();
  clear_has_audioavailable();
}
inline const ::products::AudioAvailable& ProductResponseTopic::audioavailable() const {
  return audioavailable_ != NULL ? *audioavailable_ : *default_instance_->audioavailable_;
}
inline ::products::AudioAvailable* ProductResponseTopic::mutable_audioavailable() {
  set_has_audioavailable();
  if (audioavailable_ == NULL) audioavailable_ = new ::products::AudioAvailable;
  return audioavailable_;
}
inline ::products::AudioAvailable* ProductResponseTopic::release_audioavailable() {
  clear_has_audioavailable();
  ::products::AudioAvailable* temp = audioavailable_;
  audioavailable_ = NULL;
  return temp;
}
inline void ProductResponseTopic::set_allocated_audioavailable(::products::AudioAvailable* audioavailable) {
  delete audioavailable_;
  audioavailable_ = audioavailable;
  if (audioavailable) {
    set_has_audioavailable();
  } else {
    clear_has_audioavailable();
  }
}

// -------------------------------------------------------------------

// VideoParameters

// optional string eltex = 1;
inline bool VideoParameters::has_eltex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VideoParameters::set_has_eltex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VideoParameters::clear_has_eltex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VideoParameters::clear_eltex() {
  if (eltex_ != &::google::protobuf::internal::kEmptyString) {
    eltex_->clear();
  }
  clear_has_eltex();
}
inline const ::std::string& VideoParameters::eltex() const {
  return *eltex_;
}
inline void VideoParameters::set_eltex(const ::std::string& value) {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  eltex_->assign(value);
}
inline void VideoParameters::set_eltex(const char* value) {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  eltex_->assign(value);
}
inline void VideoParameters::set_eltex(const char* value, size_t size) {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  eltex_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VideoParameters::mutable_eltex() {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  return eltex_;
}
inline ::std::string* VideoParameters::release_eltex() {
  clear_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eltex_;
    eltex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VideoParameters::set_allocated_eltex(::std::string* eltex) {
  if (eltex_ != &::google::protobuf::internal::kEmptyString) {
    delete eltex_;
  }
  if (eltex) {
    set_has_eltex();
    eltex_ = eltex;
  } else {
    clear_has_eltex();
    eltex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 instance = 2;
inline bool VideoParameters::has_instance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VideoParameters::set_has_instance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VideoParameters::clear_has_instance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VideoParameters::clear_instance() {
  instance_ = 0;
  clear_has_instance();
}
inline ::google::protobuf::int32 VideoParameters::instance() const {
  return instance_;
}
inline void VideoParameters::set_instance(::google::protobuf::int32 value) {
  set_has_instance();
  instance_ = value;
}

// optional string protocol = 3;
inline bool VideoParameters::has_protocol() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VideoParameters::set_has_protocol() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VideoParameters::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VideoParameters::clear_protocol() {
  if (protocol_ != &::google::protobuf::internal::kEmptyString) {
    protocol_->clear();
  }
  clear_has_protocol();
}
inline const ::std::string& VideoParameters::protocol() const {
  return *protocol_;
}
inline void VideoParameters::set_protocol(const ::std::string& value) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
}
inline void VideoParameters::set_protocol(const char* value) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
}
inline void VideoParameters::set_protocol(const char* value, size_t size) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VideoParameters::mutable_protocol() {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  return protocol_;
}
inline ::std::string* VideoParameters::release_protocol() {
  clear_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = protocol_;
    protocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VideoParameters::set_allocated_protocol(::std::string* protocol) {
  if (protocol_ != &::google::protobuf::internal::kEmptyString) {
    delete protocol_;
  }
  if (protocol) {
    set_has_protocol();
    protocol_ = protocol;
  } else {
    clear_has_protocol();
    protocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ipaddress = 4;
inline bool VideoParameters::has_ipaddress() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VideoParameters::set_has_ipaddress() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VideoParameters::clear_has_ipaddress() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VideoParameters::clear_ipaddress() {
  if (ipaddress_ != &::google::protobuf::internal::kEmptyString) {
    ipaddress_->clear();
  }
  clear_has_ipaddress();
}
inline const ::std::string& VideoParameters::ipaddress() const {
  return *ipaddress_;
}
inline void VideoParameters::set_ipaddress(const ::std::string& value) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(value);
}
inline void VideoParameters::set_ipaddress(const char* value) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(value);
}
inline void VideoParameters::set_ipaddress(const char* value, size_t size) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VideoParameters::mutable_ipaddress() {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  return ipaddress_;
}
inline ::std::string* VideoParameters::release_ipaddress() {
  clear_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ipaddress_;
    ipaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VideoParameters::set_allocated_ipaddress(::std::string* ipaddress) {
  if (ipaddress_ != &::google::protobuf::internal::kEmptyString) {
    delete ipaddress_;
  }
  if (ipaddress) {
    set_has_ipaddress();
    ipaddress_ = ipaddress;
  } else {
    clear_has_ipaddress();
    ipaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 port = 5;
inline bool VideoParameters::has_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VideoParameters::set_has_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VideoParameters::clear_has_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VideoParameters::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 VideoParameters::port() const {
  return port_;
}
inline void VideoParameters::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// optional string globalID = 6;
inline bool VideoParameters::has_globalid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VideoParameters::set_has_globalid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VideoParameters::clear_has_globalid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VideoParameters::clear_globalid() {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    globalid_->clear();
  }
  clear_has_globalid();
}
inline const ::std::string& VideoParameters::globalid() const {
  return *globalid_;
}
inline void VideoParameters::set_globalid(const ::std::string& value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void VideoParameters::set_globalid(const char* value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void VideoParameters::set_globalid(const char* value, size_t size) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VideoParameters::mutable_globalid() {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  return globalid_;
}
inline ::std::string* VideoParameters::release_globalid() {
  clear_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalid_;
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VideoParameters::set_allocated_globalid(::std::string* globalid) {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    delete globalid_;
  }
  if (globalid) {
    set_has_globalid();
    globalid_ = globalid;
  } else {
    clear_has_globalid();
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ESProductTopic

// optional .service_infrastructure.Header header = 100;
inline bool ESProductTopic::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ESProductTopic::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ESProductTopic::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ESProductTopic::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& ESProductTopic::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* ESProductTopic::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* ESProductTopic::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ESProductTopic::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .es_product_msg.ESObservablesRegister es_observables_register = 1;
inline bool ESProductTopic::has_es_observables_register() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ESProductTopic::set_has_es_observables_register() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ESProductTopic::clear_has_es_observables_register() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ESProductTopic::clear_es_observables_register() {
  if (es_observables_register_ != NULL) es_observables_register_->::es_product_msg::ESObservablesRegister::Clear();
  clear_has_es_observables_register();
}
inline const ::es_product_msg::ESObservablesRegister& ESProductTopic::es_observables_register() const {
  return es_observables_register_ != NULL ? *es_observables_register_ : *default_instance_->es_observables_register_;
}
inline ::es_product_msg::ESObservablesRegister* ESProductTopic::mutable_es_observables_register() {
  set_has_es_observables_register();
  if (es_observables_register_ == NULL) es_observables_register_ = new ::es_product_msg::ESObservablesRegister;
  return es_observables_register_;
}
inline ::es_product_msg::ESObservablesRegister* ESProductTopic::release_es_observables_register() {
  clear_has_es_observables_register();
  ::es_product_msg::ESObservablesRegister* temp = es_observables_register_;
  es_observables_register_ = NULL;
  return temp;
}
inline void ESProductTopic::set_allocated_es_observables_register(::es_product_msg::ESObservablesRegister* es_observables_register) {
  delete es_observables_register_;
  es_observables_register_ = es_observables_register;
  if (es_observables_register) {
    set_has_es_observables_register();
  } else {
    clear_has_es_observables_register();
  }
}

// optional .es_product_msg.ESObservablesUnregister es_observables_unregister = 2;
inline bool ESProductTopic::has_es_observables_unregister() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ESProductTopic::set_has_es_observables_unregister() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ESProductTopic::clear_has_es_observables_unregister() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ESProductTopic::clear_es_observables_unregister() {
  if (es_observables_unregister_ != NULL) es_observables_unregister_->::es_product_msg::ESObservablesUnregister::Clear();
  clear_has_es_observables_unregister();
}
inline const ::es_product_msg::ESObservablesUnregister& ESProductTopic::es_observables_unregister() const {
  return es_observables_unregister_ != NULL ? *es_observables_unregister_ : *default_instance_->es_observables_unregister_;
}
inline ::es_product_msg::ESObservablesUnregister* ESProductTopic::mutable_es_observables_unregister() {
  set_has_es_observables_unregister();
  if (es_observables_unregister_ == NULL) es_observables_unregister_ = new ::es_product_msg::ESObservablesUnregister;
  return es_observables_unregister_;
}
inline ::es_product_msg::ESObservablesUnregister* ESProductTopic::release_es_observables_unregister() {
  clear_has_es_observables_unregister();
  ::es_product_msg::ESObservablesUnregister* temp = es_observables_unregister_;
  es_observables_unregister_ = NULL;
  return temp;
}
inline void ESProductTopic::set_allocated_es_observables_unregister(::es_product_msg::ESObservablesUnregister* es_observables_unregister) {
  delete es_observables_unregister_;
  es_observables_unregister_ = es_observables_unregister;
  if (es_observables_unregister) {
    set_has_es_observables_unregister();
  } else {
    clear_has_es_observables_unregister();
  }
}

// optional .es_product_msg.ESObservables es_observables = 3;
inline bool ESProductTopic::has_es_observables() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ESProductTopic::set_has_es_observables() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ESProductTopic::clear_has_es_observables() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ESProductTopic::clear_es_observables() {
  if (es_observables_ != NULL) es_observables_->::es_product_msg::ESObservables::Clear();
  clear_has_es_observables();
}
inline const ::es_product_msg::ESObservables& ESProductTopic::es_observables() const {
  return es_observables_ != NULL ? *es_observables_ : *default_instance_->es_observables_;
}
inline ::es_product_msg::ESObservables* ESProductTopic::mutable_es_observables() {
  set_has_es_observables();
  if (es_observables_ == NULL) es_observables_ = new ::es_product_msg::ESObservables;
  return es_observables_;
}
inline ::es_product_msg::ESObservables* ESProductTopic::release_es_observables() {
  clear_has_es_observables();
  ::es_product_msg::ESObservables* temp = es_observables_;
  es_observables_ = NULL;
  return temp;
}
inline void ESProductTopic::set_allocated_es_observables(::es_product_msg::ESObservables* es_observables) {
  delete es_observables_;
  es_observables_ = es_observables;
  if (es_observables) {
    set_has_es_observables();
  } else {
    clear_has_es_observables();
  }
}

// optional .auto_kill_msg.StateResponse state_response = 4;
inline bool ESProductTopic::has_state_response() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ESProductTopic::set_has_state_response() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ESProductTopic::clear_has_state_response() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ESProductTopic::clear_state_response() {
  if (state_response_ != NULL) state_response_->::auto_kill_msg::StateResponse::Clear();
  clear_has_state_response();
}
inline const ::auto_kill_msg::StateResponse& ESProductTopic::state_response() const {
  return state_response_ != NULL ? *state_response_ : *default_instance_->state_response_;
}
inline ::auto_kill_msg::StateResponse* ESProductTopic::mutable_state_response() {
  set_has_state_response();
  if (state_response_ == NULL) state_response_ = new ::auto_kill_msg::StateResponse;
  return state_response_;
}
inline ::auto_kill_msg::StateResponse* ESProductTopic::release_state_response() {
  clear_has_state_response();
  ::auto_kill_msg::StateResponse* temp = state_response_;
  state_response_ = NULL;
  return temp;
}
inline void ESProductTopic::set_allocated_state_response(::auto_kill_msg::StateResponse* state_response) {
  delete state_response_;
  state_response_ = state_response;
  if (state_response) {
    set_has_state_response();
  } else {
    clear_has_state_response();
  }
}

// optional .auto_kill_msg.OverrideState override_state = 5;
inline bool ESProductTopic::has_override_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ESProductTopic::set_has_override_state() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ESProductTopic::clear_has_override_state() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ESProductTopic::clear_override_state() {
  if (override_state_ != NULL) override_state_->::auto_kill_msg::OverrideState::Clear();
  clear_has_override_state();
}
inline const ::auto_kill_msg::OverrideState& ESProductTopic::override_state() const {
  return override_state_ != NULL ? *override_state_ : *default_instance_->override_state_;
}
inline ::auto_kill_msg::OverrideState* ESProductTopic::mutable_override_state() {
  set_has_override_state();
  if (override_state_ == NULL) override_state_ = new ::auto_kill_msg::OverrideState;
  return override_state_;
}
inline ::auto_kill_msg::OverrideState* ESProductTopic::release_override_state() {
  clear_has_override_state();
  ::auto_kill_msg::OverrideState* temp = override_state_;
  override_state_ = NULL;
  return temp;
}
inline void ESProductTopic::set_allocated_override_state(::auto_kill_msg::OverrideState* override_state) {
  delete override_state_;
  override_state_ = override_state;
  if (override_state) {
    set_has_override_state();
  } else {
    clear_has_override_state();
  }
}

// optional .auto_kill_msg.AutoKillGUI autokill_gui = 6;
inline bool ESProductTopic::has_autokill_gui() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ESProductTopic::set_has_autokill_gui() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ESProductTopic::clear_has_autokill_gui() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ESProductTopic::clear_autokill_gui() {
  if (autokill_gui_ != NULL) autokill_gui_->::auto_kill_msg::AutoKillGUI::Clear();
  clear_has_autokill_gui();
}
inline const ::auto_kill_msg::AutoKillGUI& ESProductTopic::autokill_gui() const {
  return autokill_gui_ != NULL ? *autokill_gui_ : *default_instance_->autokill_gui_;
}
inline ::auto_kill_msg::AutoKillGUI* ESProductTopic::mutable_autokill_gui() {
  set_has_autokill_gui();
  if (autokill_gui_ == NULL) autokill_gui_ = new ::auto_kill_msg::AutoKillGUI;
  return autokill_gui_;
}
inline ::auto_kill_msg::AutoKillGUI* ESProductTopic::release_autokill_gui() {
  clear_has_autokill_gui();
  ::auto_kill_msg::AutoKillGUI* temp = autokill_gui_;
  autokill_gui_ = NULL;
  return temp;
}
inline void ESProductTopic::set_allocated_autokill_gui(::auto_kill_msg::AutoKillGUI* autokill_gui) {
  delete autokill_gui_;
  autokill_gui_ = autokill_gui;
  if (autokill_gui) {
    set_has_autokill_gui();
  } else {
    clear_has_autokill_gui();
  }
}

// -------------------------------------------------------------------

// InfrastructureEnvelope

// optional .service_infrastructure.Header header = 1;
inline bool InfrastructureEnvelope::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InfrastructureEnvelope::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InfrastructureEnvelope::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InfrastructureEnvelope::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& InfrastructureEnvelope::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* InfrastructureEnvelope::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* InfrastructureEnvelope::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InfrastructureEnvelope::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .service_infrastructure.HandshakeTopic handshake = 2;
inline bool InfrastructureEnvelope::has_handshake() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InfrastructureEnvelope::set_has_handshake() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InfrastructureEnvelope::clear_has_handshake() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InfrastructureEnvelope::clear_handshake() {
  if (handshake_ != NULL) handshake_->::service_infrastructure::HandshakeTopic::Clear();
  clear_has_handshake();
}
inline const ::service_infrastructure::HandshakeTopic& InfrastructureEnvelope::handshake() const {
  return handshake_ != NULL ? *handshake_ : *default_instance_->handshake_;
}
inline ::service_infrastructure::HandshakeTopic* InfrastructureEnvelope::mutable_handshake() {
  set_has_handshake();
  if (handshake_ == NULL) handshake_ = new ::service_infrastructure::HandshakeTopic;
  return handshake_;
}
inline ::service_infrastructure::HandshakeTopic* InfrastructureEnvelope::release_handshake() {
  clear_has_handshake();
  ::service_infrastructure::HandshakeTopic* temp = handshake_;
  handshake_ = NULL;
  return temp;
}
inline void InfrastructureEnvelope::set_allocated_handshake(::service_infrastructure::HandshakeTopic* handshake) {
  delete handshake_;
  handshake_ = handshake;
  if (handshake) {
    set_has_handshake();
  } else {
    clear_has_handshake();
  }
}

// optional .service_infrastructure.EWRequestTopic ew_request = 3;
inline bool InfrastructureEnvelope::has_ew_request() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InfrastructureEnvelope::set_has_ew_request() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InfrastructureEnvelope::clear_has_ew_request() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InfrastructureEnvelope::clear_ew_request() {
  if (ew_request_ != NULL) ew_request_->::service_infrastructure::EWRequestTopic::Clear();
  clear_has_ew_request();
}
inline const ::service_infrastructure::EWRequestTopic& InfrastructureEnvelope::ew_request() const {
  return ew_request_ != NULL ? *ew_request_ : *default_instance_->ew_request_;
}
inline ::service_infrastructure::EWRequestTopic* InfrastructureEnvelope::mutable_ew_request() {
  set_has_ew_request();
  if (ew_request_ == NULL) ew_request_ = new ::service_infrastructure::EWRequestTopic;
  return ew_request_;
}
inline ::service_infrastructure::EWRequestTopic* InfrastructureEnvelope::release_ew_request() {
  clear_has_ew_request();
  ::service_infrastructure::EWRequestTopic* temp = ew_request_;
  ew_request_ = NULL;
  return temp;
}
inline void InfrastructureEnvelope::set_allocated_ew_request(::service_infrastructure::EWRequestTopic* ew_request) {
  delete ew_request_;
  ew_request_ = ew_request;
  if (ew_request) {
    set_has_ew_request();
  } else {
    clear_has_ew_request();
  }
}

// optional .service_infrastructure.ProductRequestTopic product_request = 5;
inline bool InfrastructureEnvelope::has_product_request() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InfrastructureEnvelope::set_has_product_request() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InfrastructureEnvelope::clear_has_product_request() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InfrastructureEnvelope::clear_product_request() {
  if (product_request_ != NULL) product_request_->::service_infrastructure::ProductRequestTopic::Clear();
  clear_has_product_request();
}
inline const ::service_infrastructure::ProductRequestTopic& InfrastructureEnvelope::product_request() const {
  return product_request_ != NULL ? *product_request_ : *default_instance_->product_request_;
}
inline ::service_infrastructure::ProductRequestTopic* InfrastructureEnvelope::mutable_product_request() {
  set_has_product_request();
  if (product_request_ == NULL) product_request_ = new ::service_infrastructure::ProductRequestTopic;
  return product_request_;
}
inline ::service_infrastructure::ProductRequestTopic* InfrastructureEnvelope::release_product_request() {
  clear_has_product_request();
  ::service_infrastructure::ProductRequestTopic* temp = product_request_;
  product_request_ = NULL;
  return temp;
}
inline void InfrastructureEnvelope::set_allocated_product_request(::service_infrastructure::ProductRequestTopic* product_request) {
  delete product_request_;
  product_request_ = product_request;
  if (product_request) {
    set_has_product_request();
  } else {
    clear_has_product_request();
  }
}

// optional .service_infrastructure.RadioControlResponseTopic radio_control_response = 6;
inline bool InfrastructureEnvelope::has_radio_control_response() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InfrastructureEnvelope::set_has_radio_control_response() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InfrastructureEnvelope::clear_has_radio_control_response() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InfrastructureEnvelope::clear_radio_control_response() {
  if (radio_control_response_ != NULL) radio_control_response_->::service_infrastructure::RadioControlResponseTopic::Clear();
  clear_has_radio_control_response();
}
inline const ::service_infrastructure::RadioControlResponseTopic& InfrastructureEnvelope::radio_control_response() const {
  return radio_control_response_ != NULL ? *radio_control_response_ : *default_instance_->radio_control_response_;
}
inline ::service_infrastructure::RadioControlResponseTopic* InfrastructureEnvelope::mutable_radio_control_response() {
  set_has_radio_control_response();
  if (radio_control_response_ == NULL) radio_control_response_ = new ::service_infrastructure::RadioControlResponseTopic;
  return radio_control_response_;
}
inline ::service_infrastructure::RadioControlResponseTopic* InfrastructureEnvelope::release_radio_control_response() {
  clear_has_radio_control_response();
  ::service_infrastructure::RadioControlResponseTopic* temp = radio_control_response_;
  radio_control_response_ = NULL;
  return temp;
}
inline void InfrastructureEnvelope::set_allocated_radio_control_response(::service_infrastructure::RadioControlResponseTopic* radio_control_response) {
  delete radio_control_response_;
  radio_control_response_ = radio_control_response;
  if (radio_control_response) {
    set_has_radio_control_response();
  } else {
    clear_has_radio_control_response();
  }
}

// optional .service_infrastructure.RadioDataTopic radio_data = 7;
inline bool InfrastructureEnvelope::has_radio_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InfrastructureEnvelope::set_has_radio_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InfrastructureEnvelope::clear_has_radio_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InfrastructureEnvelope::clear_radio_data() {
  if (radio_data_ != NULL) radio_data_->::service_infrastructure::RadioDataTopic::Clear();
  clear_has_radio_data();
}
inline const ::service_infrastructure::RadioDataTopic& InfrastructureEnvelope::radio_data() const {
  return radio_data_ != NULL ? *radio_data_ : *default_instance_->radio_data_;
}
inline ::service_infrastructure::RadioDataTopic* InfrastructureEnvelope::mutable_radio_data() {
  set_has_radio_data();
  if (radio_data_ == NULL) radio_data_ = new ::service_infrastructure::RadioDataTopic;
  return radio_data_;
}
inline ::service_infrastructure::RadioDataTopic* InfrastructureEnvelope::release_radio_data() {
  clear_has_radio_data();
  ::service_infrastructure::RadioDataTopic* temp = radio_data_;
  radio_data_ = NULL;
  return temp;
}
inline void InfrastructureEnvelope::set_allocated_radio_data(::service_infrastructure::RadioDataTopic* radio_data) {
  delete radio_data_;
  radio_data_ = radio_data;
  if (radio_data) {
    set_has_radio_data();
  } else {
    clear_has_radio_data();
  }
}

// optional .service_infrastructure.DebugTopic debug_topic = 8;
inline bool InfrastructureEnvelope::has_debug_topic() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InfrastructureEnvelope::set_has_debug_topic() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InfrastructureEnvelope::clear_has_debug_topic() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InfrastructureEnvelope::clear_debug_topic() {
  if (debug_topic_ != NULL) debug_topic_->::service_infrastructure::DebugTopic::Clear();
  clear_has_debug_topic();
}
inline const ::service_infrastructure::DebugTopic& InfrastructureEnvelope::debug_topic() const {
  return debug_topic_ != NULL ? *debug_topic_ : *default_instance_->debug_topic_;
}
inline ::service_infrastructure::DebugTopic* InfrastructureEnvelope::mutable_debug_topic() {
  set_has_debug_topic();
  if (debug_topic_ == NULL) debug_topic_ = new ::service_infrastructure::DebugTopic;
  return debug_topic_;
}
inline ::service_infrastructure::DebugTopic* InfrastructureEnvelope::release_debug_topic() {
  clear_has_debug_topic();
  ::service_infrastructure::DebugTopic* temp = debug_topic_;
  debug_topic_ = NULL;
  return temp;
}
inline void InfrastructureEnvelope::set_allocated_debug_topic(::service_infrastructure::DebugTopic* debug_topic) {
  delete debug_topic_;
  debug_topic_ = debug_topic;
  if (debug_topic) {
    set_has_debug_topic();
  } else {
    clear_has_debug_topic();
  }
}

// -------------------------------------------------------------------

// ProductRequestTopic

// optional .service_infrastructure.Header header = 100;
inline bool ProductRequestTopic::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProductRequestTopic::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProductRequestTopic::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProductRequestTopic::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& ProductRequestTopic::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* ProductRequestTopic::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* ProductRequestTopic::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ProductRequestTopic::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .products.FisDRequest fisd = 1;
inline bool ProductRequestTopic::has_fisd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProductRequestTopic::set_has_fisd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProductRequestTopic::clear_has_fisd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProductRequestTopic::clear_fisd() {
  if (fisd_ != NULL) fisd_->::products::FisDRequest::Clear();
  clear_has_fisd();
}
inline const ::products::FisDRequest& ProductRequestTopic::fisd() const {
  return fisd_ != NULL ? *fisd_ : *default_instance_->fisd_;
}
inline ::products::FisDRequest* ProductRequestTopic::mutable_fisd() {
  set_has_fisd();
  if (fisd_ == NULL) fisd_ = new ::products::FisDRequest;
  return fisd_;
}
inline ::products::FisDRequest* ProductRequestTopic::release_fisd() {
  clear_has_fisd();
  ::products::FisDRequest* temp = fisd_;
  fisd_ = NULL;
  return temp;
}
inline void ProductRequestTopic::set_allocated_fisd(::products::FisDRequest* fisd) {
  delete fisd_;
  fisd_ = fisd;
  if (fisd) {
    set_has_fisd();
  } else {
    clear_has_fisd();
  }
}

// optional .service_infrastructure.ImageRequest image = 2;
inline bool ProductRequestTopic::has_image() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProductRequestTopic::set_has_image() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProductRequestTopic::clear_has_image() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProductRequestTopic::clear_image() {
  if (image_ != NULL) image_->::service_infrastructure::ImageRequest::Clear();
  clear_has_image();
}
inline const ::service_infrastructure::ImageRequest& ProductRequestTopic::image() const {
  return image_ != NULL ? *image_ : *default_instance_->image_;
}
inline ::service_infrastructure::ImageRequest* ProductRequestTopic::mutable_image() {
  set_has_image();
  if (image_ == NULL) image_ = new ::service_infrastructure::ImageRequest;
  return image_;
}
inline ::service_infrastructure::ImageRequest* ProductRequestTopic::release_image() {
  clear_has_image();
  ::service_infrastructure::ImageRequest* temp = image_;
  image_ = NULL;
  return temp;
}
inline void ProductRequestTopic::set_allocated_image(::service_infrastructure::ImageRequest* image) {
  delete image_;
  image_ = image;
  if (image) {
    set_has_image();
  } else {
    clear_has_image();
  }
}

// optional .service_infrastructure.VideoRequest video = 3;
inline bool ProductRequestTopic::has_video() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProductRequestTopic::set_has_video() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProductRequestTopic::clear_has_video() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProductRequestTopic::clear_video() {
  if (video_ != NULL) video_->::service_infrastructure::VideoRequest::Clear();
  clear_has_video();
}
inline const ::service_infrastructure::VideoRequest& ProductRequestTopic::video() const {
  return video_ != NULL ? *video_ : *default_instance_->video_;
}
inline ::service_infrastructure::VideoRequest* ProductRequestTopic::mutable_video() {
  set_has_video();
  if (video_ == NULL) video_ = new ::service_infrastructure::VideoRequest;
  return video_;
}
inline ::service_infrastructure::VideoRequest* ProductRequestTopic::release_video() {
  clear_has_video();
  ::service_infrastructure::VideoRequest* temp = video_;
  video_ = NULL;
  return temp;
}
inline void ProductRequestTopic::set_allocated_video(::service_infrastructure::VideoRequest* video) {
  delete video_;
  video_ = video;
  if (video) {
    set_has_video();
  } else {
    clear_has_video();
  }
}

// optional .products.AudioRequest audio = 4;
inline bool ProductRequestTopic::has_audio() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProductRequestTopic::set_has_audio() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProductRequestTopic::clear_has_audio() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProductRequestTopic::clear_audio() {
  if (audio_ != NULL) audio_->::products::AudioRequest::Clear();
  clear_has_audio();
}
inline const ::products::AudioRequest& ProductRequestTopic::audio() const {
  return audio_ != NULL ? *audio_ : *default_instance_->audio_;
}
inline ::products::AudioRequest* ProductRequestTopic::mutable_audio() {
  set_has_audio();
  if (audio_ == NULL) audio_ = new ::products::AudioRequest;
  return audio_;
}
inline ::products::AudioRequest* ProductRequestTopic::release_audio() {
  clear_has_audio();
  ::products::AudioRequest* temp = audio_;
  audio_ = NULL;
  return temp;
}
inline void ProductRequestTopic::set_allocated_audio(::products::AudioRequest* audio) {
  delete audio_;
  audio_ = audio;
  if (audio) {
    set_has_audio();
  } else {
    clear_has_audio();
  }
}

// -------------------------------------------------------------------

// EWRequestTopic

// optional .service_infrastructure.Header header = 100;
inline bool EWRequestTopic::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EWRequestTopic::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EWRequestTopic::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EWRequestTopic::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& EWRequestTopic::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* EWRequestTopic::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* EWRequestTopic::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void EWRequestTopic::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .fv.tb.protos.TBProtos.EWCommandRequest ew_command_request = 1;
inline bool EWRequestTopic::has_ew_command_request() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EWRequestTopic::set_has_ew_command_request() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EWRequestTopic::clear_has_ew_command_request() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EWRequestTopic::clear_ew_command_request() {
  if (ew_command_request_ != NULL) ew_command_request_->::fv::tb::protos::TBProtos::EWCommandRequest::Clear();
  clear_has_ew_command_request();
}
inline const ::fv::tb::protos::TBProtos::EWCommandRequest& EWRequestTopic::ew_command_request() const {
  return ew_command_request_ != NULL ? *ew_command_request_ : *default_instance_->ew_command_request_;
}
inline ::fv::tb::protos::TBProtos::EWCommandRequest* EWRequestTopic::mutable_ew_command_request() {
  set_has_ew_command_request();
  if (ew_command_request_ == NULL) ew_command_request_ = new ::fv::tb::protos::TBProtos::EWCommandRequest;
  return ew_command_request_;
}
inline ::fv::tb::protos::TBProtos::EWCommandRequest* EWRequestTopic::release_ew_command_request() {
  clear_has_ew_command_request();
  ::fv::tb::protos::TBProtos::EWCommandRequest* temp = ew_command_request_;
  ew_command_request_ = NULL;
  return temp;
}
inline void EWRequestTopic::set_allocated_ew_command_request(::fv::tb::protos::TBProtos::EWCommandRequest* ew_command_request) {
  delete ew_command_request_;
  ew_command_request_ = ew_command_request;
  if (ew_command_request) {
    set_has_ew_command_request();
  } else {
    clear_has_ew_command_request();
  }
}

// optional .fv.tb.protos.TBProtos.EWCeaseBuzzer ew_cease_buzzer = 2;
inline bool EWRequestTopic::has_ew_cease_buzzer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EWRequestTopic::set_has_ew_cease_buzzer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EWRequestTopic::clear_has_ew_cease_buzzer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EWRequestTopic::clear_ew_cease_buzzer() {
  if (ew_cease_buzzer_ != NULL) ew_cease_buzzer_->::fv::tb::protos::TBProtos::EWCeaseBuzzer::Clear();
  clear_has_ew_cease_buzzer();
}
inline const ::fv::tb::protos::TBProtos::EWCeaseBuzzer& EWRequestTopic::ew_cease_buzzer() const {
  return ew_cease_buzzer_ != NULL ? *ew_cease_buzzer_ : *default_instance_->ew_cease_buzzer_;
}
inline ::fv::tb::protos::TBProtos::EWCeaseBuzzer* EWRequestTopic::mutable_ew_cease_buzzer() {
  set_has_ew_cease_buzzer();
  if (ew_cease_buzzer_ == NULL) ew_cease_buzzer_ = new ::fv::tb::protos::TBProtos::EWCeaseBuzzer;
  return ew_cease_buzzer_;
}
inline ::fv::tb::protos::TBProtos::EWCeaseBuzzer* EWRequestTopic::release_ew_cease_buzzer() {
  clear_has_ew_cease_buzzer();
  ::fv::tb::protos::TBProtos::EWCeaseBuzzer* temp = ew_cease_buzzer_;
  ew_cease_buzzer_ = NULL;
  return temp;
}
inline void EWRequestTopic::set_allocated_ew_cease_buzzer(::fv::tb::protos::TBProtos::EWCeaseBuzzer* ew_cease_buzzer) {
  delete ew_cease_buzzer_;
  ew_cease_buzzer_ = ew_cease_buzzer;
  if (ew_cease_buzzer) {
    set_has_ew_cease_buzzer();
  } else {
    clear_has_ew_cease_buzzer();
  }
}

// optional .fv.tb.protos.TBProtos.EWStatusRequest ew_status_request = 4;
inline bool EWRequestTopic::has_ew_status_request() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EWRequestTopic::set_has_ew_status_request() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EWRequestTopic::clear_has_ew_status_request() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EWRequestTopic::clear_ew_status_request() {
  if (ew_status_request_ != NULL) ew_status_request_->::fv::tb::protos::TBProtos::EWStatusRequest::Clear();
  clear_has_ew_status_request();
}
inline const ::fv::tb::protos::TBProtos::EWStatusRequest& EWRequestTopic::ew_status_request() const {
  return ew_status_request_ != NULL ? *ew_status_request_ : *default_instance_->ew_status_request_;
}
inline ::fv::tb::protos::TBProtos::EWStatusRequest* EWRequestTopic::mutable_ew_status_request() {
  set_has_ew_status_request();
  if (ew_status_request_ == NULL) ew_status_request_ = new ::fv::tb::protos::TBProtos::EWStatusRequest;
  return ew_status_request_;
}
inline ::fv::tb::protos::TBProtos::EWStatusRequest* EWRequestTopic::release_ew_status_request() {
  clear_has_ew_status_request();
  ::fv::tb::protos::TBProtos::EWStatusRequest* temp = ew_status_request_;
  ew_status_request_ = NULL;
  return temp;
}
inline void EWRequestTopic::set_allocated_ew_status_request(::fv::tb::protos::TBProtos::EWStatusRequest* ew_status_request) {
  delete ew_status_request_;
  ew_status_request_ = ew_status_request;
  if (ew_status_request) {
    set_has_ew_status_request();
  } else {
    clear_has_ew_status_request();
  }
}

// optional .fv.tb.protos.TBProtos.EWOptionsRequest ew_options_request = 5;
inline bool EWRequestTopic::has_ew_options_request() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EWRequestTopic::set_has_ew_options_request() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EWRequestTopic::clear_has_ew_options_request() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EWRequestTopic::clear_ew_options_request() {
  if (ew_options_request_ != NULL) ew_options_request_->::fv::tb::protos::TBProtos::EWOptionsRequest::Clear();
  clear_has_ew_options_request();
}
inline const ::fv::tb::protos::TBProtos::EWOptionsRequest& EWRequestTopic::ew_options_request() const {
  return ew_options_request_ != NULL ? *ew_options_request_ : *default_instance_->ew_options_request_;
}
inline ::fv::tb::protos::TBProtos::EWOptionsRequest* EWRequestTopic::mutable_ew_options_request() {
  set_has_ew_options_request();
  if (ew_options_request_ == NULL) ew_options_request_ = new ::fv::tb::protos::TBProtos::EWOptionsRequest;
  return ew_options_request_;
}
inline ::fv::tb::protos::TBProtos::EWOptionsRequest* EWRequestTopic::release_ew_options_request() {
  clear_has_ew_options_request();
  ::fv::tb::protos::TBProtos::EWOptionsRequest* temp = ew_options_request_;
  ew_options_request_ = NULL;
  return temp;
}
inline void EWRequestTopic::set_allocated_ew_options_request(::fv::tb::protos::TBProtos::EWOptionsRequest* ew_options_request) {
  delete ew_options_request_;
  ew_options_request_ = ew_options_request;
  if (ew_options_request) {
    set_has_ew_options_request();
  } else {
    clear_has_ew_options_request();
  }
}

// optional .fv.tb.protos.TBProtos.RegisterRequest register_request = 6;
inline bool EWRequestTopic::has_register_request() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EWRequestTopic::set_has_register_request() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EWRequestTopic::clear_has_register_request() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EWRequestTopic::clear_register_request() {
  if (register_request_ != NULL) register_request_->::fv::tb::protos::TBProtos::RegisterRequest::Clear();
  clear_has_register_request();
}
inline const ::fv::tb::protos::TBProtos::RegisterRequest& EWRequestTopic::register_request() const {
  return register_request_ != NULL ? *register_request_ : *default_instance_->register_request_;
}
inline ::fv::tb::protos::TBProtos::RegisterRequest* EWRequestTopic::mutable_register_request() {
  set_has_register_request();
  if (register_request_ == NULL) register_request_ = new ::fv::tb::protos::TBProtos::RegisterRequest;
  return register_request_;
}
inline ::fv::tb::protos::TBProtos::RegisterRequest* EWRequestTopic::release_register_request() {
  clear_has_register_request();
  ::fv::tb::protos::TBProtos::RegisterRequest* temp = register_request_;
  register_request_ = NULL;
  return temp;
}
inline void EWRequestTopic::set_allocated_register_request(::fv::tb::protos::TBProtos::RegisterRequest* register_request) {
  delete register_request_;
  register_request_ = register_request;
  if (register_request) {
    set_has_register_request();
  } else {
    clear_has_register_request();
  }
}

// optional .fv.tb.protos.TBProtos.RegisterQuery register_query = 7;
inline bool EWRequestTopic::has_register_query() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EWRequestTopic::set_has_register_query() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EWRequestTopic::clear_has_register_query() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EWRequestTopic::clear_register_query() {
  if (register_query_ != NULL) register_query_->::fv::tb::protos::TBProtos::RegisterQuery::Clear();
  clear_has_register_query();
}
inline const ::fv::tb::protos::TBProtos::RegisterQuery& EWRequestTopic::register_query() const {
  return register_query_ != NULL ? *register_query_ : *default_instance_->register_query_;
}
inline ::fv::tb::protos::TBProtos::RegisterQuery* EWRequestTopic::mutable_register_query() {
  set_has_register_query();
  if (register_query_ == NULL) register_query_ = new ::fv::tb::protos::TBProtos::RegisterQuery;
  return register_query_;
}
inline ::fv::tb::protos::TBProtos::RegisterQuery* EWRequestTopic::release_register_query() {
  clear_has_register_query();
  ::fv::tb::protos::TBProtos::RegisterQuery* temp = register_query_;
  register_query_ = NULL;
  return temp;
}
inline void EWRequestTopic::set_allocated_register_query(::fv::tb::protos::TBProtos::RegisterQuery* register_query) {
  delete register_query_;
  register_query_ = register_query;
  if (register_query) {
    set_has_register_query();
  } else {
    clear_has_register_query();
  }
}

// optional .fv.tb.protos.TBProtos.EmergencyJam emergency_jam = 8;
inline bool EWRequestTopic::has_emergency_jam() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EWRequestTopic::set_has_emergency_jam() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EWRequestTopic::clear_has_emergency_jam() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EWRequestTopic::clear_emergency_jam() {
  if (emergency_jam_ != NULL) emergency_jam_->::fv::tb::protos::TBProtos::EmergencyJam::Clear();
  clear_has_emergency_jam();
}
inline const ::fv::tb::protos::TBProtos::EmergencyJam& EWRequestTopic::emergency_jam() const {
  return emergency_jam_ != NULL ? *emergency_jam_ : *default_instance_->emergency_jam_;
}
inline ::fv::tb::protos::TBProtos::EmergencyJam* EWRequestTopic::mutable_emergency_jam() {
  set_has_emergency_jam();
  if (emergency_jam_ == NULL) emergency_jam_ = new ::fv::tb::protos::TBProtos::EmergencyJam;
  return emergency_jam_;
}
inline ::fv::tb::protos::TBProtos::EmergencyJam* EWRequestTopic::release_emergency_jam() {
  clear_has_emergency_jam();
  ::fv::tb::protos::TBProtos::EmergencyJam* temp = emergency_jam_;
  emergency_jam_ = NULL;
  return temp;
}
inline void EWRequestTopic::set_allocated_emergency_jam(::fv::tb::protos::TBProtos::EmergencyJam* emergency_jam) {
  delete emergency_jam_;
  emergency_jam_ = emergency_jam;
  if (emergency_jam) {
    set_has_emergency_jam();
  } else {
    clear_has_emergency_jam();
  }
}

// optional .fv.tb.protos.TBProtos.TxFreqRequest tx_freq_request = 9;
inline bool EWRequestTopic::has_tx_freq_request() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EWRequestTopic::set_has_tx_freq_request() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EWRequestTopic::clear_has_tx_freq_request() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EWRequestTopic::clear_tx_freq_request() {
  if (tx_freq_request_ != NULL) tx_freq_request_->::fv::tb::protos::TBProtos::TxFreqRequest::Clear();
  clear_has_tx_freq_request();
}
inline const ::fv::tb::protos::TBProtos::TxFreqRequest& EWRequestTopic::tx_freq_request() const {
  return tx_freq_request_ != NULL ? *tx_freq_request_ : *default_instance_->tx_freq_request_;
}
inline ::fv::tb::protos::TBProtos::TxFreqRequest* EWRequestTopic::mutable_tx_freq_request() {
  set_has_tx_freq_request();
  if (tx_freq_request_ == NULL) tx_freq_request_ = new ::fv::tb::protos::TBProtos::TxFreqRequest;
  return tx_freq_request_;
}
inline ::fv::tb::protos::TBProtos::TxFreqRequest* EWRequestTopic::release_tx_freq_request() {
  clear_has_tx_freq_request();
  ::fv::tb::protos::TBProtos::TxFreqRequest* temp = tx_freq_request_;
  tx_freq_request_ = NULL;
  return temp;
}
inline void EWRequestTopic::set_allocated_tx_freq_request(::fv::tb::protos::TBProtos::TxFreqRequest* tx_freq_request) {
  delete tx_freq_request_;
  tx_freq_request_ = tx_freq_request;
  if (tx_freq_request) {
    set_has_tx_freq_request();
  } else {
    clear_has_tx_freq_request();
  }
}

// optional .fv.tb.protos.TBProtos.EWCapabilitiesRequest ew_capabilities_request = 10;
inline bool EWRequestTopic::has_ew_capabilities_request() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EWRequestTopic::set_has_ew_capabilities_request() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EWRequestTopic::clear_has_ew_capabilities_request() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EWRequestTopic::clear_ew_capabilities_request() {
  if (ew_capabilities_request_ != NULL) ew_capabilities_request_->::fv::tb::protos::TBProtos::EWCapabilitiesRequest::Clear();
  clear_has_ew_capabilities_request();
}
inline const ::fv::tb::protos::TBProtos::EWCapabilitiesRequest& EWRequestTopic::ew_capabilities_request() const {
  return ew_capabilities_request_ != NULL ? *ew_capabilities_request_ : *default_instance_->ew_capabilities_request_;
}
inline ::fv::tb::protos::TBProtos::EWCapabilitiesRequest* EWRequestTopic::mutable_ew_capabilities_request() {
  set_has_ew_capabilities_request();
  if (ew_capabilities_request_ == NULL) ew_capabilities_request_ = new ::fv::tb::protos::TBProtos::EWCapabilitiesRequest;
  return ew_capabilities_request_;
}
inline ::fv::tb::protos::TBProtos::EWCapabilitiesRequest* EWRequestTopic::release_ew_capabilities_request() {
  clear_has_ew_capabilities_request();
  ::fv::tb::protos::TBProtos::EWCapabilitiesRequest* temp = ew_capabilities_request_;
  ew_capabilities_request_ = NULL;
  return temp;
}
inline void EWRequestTopic::set_allocated_ew_capabilities_request(::fv::tb::protos::TBProtos::EWCapabilitiesRequest* ew_capabilities_request) {
  delete ew_capabilities_request_;
  ew_capabilities_request_ = ew_capabilities_request;
  if (ew_capabilities_request) {
    set_has_ew_capabilities_request();
  } else {
    clear_has_ew_capabilities_request();
  }
}

// optional .fv.tb.protos.TBProtos.EWTransmittingRequest ew_transmitting_request = 11;
inline bool EWRequestTopic::has_ew_transmitting_request() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void EWRequestTopic::set_has_ew_transmitting_request() {
  _has_bits_[0] |= 0x00000400u;
}
inline void EWRequestTopic::clear_has_ew_transmitting_request() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void EWRequestTopic::clear_ew_transmitting_request() {
  if (ew_transmitting_request_ != NULL) ew_transmitting_request_->::fv::tb::protos::TBProtos::EWTransmittingRequest::Clear();
  clear_has_ew_transmitting_request();
}
inline const ::fv::tb::protos::TBProtos::EWTransmittingRequest& EWRequestTopic::ew_transmitting_request() const {
  return ew_transmitting_request_ != NULL ? *ew_transmitting_request_ : *default_instance_->ew_transmitting_request_;
}
inline ::fv::tb::protos::TBProtos::EWTransmittingRequest* EWRequestTopic::mutable_ew_transmitting_request() {
  set_has_ew_transmitting_request();
  if (ew_transmitting_request_ == NULL) ew_transmitting_request_ = new ::fv::tb::protos::TBProtos::EWTransmittingRequest;
  return ew_transmitting_request_;
}
inline ::fv::tb::protos::TBProtos::EWTransmittingRequest* EWRequestTopic::release_ew_transmitting_request() {
  clear_has_ew_transmitting_request();
  ::fv::tb::protos::TBProtos::EWTransmittingRequest* temp = ew_transmitting_request_;
  ew_transmitting_request_ = NULL;
  return temp;
}
inline void EWRequestTopic::set_allocated_ew_transmitting_request(::fv::tb::protos::TBProtos::EWTransmittingRequest* ew_transmitting_request) {
  delete ew_transmitting_request_;
  ew_transmitting_request_ = ew_transmitting_request;
  if (ew_transmitting_request) {
    set_has_ew_transmitting_request();
  } else {
    clear_has_ew_transmitting_request();
  }
}

// optional .fv.tb.protos.TBProtos.CloseSelf close_self = 12;
inline bool EWRequestTopic::has_close_self() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void EWRequestTopic::set_has_close_self() {
  _has_bits_[0] |= 0x00000800u;
}
inline void EWRequestTopic::clear_has_close_self() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void EWRequestTopic::clear_close_self() {
  if (close_self_ != NULL) close_self_->::fv::tb::protos::TBProtos::CloseSelf::Clear();
  clear_has_close_self();
}
inline const ::fv::tb::protos::TBProtos::CloseSelf& EWRequestTopic::close_self() const {
  return close_self_ != NULL ? *close_self_ : *default_instance_->close_self_;
}
inline ::fv::tb::protos::TBProtos::CloseSelf* EWRequestTopic::mutable_close_self() {
  set_has_close_self();
  if (close_self_ == NULL) close_self_ = new ::fv::tb::protos::TBProtos::CloseSelf;
  return close_self_;
}
inline ::fv::tb::protos::TBProtos::CloseSelf* EWRequestTopic::release_close_self() {
  clear_has_close_self();
  ::fv::tb::protos::TBProtos::CloseSelf* temp = close_self_;
  close_self_ = NULL;
  return temp;
}
inline void EWRequestTopic::set_allocated_close_self(::fv::tb::protos::TBProtos::CloseSelf* close_self) {
  delete close_self_;
  close_self_ = close_self;
  if (close_self) {
    set_has_close_self();
  } else {
    clear_has_close_self();
  }
}

// optional .fv.tb.protos.TBProtos.UnregisterRequest unregister_request = 13;
inline bool EWRequestTopic::has_unregister_request() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void EWRequestTopic::set_has_unregister_request() {
  _has_bits_[0] |= 0x00001000u;
}
inline void EWRequestTopic::clear_has_unregister_request() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void EWRequestTopic::clear_unregister_request() {
  if (unregister_request_ != NULL) unregister_request_->::fv::tb::protos::TBProtos::UnregisterRequest::Clear();
  clear_has_unregister_request();
}
inline const ::fv::tb::protos::TBProtos::UnregisterRequest& EWRequestTopic::unregister_request() const {
  return unregister_request_ != NULL ? *unregister_request_ : *default_instance_->unregister_request_;
}
inline ::fv::tb::protos::TBProtos::UnregisterRequest* EWRequestTopic::mutable_unregister_request() {
  set_has_unregister_request();
  if (unregister_request_ == NULL) unregister_request_ = new ::fv::tb::protos::TBProtos::UnregisterRequest;
  return unregister_request_;
}
inline ::fv::tb::protos::TBProtos::UnregisterRequest* EWRequestTopic::release_unregister_request() {
  clear_has_unregister_request();
  ::fv::tb::protos::TBProtos::UnregisterRequest* temp = unregister_request_;
  unregister_request_ = NULL;
  return temp;
}
inline void EWRequestTopic::set_allocated_unregister_request(::fv::tb::protos::TBProtos::UnregisterRequest* unregister_request) {
  delete unregister_request_;
  unregister_request_ = unregister_request;
  if (unregister_request) {
    set_has_unregister_request();
  } else {
    clear_has_unregister_request();
  }
}

// optional .fv.tb.protos.TBProtos.EWTechniqueDescriptionsRequest ew_technique_descriptions_request = 14;
inline bool EWRequestTopic::has_ew_technique_descriptions_request() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void EWRequestTopic::set_has_ew_technique_descriptions_request() {
  _has_bits_[0] |= 0x00002000u;
}
inline void EWRequestTopic::clear_has_ew_technique_descriptions_request() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void EWRequestTopic::clear_ew_technique_descriptions_request() {
  if (ew_technique_descriptions_request_ != NULL) ew_technique_descriptions_request_->::fv::tb::protos::TBProtos::EWTechniqueDescriptionsRequest::Clear();
  clear_has_ew_technique_descriptions_request();
}
inline const ::fv::tb::protos::TBProtos::EWTechniqueDescriptionsRequest& EWRequestTopic::ew_technique_descriptions_request() const {
  return ew_technique_descriptions_request_ != NULL ? *ew_technique_descriptions_request_ : *default_instance_->ew_technique_descriptions_request_;
}
inline ::fv::tb::protos::TBProtos::EWTechniqueDescriptionsRequest* EWRequestTopic::mutable_ew_technique_descriptions_request() {
  set_has_ew_technique_descriptions_request();
  if (ew_technique_descriptions_request_ == NULL) ew_technique_descriptions_request_ = new ::fv::tb::protos::TBProtos::EWTechniqueDescriptionsRequest;
  return ew_technique_descriptions_request_;
}
inline ::fv::tb::protos::TBProtos::EWTechniqueDescriptionsRequest* EWRequestTopic::release_ew_technique_descriptions_request() {
  clear_has_ew_technique_descriptions_request();
  ::fv::tb::protos::TBProtos::EWTechniqueDescriptionsRequest* temp = ew_technique_descriptions_request_;
  ew_technique_descriptions_request_ = NULL;
  return temp;
}
inline void EWRequestTopic::set_allocated_ew_technique_descriptions_request(::fv::tb::protos::TBProtos::EWTechniqueDescriptionsRequest* ew_technique_descriptions_request) {
  delete ew_technique_descriptions_request_;
  ew_technique_descriptions_request_ = ew_technique_descriptions_request;
  if (ew_technique_descriptions_request) {
    set_has_ew_technique_descriptions_request();
  } else {
    clear_has_ew_technique_descriptions_request();
  }
}

// -------------------------------------------------------------------

// CapabilityRequestTopic

// optional .service_infrastructure.Header header = 100;
inline bool CapabilityRequestTopic::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CapabilityRequestTopic::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CapabilityRequestTopic::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CapabilityRequestTopic::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& CapabilityRequestTopic::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* CapabilityRequestTopic::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* CapabilityRequestTopic::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void CapabilityRequestTopic::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .fv.tb.protos.TBProtos.JamOff jam_off = 10;
inline bool CapabilityRequestTopic::has_jam_off() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CapabilityRequestTopic::set_has_jam_off() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CapabilityRequestTopic::clear_has_jam_off() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CapabilityRequestTopic::clear_jam_off() {
  if (jam_off_ != NULL) jam_off_->::fv::tb::protos::TBProtos::JamOff::Clear();
  clear_has_jam_off();
}
inline const ::fv::tb::protos::TBProtos::JamOff& CapabilityRequestTopic::jam_off() const {
  return jam_off_ != NULL ? *jam_off_ : *default_instance_->jam_off_;
}
inline ::fv::tb::protos::TBProtos::JamOff* CapabilityRequestTopic::mutable_jam_off() {
  set_has_jam_off();
  if (jam_off_ == NULL) jam_off_ = new ::fv::tb::protos::TBProtos::JamOff;
  return jam_off_;
}
inline ::fv::tb::protos::TBProtos::JamOff* CapabilityRequestTopic::release_jam_off() {
  clear_has_jam_off();
  ::fv::tb::protos::TBProtos::JamOff* temp = jam_off_;
  jam_off_ = NULL;
  return temp;
}
inline void CapabilityRequestTopic::set_allocated_jam_off(::fv::tb::protos::TBProtos::JamOff* jam_off) {
  delete jam_off_;
  jam_off_ = jam_off;
  if (jam_off) {
    set_has_jam_off();
  } else {
    clear_has_jam_off();
  }
}

// optional .fv.tb.protos.TBProtos.techniqueCommand technique_command = 11;
inline bool CapabilityRequestTopic::has_technique_command() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CapabilityRequestTopic::set_has_technique_command() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CapabilityRequestTopic::clear_has_technique_command() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CapabilityRequestTopic::clear_technique_command() {
  if (technique_command_ != NULL) technique_command_->::fv::tb::protos::TBProtos::techniqueCommand::Clear();
  clear_has_technique_command();
}
inline const ::fv::tb::protos::TBProtos::techniqueCommand& CapabilityRequestTopic::technique_command() const {
  return technique_command_ != NULL ? *technique_command_ : *default_instance_->technique_command_;
}
inline ::fv::tb::protos::TBProtos::techniqueCommand* CapabilityRequestTopic::mutable_technique_command() {
  set_has_technique_command();
  if (technique_command_ == NULL) technique_command_ = new ::fv::tb::protos::TBProtos::techniqueCommand;
  return technique_command_;
}
inline ::fv::tb::protos::TBProtos::techniqueCommand* CapabilityRequestTopic::release_technique_command() {
  clear_has_technique_command();
  ::fv::tb::protos::TBProtos::techniqueCommand* temp = technique_command_;
  technique_command_ = NULL;
  return temp;
}
inline void CapabilityRequestTopic::set_allocated_technique_command(::fv::tb::protos::TBProtos::techniqueCommand* technique_command) {
  delete technique_command_;
  technique_command_ = technique_command;
  if (technique_command) {
    set_has_technique_command();
  } else {
    clear_has_technique_command();
  }
}

// -------------------------------------------------------------------

// TransmitterControlRequestTopic

// optional .service_infrastructure.Header header = 100;
inline bool TransmitterControlRequestTopic::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransmitterControlRequestTopic::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransmitterControlRequestTopic::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransmitterControlRequestTopic::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& TransmitterControlRequestTopic::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* TransmitterControlRequestTopic::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* TransmitterControlRequestTopic::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void TransmitterControlRequestTopic::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .tuner_msg.TxTune txTune = 7;
inline bool TransmitterControlRequestTopic::has_txtune() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransmitterControlRequestTopic::set_has_txtune() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransmitterControlRequestTopic::clear_has_txtune() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransmitterControlRequestTopic::clear_txtune() {
  if (txtune_ != NULL) txtune_->::tuner_msg::TxTune::Clear();
  clear_has_txtune();
}
inline const ::tuner_msg::TxTune& TransmitterControlRequestTopic::txtune() const {
  return txtune_ != NULL ? *txtune_ : *default_instance_->txtune_;
}
inline ::tuner_msg::TxTune* TransmitterControlRequestTopic::mutable_txtune() {
  set_has_txtune();
  if (txtune_ == NULL) txtune_ = new ::tuner_msg::TxTune;
  return txtune_;
}
inline ::tuner_msg::TxTune* TransmitterControlRequestTopic::release_txtune() {
  clear_has_txtune();
  ::tuner_msg::TxTune* temp = txtune_;
  txtune_ = NULL;
  return temp;
}
inline void TransmitterControlRequestTopic::set_allocated_txtune(::tuner_msg::TxTune* txtune) {
  delete txtune_;
  txtune_ = txtune;
  if (txtune) {
    set_has_txtune();
  } else {
    clear_has_txtune();
  }
}

// optional .tuner_msg.ReactiveJam reactiveJam = 10;
inline bool TransmitterControlRequestTopic::has_reactivejam() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransmitterControlRequestTopic::set_has_reactivejam() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransmitterControlRequestTopic::clear_has_reactivejam() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransmitterControlRequestTopic::clear_reactivejam() {
  if (reactivejam_ != NULL) reactivejam_->::tuner_msg::ReactiveJam::Clear();
  clear_has_reactivejam();
}
inline const ::tuner_msg::ReactiveJam& TransmitterControlRequestTopic::reactivejam() const {
  return reactivejam_ != NULL ? *reactivejam_ : *default_instance_->reactivejam_;
}
inline ::tuner_msg::ReactiveJam* TransmitterControlRequestTopic::mutable_reactivejam() {
  set_has_reactivejam();
  if (reactivejam_ == NULL) reactivejam_ = new ::tuner_msg::ReactiveJam;
  return reactivejam_;
}
inline ::tuner_msg::ReactiveJam* TransmitterControlRequestTopic::release_reactivejam() {
  clear_has_reactivejam();
  ::tuner_msg::ReactiveJam* temp = reactivejam_;
  reactivejam_ = NULL;
  return temp;
}
inline void TransmitterControlRequestTopic::set_allocated_reactivejam(::tuner_msg::ReactiveJam* reactivejam) {
  delete reactivejam_;
  reactivejam_ = reactivejam;
  if (reactivejam) {
    set_has_reactivejam();
  } else {
    clear_has_reactivejam();
  }
}

// -------------------------------------------------------------------

// RadioControlResponseTopic

// optional .service_infrastructure.Header header = 100;
inline bool RadioControlResponseTopic::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RadioControlResponseTopic::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RadioControlResponseTopic::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RadioControlResponseTopic::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& RadioControlResponseTopic::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* RadioControlResponseTopic::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* RadioControlResponseTopic::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void RadioControlResponseTopic::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .service_infrastructure.Ack ack = 1;
inline bool RadioControlResponseTopic::has_ack() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RadioControlResponseTopic::set_has_ack() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RadioControlResponseTopic::clear_has_ack() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RadioControlResponseTopic::clear_ack() {
  if (ack_ != NULL) ack_->::service_infrastructure::Ack::Clear();
  clear_has_ack();
}
inline const ::service_infrastructure::Ack& RadioControlResponseTopic::ack() const {
  return ack_ != NULL ? *ack_ : *default_instance_->ack_;
}
inline ::service_infrastructure::Ack* RadioControlResponseTopic::mutable_ack() {
  set_has_ack();
  if (ack_ == NULL) ack_ = new ::service_infrastructure::Ack;
  return ack_;
}
inline ::service_infrastructure::Ack* RadioControlResponseTopic::release_ack() {
  clear_has_ack();
  ::service_infrastructure::Ack* temp = ack_;
  ack_ = NULL;
  return temp;
}
inline void RadioControlResponseTopic::set_allocated_ack(::service_infrastructure::Ack* ack) {
  delete ack_;
  ack_ = ack;
  if (ack) {
    set_has_ack();
  } else {
    clear_has_ack();
  }
}

// optional .service_infrastructure.NAck nack = 2;
inline bool RadioControlResponseTopic::has_nack() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RadioControlResponseTopic::set_has_nack() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RadioControlResponseTopic::clear_has_nack() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RadioControlResponseTopic::clear_nack() {
  if (nack_ != NULL) nack_->::service_infrastructure::NAck::Clear();
  clear_has_nack();
}
inline const ::service_infrastructure::NAck& RadioControlResponseTopic::nack() const {
  return nack_ != NULL ? *nack_ : *default_instance_->nack_;
}
inline ::service_infrastructure::NAck* RadioControlResponseTopic::mutable_nack() {
  set_has_nack();
  if (nack_ == NULL) nack_ = new ::service_infrastructure::NAck;
  return nack_;
}
inline ::service_infrastructure::NAck* RadioControlResponseTopic::release_nack() {
  clear_has_nack();
  ::service_infrastructure::NAck* temp = nack_;
  nack_ = NULL;
  return temp;
}
inline void RadioControlResponseTopic::set_allocated_nack(::service_infrastructure::NAck* nack) {
  delete nack_;
  nack_ = nack;
  if (nack) {
    set_has_nack();
  } else {
    clear_has_nack();
  }
}

// optional .tuner_msg.ReceiverStatus rx_status = 3;
inline bool RadioControlResponseTopic::has_rx_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RadioControlResponseTopic::set_has_rx_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RadioControlResponseTopic::clear_has_rx_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RadioControlResponseTopic::clear_rx_status() {
  if (rx_status_ != NULL) rx_status_->::tuner_msg::ReceiverStatus::Clear();
  clear_has_rx_status();
}
inline const ::tuner_msg::ReceiverStatus& RadioControlResponseTopic::rx_status() const {
  return rx_status_ != NULL ? *rx_status_ : *default_instance_->rx_status_;
}
inline ::tuner_msg::ReceiverStatus* RadioControlResponseTopic::mutable_rx_status() {
  set_has_rx_status();
  if (rx_status_ == NULL) rx_status_ = new ::tuner_msg::ReceiverStatus;
  return rx_status_;
}
inline ::tuner_msg::ReceiverStatus* RadioControlResponseTopic::release_rx_status() {
  clear_has_rx_status();
  ::tuner_msg::ReceiverStatus* temp = rx_status_;
  rx_status_ = NULL;
  return temp;
}
inline void RadioControlResponseTopic::set_allocated_rx_status(::tuner_msg::ReceiverStatus* rx_status) {
  delete rx_status_;
  rx_status_ = rx_status;
  if (rx_status) {
    set_has_rx_status();
  } else {
    clear_has_rx_status();
  }
}

// optional .tuner_msg.ReceiverAcquired receiver_acquired = 4;
inline bool RadioControlResponseTopic::has_receiver_acquired() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RadioControlResponseTopic::set_has_receiver_acquired() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RadioControlResponseTopic::clear_has_receiver_acquired() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RadioControlResponseTopic::clear_receiver_acquired() {
  if (receiver_acquired_ != NULL) receiver_acquired_->::tuner_msg::ReceiverAcquired::Clear();
  clear_has_receiver_acquired();
}
inline const ::tuner_msg::ReceiverAcquired& RadioControlResponseTopic::receiver_acquired() const {
  return receiver_acquired_ != NULL ? *receiver_acquired_ : *default_instance_->receiver_acquired_;
}
inline ::tuner_msg::ReceiverAcquired* RadioControlResponseTopic::mutable_receiver_acquired() {
  set_has_receiver_acquired();
  if (receiver_acquired_ == NULL) receiver_acquired_ = new ::tuner_msg::ReceiverAcquired;
  return receiver_acquired_;
}
inline ::tuner_msg::ReceiverAcquired* RadioControlResponseTopic::release_receiver_acquired() {
  clear_has_receiver_acquired();
  ::tuner_msg::ReceiverAcquired* temp = receiver_acquired_;
  receiver_acquired_ = NULL;
  return temp;
}
inline void RadioControlResponseTopic::set_allocated_receiver_acquired(::tuner_msg::ReceiverAcquired* receiver_acquired) {
  delete receiver_acquired_;
  receiver_acquired_ = receiver_acquired;
  if (receiver_acquired) {
    set_has_receiver_acquired();
  } else {
    clear_has_receiver_acquired();
  }
}

// optional .tuner_msg.ReceiverReleased receiver_released = 5;
inline bool RadioControlResponseTopic::has_receiver_released() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RadioControlResponseTopic::set_has_receiver_released() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RadioControlResponseTopic::clear_has_receiver_released() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RadioControlResponseTopic::clear_receiver_released() {
  if (receiver_released_ != NULL) receiver_released_->::tuner_msg::ReceiverReleased::Clear();
  clear_has_receiver_released();
}
inline const ::tuner_msg::ReceiverReleased& RadioControlResponseTopic::receiver_released() const {
  return receiver_released_ != NULL ? *receiver_released_ : *default_instance_->receiver_released_;
}
inline ::tuner_msg::ReceiverReleased* RadioControlResponseTopic::mutable_receiver_released() {
  set_has_receiver_released();
  if (receiver_released_ == NULL) receiver_released_ = new ::tuner_msg::ReceiverReleased;
  return receiver_released_;
}
inline ::tuner_msg::ReceiverReleased* RadioControlResponseTopic::release_receiver_released() {
  clear_has_receiver_released();
  ::tuner_msg::ReceiverReleased* temp = receiver_released_;
  receiver_released_ = NULL;
  return temp;
}
inline void RadioControlResponseTopic::set_allocated_receiver_released(::tuner_msg::ReceiverReleased* receiver_released) {
  delete receiver_released_;
  receiver_released_ = receiver_released;
  if (receiver_released) {
    set_has_receiver_released();
  } else {
    clear_has_receiver_released();
  }
}

// optional .rx_command_msg.RxCommandResponse rx_command_response = 6;
inline bool RadioControlResponseTopic::has_rx_command_response() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RadioControlResponseTopic::set_has_rx_command_response() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RadioControlResponseTopic::clear_has_rx_command_response() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RadioControlResponseTopic::clear_rx_command_response() {
  if (rx_command_response_ != NULL) rx_command_response_->::rx_command_msg::RxCommandResponse::Clear();
  clear_has_rx_command_response();
}
inline const ::rx_command_msg::RxCommandResponse& RadioControlResponseTopic::rx_command_response() const {
  return rx_command_response_ != NULL ? *rx_command_response_ : *default_instance_->rx_command_response_;
}
inline ::rx_command_msg::RxCommandResponse* RadioControlResponseTopic::mutable_rx_command_response() {
  set_has_rx_command_response();
  if (rx_command_response_ == NULL) rx_command_response_ = new ::rx_command_msg::RxCommandResponse;
  return rx_command_response_;
}
inline ::rx_command_msg::RxCommandResponse* RadioControlResponseTopic::release_rx_command_response() {
  clear_has_rx_command_response();
  ::rx_command_msg::RxCommandResponse* temp = rx_command_response_;
  rx_command_response_ = NULL;
  return temp;
}
inline void RadioControlResponseTopic::set_allocated_rx_command_response(::rx_command_msg::RxCommandResponse* rx_command_response) {
  delete rx_command_response_;
  rx_command_response_ = rx_command_response;
  if (rx_command_response) {
    set_has_rx_command_response();
  } else {
    clear_has_rx_command_response();
  }
}

// -------------------------------------------------------------------

// DebugTopic

// optional .service_infrastructure.Header header = 100;
inline bool DebugTopic::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugTopic::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugTopic::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugTopic::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& DebugTopic::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* DebugTopic::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* DebugTopic::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DebugTopic::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .falcon_debug_msg.Info info = 1;
inline bool DebugTopic::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugTopic::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DebugTopic::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DebugTopic::clear_info() {
  if (info_ != NULL) info_->::falcon_debug_msg::Info::Clear();
  clear_has_info();
}
inline const ::falcon_debug_msg::Info& DebugTopic::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::falcon_debug_msg::Info* DebugTopic::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::falcon_debug_msg::Info;
  return info_;
}
inline ::falcon_debug_msg::Info* DebugTopic::release_info() {
  clear_has_info();
  ::falcon_debug_msg::Info* temp = info_;
  info_ = NULL;
  return temp;
}
inline void DebugTopic::set_allocated_info(::falcon_debug_msg::Info* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// optional .falcon_debug_msg.Info hostname = 10;
inline bool DebugTopic::has_hostname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DebugTopic::set_has_hostname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DebugTopic::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DebugTopic::clear_hostname() {
  if (hostname_ != NULL) hostname_->::falcon_debug_msg::Info::Clear();
  clear_has_hostname();
}
inline const ::falcon_debug_msg::Info& DebugTopic::hostname() const {
  return hostname_ != NULL ? *hostname_ : *default_instance_->hostname_;
}
inline ::falcon_debug_msg::Info* DebugTopic::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == NULL) hostname_ = new ::falcon_debug_msg::Info;
  return hostname_;
}
inline ::falcon_debug_msg::Info* DebugTopic::release_hostname() {
  clear_has_hostname();
  ::falcon_debug_msg::Info* temp = hostname_;
  hostname_ = NULL;
  return temp;
}
inline void DebugTopic::set_allocated_hostname(::falcon_debug_msg::Info* hostname) {
  delete hostname_;
  hostname_ = hostname;
  if (hostname) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
}

// optional .falcon_debug_msg.Warning warning = 2;
inline bool DebugTopic::has_warning() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DebugTopic::set_has_warning() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DebugTopic::clear_has_warning() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DebugTopic::clear_warning() {
  if (warning_ != NULL) warning_->::falcon_debug_msg::Warning::Clear();
  clear_has_warning();
}
inline const ::falcon_debug_msg::Warning& DebugTopic::warning() const {
  return warning_ != NULL ? *warning_ : *default_instance_->warning_;
}
inline ::falcon_debug_msg::Warning* DebugTopic::mutable_warning() {
  set_has_warning();
  if (warning_ == NULL) warning_ = new ::falcon_debug_msg::Warning;
  return warning_;
}
inline ::falcon_debug_msg::Warning* DebugTopic::release_warning() {
  clear_has_warning();
  ::falcon_debug_msg::Warning* temp = warning_;
  warning_ = NULL;
  return temp;
}
inline void DebugTopic::set_allocated_warning(::falcon_debug_msg::Warning* warning) {
  delete warning_;
  warning_ = warning;
  if (warning) {
    set_has_warning();
  } else {
    clear_has_warning();
  }
}

// optional .falcon_debug_msg.Error error = 3;
inline bool DebugTopic::has_error() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DebugTopic::set_has_error() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DebugTopic::clear_has_error() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DebugTopic::clear_error() {
  if (error_ != NULL) error_->::falcon_debug_msg::Error::Clear();
  clear_has_error();
}
inline const ::falcon_debug_msg::Error& DebugTopic::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::falcon_debug_msg::Error* DebugTopic::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::falcon_debug_msg::Error;
  return error_;
}
inline ::falcon_debug_msg::Error* DebugTopic::release_error() {
  clear_has_error();
  ::falcon_debug_msg::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline void DebugTopic::set_allocated_error(::falcon_debug_msg::Error* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
}

// -------------------------------------------------------------------

// SigFramesTopic

// optional .service_infrastructure.Header header = 100;
inline bool SigFramesTopic::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SigFramesTopic::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SigFramesTopic::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SigFramesTopic::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& SigFramesTopic::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* SigFramesTopic::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* SigFramesTopic::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void SigFramesTopic::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .fv.sf.protos.SFProtos.SIGFrame sigframe = 1;
inline bool SigFramesTopic::has_sigframe() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SigFramesTopic::set_has_sigframe() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SigFramesTopic::clear_has_sigframe() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SigFramesTopic::clear_sigframe() {
  if (sigframe_ != NULL) sigframe_->::fv::sf::protos::SFProtos::SIGFrame::Clear();
  clear_has_sigframe();
}
inline const ::fv::sf::protos::SFProtos::SIGFrame& SigFramesTopic::sigframe() const {
  return sigframe_ != NULL ? *sigframe_ : *default_instance_->sigframe_;
}
inline ::fv::sf::protos::SFProtos::SIGFrame* SigFramesTopic::mutable_sigframe() {
  set_has_sigframe();
  if (sigframe_ == NULL) sigframe_ = new ::fv::sf::protos::SFProtos::SIGFrame;
  return sigframe_;
}
inline ::fv::sf::protos::SFProtos::SIGFrame* SigFramesTopic::release_sigframe() {
  clear_has_sigframe();
  ::fv::sf::protos::SFProtos::SIGFrame* temp = sigframe_;
  sigframe_ = NULL;
  return temp;
}
inline void SigFramesTopic::set_allocated_sigframe(::fv::sf::protos::SFProtos::SIGFrame* sigframe) {
  delete sigframe_;
  sigframe_ = sigframe;
  if (sigframe) {
    set_has_sigframe();
  } else {
    clear_has_sigframe();
  }
}

// -------------------------------------------------------------------

// RadioDataTopic

// optional .service_infrastructure.Header header = 100;
inline bool RadioDataTopic::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RadioDataTopic::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RadioDataTopic::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RadioDataTopic::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& RadioDataTopic::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* RadioDataTopic::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* RadioDataTopic::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void RadioDataTopic::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .tuner_msg.SnapInfo snap_info = 1;
inline bool RadioDataTopic::has_snap_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RadioDataTopic::set_has_snap_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RadioDataTopic::clear_has_snap_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RadioDataTopic::clear_snap_info() {
  if (snap_info_ != NULL) snap_info_->::tuner_msg::SnapInfo::Clear();
  clear_has_snap_info();
}
inline const ::tuner_msg::SnapInfo& RadioDataTopic::snap_info() const {
  return snap_info_ != NULL ? *snap_info_ : *default_instance_->snap_info_;
}
inline ::tuner_msg::SnapInfo* RadioDataTopic::mutable_snap_info() {
  set_has_snap_info();
  if (snap_info_ == NULL) snap_info_ = new ::tuner_msg::SnapInfo;
  return snap_info_;
}
inline ::tuner_msg::SnapInfo* RadioDataTopic::release_snap_info() {
  clear_has_snap_info();
  ::tuner_msg::SnapInfo* temp = snap_info_;
  snap_info_ = NULL;
  return temp;
}
inline void RadioDataTopic::set_allocated_snap_info(::tuner_msg::SnapInfo* snap_info) {
  delete snap_info_;
  snap_info_ = snap_info;
  if (snap_info) {
    set_has_snap_info();
  } else {
    clear_has_snap_info();
  }
}

// -------------------------------------------------------------------

// GeoTopic

// optional .service_infrastructure.Header header = 100;
inline bool GeoTopic::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GeoTopic::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GeoTopic::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GeoTopic::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& GeoTopic::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* GeoTopic::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* GeoTopic::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GeoTopic::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .falcon_common_msg.GeoTip geo_tip = 1;
inline bool GeoTopic::has_geo_tip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GeoTopic::set_has_geo_tip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GeoTopic::clear_has_geo_tip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GeoTopic::clear_geo_tip() {
  if (geo_tip_ != NULL) geo_tip_->::falcon_common_msg::GeoTip::Clear();
  clear_has_geo_tip();
}
inline const ::falcon_common_msg::GeoTip& GeoTopic::geo_tip() const {
  return geo_tip_ != NULL ? *geo_tip_ : *default_instance_->geo_tip_;
}
inline ::falcon_common_msg::GeoTip* GeoTopic::mutable_geo_tip() {
  set_has_geo_tip();
  if (geo_tip_ == NULL) geo_tip_ = new ::falcon_common_msg::GeoTip;
  return geo_tip_;
}
inline ::falcon_common_msg::GeoTip* GeoTopic::release_geo_tip() {
  clear_has_geo_tip();
  ::falcon_common_msg::GeoTip* temp = geo_tip_;
  geo_tip_ = NULL;
  return temp;
}
inline void GeoTopic::set_allocated_geo_tip(::falcon_common_msg::GeoTip* geo_tip) {
  delete geo_tip_;
  geo_tip_ = geo_tip;
  if (geo_tip) {
    set_has_geo_tip();
  } else {
    clear_has_geo_tip();
  }
}

// optional .falcon_common_msg.GeoResult geo_result = 2;
inline bool GeoTopic::has_geo_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GeoTopic::set_has_geo_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GeoTopic::clear_has_geo_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GeoTopic::clear_geo_result() {
  if (geo_result_ != NULL) geo_result_->::falcon_common_msg::GeoResult::Clear();
  clear_has_geo_result();
}
inline const ::falcon_common_msg::GeoResult& GeoTopic::geo_result() const {
  return geo_result_ != NULL ? *geo_result_ : *default_instance_->geo_result_;
}
inline ::falcon_common_msg::GeoResult* GeoTopic::mutable_geo_result() {
  set_has_geo_result();
  if (geo_result_ == NULL) geo_result_ = new ::falcon_common_msg::GeoResult;
  return geo_result_;
}
inline ::falcon_common_msg::GeoResult* GeoTopic::release_geo_result() {
  clear_has_geo_result();
  ::falcon_common_msg::GeoResult* temp = geo_result_;
  geo_result_ = NULL;
  return temp;
}
inline void GeoTopic::set_allocated_geo_result(::falcon_common_msg::GeoResult* geo_result) {
  delete geo_result_;
  geo_result_ = geo_result;
  if (geo_result) {
    set_has_geo_result();
  } else {
    clear_has_geo_result();
  }
}

// optional .falcon_common_msg.DetectionTip detection_tip = 3;
inline bool GeoTopic::has_detection_tip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GeoTopic::set_has_detection_tip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GeoTopic::clear_has_detection_tip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GeoTopic::clear_detection_tip() {
  if (detection_tip_ != NULL) detection_tip_->::falcon_common_msg::DetectionTip::Clear();
  clear_has_detection_tip();
}
inline const ::falcon_common_msg::DetectionTip& GeoTopic::detection_tip() const {
  return detection_tip_ != NULL ? *detection_tip_ : *default_instance_->detection_tip_;
}
inline ::falcon_common_msg::DetectionTip* GeoTopic::mutable_detection_tip() {
  set_has_detection_tip();
  if (detection_tip_ == NULL) detection_tip_ = new ::falcon_common_msg::DetectionTip;
  return detection_tip_;
}
inline ::falcon_common_msg::DetectionTip* GeoTopic::release_detection_tip() {
  clear_has_detection_tip();
  ::falcon_common_msg::DetectionTip* temp = detection_tip_;
  detection_tip_ = NULL;
  return temp;
}
inline void GeoTopic::set_allocated_detection_tip(::falcon_common_msg::DetectionTip* detection_tip) {
  delete detection_tip_;
  detection_tip_ = detection_tip;
  if (detection_tip) {
    set_has_detection_tip();
  } else {
    clear_has_detection_tip();
  }
}

// -------------------------------------------------------------------

// SensorTopic

// optional .service_infrastructure.Header header = 100;
inline bool SensorTopic::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorTopic::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SensorTopic::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SensorTopic::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& SensorTopic::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* SensorTopic::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* SensorTopic::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void SensorTopic::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .falcon_remoting_msg.HardwareStatus hardware_status = 1;
inline bool SensorTopic::has_hardware_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorTopic::set_has_hardware_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SensorTopic::clear_has_hardware_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SensorTopic::clear_hardware_status() {
  if (hardware_status_ != NULL) hardware_status_->::falcon_remoting_msg::HardwareStatus::Clear();
  clear_has_hardware_status();
}
inline const ::falcon_remoting_msg::HardwareStatus& SensorTopic::hardware_status() const {
  return hardware_status_ != NULL ? *hardware_status_ : *default_instance_->hardware_status_;
}
inline ::falcon_remoting_msg::HardwareStatus* SensorTopic::mutable_hardware_status() {
  set_has_hardware_status();
  if (hardware_status_ == NULL) hardware_status_ = new ::falcon_remoting_msg::HardwareStatus;
  return hardware_status_;
}
inline ::falcon_remoting_msg::HardwareStatus* SensorTopic::release_hardware_status() {
  clear_has_hardware_status();
  ::falcon_remoting_msg::HardwareStatus* temp = hardware_status_;
  hardware_status_ = NULL;
  return temp;
}
inline void SensorTopic::set_allocated_hardware_status(::falcon_remoting_msg::HardwareStatus* hardware_status) {
  delete hardware_status_;
  hardware_status_ = hardware_status;
  if (hardware_status) {
    set_has_hardware_status();
  } else {
    clear_has_hardware_status();
  }
}

// optional .falcon_remoting_msg.SensorPosition sensor_position = 2;
inline bool SensorTopic::has_sensor_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SensorTopic::set_has_sensor_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SensorTopic::clear_has_sensor_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SensorTopic::clear_sensor_position() {
  if (sensor_position_ != NULL) sensor_position_->::falcon_remoting_msg::SensorPosition::Clear();
  clear_has_sensor_position();
}
inline const ::falcon_remoting_msg::SensorPosition& SensorTopic::sensor_position() const {
  return sensor_position_ != NULL ? *sensor_position_ : *default_instance_->sensor_position_;
}
inline ::falcon_remoting_msg::SensorPosition* SensorTopic::mutable_sensor_position() {
  set_has_sensor_position();
  if (sensor_position_ == NULL) sensor_position_ = new ::falcon_remoting_msg::SensorPosition;
  return sensor_position_;
}
inline ::falcon_remoting_msg::SensorPosition* SensorTopic::release_sensor_position() {
  clear_has_sensor_position();
  ::falcon_remoting_msg::SensorPosition* temp = sensor_position_;
  sensor_position_ = NULL;
  return temp;
}
inline void SensorTopic::set_allocated_sensor_position(::falcon_remoting_msg::SensorPosition* sensor_position) {
  delete sensor_position_;
  sensor_position_ = sensor_position;
  if (sensor_position) {
    set_has_sensor_position();
  } else {
    clear_has_sensor_position();
  }
}

// optional .falcon_antenna_msg.SwitchStatus switch_status = 3;
inline bool SensorTopic::has_switch_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SensorTopic::set_has_switch_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SensorTopic::clear_has_switch_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SensorTopic::clear_switch_status() {
  if (switch_status_ != NULL) switch_status_->::falcon_antenna_msg::SwitchStatus::Clear();
  clear_has_switch_status();
}
inline const ::falcon_antenna_msg::SwitchStatus& SensorTopic::switch_status() const {
  return switch_status_ != NULL ? *switch_status_ : *default_instance_->switch_status_;
}
inline ::falcon_antenna_msg::SwitchStatus* SensorTopic::mutable_switch_status() {
  set_has_switch_status();
  if (switch_status_ == NULL) switch_status_ = new ::falcon_antenna_msg::SwitchStatus;
  return switch_status_;
}
inline ::falcon_antenna_msg::SwitchStatus* SensorTopic::release_switch_status() {
  clear_has_switch_status();
  ::falcon_antenna_msg::SwitchStatus* temp = switch_status_;
  switch_status_ = NULL;
  return temp;
}
inline void SensorTopic::set_allocated_switch_status(::falcon_antenna_msg::SwitchStatus* switch_status) {
  delete switch_status_;
  switch_status_ = switch_status;
  if (switch_status) {
    set_has_switch_status();
  } else {
    clear_has_switch_status();
  }
}

// optional .falcon_remoting_msg.SensorStatus sensor_status = 4;
inline bool SensorTopic::has_sensor_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SensorTopic::set_has_sensor_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SensorTopic::clear_has_sensor_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SensorTopic::clear_sensor_status() {
  if (sensor_status_ != NULL) sensor_status_->::falcon_remoting_msg::SensorStatus::Clear();
  clear_has_sensor_status();
}
inline const ::falcon_remoting_msg::SensorStatus& SensorTopic::sensor_status() const {
  return sensor_status_ != NULL ? *sensor_status_ : *default_instance_->sensor_status_;
}
inline ::falcon_remoting_msg::SensorStatus* SensorTopic::mutable_sensor_status() {
  set_has_sensor_status();
  if (sensor_status_ == NULL) sensor_status_ = new ::falcon_remoting_msg::SensorStatus;
  return sensor_status_;
}
inline ::falcon_remoting_msg::SensorStatus* SensorTopic::release_sensor_status() {
  clear_has_sensor_status();
  ::falcon_remoting_msg::SensorStatus* temp = sensor_status_;
  sensor_status_ = NULL;
  return temp;
}
inline void SensorTopic::set_allocated_sensor_status(::falcon_remoting_msg::SensorStatus* sensor_status) {
  delete sensor_status_;
  sensor_status_ = sensor_status;
  if (sensor_status) {
    set_has_sensor_status();
  } else {
    clear_has_sensor_status();
  }
}

// -------------------------------------------------------------------

// ImageRequest

// optional .service_infrastructure.Header header = 100;
inline bool ImageRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageRequest::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& ImageRequest::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* ImageRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* ImageRequest::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ImageRequest::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional string eltex = 1;
inline bool ImageRequest::has_eltex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageRequest::set_has_eltex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageRequest::clear_has_eltex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageRequest::clear_eltex() {
  if (eltex_ != &::google::protobuf::internal::kEmptyString) {
    eltex_->clear();
  }
  clear_has_eltex();
}
inline const ::std::string& ImageRequest::eltex() const {
  return *eltex_;
}
inline void ImageRequest::set_eltex(const ::std::string& value) {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  eltex_->assign(value);
}
inline void ImageRequest::set_eltex(const char* value) {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  eltex_->assign(value);
}
inline void ImageRequest::set_eltex(const char* value, size_t size) {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  eltex_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImageRequest::mutable_eltex() {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  return eltex_;
}
inline ::std::string* ImageRequest::release_eltex() {
  clear_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eltex_;
    eltex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ImageRequest::set_allocated_eltex(::std::string* eltex) {
  if (eltex_ != &::google::protobuf::internal::kEmptyString) {
    delete eltex_;
  }
  if (eltex) {
    set_has_eltex();
    eltex_ = eltex;
  } else {
    clear_has_eltex();
    eltex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string connection_id = 2;
inline bool ImageRequest::has_connection_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageRequest::set_has_connection_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageRequest::clear_has_connection_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageRequest::clear_connection_id() {
  if (connection_id_ != &::google::protobuf::internal::kEmptyString) {
    connection_id_->clear();
  }
  clear_has_connection_id();
}
inline const ::std::string& ImageRequest::connection_id() const {
  return *connection_id_;
}
inline void ImageRequest::set_connection_id(const ::std::string& value) {
  set_has_connection_id();
  if (connection_id_ == &::google::protobuf::internal::kEmptyString) {
    connection_id_ = new ::std::string;
  }
  connection_id_->assign(value);
}
inline void ImageRequest::set_connection_id(const char* value) {
  set_has_connection_id();
  if (connection_id_ == &::google::protobuf::internal::kEmptyString) {
    connection_id_ = new ::std::string;
  }
  connection_id_->assign(value);
}
inline void ImageRequest::set_connection_id(const char* value, size_t size) {
  set_has_connection_id();
  if (connection_id_ == &::google::protobuf::internal::kEmptyString) {
    connection_id_ = new ::std::string;
  }
  connection_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImageRequest::mutable_connection_id() {
  set_has_connection_id();
  if (connection_id_ == &::google::protobuf::internal::kEmptyString) {
    connection_id_ = new ::std::string;
  }
  return connection_id_;
}
inline ::std::string* ImageRequest::release_connection_id() {
  clear_has_connection_id();
  if (connection_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = connection_id_;
    connection_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ImageRequest::set_allocated_connection_id(::std::string* connection_id) {
  if (connection_id_ != &::google::protobuf::internal::kEmptyString) {
    delete connection_id_;
  }
  if (connection_id) {
    set_has_connection_id();
    connection_id_ = connection_id;
  } else {
    clear_has_connection_id();
    connection_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// VideoRequest

// optional .service_infrastructure.Header header = 100;
inline bool VideoRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VideoRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VideoRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VideoRequest::clear_header() {
  if (header_ != NULL) header_->::service_infrastructure::Header::Clear();
  clear_has_header();
}
inline const ::service_infrastructure::Header& VideoRequest::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::service_infrastructure::Header* VideoRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::service_infrastructure::Header;
  return header_;
}
inline ::service_infrastructure::Header* VideoRequest::release_header() {
  clear_has_header();
  ::service_infrastructure::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void VideoRequest::set_allocated_header(::service_infrastructure::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional string eltex = 1;
inline bool VideoRequest::has_eltex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VideoRequest::set_has_eltex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VideoRequest::clear_has_eltex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VideoRequest::clear_eltex() {
  if (eltex_ != &::google::protobuf::internal::kEmptyString) {
    eltex_->clear();
  }
  clear_has_eltex();
}
inline const ::std::string& VideoRequest::eltex() const {
  return *eltex_;
}
inline void VideoRequest::set_eltex(const ::std::string& value) {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  eltex_->assign(value);
}
inline void VideoRequest::set_eltex(const char* value) {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  eltex_->assign(value);
}
inline void VideoRequest::set_eltex(const char* value, size_t size) {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  eltex_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VideoRequest::mutable_eltex() {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  return eltex_;
}
inline ::std::string* VideoRequest::release_eltex() {
  clear_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eltex_;
    eltex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VideoRequest::set_allocated_eltex(::std::string* eltex) {
  if (eltex_ != &::google::protobuf::internal::kEmptyString) {
    delete eltex_;
  }
  if (eltex) {
    set_has_eltex();
    eltex_ = eltex;
  } else {
    clear_has_eltex();
    eltex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string connection_id = 2;
inline bool VideoRequest::has_connection_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VideoRequest::set_has_connection_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VideoRequest::clear_has_connection_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VideoRequest::clear_connection_id() {
  if (connection_id_ != &::google::protobuf::internal::kEmptyString) {
    connection_id_->clear();
  }
  clear_has_connection_id();
}
inline const ::std::string& VideoRequest::connection_id() const {
  return *connection_id_;
}
inline void VideoRequest::set_connection_id(const ::std::string& value) {
  set_has_connection_id();
  if (connection_id_ == &::google::protobuf::internal::kEmptyString) {
    connection_id_ = new ::std::string;
  }
  connection_id_->assign(value);
}
inline void VideoRequest::set_connection_id(const char* value) {
  set_has_connection_id();
  if (connection_id_ == &::google::protobuf::internal::kEmptyString) {
    connection_id_ = new ::std::string;
  }
  connection_id_->assign(value);
}
inline void VideoRequest::set_connection_id(const char* value, size_t size) {
  set_has_connection_id();
  if (connection_id_ == &::google::protobuf::internal::kEmptyString) {
    connection_id_ = new ::std::string;
  }
  connection_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VideoRequest::mutable_connection_id() {
  set_has_connection_id();
  if (connection_id_ == &::google::protobuf::internal::kEmptyString) {
    connection_id_ = new ::std::string;
  }
  return connection_id_;
}
inline ::std::string* VideoRequest::release_connection_id() {
  clear_has_connection_id();
  if (connection_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = connection_id_;
    connection_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VideoRequest::set_allocated_connection_id(::std::string* connection_id) {
  if (connection_id_ != &::google::protobuf::internal::kEmptyString) {
    delete connection_id_;
  }
  if (connection_id) {
    set_has_connection_id();
    connection_id_ = connection_id;
  } else {
    clear_has_connection_id();
    connection_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace service_infrastructure

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ServiceInfrastructureExclusive_2eproto__INCLUDED
