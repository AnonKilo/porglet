// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service_ant_scheduler.proto

#ifndef PROTOBUF_service_5fant_5fscheduler_2eproto__INCLUDED
#define PROTOBUF_service_5fant_5fscheduler_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace service_ant_scheduler {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_service_5fant_5fscheduler_2eproto();
void protobuf_AssignDesc_service_5fant_5fscheduler_2eproto();
void protobuf_ShutdownFile_service_5fant_5fscheduler_2eproto();

class ANTSchedulerConfig;
class ANTSchedulerConfig_TimelineImportInfo;
class ANTSchedulerConfig_BoxScanImportInfo;

// ===================================================================

class ANTSchedulerConfig_TimelineImportInfo : public ::google::protobuf::Message {
 public:
  ANTSchedulerConfig_TimelineImportInfo();
  virtual ~ANTSchedulerConfig_TimelineImportInfo();

  ANTSchedulerConfig_TimelineImportInfo(const ANTSchedulerConfig_TimelineImportInfo& from);

  inline ANTSchedulerConfig_TimelineImportInfo& operator=(const ANTSchedulerConfig_TimelineImportInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ANTSchedulerConfig_TimelineImportInfo& default_instance();

  void Swap(ANTSchedulerConfig_TimelineImportInfo* other);

  // implements Message ----------------------------------------------

  ANTSchedulerConfig_TimelineImportInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ANTSchedulerConfig_TimelineImportInfo& from);
  void MergeFrom(const ANTSchedulerConfig_TimelineImportInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string channelId = 1;
  inline bool has_channelid() const;
  inline void clear_channelid();
  static const int kChannelIdFieldNumber = 1;
  inline const ::std::string& channelid() const;
  inline void set_channelid(const ::std::string& value);
  inline void set_channelid(const char* value);
  inline void set_channelid(const char* value, size_t size);
  inline ::std::string* mutable_channelid();
  inline ::std::string* release_channelid();
  inline void set_allocated_channelid(::std::string* channelid);

  // optional string startTime = 2;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 2;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  inline void set_allocated_starttime(::std::string* starttime);

  // optional string stopTime = 3;
  inline bool has_stoptime() const;
  inline void clear_stoptime();
  static const int kStopTimeFieldNumber = 3;
  inline const ::std::string& stoptime() const;
  inline void set_stoptime(const ::std::string& value);
  inline void set_stoptime(const char* value);
  inline void set_stoptime(const char* value, size_t size);
  inline ::std::string* mutable_stoptime();
  inline ::std::string* release_stoptime();
  inline void set_allocated_stoptime(::std::string* stoptime);

  // optional string filePath = 4;
  inline bool has_filepath() const;
  inline void clear_filepath();
  static const int kFilePathFieldNumber = 4;
  inline const ::std::string& filepath() const;
  inline void set_filepath(const ::std::string& value);
  inline void set_filepath(const char* value);
  inline void set_filepath(const char* value, size_t size);
  inline ::std::string* mutable_filepath();
  inline ::std::string* release_filepath();
  inline void set_allocated_filepath(::std::string* filepath);

  // @@protoc_insertion_point(class_scope:service_ant_scheduler.ANTSchedulerConfig.TimelineImportInfo)
 private:
  inline void set_has_channelid();
  inline void clear_has_channelid();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_stoptime();
  inline void clear_has_stoptime();
  inline void set_has_filepath();
  inline void clear_has_filepath();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* channelid_;
  ::std::string* starttime_;
  ::std::string* stoptime_;
  ::std::string* filepath_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_service_5fant_5fscheduler_2eproto();
  friend void protobuf_AssignDesc_service_5fant_5fscheduler_2eproto();
  friend void protobuf_ShutdownFile_service_5fant_5fscheduler_2eproto();

  void InitAsDefaultInstance();
  static ANTSchedulerConfig_TimelineImportInfo* default_instance_;
};
// -------------------------------------------------------------------

class ANTSchedulerConfig_BoxScanImportInfo : public ::google::protobuf::Message {
 public:
  ANTSchedulerConfig_BoxScanImportInfo();
  virtual ~ANTSchedulerConfig_BoxScanImportInfo();

  ANTSchedulerConfig_BoxScanImportInfo(const ANTSchedulerConfig_BoxScanImportInfo& from);

  inline ANTSchedulerConfig_BoxScanImportInfo& operator=(const ANTSchedulerConfig_BoxScanImportInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ANTSchedulerConfig_BoxScanImportInfo& default_instance();

  void Swap(ANTSchedulerConfig_BoxScanImportInfo* other);

  // implements Message ----------------------------------------------

  ANTSchedulerConfig_BoxScanImportInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ANTSchedulerConfig_BoxScanImportInfo& from);
  void MergeFrom(const ANTSchedulerConfig_BoxScanImportInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float azStart = 1;
  inline bool has_azstart() const;
  inline void clear_azstart();
  static const int kAzStartFieldNumber = 1;
  inline float azstart() const;
  inline void set_azstart(float value);

  // optional float azStop = 2;
  inline bool has_azstop() const;
  inline void clear_azstop();
  static const int kAzStopFieldNumber = 2;
  inline float azstop() const;
  inline void set_azstop(float value);

  // optional float azStep = 3;
  inline bool has_azstep() const;
  inline void clear_azstep();
  static const int kAzStepFieldNumber = 3;
  inline float azstep() const;
  inline void set_azstep(float value);

  // optional float elStart = 4;
  inline bool has_elstart() const;
  inline void clear_elstart();
  static const int kElStartFieldNumber = 4;
  inline float elstart() const;
  inline void set_elstart(float value);

  // optional float elStop = 5;
  inline bool has_elstop() const;
  inline void clear_elstop();
  static const int kElStopFieldNumber = 5;
  inline float elstop() const;
  inline void set_elstop(float value);

  // optional float elStep = 6;
  inline bool has_elstep() const;
  inline void clear_elstep();
  static const int kElStepFieldNumber = 6;
  inline float elstep() const;
  inline void set_elstep(float value);

  // optional float stepTime = 7;
  inline bool has_steptime() const;
  inline void clear_steptime();
  static const int kStepTimeFieldNumber = 7;
  inline float steptime() const;
  inline void set_steptime(float value);

  // @@protoc_insertion_point(class_scope:service_ant_scheduler.ANTSchedulerConfig.BoxScanImportInfo)
 private:
  inline void set_has_azstart();
  inline void clear_has_azstart();
  inline void set_has_azstop();
  inline void clear_has_azstop();
  inline void set_has_azstep();
  inline void clear_has_azstep();
  inline void set_has_elstart();
  inline void clear_has_elstart();
  inline void set_has_elstop();
  inline void clear_has_elstop();
  inline void set_has_elstep();
  inline void clear_has_elstep();
  inline void set_has_steptime();
  inline void clear_has_steptime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float azstart_;
  float azstop_;
  float azstep_;
  float elstart_;
  float elstop_;
  float elstep_;
  float steptime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_service_5fant_5fscheduler_2eproto();
  friend void protobuf_AssignDesc_service_5fant_5fscheduler_2eproto();
  friend void protobuf_ShutdownFile_service_5fant_5fscheduler_2eproto();

  void InitAsDefaultInstance();
  static ANTSchedulerConfig_BoxScanImportInfo* default_instance_;
};
// -------------------------------------------------------------------

class ANTSchedulerConfig : public ::google::protobuf::Message {
 public:
  ANTSchedulerConfig();
  virtual ~ANTSchedulerConfig();

  ANTSchedulerConfig(const ANTSchedulerConfig& from);

  inline ANTSchedulerConfig& operator=(const ANTSchedulerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ANTSchedulerConfig& default_instance();

  void Swap(ANTSchedulerConfig* other);

  // implements Message ----------------------------------------------

  ANTSchedulerConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ANTSchedulerConfig& from);
  void MergeFrom(const ANTSchedulerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ANTSchedulerConfig_TimelineImportInfo TimelineImportInfo;
  typedef ANTSchedulerConfig_BoxScanImportInfo BoxScanImportInfo;

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "service_ant_scheduler.AntSchedulerConfig"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional bool showGUI = 2 [default = false];
  inline bool has_showgui() const;
  inline void clear_showgui();
  static const int kShowGUIFieldNumber = 2;
  inline bool showgui() const;
  inline void set_showgui(bool value);

  // required int32 antenna = 3;
  inline bool has_antenna() const;
  inline void clear_antenna();
  static const int kAntennaFieldNumber = 3;
  inline ::google::protobuf::int32 antenna() const;
  inline void set_antenna(::google::protobuf::int32 value);

  // optional int32 mode = 4;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 4;
  inline ::google::protobuf::int32 mode() const;
  inline void set_mode(::google::protobuf::int32 value);

  // optional int32 polarity = 5;
  inline bool has_polarity() const;
  inline void clear_polarity();
  static const int kPolarityFieldNumber = 5;
  inline ::google::protobuf::int32 polarity() const;
  inline void set_polarity(::google::protobuf::int32 value);

  // optional int32 priority = 6;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 6;
  inline ::google::protobuf::int32 priority() const;
  inline void set_priority(::google::protobuf::int32 value);

  // optional string schedulePath = 7;
  inline bool has_schedulepath() const;
  inline void clear_schedulepath();
  static const int kSchedulePathFieldNumber = 7;
  inline const ::std::string& schedulepath() const;
  inline void set_schedulepath(const ::std::string& value);
  inline void set_schedulepath(const char* value);
  inline void set_schedulepath(const char* value, size_t size);
  inline ::std::string* mutable_schedulepath();
  inline ::std::string* release_schedulepath();
  inline void set_allocated_schedulepath(::std::string* schedulepath);

  // repeated .service_ant_scheduler.ANTSchedulerConfig.TimelineImportInfo timelineImportInfos = 8;
  inline int timelineimportinfos_size() const;
  inline void clear_timelineimportinfos();
  static const int kTimelineImportInfosFieldNumber = 8;
  inline const ::service_ant_scheduler::ANTSchedulerConfig_TimelineImportInfo& timelineimportinfos(int index) const;
  inline ::service_ant_scheduler::ANTSchedulerConfig_TimelineImportInfo* mutable_timelineimportinfos(int index);
  inline ::service_ant_scheduler::ANTSchedulerConfig_TimelineImportInfo* add_timelineimportinfos();
  inline const ::google::protobuf::RepeatedPtrField< ::service_ant_scheduler::ANTSchedulerConfig_TimelineImportInfo >&
      timelineimportinfos() const;
  inline ::google::protobuf::RepeatedPtrField< ::service_ant_scheduler::ANTSchedulerConfig_TimelineImportInfo >*
      mutable_timelineimportinfos();

  // optional .service_ant_scheduler.ANTSchedulerConfig.BoxScanImportInfo boxScanImportInfos = 9;
  inline bool has_boxscanimportinfos() const;
  inline void clear_boxscanimportinfos();
  static const int kBoxScanImportInfosFieldNumber = 9;
  inline const ::service_ant_scheduler::ANTSchedulerConfig_BoxScanImportInfo& boxscanimportinfos() const;
  inline ::service_ant_scheduler::ANTSchedulerConfig_BoxScanImportInfo* mutable_boxscanimportinfos();
  inline ::service_ant_scheduler::ANTSchedulerConfig_BoxScanImportInfo* release_boxscanimportinfos();
  inline void set_allocated_boxscanimportinfos(::service_ant_scheduler::ANTSchedulerConfig_BoxScanImportInfo* boxscanimportinfos);

  // @@protoc_insertion_point(class_scope:service_ant_scheduler.ANTSchedulerConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_showgui();
  inline void clear_has_showgui();
  inline void set_has_antenna();
  inline void clear_has_antenna();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_polarity();
  inline void clear_has_polarity();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_schedulepath();
  inline void clear_has_schedulepath();
  inline void set_has_boxscanimportinfos();
  inline void clear_has_boxscanimportinfos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  bool showgui_;
  ::google::protobuf::int32 antenna_;
  ::google::protobuf::int32 mode_;
  ::google::protobuf::int32 polarity_;
  ::std::string* schedulepath_;
  ::google::protobuf::RepeatedPtrField< ::service_ant_scheduler::ANTSchedulerConfig_TimelineImportInfo > timelineimportinfos_;
  ::service_ant_scheduler::ANTSchedulerConfig_BoxScanImportInfo* boxscanimportinfos_;
  ::google::protobuf::int32 priority_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_service_5fant_5fscheduler_2eproto();
  friend void protobuf_AssignDesc_service_5fant_5fscheduler_2eproto();
  friend void protobuf_ShutdownFile_service_5fant_5fscheduler_2eproto();

  void InitAsDefaultInstance();
  static ANTSchedulerConfig* default_instance_;
};
// ===================================================================


// ===================================================================

// ANTSchedulerConfig_TimelineImportInfo

// optional string channelId = 1;
inline bool ANTSchedulerConfig_TimelineImportInfo::has_channelid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ANTSchedulerConfig_TimelineImportInfo::set_has_channelid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ANTSchedulerConfig_TimelineImportInfo::clear_has_channelid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ANTSchedulerConfig_TimelineImportInfo::clear_channelid() {
  if (channelid_ != &::google::protobuf::internal::kEmptyString) {
    channelid_->clear();
  }
  clear_has_channelid();
}
inline const ::std::string& ANTSchedulerConfig_TimelineImportInfo::channelid() const {
  return *channelid_;
}
inline void ANTSchedulerConfig_TimelineImportInfo::set_channelid(const ::std::string& value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
}
inline void ANTSchedulerConfig_TimelineImportInfo::set_channelid(const char* value) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(value);
}
inline void ANTSchedulerConfig_TimelineImportInfo::set_channelid(const char* value, size_t size) {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  channelid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ANTSchedulerConfig_TimelineImportInfo::mutable_channelid() {
  set_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    channelid_ = new ::std::string;
  }
  return channelid_;
}
inline ::std::string* ANTSchedulerConfig_TimelineImportInfo::release_channelid() {
  clear_has_channelid();
  if (channelid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channelid_;
    channelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ANTSchedulerConfig_TimelineImportInfo::set_allocated_channelid(::std::string* channelid) {
  if (channelid_ != &::google::protobuf::internal::kEmptyString) {
    delete channelid_;
  }
  if (channelid) {
    set_has_channelid();
    channelid_ = channelid;
  } else {
    clear_has_channelid();
    channelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string startTime = 2;
inline bool ANTSchedulerConfig_TimelineImportInfo::has_starttime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ANTSchedulerConfig_TimelineImportInfo::set_has_starttime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ANTSchedulerConfig_TimelineImportInfo::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ANTSchedulerConfig_TimelineImportInfo::clear_starttime() {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    starttime_->clear();
  }
  clear_has_starttime();
}
inline const ::std::string& ANTSchedulerConfig_TimelineImportInfo::starttime() const {
  return *starttime_;
}
inline void ANTSchedulerConfig_TimelineImportInfo::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void ANTSchedulerConfig_TimelineImportInfo::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void ANTSchedulerConfig_TimelineImportInfo::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ANTSchedulerConfig_TimelineImportInfo::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  return starttime_;
}
inline ::std::string* ANTSchedulerConfig_TimelineImportInfo::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ANTSchedulerConfig_TimelineImportInfo::set_allocated_starttime(::std::string* starttime) {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    delete starttime_;
  }
  if (starttime) {
    set_has_starttime();
    starttime_ = starttime;
  } else {
    clear_has_starttime();
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string stopTime = 3;
inline bool ANTSchedulerConfig_TimelineImportInfo::has_stoptime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ANTSchedulerConfig_TimelineImportInfo::set_has_stoptime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ANTSchedulerConfig_TimelineImportInfo::clear_has_stoptime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ANTSchedulerConfig_TimelineImportInfo::clear_stoptime() {
  if (stoptime_ != &::google::protobuf::internal::kEmptyString) {
    stoptime_->clear();
  }
  clear_has_stoptime();
}
inline const ::std::string& ANTSchedulerConfig_TimelineImportInfo::stoptime() const {
  return *stoptime_;
}
inline void ANTSchedulerConfig_TimelineImportInfo::set_stoptime(const ::std::string& value) {
  set_has_stoptime();
  if (stoptime_ == &::google::protobuf::internal::kEmptyString) {
    stoptime_ = new ::std::string;
  }
  stoptime_->assign(value);
}
inline void ANTSchedulerConfig_TimelineImportInfo::set_stoptime(const char* value) {
  set_has_stoptime();
  if (stoptime_ == &::google::protobuf::internal::kEmptyString) {
    stoptime_ = new ::std::string;
  }
  stoptime_->assign(value);
}
inline void ANTSchedulerConfig_TimelineImportInfo::set_stoptime(const char* value, size_t size) {
  set_has_stoptime();
  if (stoptime_ == &::google::protobuf::internal::kEmptyString) {
    stoptime_ = new ::std::string;
  }
  stoptime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ANTSchedulerConfig_TimelineImportInfo::mutable_stoptime() {
  set_has_stoptime();
  if (stoptime_ == &::google::protobuf::internal::kEmptyString) {
    stoptime_ = new ::std::string;
  }
  return stoptime_;
}
inline ::std::string* ANTSchedulerConfig_TimelineImportInfo::release_stoptime() {
  clear_has_stoptime();
  if (stoptime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stoptime_;
    stoptime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ANTSchedulerConfig_TimelineImportInfo::set_allocated_stoptime(::std::string* stoptime) {
  if (stoptime_ != &::google::protobuf::internal::kEmptyString) {
    delete stoptime_;
  }
  if (stoptime) {
    set_has_stoptime();
    stoptime_ = stoptime;
  } else {
    clear_has_stoptime();
    stoptime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string filePath = 4;
inline bool ANTSchedulerConfig_TimelineImportInfo::has_filepath() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ANTSchedulerConfig_TimelineImportInfo::set_has_filepath() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ANTSchedulerConfig_TimelineImportInfo::clear_has_filepath() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ANTSchedulerConfig_TimelineImportInfo::clear_filepath() {
  if (filepath_ != &::google::protobuf::internal::kEmptyString) {
    filepath_->clear();
  }
  clear_has_filepath();
}
inline const ::std::string& ANTSchedulerConfig_TimelineImportInfo::filepath() const {
  return *filepath_;
}
inline void ANTSchedulerConfig_TimelineImportInfo::set_filepath(const ::std::string& value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
}
inline void ANTSchedulerConfig_TimelineImportInfo::set_filepath(const char* value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
}
inline void ANTSchedulerConfig_TimelineImportInfo::set_filepath(const char* value, size_t size) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ANTSchedulerConfig_TimelineImportInfo::mutable_filepath() {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  return filepath_;
}
inline ::std::string* ANTSchedulerConfig_TimelineImportInfo::release_filepath() {
  clear_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filepath_;
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ANTSchedulerConfig_TimelineImportInfo::set_allocated_filepath(::std::string* filepath) {
  if (filepath_ != &::google::protobuf::internal::kEmptyString) {
    delete filepath_;
  }
  if (filepath) {
    set_has_filepath();
    filepath_ = filepath;
  } else {
    clear_has_filepath();
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ANTSchedulerConfig_BoxScanImportInfo

// optional float azStart = 1;
inline bool ANTSchedulerConfig_BoxScanImportInfo::has_azstart() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ANTSchedulerConfig_BoxScanImportInfo::set_has_azstart() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ANTSchedulerConfig_BoxScanImportInfo::clear_has_azstart() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ANTSchedulerConfig_BoxScanImportInfo::clear_azstart() {
  azstart_ = 0;
  clear_has_azstart();
}
inline float ANTSchedulerConfig_BoxScanImportInfo::azstart() const {
  return azstart_;
}
inline void ANTSchedulerConfig_BoxScanImportInfo::set_azstart(float value) {
  set_has_azstart();
  azstart_ = value;
}

// optional float azStop = 2;
inline bool ANTSchedulerConfig_BoxScanImportInfo::has_azstop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ANTSchedulerConfig_BoxScanImportInfo::set_has_azstop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ANTSchedulerConfig_BoxScanImportInfo::clear_has_azstop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ANTSchedulerConfig_BoxScanImportInfo::clear_azstop() {
  azstop_ = 0;
  clear_has_azstop();
}
inline float ANTSchedulerConfig_BoxScanImportInfo::azstop() const {
  return azstop_;
}
inline void ANTSchedulerConfig_BoxScanImportInfo::set_azstop(float value) {
  set_has_azstop();
  azstop_ = value;
}

// optional float azStep = 3;
inline bool ANTSchedulerConfig_BoxScanImportInfo::has_azstep() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ANTSchedulerConfig_BoxScanImportInfo::set_has_azstep() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ANTSchedulerConfig_BoxScanImportInfo::clear_has_azstep() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ANTSchedulerConfig_BoxScanImportInfo::clear_azstep() {
  azstep_ = 0;
  clear_has_azstep();
}
inline float ANTSchedulerConfig_BoxScanImportInfo::azstep() const {
  return azstep_;
}
inline void ANTSchedulerConfig_BoxScanImportInfo::set_azstep(float value) {
  set_has_azstep();
  azstep_ = value;
}

// optional float elStart = 4;
inline bool ANTSchedulerConfig_BoxScanImportInfo::has_elstart() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ANTSchedulerConfig_BoxScanImportInfo::set_has_elstart() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ANTSchedulerConfig_BoxScanImportInfo::clear_has_elstart() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ANTSchedulerConfig_BoxScanImportInfo::clear_elstart() {
  elstart_ = 0;
  clear_has_elstart();
}
inline float ANTSchedulerConfig_BoxScanImportInfo::elstart() const {
  return elstart_;
}
inline void ANTSchedulerConfig_BoxScanImportInfo::set_elstart(float value) {
  set_has_elstart();
  elstart_ = value;
}

// optional float elStop = 5;
inline bool ANTSchedulerConfig_BoxScanImportInfo::has_elstop() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ANTSchedulerConfig_BoxScanImportInfo::set_has_elstop() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ANTSchedulerConfig_BoxScanImportInfo::clear_has_elstop() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ANTSchedulerConfig_BoxScanImportInfo::clear_elstop() {
  elstop_ = 0;
  clear_has_elstop();
}
inline float ANTSchedulerConfig_BoxScanImportInfo::elstop() const {
  return elstop_;
}
inline void ANTSchedulerConfig_BoxScanImportInfo::set_elstop(float value) {
  set_has_elstop();
  elstop_ = value;
}

// optional float elStep = 6;
inline bool ANTSchedulerConfig_BoxScanImportInfo::has_elstep() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ANTSchedulerConfig_BoxScanImportInfo::set_has_elstep() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ANTSchedulerConfig_BoxScanImportInfo::clear_has_elstep() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ANTSchedulerConfig_BoxScanImportInfo::clear_elstep() {
  elstep_ = 0;
  clear_has_elstep();
}
inline float ANTSchedulerConfig_BoxScanImportInfo::elstep() const {
  return elstep_;
}
inline void ANTSchedulerConfig_BoxScanImportInfo::set_elstep(float value) {
  set_has_elstep();
  elstep_ = value;
}

// optional float stepTime = 7;
inline bool ANTSchedulerConfig_BoxScanImportInfo::has_steptime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ANTSchedulerConfig_BoxScanImportInfo::set_has_steptime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ANTSchedulerConfig_BoxScanImportInfo::clear_has_steptime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ANTSchedulerConfig_BoxScanImportInfo::clear_steptime() {
  steptime_ = 0;
  clear_has_steptime();
}
inline float ANTSchedulerConfig_BoxScanImportInfo::steptime() const {
  return steptime_;
}
inline void ANTSchedulerConfig_BoxScanImportInfo::set_steptime(float value) {
  set_has_steptime();
  steptime_ = value;
}

// -------------------------------------------------------------------

// ANTSchedulerConfig

// optional string msgName = 1 [default = "service_ant_scheduler.AntSchedulerConfig"];
inline bool ANTSchedulerConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ANTSchedulerConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ANTSchedulerConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ANTSchedulerConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ANTSchedulerConfig::msgname() const {
  return *msgname_;
}
inline void ANTSchedulerConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ANTSchedulerConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ANTSchedulerConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ANTSchedulerConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ANTSchedulerConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ANTSchedulerConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional bool showGUI = 2 [default = false];
inline bool ANTSchedulerConfig::has_showgui() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ANTSchedulerConfig::set_has_showgui() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ANTSchedulerConfig::clear_has_showgui() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ANTSchedulerConfig::clear_showgui() {
  showgui_ = false;
  clear_has_showgui();
}
inline bool ANTSchedulerConfig::showgui() const {
  return showgui_;
}
inline void ANTSchedulerConfig::set_showgui(bool value) {
  set_has_showgui();
  showgui_ = value;
}

// required int32 antenna = 3;
inline bool ANTSchedulerConfig::has_antenna() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ANTSchedulerConfig::set_has_antenna() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ANTSchedulerConfig::clear_has_antenna() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ANTSchedulerConfig::clear_antenna() {
  antenna_ = 0;
  clear_has_antenna();
}
inline ::google::protobuf::int32 ANTSchedulerConfig::antenna() const {
  return antenna_;
}
inline void ANTSchedulerConfig::set_antenna(::google::protobuf::int32 value) {
  set_has_antenna();
  antenna_ = value;
}

// optional int32 mode = 4;
inline bool ANTSchedulerConfig::has_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ANTSchedulerConfig::set_has_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ANTSchedulerConfig::clear_has_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ANTSchedulerConfig::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::google::protobuf::int32 ANTSchedulerConfig::mode() const {
  return mode_;
}
inline void ANTSchedulerConfig::set_mode(::google::protobuf::int32 value) {
  set_has_mode();
  mode_ = value;
}

// optional int32 polarity = 5;
inline bool ANTSchedulerConfig::has_polarity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ANTSchedulerConfig::set_has_polarity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ANTSchedulerConfig::clear_has_polarity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ANTSchedulerConfig::clear_polarity() {
  polarity_ = 0;
  clear_has_polarity();
}
inline ::google::protobuf::int32 ANTSchedulerConfig::polarity() const {
  return polarity_;
}
inline void ANTSchedulerConfig::set_polarity(::google::protobuf::int32 value) {
  set_has_polarity();
  polarity_ = value;
}

// optional int32 priority = 6;
inline bool ANTSchedulerConfig::has_priority() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ANTSchedulerConfig::set_has_priority() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ANTSchedulerConfig::clear_has_priority() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ANTSchedulerConfig::clear_priority() {
  priority_ = 0;
  clear_has_priority();
}
inline ::google::protobuf::int32 ANTSchedulerConfig::priority() const {
  return priority_;
}
inline void ANTSchedulerConfig::set_priority(::google::protobuf::int32 value) {
  set_has_priority();
  priority_ = value;
}

// optional string schedulePath = 7;
inline bool ANTSchedulerConfig::has_schedulepath() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ANTSchedulerConfig::set_has_schedulepath() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ANTSchedulerConfig::clear_has_schedulepath() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ANTSchedulerConfig::clear_schedulepath() {
  if (schedulepath_ != &::google::protobuf::internal::kEmptyString) {
    schedulepath_->clear();
  }
  clear_has_schedulepath();
}
inline const ::std::string& ANTSchedulerConfig::schedulepath() const {
  return *schedulepath_;
}
inline void ANTSchedulerConfig::set_schedulepath(const ::std::string& value) {
  set_has_schedulepath();
  if (schedulepath_ == &::google::protobuf::internal::kEmptyString) {
    schedulepath_ = new ::std::string;
  }
  schedulepath_->assign(value);
}
inline void ANTSchedulerConfig::set_schedulepath(const char* value) {
  set_has_schedulepath();
  if (schedulepath_ == &::google::protobuf::internal::kEmptyString) {
    schedulepath_ = new ::std::string;
  }
  schedulepath_->assign(value);
}
inline void ANTSchedulerConfig::set_schedulepath(const char* value, size_t size) {
  set_has_schedulepath();
  if (schedulepath_ == &::google::protobuf::internal::kEmptyString) {
    schedulepath_ = new ::std::string;
  }
  schedulepath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ANTSchedulerConfig::mutable_schedulepath() {
  set_has_schedulepath();
  if (schedulepath_ == &::google::protobuf::internal::kEmptyString) {
    schedulepath_ = new ::std::string;
  }
  return schedulepath_;
}
inline ::std::string* ANTSchedulerConfig::release_schedulepath() {
  clear_has_schedulepath();
  if (schedulepath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = schedulepath_;
    schedulepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ANTSchedulerConfig::set_allocated_schedulepath(::std::string* schedulepath) {
  if (schedulepath_ != &::google::protobuf::internal::kEmptyString) {
    delete schedulepath_;
  }
  if (schedulepath) {
    set_has_schedulepath();
    schedulepath_ = schedulepath;
  } else {
    clear_has_schedulepath();
    schedulepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .service_ant_scheduler.ANTSchedulerConfig.TimelineImportInfo timelineImportInfos = 8;
inline int ANTSchedulerConfig::timelineimportinfos_size() const {
  return timelineimportinfos_.size();
}
inline void ANTSchedulerConfig::clear_timelineimportinfos() {
  timelineimportinfos_.Clear();
}
inline const ::service_ant_scheduler::ANTSchedulerConfig_TimelineImportInfo& ANTSchedulerConfig::timelineimportinfos(int index) const {
  return timelineimportinfos_.Get(index);
}
inline ::service_ant_scheduler::ANTSchedulerConfig_TimelineImportInfo* ANTSchedulerConfig::mutable_timelineimportinfos(int index) {
  return timelineimportinfos_.Mutable(index);
}
inline ::service_ant_scheduler::ANTSchedulerConfig_TimelineImportInfo* ANTSchedulerConfig::add_timelineimportinfos() {
  return timelineimportinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::service_ant_scheduler::ANTSchedulerConfig_TimelineImportInfo >&
ANTSchedulerConfig::timelineimportinfos() const {
  return timelineimportinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::service_ant_scheduler::ANTSchedulerConfig_TimelineImportInfo >*
ANTSchedulerConfig::mutable_timelineimportinfos() {
  return &timelineimportinfos_;
}

// optional .service_ant_scheduler.ANTSchedulerConfig.BoxScanImportInfo boxScanImportInfos = 9;
inline bool ANTSchedulerConfig::has_boxscanimportinfos() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ANTSchedulerConfig::set_has_boxscanimportinfos() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ANTSchedulerConfig::clear_has_boxscanimportinfos() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ANTSchedulerConfig::clear_boxscanimportinfos() {
  if (boxscanimportinfos_ != NULL) boxscanimportinfos_->::service_ant_scheduler::ANTSchedulerConfig_BoxScanImportInfo::Clear();
  clear_has_boxscanimportinfos();
}
inline const ::service_ant_scheduler::ANTSchedulerConfig_BoxScanImportInfo& ANTSchedulerConfig::boxscanimportinfos() const {
  return boxscanimportinfos_ != NULL ? *boxscanimportinfos_ : *default_instance_->boxscanimportinfos_;
}
inline ::service_ant_scheduler::ANTSchedulerConfig_BoxScanImportInfo* ANTSchedulerConfig::mutable_boxscanimportinfos() {
  set_has_boxscanimportinfos();
  if (boxscanimportinfos_ == NULL) boxscanimportinfos_ = new ::service_ant_scheduler::ANTSchedulerConfig_BoxScanImportInfo;
  return boxscanimportinfos_;
}
inline ::service_ant_scheduler::ANTSchedulerConfig_BoxScanImportInfo* ANTSchedulerConfig::release_boxscanimportinfos() {
  clear_has_boxscanimportinfos();
  ::service_ant_scheduler::ANTSchedulerConfig_BoxScanImportInfo* temp = boxscanimportinfos_;
  boxscanimportinfos_ = NULL;
  return temp;
}
inline void ANTSchedulerConfig::set_allocated_boxscanimportinfos(::service_ant_scheduler::ANTSchedulerConfig_BoxScanImportInfo* boxscanimportinfos) {
  delete boxscanimportinfos_;
  boxscanimportinfos_ = boxscanimportinfos;
  if (boxscanimportinfos) {
    set_has_boxscanimportinfos();
  } else {
    clear_has_boxscanimportinfos();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace service_ant_scheduler

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_service_5fant_5fscheduler_2eproto__INCLUDED
