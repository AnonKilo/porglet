// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ESProductMessages.proto

#ifndef PROTOBUF_ESProductMessages_2eproto__INCLUDED
#define PROTOBUF_ESProductMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "FalconCommonMessages.pb.h"
#include "FalconExternalsMessages.pb.h"
// @@protoc_insertion_point(includes)

namespace es_product_msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ESProductMessages_2eproto();
void protobuf_AssignDesc_ESProductMessages_2eproto();
void protobuf_ShutdownFile_ESProductMessages_2eproto();

class ESProductHeader;
class ESObservablesRegister;
class ESObservablesUnregister;
class ESObservables;
class ESObservationsBool;
class ESObservationsTyped;
class IQCollectionParameters;
class CollectionFrontendParameters;
class SignalEvent;
class GPSPosition;
class ExternalHit;
class InternalHit;
class FisD;
class SIGFrame;
class ImageAvailable;
class AudioAvailable;
class DmrMeta;

enum SignalEvent_Type {
  SignalEvent_Type_SIGDET = 0,
  SignalEvent_Type_SIGUP = 1,
  SignalEvent_Type_SIGDOWN = 2,
  SignalEvent_Type_SIGTIMEOUT = 3
};
bool SignalEvent_Type_IsValid(int value);
const SignalEvent_Type SignalEvent_Type_Type_MIN = SignalEvent_Type_SIGDET;
const SignalEvent_Type SignalEvent_Type_Type_MAX = SignalEvent_Type_SIGTIMEOUT;
const int SignalEvent_Type_Type_ARRAYSIZE = SignalEvent_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* SignalEvent_Type_descriptor();
inline const ::std::string& SignalEvent_Type_Name(SignalEvent_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    SignalEvent_Type_descriptor(), value);
}
inline bool SignalEvent_Type_Parse(
    const ::std::string& name, SignalEvent_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SignalEvent_Type>(
    SignalEvent_Type_descriptor(), name, value);
}
enum ExternalHit_Type {
  ExternalHit_Type_KNOWN_RED = 0,
  ExternalHit_Type_KNOWN_GRAY = 1,
  ExternalHit_Type_KNOWN_BLUE = 2,
  ExternalHit_Type_UNKNOWN = 3,
  ExternalHit_Type_ANOMALY = 4
};
bool ExternalHit_Type_IsValid(int value);
const ExternalHit_Type ExternalHit_Type_Type_MIN = ExternalHit_Type_KNOWN_RED;
const ExternalHit_Type ExternalHit_Type_Type_MAX = ExternalHit_Type_ANOMALY;
const int ExternalHit_Type_Type_ARRAYSIZE = ExternalHit_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExternalHit_Type_descriptor();
inline const ::std::string& ExternalHit_Type_Name(ExternalHit_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExternalHit_Type_descriptor(), value);
}
inline bool ExternalHit_Type_Parse(
    const ::std::string& name, ExternalHit_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExternalHit_Type>(
    ExternalHit_Type_descriptor(), name, value);
}
enum FisD_FileType {
  FisD_FileType_FS = 0,
  FisD_FileType_TC = 1,
  FisD_FileType_BER = 2
};
bool FisD_FileType_IsValid(int value);
const FisD_FileType FisD_FileType_FileType_MIN = FisD_FileType_FS;
const FisD_FileType FisD_FileType_FileType_MAX = FisD_FileType_BER;
const int FisD_FileType_FileType_ARRAYSIZE = FisD_FileType_FileType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FisD_FileType_descriptor();
inline const ::std::string& FisD_FileType_Name(FisD_FileType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FisD_FileType_descriptor(), value);
}
inline bool FisD_FileType_Parse(
    const ::std::string& name, FisD_FileType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FisD_FileType>(
    FisD_FileType_descriptor(), name, value);
}
enum ImageAvailable_Status {
  ImageAvailable_Status_AVAILABLE = -1,
  ImageAvailable_Status_UNAVAILABLE = 0,
  ImageAvailable_Status_PENDING = 1
};
bool ImageAvailable_Status_IsValid(int value);
const ImageAvailable_Status ImageAvailable_Status_Status_MIN = ImageAvailable_Status_AVAILABLE;
const ImageAvailable_Status ImageAvailable_Status_Status_MAX = ImageAvailable_Status_PENDING;
const int ImageAvailable_Status_Status_ARRAYSIZE = ImageAvailable_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* ImageAvailable_Status_descriptor();
inline const ::std::string& ImageAvailable_Status_Name(ImageAvailable_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    ImageAvailable_Status_descriptor(), value);
}
inline bool ImageAvailable_Status_Parse(
    const ::std::string& name, ImageAvailable_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImageAvailable_Status>(
    ImageAvailable_Status_descriptor(), name, value);
}
enum AudioAvailable_Status {
  AudioAvailable_Status_AVAILABLE = -1,
  AudioAvailable_Status_UNAVAILABLE = 0,
  AudioAvailable_Status_PENDING = 1
};
bool AudioAvailable_Status_IsValid(int value);
const AudioAvailable_Status AudioAvailable_Status_Status_MIN = AudioAvailable_Status_AVAILABLE;
const AudioAvailable_Status AudioAvailable_Status_Status_MAX = AudioAvailable_Status_PENDING;
const int AudioAvailable_Status_Status_ARRAYSIZE = AudioAvailable_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* AudioAvailable_Status_descriptor();
inline const ::std::string& AudioAvailable_Status_Name(AudioAvailable_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    AudioAvailable_Status_descriptor(), value);
}
inline bool AudioAvailable_Status_Parse(
    const ::std::string& name, AudioAvailable_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AudioAvailable_Status>(
    AudioAvailable_Status_descriptor(), name, value);
}
// ===================================================================

class ESProductHeader : public ::google::protobuf::Message {
 public:
  ESProductHeader();
  virtual ~ESProductHeader();

  ESProductHeader(const ESProductHeader& from);

  inline ESProductHeader& operator=(const ESProductHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ESProductHeader& default_instance();

  void Swap(ESProductHeader* other);

  // implements Message ----------------------------------------------

  ESProductHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ESProductHeader& from);
  void MergeFrom(const ESProductHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ES_PRODUCT_HEADER"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string esProductID = 2;
  inline bool has_esproductid() const;
  inline void clear_esproductid();
  static const int kEsProductIDFieldNumber = 2;
  inline const ::std::string& esproductid() const;
  inline void set_esproductid(const ::std::string& value);
  inline void set_esproductid(const char* value);
  inline void set_esproductid(const char* value, size_t size);
  inline ::std::string* mutable_esproductid();
  inline ::std::string* release_esproductid();
  inline void set_allocated_esproductid(::std::string* esproductid);

  // optional string globalID = 3;
  inline bool has_globalid() const;
  inline void clear_globalid();
  static const int kGlobalIDFieldNumber = 3;
  inline const ::std::string& globalid() const;
  inline void set_globalid(const ::std::string& value);
  inline void set_globalid(const char* value);
  inline void set_globalid(const char* value, size_t size);
  inline ::std::string* mutable_globalid();
  inline ::std::string* release_globalid();
  inline void set_allocated_globalid(::std::string* globalid);

  // optional string soiNum = 4;
  inline bool has_soinum() const;
  inline void clear_soinum();
  static const int kSoiNumFieldNumber = 4;
  inline const ::std::string& soinum() const;
  inline void set_soinum(const ::std::string& value);
  inline void set_soinum(const char* value);
  inline void set_soinum(const char* value, size_t size);
  inline ::std::string* mutable_soinum();
  inline ::std::string* release_soinum();
  inline void set_allocated_soinum(::std::string* soinum);

  // optional string signalName = 5;
  inline bool has_signalname() const;
  inline void clear_signalname();
  static const int kSignalNameFieldNumber = 5;
  inline const ::std::string& signalname() const;
  inline void set_signalname(const ::std::string& value);
  inline void set_signalname(const char* value);
  inline void set_signalname(const char* value, size_t size);
  inline ::std::string* mutable_signalname();
  inline ::std::string* release_signalname();
  inline void set_allocated_signalname(::std::string* signalname);

  // optional string sensorName = 6;
  inline bool has_sensorname() const;
  inline void clear_sensorname();
  static const int kSensorNameFieldNumber = 6;
  inline const ::std::string& sensorname() const;
  inline void set_sensorname(const ::std::string& value);
  inline void set_sensorname(const char* value);
  inline void set_sensorname(const char* value, size_t size);
  inline ::std::string* mutable_sensorname();
  inline ::std::string* release_sensorname();
  inline void set_allocated_sensorname(::std::string* sensorname);

  // optional .falcon_common_msg.Timestamp timestamp = 7;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 7;
  inline const ::falcon_common_msg::Timestamp& timestamp() const;
  inline ::falcon_common_msg::Timestamp* mutable_timestamp();
  inline ::falcon_common_msg::Timestamp* release_timestamp();
  inline void set_allocated_timestamp(::falcon_common_msg::Timestamp* timestamp);

  // @@protoc_insertion_point(class_scope:es_product_msg.ESProductHeader)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_esproductid();
  inline void clear_has_esproductid();
  inline void set_has_globalid();
  inline void clear_has_globalid();
  inline void set_has_soinum();
  inline void clear_has_soinum();
  inline void set_has_signalname();
  inline void clear_has_signalname();
  inline void set_has_sensorname();
  inline void clear_has_sensorname();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* esproductid_;
  ::std::string* globalid_;
  ::std::string* soinum_;
  ::std::string* signalname_;
  ::std::string* sensorname_;
  ::falcon_common_msg::Timestamp* timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_ESProductMessages_2eproto();
  friend void protobuf_AssignDesc_ESProductMessages_2eproto();
  friend void protobuf_ShutdownFile_ESProductMessages_2eproto();

  void InitAsDefaultInstance();
  static ESProductHeader* default_instance_;
};
// -------------------------------------------------------------------

class ESObservablesRegister : public ::google::protobuf::Message {
 public:
  ESObservablesRegister();
  virtual ~ESObservablesRegister();

  ESObservablesRegister(const ESObservablesRegister& from);

  inline ESObservablesRegister& operator=(const ESObservablesRegister& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ESObservablesRegister& default_instance();

  void Swap(ESObservablesRegister* other);

  // implements Message ----------------------------------------------

  ESObservablesRegister* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ESObservablesRegister& from);
  void MergeFrom(const ESObservablesRegister& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ES_OBSERVABLES_REGISTER"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional .es_product_msg.ESProductHeader header = 2;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 2;
  inline const ::es_product_msg::ESProductHeader& header() const;
  inline ::es_product_msg::ESProductHeader* mutable_header();
  inline ::es_product_msg::ESProductHeader* release_header();
  inline void set_allocated_header(::es_product_msg::ESProductHeader* header);

  // optional .es_product_msg.ESObservationsBool esObservationsBool = 3;
  inline bool has_esobservationsbool() const;
  inline void clear_esobservationsbool();
  static const int kEsObservationsBoolFieldNumber = 3;
  inline const ::es_product_msg::ESObservationsBool& esobservationsbool() const;
  inline ::es_product_msg::ESObservationsBool* mutable_esobservationsbool();
  inline ::es_product_msg::ESObservationsBool* release_esobservationsbool();
  inline void set_allocated_esobservationsbool(::es_product_msg::ESObservationsBool* esobservationsbool);

  // @@protoc_insertion_point(class_scope:es_product_msg.ESObservablesRegister)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_esobservationsbool();
  inline void clear_has_esobservationsbool();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::es_product_msg::ESProductHeader* header_;
  ::es_product_msg::ESObservationsBool* esobservationsbool_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ESProductMessages_2eproto();
  friend void protobuf_AssignDesc_ESProductMessages_2eproto();
  friend void protobuf_ShutdownFile_ESProductMessages_2eproto();

  void InitAsDefaultInstance();
  static ESObservablesRegister* default_instance_;
};
// -------------------------------------------------------------------

class ESObservablesUnregister : public ::google::protobuf::Message {
 public:
  ESObservablesUnregister();
  virtual ~ESObservablesUnregister();

  ESObservablesUnregister(const ESObservablesUnregister& from);

  inline ESObservablesUnregister& operator=(const ESObservablesUnregister& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ESObservablesUnregister& default_instance();

  void Swap(ESObservablesUnregister* other);

  // implements Message ----------------------------------------------

  ESObservablesUnregister* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ESObservablesUnregister& from);
  void MergeFrom(const ESObservablesUnregister& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ES_OBSERVABLES_UNREGISTER"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string esProductID = 2;
  inline bool has_esproductid() const;
  inline void clear_esproductid();
  static const int kEsProductIDFieldNumber = 2;
  inline const ::std::string& esproductid() const;
  inline void set_esproductid(const ::std::string& value);
  inline void set_esproductid(const char* value);
  inline void set_esproductid(const char* value, size_t size);
  inline ::std::string* mutable_esproductid();
  inline ::std::string* release_esproductid();
  inline void set_allocated_esproductid(::std::string* esproductid);

  // @@protoc_insertion_point(class_scope:es_product_msg.ESObservablesUnregister)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_esproductid();
  inline void clear_has_esproductid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* esproductid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ESProductMessages_2eproto();
  friend void protobuf_AssignDesc_ESProductMessages_2eproto();
  friend void protobuf_ShutdownFile_ESProductMessages_2eproto();

  void InitAsDefaultInstance();
  static ESObservablesUnregister* default_instance_;
};
// -------------------------------------------------------------------

class ESObservables : public ::google::protobuf::Message {
 public:
  ESObservables();
  virtual ~ESObservables();

  ESObservables(const ESObservables& from);

  inline ESObservables& operator=(const ESObservables& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ESObservables& default_instance();

  void Swap(ESObservables* other);

  // implements Message ----------------------------------------------

  ESObservables* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ESObservables& from);
  void MergeFrom(const ESObservables& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ES_OBSERVABLES"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional .es_product_msg.ESProductHeader header = 2;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 2;
  inline const ::es_product_msg::ESProductHeader& header() const;
  inline ::es_product_msg::ESProductHeader* mutable_header();
  inline ::es_product_msg::ESProductHeader* release_header();
  inline void set_allocated_header(::es_product_msg::ESProductHeader* header);

  // optional .es_product_msg.ESObservationsTyped esObservationsTyped = 3;
  inline bool has_esobservationstyped() const;
  inline void clear_esobservationstyped();
  static const int kEsObservationsTypedFieldNumber = 3;
  inline const ::es_product_msg::ESObservationsTyped& esobservationstyped() const;
  inline ::es_product_msg::ESObservationsTyped* mutable_esobservationstyped();
  inline ::es_product_msg::ESObservationsTyped* release_esobservationstyped();
  inline void set_allocated_esobservationstyped(::es_product_msg::ESObservationsTyped* esobservationstyped);

  // @@protoc_insertion_point(class_scope:es_product_msg.ESObservables)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_esobservationstyped();
  inline void clear_has_esobservationstyped();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::es_product_msg::ESProductHeader* header_;
  ::es_product_msg::ESObservationsTyped* esobservationstyped_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ESProductMessages_2eproto();
  friend void protobuf_AssignDesc_ESProductMessages_2eproto();
  friend void protobuf_ShutdownFile_ESProductMessages_2eproto();

  void InitAsDefaultInstance();
  static ESObservables* default_instance_;
};
// -------------------------------------------------------------------

class ESObservationsBool : public ::google::protobuf::Message {
 public:
  ESObservationsBool();
  virtual ~ESObservationsBool();

  ESObservationsBool(const ESObservationsBool& from);

  inline ESObservationsBool& operator=(const ESObservationsBool& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ESObservationsBool& default_instance();

  void Swap(ESObservationsBool* other);

  // implements Message ----------------------------------------------

  ESObservationsBool* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ESObservationsBool& from);
  void MergeFrom(const ESObservationsBool& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ES_OBSERVATIONS_BOOL"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional bool iqCollectionParameters = 2;
  inline bool has_iqcollectionparameters() const;
  inline void clear_iqcollectionparameters();
  static const int kIqCollectionParametersFieldNumber = 2;
  inline bool iqcollectionparameters() const;
  inline void set_iqcollectionparameters(bool value);

  // optional bool collectionFrontendParameters = 3;
  inline bool has_collectionfrontendparameters() const;
  inline void clear_collectionfrontendparameters();
  static const int kCollectionFrontendParametersFieldNumber = 3;
  inline bool collectionfrontendparameters() const;
  inline void set_collectionfrontendparameters(bool value);

  // optional bool signalEvent = 4;
  inline bool has_signalevent() const;
  inline void clear_signalevent();
  static const int kSignalEventFieldNumber = 4;
  inline bool signalevent() const;
  inline void set_signalevent(bool value);

  // optional bool gpsPosition = 5;
  inline bool has_gpsposition() const;
  inline void clear_gpsposition();
  static const int kGpsPositionFieldNumber = 5;
  inline bool gpsposition() const;
  inline void set_gpsposition(bool value);

  // optional bool esExternalHit = 6;
  inline bool has_esexternalhit() const;
  inline void clear_esexternalhit();
  static const int kEsExternalHitFieldNumber = 6;
  inline bool esexternalhit() const;
  inline void set_esexternalhit(bool value);

  // optional bool esInternalHit = 7;
  inline bool has_esinternalhit() const;
  inline void clear_esinternalhit();
  static const int kEsInternalHitFieldNumber = 7;
  inline bool esinternalhit() const;
  inline void set_esinternalhit(bool value);

  // optional bool fisD = 8;
  inline bool has_fisd() const;
  inline void clear_fisd();
  static const int kFisDFieldNumber = 8;
  inline bool fisd() const;
  inline void set_fisd(bool value);

  // optional bool sigFrame = 9;
  inline bool has_sigframe() const;
  inline void clear_sigframe();
  static const int kSigFrameFieldNumber = 9;
  inline bool sigframe() const;
  inline void set_sigframe(bool value);

  // optional bool imageAvailable = 10;
  inline bool has_imageavailable() const;
  inline void clear_imageavailable();
  static const int kImageAvailableFieldNumber = 10;
  inline bool imageavailable() const;
  inline void set_imageavailable(bool value);

  // optional bool audioAvailable = 11;
  inline bool has_audioavailable() const;
  inline void clear_audioavailable();
  static const int kAudioAvailableFieldNumber = 11;
  inline bool audioavailable() const;
  inline void set_audioavailable(bool value);

  // optional bool dmrMeta = 12;
  inline bool has_dmrmeta() const;
  inline void clear_dmrmeta();
  static const int kDmrMetaFieldNumber = 12;
  inline bool dmrmeta() const;
  inline void set_dmrmeta(bool value);

  // repeated string kvpl = 500;
  inline int kvpl_size() const;
  inline void clear_kvpl();
  static const int kKvplFieldNumber = 500;
  inline const ::std::string& kvpl(int index) const;
  inline ::std::string* mutable_kvpl(int index);
  inline void set_kvpl(int index, const ::std::string& value);
  inline void set_kvpl(int index, const char* value);
  inline void set_kvpl(int index, const char* value, size_t size);
  inline ::std::string* add_kvpl();
  inline void add_kvpl(const ::std::string& value);
  inline void add_kvpl(const char* value);
  inline void add_kvpl(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& kvpl() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_kvpl();

  // @@protoc_insertion_point(class_scope:es_product_msg.ESObservationsBool)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_iqcollectionparameters();
  inline void clear_has_iqcollectionparameters();
  inline void set_has_collectionfrontendparameters();
  inline void clear_has_collectionfrontendparameters();
  inline void set_has_signalevent();
  inline void clear_has_signalevent();
  inline void set_has_gpsposition();
  inline void clear_has_gpsposition();
  inline void set_has_esexternalhit();
  inline void clear_has_esexternalhit();
  inline void set_has_esinternalhit();
  inline void clear_has_esinternalhit();
  inline void set_has_fisd();
  inline void clear_has_fisd();
  inline void set_has_sigframe();
  inline void clear_has_sigframe();
  inline void set_has_imageavailable();
  inline void clear_has_imageavailable();
  inline void set_has_audioavailable();
  inline void clear_has_audioavailable();
  inline void set_has_dmrmeta();
  inline void clear_has_dmrmeta();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  bool iqcollectionparameters_;
  bool collectionfrontendparameters_;
  bool signalevent_;
  bool gpsposition_;
  bool esexternalhit_;
  bool esinternalhit_;
  bool fisd_;
  bool sigframe_;
  ::google::protobuf::RepeatedPtrField< ::std::string> kvpl_;
  bool imageavailable_;
  bool audioavailable_;
  bool dmrmeta_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_ESProductMessages_2eproto();
  friend void protobuf_AssignDesc_ESProductMessages_2eproto();
  friend void protobuf_ShutdownFile_ESProductMessages_2eproto();

  void InitAsDefaultInstance();
  static ESObservationsBool* default_instance_;
};
// -------------------------------------------------------------------

class ESObservationsTyped : public ::google::protobuf::Message {
 public:
  ESObservationsTyped();
  virtual ~ESObservationsTyped();

  ESObservationsTyped(const ESObservationsTyped& from);

  inline ESObservationsTyped& operator=(const ESObservationsTyped& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ESObservationsTyped& default_instance();

  void Swap(ESObservationsTyped* other);

  // implements Message ----------------------------------------------

  ESObservationsTyped* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ESObservationsTyped& from);
  void MergeFrom(const ESObservationsTyped& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ES_OBSERVATIONS_BOOL"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional .es_product_msg.IQCollectionParameters iqCollectionParameters = 2;
  inline bool has_iqcollectionparameters() const;
  inline void clear_iqcollectionparameters();
  static const int kIqCollectionParametersFieldNumber = 2;
  inline const ::es_product_msg::IQCollectionParameters& iqcollectionparameters() const;
  inline ::es_product_msg::IQCollectionParameters* mutable_iqcollectionparameters();
  inline ::es_product_msg::IQCollectionParameters* release_iqcollectionparameters();
  inline void set_allocated_iqcollectionparameters(::es_product_msg::IQCollectionParameters* iqcollectionparameters);

  // optional .es_product_msg.CollectionFrontendParameters collectionFrontendParameters = 3;
  inline bool has_collectionfrontendparameters() const;
  inline void clear_collectionfrontendparameters();
  static const int kCollectionFrontendParametersFieldNumber = 3;
  inline const ::es_product_msg::CollectionFrontendParameters& collectionfrontendparameters() const;
  inline ::es_product_msg::CollectionFrontendParameters* mutable_collectionfrontendparameters();
  inline ::es_product_msg::CollectionFrontendParameters* release_collectionfrontendparameters();
  inline void set_allocated_collectionfrontendparameters(::es_product_msg::CollectionFrontendParameters* collectionfrontendparameters);

  // optional .es_product_msg.SignalEvent signalEvent = 4;
  inline bool has_signalevent() const;
  inline void clear_signalevent();
  static const int kSignalEventFieldNumber = 4;
  inline const ::es_product_msg::SignalEvent& signalevent() const;
  inline ::es_product_msg::SignalEvent* mutable_signalevent();
  inline ::es_product_msg::SignalEvent* release_signalevent();
  inline void set_allocated_signalevent(::es_product_msg::SignalEvent* signalevent);

  // optional .es_product_msg.GPSPosition gpsPosition = 5;
  inline bool has_gpsposition() const;
  inline void clear_gpsposition();
  static const int kGpsPositionFieldNumber = 5;
  inline const ::es_product_msg::GPSPosition& gpsposition() const;
  inline ::es_product_msg::GPSPosition* mutable_gpsposition();
  inline ::es_product_msg::GPSPosition* release_gpsposition();
  inline void set_allocated_gpsposition(::es_product_msg::GPSPosition* gpsposition);

  // optional .es_product_msg.ExternalHit externalHit = 6;
  inline bool has_externalhit() const;
  inline void clear_externalhit();
  static const int kExternalHitFieldNumber = 6;
  inline const ::es_product_msg::ExternalHit& externalhit() const;
  inline ::es_product_msg::ExternalHit* mutable_externalhit();
  inline ::es_product_msg::ExternalHit* release_externalhit();
  inline void set_allocated_externalhit(::es_product_msg::ExternalHit* externalhit);

  // optional .es_product_msg.InternalHit internalHit = 7;
  inline bool has_internalhit() const;
  inline void clear_internalhit();
  static const int kInternalHitFieldNumber = 7;
  inline const ::es_product_msg::InternalHit& internalhit() const;
  inline ::es_product_msg::InternalHit* mutable_internalhit();
  inline ::es_product_msg::InternalHit* release_internalhit();
  inline void set_allocated_internalhit(::es_product_msg::InternalHit* internalhit);

  // optional .es_product_msg.FisD fisD = 8;
  inline bool has_fisd() const;
  inline void clear_fisd();
  static const int kFisDFieldNumber = 8;
  inline const ::es_product_msg::FisD& fisd() const;
  inline ::es_product_msg::FisD* mutable_fisd();
  inline ::es_product_msg::FisD* release_fisd();
  inline void set_allocated_fisd(::es_product_msg::FisD* fisd);

  // optional .es_product_msg.SIGFrame sigFrame = 9;
  inline bool has_sigframe() const;
  inline void clear_sigframe();
  static const int kSigFrameFieldNumber = 9;
  inline const ::es_product_msg::SIGFrame& sigframe() const;
  inline ::es_product_msg::SIGFrame* mutable_sigframe();
  inline ::es_product_msg::SIGFrame* release_sigframe();
  inline void set_allocated_sigframe(::es_product_msg::SIGFrame* sigframe);

  // optional .es_product_msg.ImageAvailable imageAvailable = 10;
  inline bool has_imageavailable() const;
  inline void clear_imageavailable();
  static const int kImageAvailableFieldNumber = 10;
  inline const ::es_product_msg::ImageAvailable& imageavailable() const;
  inline ::es_product_msg::ImageAvailable* mutable_imageavailable();
  inline ::es_product_msg::ImageAvailable* release_imageavailable();
  inline void set_allocated_imageavailable(::es_product_msg::ImageAvailable* imageavailable);

  // optional .es_product_msg.AudioAvailable audioAvailable = 11;
  inline bool has_audioavailable() const;
  inline void clear_audioavailable();
  static const int kAudioAvailableFieldNumber = 11;
  inline const ::es_product_msg::AudioAvailable& audioavailable() const;
  inline ::es_product_msg::AudioAvailable* mutable_audioavailable();
  inline ::es_product_msg::AudioAvailable* release_audioavailable();
  inline void set_allocated_audioavailable(::es_product_msg::AudioAvailable* audioavailable);

  // optional .es_product_msg.DmrMeta dmrMeta = 12;
  inline bool has_dmrmeta() const;
  inline void clear_dmrmeta();
  static const int kDmrMetaFieldNumber = 12;
  inline const ::es_product_msg::DmrMeta& dmrmeta() const;
  inline ::es_product_msg::DmrMeta* mutable_dmrmeta();
  inline ::es_product_msg::DmrMeta* release_dmrmeta();
  inline void set_allocated_dmrmeta(::es_product_msg::DmrMeta* dmrmeta);

  // repeated .falcon_common_msg.KeyValuePair kvps = 500;
  inline int kvps_size() const;
  inline void clear_kvps();
  static const int kKvpsFieldNumber = 500;
  inline const ::falcon_common_msg::KeyValuePair& kvps(int index) const;
  inline ::falcon_common_msg::KeyValuePair* mutable_kvps(int index);
  inline ::falcon_common_msg::KeyValuePair* add_kvps();
  inline const ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::KeyValuePair >&
      kvps() const;
  inline ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::KeyValuePair >*
      mutable_kvps();

  // @@protoc_insertion_point(class_scope:es_product_msg.ESObservationsTyped)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_iqcollectionparameters();
  inline void clear_has_iqcollectionparameters();
  inline void set_has_collectionfrontendparameters();
  inline void clear_has_collectionfrontendparameters();
  inline void set_has_signalevent();
  inline void clear_has_signalevent();
  inline void set_has_gpsposition();
  inline void clear_has_gpsposition();
  inline void set_has_externalhit();
  inline void clear_has_externalhit();
  inline void set_has_internalhit();
  inline void clear_has_internalhit();
  inline void set_has_fisd();
  inline void clear_has_fisd();
  inline void set_has_sigframe();
  inline void clear_has_sigframe();
  inline void set_has_imageavailable();
  inline void clear_has_imageavailable();
  inline void set_has_audioavailable();
  inline void clear_has_audioavailable();
  inline void set_has_dmrmeta();
  inline void clear_has_dmrmeta();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::es_product_msg::IQCollectionParameters* iqcollectionparameters_;
  ::es_product_msg::CollectionFrontendParameters* collectionfrontendparameters_;
  ::es_product_msg::SignalEvent* signalevent_;
  ::es_product_msg::GPSPosition* gpsposition_;
  ::es_product_msg::ExternalHit* externalhit_;
  ::es_product_msg::InternalHit* internalhit_;
  ::es_product_msg::FisD* fisd_;
  ::es_product_msg::SIGFrame* sigframe_;
  ::es_product_msg::ImageAvailable* imageavailable_;
  ::es_product_msg::AudioAvailable* audioavailable_;
  ::es_product_msg::DmrMeta* dmrmeta_;
  ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::KeyValuePair > kvps_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_ESProductMessages_2eproto();
  friend void protobuf_AssignDesc_ESProductMessages_2eproto();
  friend void protobuf_ShutdownFile_ESProductMessages_2eproto();

  void InitAsDefaultInstance();
  static ESObservationsTyped* default_instance_;
};
// -------------------------------------------------------------------

class IQCollectionParameters : public ::google::protobuf::Message {
 public:
  IQCollectionParameters();
  virtual ~IQCollectionParameters();

  IQCollectionParameters(const IQCollectionParameters& from);

  inline IQCollectionParameters& operator=(const IQCollectionParameters& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IQCollectionParameters& default_instance();

  void Swap(IQCollectionParameters* other);

  // implements Message ----------------------------------------------

  IQCollectionParameters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IQCollectionParameters& from);
  void MergeFrom(const IQCollectionParameters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "IQ_COLLECTION_PARAMETERS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional double centerFreqMHz = 2;
  inline bool has_centerfreqmhz() const;
  inline void clear_centerfreqmhz();
  static const int kCenterFreqMHzFieldNumber = 2;
  inline double centerfreqmhz() const;
  inline void set_centerfreqmhz(double value);

  // optional double sampleRateMHz = 3;
  inline bool has_sampleratemhz() const;
  inline void clear_sampleratemhz();
  static const int kSampleRateMHzFieldNumber = 3;
  inline double sampleratemhz() const;
  inline void set_sampleratemhz(double value);

  // optional int32 channel = 4;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 4;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional .falcon_common_msg.Timestamp timestamp = 5;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  inline const ::falcon_common_msg::Timestamp& timestamp() const;
  inline ::falcon_common_msg::Timestamp* mutable_timestamp();
  inline ::falcon_common_msg::Timestamp* release_timestamp();
  inline void set_allocated_timestamp(::falcon_common_msg::Timestamp* timestamp);

  // @@protoc_insertion_point(class_scope:es_product_msg.IQCollectionParameters)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_centerfreqmhz();
  inline void clear_has_centerfreqmhz();
  inline void set_has_sampleratemhz();
  inline void clear_has_sampleratemhz();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  double centerfreqmhz_;
  double sampleratemhz_;
  ::falcon_common_msg::Timestamp* timestamp_;
  ::google::protobuf::int32 channel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ESProductMessages_2eproto();
  friend void protobuf_AssignDesc_ESProductMessages_2eproto();
  friend void protobuf_ShutdownFile_ESProductMessages_2eproto();

  void InitAsDefaultInstance();
  static IQCollectionParameters* default_instance_;
};
// -------------------------------------------------------------------

class CollectionFrontendParameters : public ::google::protobuf::Message {
 public:
  CollectionFrontendParameters();
  virtual ~CollectionFrontendParameters();

  CollectionFrontendParameters(const CollectionFrontendParameters& from);

  inline CollectionFrontendParameters& operator=(const CollectionFrontendParameters& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CollectionFrontendParameters& default_instance();

  void Swap(CollectionFrontendParameters* other);

  // implements Message ----------------------------------------------

  CollectionFrontendParameters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CollectionFrontendParameters& from);
  void MergeFrom(const CollectionFrontendParameters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "COLLECTION_FRONTEND_PARAMETERS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 antNum = 2;
  inline bool has_antnum() const;
  inline void clear_antnum();
  static const int kAntNumFieldNumber = 2;
  inline ::google::protobuf::int32 antnum() const;
  inline void set_antnum(::google::protobuf::int32 value);

  // optional float antAz = 3;
  inline bool has_antaz() const;
  inline void clear_antaz();
  static const int kAntAzFieldNumber = 3;
  inline float antaz() const;
  inline void set_antaz(float value);

  // optional float antEl = 4;
  inline bool has_antel() const;
  inline void clear_antel();
  static const int kAntElFieldNumber = 4;
  inline float antel() const;
  inline void set_antel(float value);

  // optional float bwMHz = 5;
  inline bool has_bwmhz() const;
  inline void clear_bwmhz();
  static const int kBwMHzFieldNumber = 5;
  inline float bwmhz() const;
  inline void set_bwmhz(float value);

  // @@protoc_insertion_point(class_scope:es_product_msg.CollectionFrontendParameters)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_antnum();
  inline void clear_has_antnum();
  inline void set_has_antaz();
  inline void clear_has_antaz();
  inline void set_has_antel();
  inline void clear_has_antel();
  inline void set_has_bwmhz();
  inline void clear_has_bwmhz();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 antnum_;
  float antaz_;
  float antel_;
  float bwmhz_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ESProductMessages_2eproto();
  friend void protobuf_AssignDesc_ESProductMessages_2eproto();
  friend void protobuf_ShutdownFile_ESProductMessages_2eproto();

  void InitAsDefaultInstance();
  static CollectionFrontendParameters* default_instance_;
};
// -------------------------------------------------------------------

class SignalEvent : public ::google::protobuf::Message {
 public:
  SignalEvent();
  virtual ~SignalEvent();

  SignalEvent(const SignalEvent& from);

  inline SignalEvent& operator=(const SignalEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignalEvent& default_instance();

  void Swap(SignalEvent* other);

  // implements Message ----------------------------------------------

  SignalEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignalEvent& from);
  void MergeFrom(const SignalEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SignalEvent_Type Type;
  static const Type SIGDET = SignalEvent_Type_SIGDET;
  static const Type SIGUP = SignalEvent_Type_SIGUP;
  static const Type SIGDOWN = SignalEvent_Type_SIGDOWN;
  static const Type SIGTIMEOUT = SignalEvent_Type_SIGTIMEOUT;
  static inline bool Type_IsValid(int value) {
    return SignalEvent_Type_IsValid(value);
  }
  static const Type Type_MIN =
    SignalEvent_Type_Type_MIN;
  static const Type Type_MAX =
    SignalEvent_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    SignalEvent_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return SignalEvent_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return SignalEvent_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return SignalEvent_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SIGNAL_EVENT"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional .es_product_msg.SignalEvent.Type eventType = 2;
  inline bool has_eventtype() const;
  inline void clear_eventtype();
  static const int kEventTypeFieldNumber = 2;
  inline ::es_product_msg::SignalEvent_Type eventtype() const;
  inline void set_eventtype(::es_product_msg::SignalEvent_Type value);

  // optional string eventID = 3;
  inline bool has_eventid() const;
  inline void clear_eventid();
  static const int kEventIDFieldNumber = 3;
  inline const ::std::string& eventid() const;
  inline void set_eventid(const ::std::string& value);
  inline void set_eventid(const char* value);
  inline void set_eventid(const char* value, size_t size);
  inline ::std::string* mutable_eventid();
  inline ::std::string* release_eventid();
  inline void set_allocated_eventid(::std::string* eventid);

  // optional .falcon_common_msg.Timestamp timestamp = 4;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  inline const ::falcon_common_msg::Timestamp& timestamp() const;
  inline ::falcon_common_msg::Timestamp* mutable_timestamp();
  inline ::falcon_common_msg::Timestamp* release_timestamp();
  inline void set_allocated_timestamp(::falcon_common_msg::Timestamp* timestamp);

  // optional float rfMHz = 5;
  inline bool has_rfmhz() const;
  inline void clear_rfmhz();
  static const int kRfMHzFieldNumber = 5;
  inline float rfmhz() const;
  inline void set_rfmhz(float value);

  // optional float subcarMHz = 6;
  inline bool has_subcarmhz() const;
  inline void clear_subcarmhz();
  static const int kSubcarMHzFieldNumber = 6;
  inline float subcarmhz() const;
  inline void set_subcarmhz(float value);

  // optional float excurKHz = 7;
  inline bool has_excurkhz() const;
  inline void clear_excurkhz();
  static const int kExcurKHzFieldNumber = 7;
  inline float excurkhz() const;
  inline void set_excurkhz(float value);

  // optional int32 appID = 8;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 8;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional string scrypt = 9;
  inline bool has_scrypt() const;
  inline void clear_scrypt();
  static const int kScryptFieldNumber = 9;
  inline const ::std::string& scrypt() const;
  inline void set_scrypt(const ::std::string& value);
  inline void set_scrypt(const char* value);
  inline void set_scrypt(const char* value, size_t size);
  inline ::std::string* mutable_scrypt();
  inline ::std::string* release_scrypt();
  inline void set_allocated_scrypt(::std::string* scrypt);

  // optional int32 exportPort = 10;
  inline bool has_exportport() const;
  inline void clear_exportport();
  static const int kExportPortFieldNumber = 10;
  inline ::google::protobuf::int32 exportport() const;
  inline void set_exportport(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:es_product_msg.SignalEvent)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_eventtype();
  inline void clear_has_eventtype();
  inline void set_has_eventid();
  inline void clear_has_eventid();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_rfmhz();
  inline void clear_has_rfmhz();
  inline void set_has_subcarmhz();
  inline void clear_has_subcarmhz();
  inline void set_has_excurkhz();
  inline void clear_has_excurkhz();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_scrypt();
  inline void clear_has_scrypt();
  inline void set_has_exportport();
  inline void clear_has_exportport();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* eventid_;
  int eventtype_;
  float rfmhz_;
  ::falcon_common_msg::Timestamp* timestamp_;
  float subcarmhz_;
  float excurkhz_;
  ::std::string* scrypt_;
  ::google::protobuf::int32 appid_;
  ::google::protobuf::int32 exportport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_ESProductMessages_2eproto();
  friend void protobuf_AssignDesc_ESProductMessages_2eproto();
  friend void protobuf_ShutdownFile_ESProductMessages_2eproto();

  void InitAsDefaultInstance();
  static SignalEvent* default_instance_;
};
// -------------------------------------------------------------------

class GPSPosition : public ::google::protobuf::Message {
 public:
  GPSPosition();
  virtual ~GPSPosition();

  GPSPosition(const GPSPosition& from);

  inline GPSPosition& operator=(const GPSPosition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GPSPosition& default_instance();

  void Swap(GPSPosition* other);

  // implements Message ----------------------------------------------

  GPSPosition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPSPosition& from);
  void MergeFrom(const GPSPosition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "GPS_POSITION"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string eventID = 2;
  inline bool has_eventid() const;
  inline void clear_eventid();
  static const int kEventIDFieldNumber = 2;
  inline const ::std::string& eventid() const;
  inline void set_eventid(const ::std::string& value);
  inline void set_eventid(const char* value);
  inline void set_eventid(const char* value, size_t size);
  inline ::std::string* mutable_eventid();
  inline ::std::string* release_eventid();
  inline void set_allocated_eventid(::std::string* eventid);

  // optional float latitude = 3;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 3;
  inline float latitude() const;
  inline void set_latitude(float value);

  // optional float longitude = 4;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 4;
  inline float longitude() const;
  inline void set_longitude(float value);

  // optional float altitude = 5;
  inline bool has_altitude() const;
  inline void clear_altitude();
  static const int kAltitudeFieldNumber = 5;
  inline float altitude() const;
  inline void set_altitude(float value);

  // optional float wpLatitude = 6;
  inline bool has_wplatitude() const;
  inline void clear_wplatitude();
  static const int kWpLatitudeFieldNumber = 6;
  inline float wplatitude() const;
  inline void set_wplatitude(float value);

  // optional float wpLongitude = 7;
  inline bool has_wplongitude() const;
  inline void clear_wplongitude();
  static const int kWpLongitudeFieldNumber = 7;
  inline float wplongitude() const;
  inline void set_wplongitude(float value);

  // optional float velocity = 8;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 8;
  inline float velocity() const;
  inline void set_velocity(float value);

  // optional float bearing = 9;
  inline bool has_bearing() const;
  inline void clear_bearing();
  static const int kBearingFieldNumber = 9;
  inline float bearing() const;
  inline void set_bearing(float value);

  // optional float range = 10;
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 10;
  inline float range() const;
  inline void set_range(float value);

  // optional .falcon_common_msg.Timestamp timestamp = 11;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 11;
  inline const ::falcon_common_msg::Timestamp& timestamp() const;
  inline ::falcon_common_msg::Timestamp* mutable_timestamp();
  inline ::falcon_common_msg::Timestamp* release_timestamp();
  inline void set_allocated_timestamp(::falcon_common_msg::Timestamp* timestamp);

  // optional float seqNum = 12;
  inline bool has_seqnum() const;
  inline void clear_seqnum();
  static const int kSeqNumFieldNumber = 12;
  inline float seqnum() const;
  inline void set_seqnum(float value);

  // optional bool isPrediction = 13;
  inline bool has_isprediction() const;
  inline void clear_isprediction();
  static const int kIsPredictionFieldNumber = 13;
  inline bool isprediction() const;
  inline void set_isprediction(bool value);

  // optional float major = 14;
  inline bool has_major() const;
  inline void clear_major();
  static const int kMajorFieldNumber = 14;
  inline float major() const;
  inline void set_major(float value);

  // optional float minor = 15;
  inline bool has_minor() const;
  inline void clear_minor();
  static const int kMinorFieldNumber = 15;
  inline float minor() const;
  inline void set_minor(float value);

  // optional float vector = 16;
  inline bool has_vector() const;
  inline void clear_vector();
  static const int kVectorFieldNumber = 16;
  inline float vector() const;
  inline void set_vector(float value);

  // optional int32 appID = 17;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 17;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:es_product_msg.GPSPosition)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_eventid();
  inline void clear_has_eventid();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_altitude();
  inline void clear_has_altitude();
  inline void set_has_wplatitude();
  inline void clear_has_wplatitude();
  inline void set_has_wplongitude();
  inline void clear_has_wplongitude();
  inline void set_has_velocity();
  inline void clear_has_velocity();
  inline void set_has_bearing();
  inline void clear_has_bearing();
  inline void set_has_range();
  inline void clear_has_range();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_seqnum();
  inline void clear_has_seqnum();
  inline void set_has_isprediction();
  inline void clear_has_isprediction();
  inline void set_has_major();
  inline void clear_has_major();
  inline void set_has_minor();
  inline void clear_has_minor();
  inline void set_has_vector();
  inline void clear_has_vector();
  inline void set_has_appid();
  inline void clear_has_appid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* eventid_;
  float latitude_;
  float longitude_;
  float altitude_;
  float wplatitude_;
  float wplongitude_;
  float velocity_;
  float bearing_;
  float range_;
  ::falcon_common_msg::Timestamp* timestamp_;
  float seqnum_;
  bool isprediction_;
  float major_;
  float minor_;
  float vector_;
  ::google::protobuf::int32 appid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  friend void  protobuf_AddDesc_ESProductMessages_2eproto();
  friend void protobuf_AssignDesc_ESProductMessages_2eproto();
  friend void protobuf_ShutdownFile_ESProductMessages_2eproto();

  void InitAsDefaultInstance();
  static GPSPosition* default_instance_;
};
// -------------------------------------------------------------------

class ExternalHit : public ::google::protobuf::Message {
 public:
  ExternalHit();
  virtual ~ExternalHit();

  ExternalHit(const ExternalHit& from);

  inline ExternalHit& operator=(const ExternalHit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExternalHit& default_instance();

  void Swap(ExternalHit* other);

  // implements Message ----------------------------------------------

  ExternalHit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExternalHit& from);
  void MergeFrom(const ExternalHit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ExternalHit_Type Type;
  static const Type KNOWN_RED = ExternalHit_Type_KNOWN_RED;
  static const Type KNOWN_GRAY = ExternalHit_Type_KNOWN_GRAY;
  static const Type KNOWN_BLUE = ExternalHit_Type_KNOWN_BLUE;
  static const Type UNKNOWN = ExternalHit_Type_UNKNOWN;
  static const Type ANOMALY = ExternalHit_Type_ANOMALY;
  static inline bool Type_IsValid(int value) {
    return ExternalHit_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ExternalHit_Type_Type_MIN;
  static const Type Type_MAX =
    ExternalHit_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ExternalHit_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ExternalHit_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ExternalHit_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ExternalHit_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "EXTERNAL_HIT"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional .es_product_msg.ExternalHit.Type threatType = 2;
  inline bool has_threattype() const;
  inline void clear_threattype();
  static const int kThreatTypeFieldNumber = 2;
  inline ::es_product_msg::ExternalHit_Type threattype() const;
  inline void set_threattype(::es_product_msg::ExternalHit_Type value);

  // optional double centerFreqMHz = 3;
  inline bool has_centerfreqmhz() const;
  inline void clear_centerfreqmhz();
  static const int kCenterFreqMHzFieldNumber = 3;
  inline double centerfreqmhz() const;
  inline void set_centerfreqmhz(double value);

  // optional int32 pseudoUniqueId = 4;
  inline bool has_pseudouniqueid() const;
  inline void clear_pseudouniqueid();
  static const int kPseudoUniqueIdFieldNumber = 4;
  inline ::google::protobuf::int32 pseudouniqueid() const;
  inline void set_pseudouniqueid(::google::protobuf::int32 value);

  // optional .falcon_common_msg.Timestamp timestamp = 5;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  inline const ::falcon_common_msg::Timestamp& timestamp() const;
  inline ::falcon_common_msg::Timestamp* mutable_timestamp();
  inline ::falcon_common_msg::Timestamp* release_timestamp();
  inline void set_allocated_timestamp(::falcon_common_msg::Timestamp* timestamp);

  // optional bool isTrigger = 6;
  inline bool has_istrigger() const;
  inline void clear_istrigger();
  static const int kIsTriggerFieldNumber = 6;
  inline bool istrigger() const;
  inline void set_istrigger(bool value);

  // optional .falcon_externals_msg.HopDescriptor hopDescriptor = 7;
  inline bool has_hopdescriptor() const;
  inline void clear_hopdescriptor();
  static const int kHopDescriptorFieldNumber = 7;
  inline const ::falcon_externals_msg::HopDescriptor& hopdescriptor() const;
  inline ::falcon_externals_msg::HopDescriptor* mutable_hopdescriptor();
  inline ::falcon_externals_msg::HopDescriptor* release_hopdescriptor();
  inline void set_allocated_hopdescriptor(::falcon_externals_msg::HopDescriptor* hopdescriptor);

  // optional .falcon_externals_msg.FSKDescriptor fskDescriptor = 8;
  inline bool has_fskdescriptor() const;
  inline void clear_fskdescriptor();
  static const int kFskDescriptorFieldNumber = 8;
  inline const ::falcon_externals_msg::FSKDescriptor& fskdescriptor() const;
  inline ::falcon_externals_msg::FSKDescriptor* mutable_fskdescriptor();
  inline ::falcon_externals_msg::FSKDescriptor* release_fskdescriptor();
  inline void set_allocated_fskdescriptor(::falcon_externals_msg::FSKDescriptor* fskdescriptor);

  // optional .falcon_externals_msg.CWDescriptor cwDescriptor = 9;
  inline bool has_cwdescriptor() const;
  inline void clear_cwdescriptor();
  static const int kCwDescriptorFieldNumber = 9;
  inline const ::falcon_externals_msg::CWDescriptor& cwdescriptor() const;
  inline ::falcon_externals_msg::CWDescriptor* mutable_cwdescriptor();
  inline ::falcon_externals_msg::CWDescriptor* release_cwdescriptor();
  inline void set_allocated_cwdescriptor(::falcon_externals_msg::CWDescriptor* cwdescriptor);

  // optional .falcon_externals_msg.SpreadDescriptor spreadDescriptor = 10;
  inline bool has_spreaddescriptor() const;
  inline void clear_spreaddescriptor();
  static const int kSpreadDescriptorFieldNumber = 10;
  inline const ::falcon_externals_msg::SpreadDescriptor& spreaddescriptor() const;
  inline ::falcon_externals_msg::SpreadDescriptor* mutable_spreaddescriptor();
  inline ::falcon_externals_msg::SpreadDescriptor* release_spreaddescriptor();
  inline void set_allocated_spreaddescriptor(::falcon_externals_msg::SpreadDescriptor* spreaddescriptor);

  // optional .falcon_externals_msg.AVDescriptor avDescriptor = 11;
  inline bool has_avdescriptor() const;
  inline void clear_avdescriptor();
  static const int kAvDescriptorFieldNumber = 11;
  inline const ::falcon_externals_msg::AVDescriptor& avdescriptor() const;
  inline ::falcon_externals_msg::AVDescriptor* mutable_avdescriptor();
  inline ::falcon_externals_msg::AVDescriptor* release_avdescriptor();
  inline void set_allocated_avdescriptor(::falcon_externals_msg::AVDescriptor* avdescriptor);

  // optional .falcon_externals_msg.DsssDescriptor dsssDescriptor = 12;
  inline bool has_dsssdescriptor() const;
  inline void clear_dsssdescriptor();
  static const int kDsssDescriptorFieldNumber = 12;
  inline const ::falcon_externals_msg::DsssDescriptor& dsssdescriptor() const;
  inline ::falcon_externals_msg::DsssDescriptor* mutable_dsssdescriptor();
  inline ::falcon_externals_msg::DsssDescriptor* release_dsssdescriptor();
  inline void set_allocated_dsssdescriptor(::falcon_externals_msg::DsssDescriptor* dsssdescriptor);

  // optional int32 updateValues = 13;
  inline bool has_updatevalues() const;
  inline void clear_updatevalues();
  static const int kUpdateValuesFieldNumber = 13;
  inline ::google::protobuf::int32 updatevalues() const;
  inline void set_updatevalues(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:es_product_msg.ExternalHit)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_threattype();
  inline void clear_has_threattype();
  inline void set_has_centerfreqmhz();
  inline void clear_has_centerfreqmhz();
  inline void set_has_pseudouniqueid();
  inline void clear_has_pseudouniqueid();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_istrigger();
  inline void clear_has_istrigger();
  inline void set_has_hopdescriptor();
  inline void clear_has_hopdescriptor();
  inline void set_has_fskdescriptor();
  inline void clear_has_fskdescriptor();
  inline void set_has_cwdescriptor();
  inline void clear_has_cwdescriptor();
  inline void set_has_spreaddescriptor();
  inline void clear_has_spreaddescriptor();
  inline void set_has_avdescriptor();
  inline void clear_has_avdescriptor();
  inline void set_has_dsssdescriptor();
  inline void clear_has_dsssdescriptor();
  inline void set_has_updatevalues();
  inline void clear_has_updatevalues();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  double centerfreqmhz_;
  int threattype_;
  ::google::protobuf::int32 pseudouniqueid_;
  ::falcon_common_msg::Timestamp* timestamp_;
  ::falcon_externals_msg::HopDescriptor* hopdescriptor_;
  ::falcon_externals_msg::FSKDescriptor* fskdescriptor_;
  ::falcon_externals_msg::CWDescriptor* cwdescriptor_;
  bool istrigger_;
  ::google::protobuf::int32 updatevalues_;
  ::falcon_externals_msg::SpreadDescriptor* spreaddescriptor_;
  ::falcon_externals_msg::AVDescriptor* avdescriptor_;
  ::falcon_externals_msg::DsssDescriptor* dsssdescriptor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_ESProductMessages_2eproto();
  friend void protobuf_AssignDesc_ESProductMessages_2eproto();
  friend void protobuf_ShutdownFile_ESProductMessages_2eproto();

  void InitAsDefaultInstance();
  static ExternalHit* default_instance_;
};
// -------------------------------------------------------------------

class InternalHit : public ::google::protobuf::Message {
 public:
  InternalHit();
  virtual ~InternalHit();

  InternalHit(const InternalHit& from);

  inline InternalHit& operator=(const InternalHit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalHit& default_instance();

  void Swap(InternalHit* other);

  // implements Message ----------------------------------------------

  InternalHit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalHit& from);
  void MergeFrom(const InternalHit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "INTERNAL_HIT"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional double centerFreqMHz = 2;
  inline bool has_centerfreqmhz() const;
  inline void clear_centerfreqmhz();
  static const int kCenterFreqMHzFieldNumber = 2;
  inline double centerfreqmhz() const;
  inline void set_centerfreqmhz(double value);

  // optional int32 pseudoUniqueId = 3;
  inline bool has_pseudouniqueid() const;
  inline void clear_pseudouniqueid();
  static const int kPseudoUniqueIdFieldNumber = 3;
  inline ::google::protobuf::int32 pseudouniqueid() const;
  inline void set_pseudouniqueid(::google::protobuf::int32 value);

  // optional .falcon_common_msg.Timestamp timestamp = 4;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  inline const ::falcon_common_msg::Timestamp& timestamp() const;
  inline ::falcon_common_msg::Timestamp* mutable_timestamp();
  inline ::falcon_common_msg::Timestamp* release_timestamp();
  inline void set_allocated_timestamp(::falcon_common_msg::Timestamp* timestamp);

  // optional bool isTrigger = 5;
  inline bool has_istrigger() const;
  inline void clear_istrigger();
  static const int kIsTriggerFieldNumber = 5;
  inline bool istrigger() const;
  inline void set_istrigger(bool value);

  // optional .falcon_externals_msg.HopDescriptor hopDescriptor = 6;
  inline bool has_hopdescriptor() const;
  inline void clear_hopdescriptor();
  static const int kHopDescriptorFieldNumber = 6;
  inline const ::falcon_externals_msg::HopDescriptor& hopdescriptor() const;
  inline ::falcon_externals_msg::HopDescriptor* mutable_hopdescriptor();
  inline ::falcon_externals_msg::HopDescriptor* release_hopdescriptor();
  inline void set_allocated_hopdescriptor(::falcon_externals_msg::HopDescriptor* hopdescriptor);

  // optional .falcon_externals_msg.FSKDescriptor fskDescriptor = 7;
  inline bool has_fskdescriptor() const;
  inline void clear_fskdescriptor();
  static const int kFskDescriptorFieldNumber = 7;
  inline const ::falcon_externals_msg::FSKDescriptor& fskdescriptor() const;
  inline ::falcon_externals_msg::FSKDescriptor* mutable_fskdescriptor();
  inline ::falcon_externals_msg::FSKDescriptor* release_fskdescriptor();
  inline void set_allocated_fskdescriptor(::falcon_externals_msg::FSKDescriptor* fskdescriptor);

  // optional .falcon_externals_msg.CWDescriptor cwDescriptor = 8;
  inline bool has_cwdescriptor() const;
  inline void clear_cwdescriptor();
  static const int kCwDescriptorFieldNumber = 8;
  inline const ::falcon_externals_msg::CWDescriptor& cwdescriptor() const;
  inline ::falcon_externals_msg::CWDescriptor* mutable_cwdescriptor();
  inline ::falcon_externals_msg::CWDescriptor* release_cwdescriptor();
  inline void set_allocated_cwdescriptor(::falcon_externals_msg::CWDescriptor* cwdescriptor);

  // optional .falcon_externals_msg.SpreadDescriptor spreadDescriptor = 9;
  inline bool has_spreaddescriptor() const;
  inline void clear_spreaddescriptor();
  static const int kSpreadDescriptorFieldNumber = 9;
  inline const ::falcon_externals_msg::SpreadDescriptor& spreaddescriptor() const;
  inline ::falcon_externals_msg::SpreadDescriptor* mutable_spreaddescriptor();
  inline ::falcon_externals_msg::SpreadDescriptor* release_spreaddescriptor();
  inline void set_allocated_spreaddescriptor(::falcon_externals_msg::SpreadDescriptor* spreaddescriptor);

  // optional .falcon_externals_msg.AVDescriptor avDescriptor = 10;
  inline bool has_avdescriptor() const;
  inline void clear_avdescriptor();
  static const int kAvDescriptorFieldNumber = 10;
  inline const ::falcon_externals_msg::AVDescriptor& avdescriptor() const;
  inline ::falcon_externals_msg::AVDescriptor* mutable_avdescriptor();
  inline ::falcon_externals_msg::AVDescriptor* release_avdescriptor();
  inline void set_allocated_avdescriptor(::falcon_externals_msg::AVDescriptor* avdescriptor);

  // optional .falcon_externals_msg.DsssDescriptor dsssDescriptor = 11;
  inline bool has_dsssdescriptor() const;
  inline void clear_dsssdescriptor();
  static const int kDsssDescriptorFieldNumber = 11;
  inline const ::falcon_externals_msg::DsssDescriptor& dsssdescriptor() const;
  inline ::falcon_externals_msg::DsssDescriptor* mutable_dsssdescriptor();
  inline ::falcon_externals_msg::DsssDescriptor* release_dsssdescriptor();
  inline void set_allocated_dsssdescriptor(::falcon_externals_msg::DsssDescriptor* dsssdescriptor);

  // optional int32 updateValues = 12;
  inline bool has_updatevalues() const;
  inline void clear_updatevalues();
  static const int kUpdateValuesFieldNumber = 12;
  inline ::google::protobuf::int32 updatevalues() const;
  inline void set_updatevalues(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:es_product_msg.InternalHit)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_centerfreqmhz();
  inline void clear_has_centerfreqmhz();
  inline void set_has_pseudouniqueid();
  inline void clear_has_pseudouniqueid();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_istrigger();
  inline void clear_has_istrigger();
  inline void set_has_hopdescriptor();
  inline void clear_has_hopdescriptor();
  inline void set_has_fskdescriptor();
  inline void clear_has_fskdescriptor();
  inline void set_has_cwdescriptor();
  inline void clear_has_cwdescriptor();
  inline void set_has_spreaddescriptor();
  inline void clear_has_spreaddescriptor();
  inline void set_has_avdescriptor();
  inline void clear_has_avdescriptor();
  inline void set_has_dsssdescriptor();
  inline void clear_has_dsssdescriptor();
  inline void set_has_updatevalues();
  inline void clear_has_updatevalues();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  double centerfreqmhz_;
  ::falcon_common_msg::Timestamp* timestamp_;
  ::google::protobuf::int32 pseudouniqueid_;
  bool istrigger_;
  ::falcon_externals_msg::HopDescriptor* hopdescriptor_;
  ::falcon_externals_msg::FSKDescriptor* fskdescriptor_;
  ::falcon_externals_msg::CWDescriptor* cwdescriptor_;
  ::falcon_externals_msg::SpreadDescriptor* spreaddescriptor_;
  ::falcon_externals_msg::AVDescriptor* avdescriptor_;
  ::falcon_externals_msg::DsssDescriptor* dsssdescriptor_;
  ::google::protobuf::int32 updatevalues_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_ESProductMessages_2eproto();
  friend void protobuf_AssignDesc_ESProductMessages_2eproto();
  friend void protobuf_ShutdownFile_ESProductMessages_2eproto();

  void InitAsDefaultInstance();
  static InternalHit* default_instance_;
};
// -------------------------------------------------------------------

class FisD : public ::google::protobuf::Message {
 public:
  FisD();
  virtual ~FisD();

  FisD(const FisD& from);

  inline FisD& operator=(const FisD& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FisD& default_instance();

  void Swap(FisD* other);

  // implements Message ----------------------------------------------

  FisD* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FisD& from);
  void MergeFrom(const FisD& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef FisD_FileType FileType;
  static const FileType FS = FisD_FileType_FS;
  static const FileType TC = FisD_FileType_TC;
  static const FileType BER = FisD_FileType_BER;
  static inline bool FileType_IsValid(int value) {
    return FisD_FileType_IsValid(value);
  }
  static const FileType FileType_MIN =
    FisD_FileType_FileType_MIN;
  static const FileType FileType_MAX =
    FisD_FileType_FileType_MAX;
  static const int FileType_ARRAYSIZE =
    FisD_FileType_FileType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FileType_descriptor() {
    return FisD_FileType_descriptor();
  }
  static inline const ::std::string& FileType_Name(FileType value) {
    return FisD_FileType_Name(value);
  }
  static inline bool FileType_Parse(const ::std::string& name,
      FileType* value) {
    return FisD_FileType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "FIS_D"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional .es_product_msg.FisD.FileType fileType = 2;
  inline bool has_filetype() const;
  inline void clear_filetype();
  static const int kFileTypeFieldNumber = 2;
  inline ::es_product_msg::FisD_FileType filetype() const;
  inline void set_filetype(::es_product_msg::FisD_FileType value);

  // optional string fileName = 3;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 3;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional bytes file = 4;
  inline bool has_file() const;
  inline void clear_file();
  static const int kFileFieldNumber = 4;
  inline const ::std::string& file() const;
  inline void set_file(const ::std::string& value);
  inline void set_file(const char* value);
  inline void set_file(const void* value, size_t size);
  inline ::std::string* mutable_file();
  inline ::std::string* release_file();
  inline void set_allocated_file(::std::string* file);

  // optional string eventID = 5;
  inline bool has_eventid() const;
  inline void clear_eventid();
  static const int kEventIDFieldNumber = 5;
  inline const ::std::string& eventid() const;
  inline void set_eventid(const ::std::string& value);
  inline void set_eventid(const char* value);
  inline void set_eventid(const char* value, size_t size);
  inline ::std::string* mutable_eventid();
  inline ::std::string* release_eventid();
  inline void set_allocated_eventid(::std::string* eventid);

  // @@protoc_insertion_point(class_scope:es_product_msg.FisD)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_filetype();
  inline void clear_has_filetype();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_file();
  inline void clear_has_file();
  inline void set_has_eventid();
  inline void clear_has_eventid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* filename_;
  ::std::string* file_;
  ::std::string* eventid_;
  int filetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ESProductMessages_2eproto();
  friend void protobuf_AssignDesc_ESProductMessages_2eproto();
  friend void protobuf_ShutdownFile_ESProductMessages_2eproto();

  void InitAsDefaultInstance();
  static FisD* default_instance_;
};
// -------------------------------------------------------------------

class SIGFrame : public ::google::protobuf::Message {
 public:
  SIGFrame();
  virtual ~SIGFrame();

  SIGFrame(const SIGFrame& from);

  inline SIGFrame& operator=(const SIGFrame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SIGFrame& default_instance();

  void Swap(SIGFrame* other);

  // implements Message ----------------------------------------------

  SIGFrame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SIGFrame& from);
  void MergeFrom(const SIGFrame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SIG_FRAME"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string signalID = 2;
  inline bool has_signalid() const;
  inline void clear_signalid();
  static const int kSignalIDFieldNumber = 2;
  inline const ::std::string& signalid() const;
  inline void set_signalid(const ::std::string& value);
  inline void set_signalid(const char* value);
  inline void set_signalid(const char* value, size_t size);
  inline ::std::string* mutable_signalid();
  inline ::std::string* release_signalid();
  inline void set_allocated_signalid(::std::string* signalid);

  // optional .falcon_common_msg.Timestamp timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline const ::falcon_common_msg::Timestamp& timestamp() const;
  inline ::falcon_common_msg::Timestamp* mutable_timestamp();
  inline ::falcon_common_msg::Timestamp* release_timestamp();
  inline void set_allocated_timestamp(::falcon_common_msg::Timestamp* timestamp);

  // optional double duration = 4;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 4;
  inline double duration() const;
  inline void set_duration(double value);

  // optional double centerFreqMHz = 5;
  inline bool has_centerfreqmhz() const;
  inline void clear_centerfreqmhz();
  static const int kCenterFreqMHzFieldNumber = 5;
  inline double centerfreqmhz() const;
  inline void set_centerfreqmhz(double value);

  // optional double centerFreqOffsetHz = 6;
  inline bool has_centerfreqoffsethz() const;
  inline void clear_centerfreqoffsethz();
  static const int kCenterFreqOffsetHzFieldNumber = 6;
  inline double centerfreqoffsethz() const;
  inline void set_centerfreqoffsethz(double value);

  // optional double sampleRate = 7;
  inline bool has_samplerate() const;
  inline void clear_samplerate();
  static const int kSampleRateFieldNumber = 7;
  inline double samplerate() const;
  inline void set_samplerate(double value);

  // optional double bandwidth = 8;
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandwidthFieldNumber = 8;
  inline double bandwidth() const;
  inline void set_bandwidth(double value);

  // optional double power = 9;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 9;
  inline double power() const;
  inline void set_power(double value);

  // optional double ber = 10;
  inline bool has_ber() const;
  inline void clear_ber();
  static const int kBerFieldNumber = 10;
  inline double ber() const;
  inline void set_ber(double value);

  // optional int32 frameLength = 11;
  inline bool has_framelength() const;
  inline void clear_framelength();
  static const int kFrameLengthFieldNumber = 11;
  inline ::google::protobuf::int32 framelength() const;
  inline void set_framelength(::google::protobuf::int32 value);

  // optional bytes frame = 12;
  inline bool has_frame() const;
  inline void clear_frame();
  static const int kFrameFieldNumber = 12;
  inline const ::std::string& frame() const;
  inline void set_frame(const ::std::string& value);
  inline void set_frame(const char* value);
  inline void set_frame(const void* value, size_t size);
  inline ::std::string* mutable_frame();
  inline ::std::string* release_frame();
  inline void set_allocated_frame(::std::string* frame);

  // optional int32 tailID = 13;
  inline bool has_tailid() const;
  inline void clear_tailid();
  static const int kTailIDFieldNumber = 13;
  inline ::google::protobuf::int32 tailid() const;
  inline void set_tailid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:es_product_msg.SIGFrame)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_signalid();
  inline void clear_has_signalid();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_centerfreqmhz();
  inline void clear_has_centerfreqmhz();
  inline void set_has_centerfreqoffsethz();
  inline void clear_has_centerfreqoffsethz();
  inline void set_has_samplerate();
  inline void clear_has_samplerate();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();
  inline void set_has_power();
  inline void clear_has_power();
  inline void set_has_ber();
  inline void clear_has_ber();
  inline void set_has_framelength();
  inline void clear_has_framelength();
  inline void set_has_frame();
  inline void clear_has_frame();
  inline void set_has_tailid();
  inline void clear_has_tailid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* signalid_;
  ::falcon_common_msg::Timestamp* timestamp_;
  double duration_;
  double centerfreqmhz_;
  double centerfreqoffsethz_;
  double samplerate_;
  double bandwidth_;
  double power_;
  double ber_;
  ::std::string* frame_;
  ::google::protobuf::int32 framelength_;
  ::google::protobuf::int32 tailid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_ESProductMessages_2eproto();
  friend void protobuf_AssignDesc_ESProductMessages_2eproto();
  friend void protobuf_ShutdownFile_ESProductMessages_2eproto();

  void InitAsDefaultInstance();
  static SIGFrame* default_instance_;
};
// -------------------------------------------------------------------

class ImageAvailable : public ::google::protobuf::Message {
 public:
  ImageAvailable();
  virtual ~ImageAvailable();

  ImageAvailable(const ImageAvailable& from);

  inline ImageAvailable& operator=(const ImageAvailable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageAvailable& default_instance();

  void Swap(ImageAvailable* other);

  // implements Message ----------------------------------------------

  ImageAvailable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImageAvailable& from);
  void MergeFrom(const ImageAvailable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ImageAvailable_Status Status;
  static const Status AVAILABLE = ImageAvailable_Status_AVAILABLE;
  static const Status UNAVAILABLE = ImageAvailable_Status_UNAVAILABLE;
  static const Status PENDING = ImageAvailable_Status_PENDING;
  static inline bool Status_IsValid(int value) {
    return ImageAvailable_Status_IsValid(value);
  }
  static const Status Status_MIN =
    ImageAvailable_Status_Status_MIN;
  static const Status Status_MAX =
    ImageAvailable_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    ImageAvailable_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return ImageAvailable_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return ImageAvailable_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return ImageAvailable_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "IMAGE_AVAILABLE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 imageWidth = 2;
  inline bool has_imagewidth() const;
  inline void clear_imagewidth();
  static const int kImageWidthFieldNumber = 2;
  inline ::google::protobuf::int32 imagewidth() const;
  inline void set_imagewidth(::google::protobuf::int32 value);

  // optional int32 imageHeight = 3;
  inline bool has_imageheight() const;
  inline void clear_imageheight();
  static const int kImageHeightFieldNumber = 3;
  inline ::google::protobuf::int32 imageheight() const;
  inline void set_imageheight(::google::protobuf::int32 value);

  // optional int32 videoPort = 4;
  inline bool has_videoport() const;
  inline void clear_videoport();
  static const int kVideoPortFieldNumber = 4;
  inline ::google::protobuf::int32 videoport() const;
  inline void set_videoport(::google::protobuf::int32 value);

  // optional int32 framerate = 5;
  inline bool has_framerate() const;
  inline void clear_framerate();
  static const int kFramerateFieldNumber = 5;
  inline ::google::protobuf::int32 framerate() const;
  inline void set_framerate(::google::protobuf::int32 value);

  // optional bytes byteArray = 6;
  inline bool has_bytearray() const;
  inline void clear_bytearray();
  static const int kByteArrayFieldNumber = 6;
  inline const ::std::string& bytearray() const;
  inline void set_bytearray(const ::std::string& value);
  inline void set_bytearray(const char* value);
  inline void set_bytearray(const void* value, size_t size);
  inline ::std::string* mutable_bytearray();
  inline ::std::string* release_bytearray();
  inline void set_allocated_bytearray(::std::string* bytearray);

  // optional .es_product_msg.ImageAvailable.Status status = 7;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 7;
  inline ::es_product_msg::ImageAvailable_Status status() const;
  inline void set_status(::es_product_msg::ImageAvailable_Status value);

  // optional int32 msgID = 8;
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgIDFieldNumber = 8;
  inline ::google::protobuf::int32 msgid() const;
  inline void set_msgid(::google::protobuf::int32 value);

  // optional string eventID = 9;
  inline bool has_eventid() const;
  inline void clear_eventid();
  static const int kEventIDFieldNumber = 9;
  inline const ::std::string& eventid() const;
  inline void set_eventid(const ::std::string& value);
  inline void set_eventid(const char* value);
  inline void set_eventid(const char* value, size_t size);
  inline ::std::string* mutable_eventid();
  inline ::std::string* release_eventid();
  inline void set_allocated_eventid(::std::string* eventid);

  // @@protoc_insertion_point(class_scope:es_product_msg.ImageAvailable)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_imagewidth();
  inline void clear_has_imagewidth();
  inline void set_has_imageheight();
  inline void clear_has_imageheight();
  inline void set_has_videoport();
  inline void clear_has_videoport();
  inline void set_has_framerate();
  inline void clear_has_framerate();
  inline void set_has_bytearray();
  inline void clear_has_bytearray();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_msgid();
  inline void clear_has_msgid();
  inline void set_has_eventid();
  inline void clear_has_eventid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 imagewidth_;
  ::google::protobuf::int32 imageheight_;
  ::google::protobuf::int32 videoport_;
  ::google::protobuf::int32 framerate_;
  ::std::string* bytearray_;
  int status_;
  ::google::protobuf::int32 msgid_;
  ::std::string* eventid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_ESProductMessages_2eproto();
  friend void protobuf_AssignDesc_ESProductMessages_2eproto();
  friend void protobuf_ShutdownFile_ESProductMessages_2eproto();

  void InitAsDefaultInstance();
  static ImageAvailable* default_instance_;
};
// -------------------------------------------------------------------

class AudioAvailable : public ::google::protobuf::Message {
 public:
  AudioAvailable();
  virtual ~AudioAvailable();

  AudioAvailable(const AudioAvailable& from);

  inline AudioAvailable& operator=(const AudioAvailable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioAvailable& default_instance();

  void Swap(AudioAvailable* other);

  // implements Message ----------------------------------------------

  AudioAvailable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioAvailable& from);
  void MergeFrom(const AudioAvailable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AudioAvailable_Status Status;
  static const Status AVAILABLE = AudioAvailable_Status_AVAILABLE;
  static const Status UNAVAILABLE = AudioAvailable_Status_UNAVAILABLE;
  static const Status PENDING = AudioAvailable_Status_PENDING;
  static inline bool Status_IsValid(int value) {
    return AudioAvailable_Status_IsValid(value);
  }
  static const Status Status_MIN =
    AudioAvailable_Status_Status_MIN;
  static const Status Status_MAX =
    AudioAvailable_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    AudioAvailable_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return AudioAvailable_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return AudioAvailable_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return AudioAvailable_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "AUDIO_AVAILABLE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional double centerFreqMHz = 2;
  inline bool has_centerfreqmhz() const;
  inline void clear_centerfreqmhz();
  static const int kCenterFreqMHzFieldNumber = 2;
  inline double centerfreqmhz() const;
  inline void set_centerfreqmhz(double value);

  // optional .es_product_msg.AudioAvailable.Status status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::es_product_msg::AudioAvailable_Status status() const;
  inline void set_status(::es_product_msg::AudioAvailable_Status value);

  // optional string audiofile = 4;
  inline bool has_audiofile() const;
  inline void clear_audiofile();
  static const int kAudiofileFieldNumber = 4;
  inline const ::std::string& audiofile() const;
  inline void set_audiofile(const ::std::string& value);
  inline void set_audiofile(const char* value);
  inline void set_audiofile(const char* value, size_t size);
  inline ::std::string* mutable_audiofile();
  inline ::std::string* release_audiofile();
  inline void set_allocated_audiofile(::std::string* audiofile);

  // optional int32 msgID = 5;
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgIDFieldNumber = 5;
  inline ::google::protobuf::int32 msgid() const;
  inline void set_msgid(::google::protobuf::int32 value);

  // optional string soiNum = 6;
  inline bool has_soinum() const;
  inline void clear_soinum();
  static const int kSoiNumFieldNumber = 6;
  inline const ::std::string& soinum() const;
  inline void set_soinum(const ::std::string& value);
  inline void set_soinum(const char* value);
  inline void set_soinum(const char* value, size_t size);
  inline ::std::string* mutable_soinum();
  inline ::std::string* release_soinum();
  inline void set_allocated_soinum(::std::string* soinum);

  // @@protoc_insertion_point(class_scope:es_product_msg.AudioAvailable)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_centerfreqmhz();
  inline void clear_has_centerfreqmhz();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_audiofile();
  inline void clear_has_audiofile();
  inline void set_has_msgid();
  inline void clear_has_msgid();
  inline void set_has_soinum();
  inline void clear_has_soinum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  double centerfreqmhz_;
  ::std::string* audiofile_;
  int status_;
  ::google::protobuf::int32 msgid_;
  ::std::string* soinum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_ESProductMessages_2eproto();
  friend void protobuf_AssignDesc_ESProductMessages_2eproto();
  friend void protobuf_ShutdownFile_ESProductMessages_2eproto();

  void InitAsDefaultInstance();
  static AudioAvailable* default_instance_;
};
// -------------------------------------------------------------------

class DmrMeta : public ::google::protobuf::Message {
 public:
  DmrMeta();
  virtual ~DmrMeta();

  DmrMeta(const DmrMeta& from);

  inline DmrMeta& operator=(const DmrMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DmrMeta& default_instance();

  void Swap(DmrMeta* other);

  // implements Message ----------------------------------------------

  DmrMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DmrMeta& from);
  void MergeFrom(const DmrMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "DMR_META"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional double centerFreqMHz = 2;
  inline bool has_centerfreqmhz() const;
  inline void clear_centerfreqmhz();
  static const int kCenterFreqMHzFieldNumber = 2;
  inline double centerfreqmhz() const;
  inline void set_centerfreqmhz(double value);

  // optional string srcType = 3;
  inline bool has_srctype() const;
  inline void clear_srctype();
  static const int kSrcTypeFieldNumber = 3;
  inline const ::std::string& srctype() const;
  inline void set_srctype(const ::std::string& value);
  inline void set_srctype(const char* value);
  inline void set_srctype(const char* value, size_t size);
  inline ::std::string* mutable_srctype();
  inline ::std::string* release_srctype();
  inline void set_allocated_srctype(::std::string* srctype);

  // optional int32 srcAddr = 4;
  inline bool has_srcaddr() const;
  inline void clear_srcaddr();
  static const int kSrcAddrFieldNumber = 4;
  inline ::google::protobuf::int32 srcaddr() const;
  inline void set_srcaddr(::google::protobuf::int32 value);

  // optional string destType = 5;
  inline bool has_desttype() const;
  inline void clear_desttype();
  static const int kDestTypeFieldNumber = 5;
  inline const ::std::string& desttype() const;
  inline void set_desttype(const ::std::string& value);
  inline void set_desttype(const char* value);
  inline void set_desttype(const char* value, size_t size);
  inline ::std::string* mutable_desttype();
  inline ::std::string* release_desttype();
  inline void set_allocated_desttype(::std::string* desttype);

  // optional int32 destAddr = 6;
  inline bool has_destaddr() const;
  inline void clear_destaddr();
  static const int kDestAddrFieldNumber = 6;
  inline ::google::protobuf::int32 destaddr() const;
  inline void set_destaddr(::google::protobuf::int32 value);

  // optional int32 timeSlot = 7;
  inline bool has_timeslot() const;
  inline void clear_timeslot();
  static const int kTimeSlotFieldNumber = 7;
  inline ::google::protobuf::int32 timeslot() const;
  inline void set_timeslot(::google::protobuf::int32 value);

  // optional string callType = 8;
  inline bool has_calltype() const;
  inline void clear_calltype();
  static const int kCallTypeFieldNumber = 8;
  inline const ::std::string& calltype() const;
  inline void set_calltype(const ::std::string& value);
  inline void set_calltype(const char* value);
  inline void set_calltype(const char* value, size_t size);
  inline ::std::string* mutable_calltype();
  inline ::std::string* release_calltype();
  inline void set_allocated_calltype(::std::string* calltype);

  // optional int32 colorCode = 9;
  inline bool has_colorcode() const;
  inline void clear_colorcode();
  static const int kColorCodeFieldNumber = 9;
  inline ::google::protobuf::int32 colorcode() const;
  inline void set_colorcode(::google::protobuf::int32 value);

  // optional string text = 10;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 10;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional .falcon_common_msg.GeodeticPosition geo = 11;
  inline bool has_geo() const;
  inline void clear_geo();
  static const int kGeoFieldNumber = 11;
  inline const ::falcon_common_msg::GeodeticPosition& geo() const;
  inline ::falcon_common_msg::GeodeticPosition* mutable_geo();
  inline ::falcon_common_msg::GeodeticPosition* release_geo();
  inline void set_allocated_geo(::falcon_common_msg::GeodeticPosition* geo);

  // @@protoc_insertion_point(class_scope:es_product_msg.DmrMeta)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_centerfreqmhz();
  inline void clear_has_centerfreqmhz();
  inline void set_has_srctype();
  inline void clear_has_srctype();
  inline void set_has_srcaddr();
  inline void clear_has_srcaddr();
  inline void set_has_desttype();
  inline void clear_has_desttype();
  inline void set_has_destaddr();
  inline void clear_has_destaddr();
  inline void set_has_timeslot();
  inline void clear_has_timeslot();
  inline void set_has_calltype();
  inline void clear_has_calltype();
  inline void set_has_colorcode();
  inline void clear_has_colorcode();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_geo();
  inline void clear_has_geo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  double centerfreqmhz_;
  ::std::string* srctype_;
  ::std::string* desttype_;
  ::google::protobuf::int32 srcaddr_;
  ::google::protobuf::int32 destaddr_;
  ::std::string* calltype_;
  ::google::protobuf::int32 timeslot_;
  ::google::protobuf::int32 colorcode_;
  ::std::string* text_;
  ::falcon_common_msg::GeodeticPosition* geo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_ESProductMessages_2eproto();
  friend void protobuf_AssignDesc_ESProductMessages_2eproto();
  friend void protobuf_ShutdownFile_ESProductMessages_2eproto();

  void InitAsDefaultInstance();
  static DmrMeta* default_instance_;
};
// ===================================================================


// ===================================================================

// ESProductHeader

// optional string msgName = 1 [default = "ES_PRODUCT_HEADER"];
inline bool ESProductHeader::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ESProductHeader::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ESProductHeader::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ESProductHeader::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ESProductHeader::msgname() const {
  return *msgname_;
}
inline void ESProductHeader::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ESProductHeader::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ESProductHeader::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ESProductHeader::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ESProductHeader::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ESProductHeader::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string esProductID = 2;
inline bool ESProductHeader::has_esproductid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ESProductHeader::set_has_esproductid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ESProductHeader::clear_has_esproductid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ESProductHeader::clear_esproductid() {
  if (esproductid_ != &::google::protobuf::internal::kEmptyString) {
    esproductid_->clear();
  }
  clear_has_esproductid();
}
inline const ::std::string& ESProductHeader::esproductid() const {
  return *esproductid_;
}
inline void ESProductHeader::set_esproductid(const ::std::string& value) {
  set_has_esproductid();
  if (esproductid_ == &::google::protobuf::internal::kEmptyString) {
    esproductid_ = new ::std::string;
  }
  esproductid_->assign(value);
}
inline void ESProductHeader::set_esproductid(const char* value) {
  set_has_esproductid();
  if (esproductid_ == &::google::protobuf::internal::kEmptyString) {
    esproductid_ = new ::std::string;
  }
  esproductid_->assign(value);
}
inline void ESProductHeader::set_esproductid(const char* value, size_t size) {
  set_has_esproductid();
  if (esproductid_ == &::google::protobuf::internal::kEmptyString) {
    esproductid_ = new ::std::string;
  }
  esproductid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ESProductHeader::mutable_esproductid() {
  set_has_esproductid();
  if (esproductid_ == &::google::protobuf::internal::kEmptyString) {
    esproductid_ = new ::std::string;
  }
  return esproductid_;
}
inline ::std::string* ESProductHeader::release_esproductid() {
  clear_has_esproductid();
  if (esproductid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = esproductid_;
    esproductid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ESProductHeader::set_allocated_esproductid(::std::string* esproductid) {
  if (esproductid_ != &::google::protobuf::internal::kEmptyString) {
    delete esproductid_;
  }
  if (esproductid) {
    set_has_esproductid();
    esproductid_ = esproductid;
  } else {
    clear_has_esproductid();
    esproductid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string globalID = 3;
inline bool ESProductHeader::has_globalid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ESProductHeader::set_has_globalid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ESProductHeader::clear_has_globalid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ESProductHeader::clear_globalid() {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    globalid_->clear();
  }
  clear_has_globalid();
}
inline const ::std::string& ESProductHeader::globalid() const {
  return *globalid_;
}
inline void ESProductHeader::set_globalid(const ::std::string& value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void ESProductHeader::set_globalid(const char* value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void ESProductHeader::set_globalid(const char* value, size_t size) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ESProductHeader::mutable_globalid() {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  return globalid_;
}
inline ::std::string* ESProductHeader::release_globalid() {
  clear_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalid_;
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ESProductHeader::set_allocated_globalid(::std::string* globalid) {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    delete globalid_;
  }
  if (globalid) {
    set_has_globalid();
    globalid_ = globalid;
  } else {
    clear_has_globalid();
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string soiNum = 4;
inline bool ESProductHeader::has_soinum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ESProductHeader::set_has_soinum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ESProductHeader::clear_has_soinum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ESProductHeader::clear_soinum() {
  if (soinum_ != &::google::protobuf::internal::kEmptyString) {
    soinum_->clear();
  }
  clear_has_soinum();
}
inline const ::std::string& ESProductHeader::soinum() const {
  return *soinum_;
}
inline void ESProductHeader::set_soinum(const ::std::string& value) {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  soinum_->assign(value);
}
inline void ESProductHeader::set_soinum(const char* value) {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  soinum_->assign(value);
}
inline void ESProductHeader::set_soinum(const char* value, size_t size) {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  soinum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ESProductHeader::mutable_soinum() {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  return soinum_;
}
inline ::std::string* ESProductHeader::release_soinum() {
  clear_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = soinum_;
    soinum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ESProductHeader::set_allocated_soinum(::std::string* soinum) {
  if (soinum_ != &::google::protobuf::internal::kEmptyString) {
    delete soinum_;
  }
  if (soinum) {
    set_has_soinum();
    soinum_ = soinum;
  } else {
    clear_has_soinum();
    soinum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string signalName = 5;
inline bool ESProductHeader::has_signalname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ESProductHeader::set_has_signalname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ESProductHeader::clear_has_signalname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ESProductHeader::clear_signalname() {
  if (signalname_ != &::google::protobuf::internal::kEmptyString) {
    signalname_->clear();
  }
  clear_has_signalname();
}
inline const ::std::string& ESProductHeader::signalname() const {
  return *signalname_;
}
inline void ESProductHeader::set_signalname(const ::std::string& value) {
  set_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    signalname_ = new ::std::string;
  }
  signalname_->assign(value);
}
inline void ESProductHeader::set_signalname(const char* value) {
  set_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    signalname_ = new ::std::string;
  }
  signalname_->assign(value);
}
inline void ESProductHeader::set_signalname(const char* value, size_t size) {
  set_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    signalname_ = new ::std::string;
  }
  signalname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ESProductHeader::mutable_signalname() {
  set_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    signalname_ = new ::std::string;
  }
  return signalname_;
}
inline ::std::string* ESProductHeader::release_signalname() {
  clear_has_signalname();
  if (signalname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signalname_;
    signalname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ESProductHeader::set_allocated_signalname(::std::string* signalname) {
  if (signalname_ != &::google::protobuf::internal::kEmptyString) {
    delete signalname_;
  }
  if (signalname) {
    set_has_signalname();
    signalname_ = signalname;
  } else {
    clear_has_signalname();
    signalname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sensorName = 6;
inline bool ESProductHeader::has_sensorname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ESProductHeader::set_has_sensorname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ESProductHeader::clear_has_sensorname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ESProductHeader::clear_sensorname() {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    sensorname_->clear();
  }
  clear_has_sensorname();
}
inline const ::std::string& ESProductHeader::sensorname() const {
  return *sensorname_;
}
inline void ESProductHeader::set_sensorname(const ::std::string& value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void ESProductHeader::set_sensorname(const char* value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void ESProductHeader::set_sensorname(const char* value, size_t size) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ESProductHeader::mutable_sensorname() {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  return sensorname_;
}
inline ::std::string* ESProductHeader::release_sensorname() {
  clear_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sensorname_;
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ESProductHeader::set_allocated_sensorname(::std::string* sensorname) {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    delete sensorname_;
  }
  if (sensorname) {
    set_has_sensorname();
    sensorname_ = sensorname;
  } else {
    clear_has_sensorname();
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .falcon_common_msg.Timestamp timestamp = 7;
inline bool ESProductHeader::has_timestamp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ESProductHeader::set_has_timestamp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ESProductHeader::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ESProductHeader::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::falcon_common_msg::Timestamp::Clear();
  clear_has_timestamp();
}
inline const ::falcon_common_msg::Timestamp& ESProductHeader::timestamp() const {
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
inline ::falcon_common_msg::Timestamp* ESProductHeader::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) timestamp_ = new ::falcon_common_msg::Timestamp;
  return timestamp_;
}
inline ::falcon_common_msg::Timestamp* ESProductHeader::release_timestamp() {
  clear_has_timestamp();
  ::falcon_common_msg::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void ESProductHeader::set_allocated_timestamp(::falcon_common_msg::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
}

// -------------------------------------------------------------------

// ESObservablesRegister

// optional string msgName = 1 [default = "ES_OBSERVABLES_REGISTER"];
inline bool ESObservablesRegister::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ESObservablesRegister::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ESObservablesRegister::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ESObservablesRegister::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ESObservablesRegister::msgname() const {
  return *msgname_;
}
inline void ESObservablesRegister::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ESObservablesRegister::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ESObservablesRegister::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ESObservablesRegister::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ESObservablesRegister::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ESObservablesRegister::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional .es_product_msg.ESProductHeader header = 2;
inline bool ESObservablesRegister::has_header() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ESObservablesRegister::set_has_header() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ESObservablesRegister::clear_has_header() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ESObservablesRegister::clear_header() {
  if (header_ != NULL) header_->::es_product_msg::ESProductHeader::Clear();
  clear_has_header();
}
inline const ::es_product_msg::ESProductHeader& ESObservablesRegister::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::es_product_msg::ESProductHeader* ESObservablesRegister::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::es_product_msg::ESProductHeader;
  return header_;
}
inline ::es_product_msg::ESProductHeader* ESObservablesRegister::release_header() {
  clear_has_header();
  ::es_product_msg::ESProductHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ESObservablesRegister::set_allocated_header(::es_product_msg::ESProductHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .es_product_msg.ESObservationsBool esObservationsBool = 3;
inline bool ESObservablesRegister::has_esobservationsbool() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ESObservablesRegister::set_has_esobservationsbool() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ESObservablesRegister::clear_has_esobservationsbool() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ESObservablesRegister::clear_esobservationsbool() {
  if (esobservationsbool_ != NULL) esobservationsbool_->::es_product_msg::ESObservationsBool::Clear();
  clear_has_esobservationsbool();
}
inline const ::es_product_msg::ESObservationsBool& ESObservablesRegister::esobservationsbool() const {
  return esobservationsbool_ != NULL ? *esobservationsbool_ : *default_instance_->esobservationsbool_;
}
inline ::es_product_msg::ESObservationsBool* ESObservablesRegister::mutable_esobservationsbool() {
  set_has_esobservationsbool();
  if (esobservationsbool_ == NULL) esobservationsbool_ = new ::es_product_msg::ESObservationsBool;
  return esobservationsbool_;
}
inline ::es_product_msg::ESObservationsBool* ESObservablesRegister::release_esobservationsbool() {
  clear_has_esobservationsbool();
  ::es_product_msg::ESObservationsBool* temp = esobservationsbool_;
  esobservationsbool_ = NULL;
  return temp;
}
inline void ESObservablesRegister::set_allocated_esobservationsbool(::es_product_msg::ESObservationsBool* esobservationsbool) {
  delete esobservationsbool_;
  esobservationsbool_ = esobservationsbool;
  if (esobservationsbool) {
    set_has_esobservationsbool();
  } else {
    clear_has_esobservationsbool();
  }
}

// -------------------------------------------------------------------

// ESObservablesUnregister

// optional string msgName = 1 [default = "ES_OBSERVABLES_UNREGISTER"];
inline bool ESObservablesUnregister::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ESObservablesUnregister::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ESObservablesUnregister::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ESObservablesUnregister::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ESObservablesUnregister::msgname() const {
  return *msgname_;
}
inline void ESObservablesUnregister::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ESObservablesUnregister::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ESObservablesUnregister::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ESObservablesUnregister::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ESObservablesUnregister::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ESObservablesUnregister::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string esProductID = 2;
inline bool ESObservablesUnregister::has_esproductid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ESObservablesUnregister::set_has_esproductid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ESObservablesUnregister::clear_has_esproductid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ESObservablesUnregister::clear_esproductid() {
  if (esproductid_ != &::google::protobuf::internal::kEmptyString) {
    esproductid_->clear();
  }
  clear_has_esproductid();
}
inline const ::std::string& ESObservablesUnregister::esproductid() const {
  return *esproductid_;
}
inline void ESObservablesUnregister::set_esproductid(const ::std::string& value) {
  set_has_esproductid();
  if (esproductid_ == &::google::protobuf::internal::kEmptyString) {
    esproductid_ = new ::std::string;
  }
  esproductid_->assign(value);
}
inline void ESObservablesUnregister::set_esproductid(const char* value) {
  set_has_esproductid();
  if (esproductid_ == &::google::protobuf::internal::kEmptyString) {
    esproductid_ = new ::std::string;
  }
  esproductid_->assign(value);
}
inline void ESObservablesUnregister::set_esproductid(const char* value, size_t size) {
  set_has_esproductid();
  if (esproductid_ == &::google::protobuf::internal::kEmptyString) {
    esproductid_ = new ::std::string;
  }
  esproductid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ESObservablesUnregister::mutable_esproductid() {
  set_has_esproductid();
  if (esproductid_ == &::google::protobuf::internal::kEmptyString) {
    esproductid_ = new ::std::string;
  }
  return esproductid_;
}
inline ::std::string* ESObservablesUnregister::release_esproductid() {
  clear_has_esproductid();
  if (esproductid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = esproductid_;
    esproductid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ESObservablesUnregister::set_allocated_esproductid(::std::string* esproductid) {
  if (esproductid_ != &::google::protobuf::internal::kEmptyString) {
    delete esproductid_;
  }
  if (esproductid) {
    set_has_esproductid();
    esproductid_ = esproductid;
  } else {
    clear_has_esproductid();
    esproductid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ESObservables

// optional string msgName = 1 [default = "ES_OBSERVABLES"];
inline bool ESObservables::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ESObservables::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ESObservables::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ESObservables::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ESObservables::msgname() const {
  return *msgname_;
}
inline void ESObservables::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ESObservables::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ESObservables::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ESObservables::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ESObservables::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ESObservables::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional .es_product_msg.ESProductHeader header = 2;
inline bool ESObservables::has_header() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ESObservables::set_has_header() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ESObservables::clear_has_header() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ESObservables::clear_header() {
  if (header_ != NULL) header_->::es_product_msg::ESProductHeader::Clear();
  clear_has_header();
}
inline const ::es_product_msg::ESProductHeader& ESObservables::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::es_product_msg::ESProductHeader* ESObservables::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::es_product_msg::ESProductHeader;
  return header_;
}
inline ::es_product_msg::ESProductHeader* ESObservables::release_header() {
  clear_has_header();
  ::es_product_msg::ESProductHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ESObservables::set_allocated_header(::es_product_msg::ESProductHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .es_product_msg.ESObservationsTyped esObservationsTyped = 3;
inline bool ESObservables::has_esobservationstyped() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ESObservables::set_has_esobservationstyped() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ESObservables::clear_has_esobservationstyped() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ESObservables::clear_esobservationstyped() {
  if (esobservationstyped_ != NULL) esobservationstyped_->::es_product_msg::ESObservationsTyped::Clear();
  clear_has_esobservationstyped();
}
inline const ::es_product_msg::ESObservationsTyped& ESObservables::esobservationstyped() const {
  return esobservationstyped_ != NULL ? *esobservationstyped_ : *default_instance_->esobservationstyped_;
}
inline ::es_product_msg::ESObservationsTyped* ESObservables::mutable_esobservationstyped() {
  set_has_esobservationstyped();
  if (esobservationstyped_ == NULL) esobservationstyped_ = new ::es_product_msg::ESObservationsTyped;
  return esobservationstyped_;
}
inline ::es_product_msg::ESObservationsTyped* ESObservables::release_esobservationstyped() {
  clear_has_esobservationstyped();
  ::es_product_msg::ESObservationsTyped* temp = esobservationstyped_;
  esobservationstyped_ = NULL;
  return temp;
}
inline void ESObservables::set_allocated_esobservationstyped(::es_product_msg::ESObservationsTyped* esobservationstyped) {
  delete esobservationstyped_;
  esobservationstyped_ = esobservationstyped;
  if (esobservationstyped) {
    set_has_esobservationstyped();
  } else {
    clear_has_esobservationstyped();
  }
}

// -------------------------------------------------------------------

// ESObservationsBool

// optional string msgName = 1 [default = "ES_OBSERVATIONS_BOOL"];
inline bool ESObservationsBool::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ESObservationsBool::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ESObservationsBool::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ESObservationsBool::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ESObservationsBool::msgname() const {
  return *msgname_;
}
inline void ESObservationsBool::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ESObservationsBool::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ESObservationsBool::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ESObservationsBool::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ESObservationsBool::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ESObservationsBool::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional bool iqCollectionParameters = 2;
inline bool ESObservationsBool::has_iqcollectionparameters() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ESObservationsBool::set_has_iqcollectionparameters() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ESObservationsBool::clear_has_iqcollectionparameters() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ESObservationsBool::clear_iqcollectionparameters() {
  iqcollectionparameters_ = false;
  clear_has_iqcollectionparameters();
}
inline bool ESObservationsBool::iqcollectionparameters() const {
  return iqcollectionparameters_;
}
inline void ESObservationsBool::set_iqcollectionparameters(bool value) {
  set_has_iqcollectionparameters();
  iqcollectionparameters_ = value;
}

// optional bool collectionFrontendParameters = 3;
inline bool ESObservationsBool::has_collectionfrontendparameters() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ESObservationsBool::set_has_collectionfrontendparameters() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ESObservationsBool::clear_has_collectionfrontendparameters() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ESObservationsBool::clear_collectionfrontendparameters() {
  collectionfrontendparameters_ = false;
  clear_has_collectionfrontendparameters();
}
inline bool ESObservationsBool::collectionfrontendparameters() const {
  return collectionfrontendparameters_;
}
inline void ESObservationsBool::set_collectionfrontendparameters(bool value) {
  set_has_collectionfrontendparameters();
  collectionfrontendparameters_ = value;
}

// optional bool signalEvent = 4;
inline bool ESObservationsBool::has_signalevent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ESObservationsBool::set_has_signalevent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ESObservationsBool::clear_has_signalevent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ESObservationsBool::clear_signalevent() {
  signalevent_ = false;
  clear_has_signalevent();
}
inline bool ESObservationsBool::signalevent() const {
  return signalevent_;
}
inline void ESObservationsBool::set_signalevent(bool value) {
  set_has_signalevent();
  signalevent_ = value;
}

// optional bool gpsPosition = 5;
inline bool ESObservationsBool::has_gpsposition() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ESObservationsBool::set_has_gpsposition() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ESObservationsBool::clear_has_gpsposition() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ESObservationsBool::clear_gpsposition() {
  gpsposition_ = false;
  clear_has_gpsposition();
}
inline bool ESObservationsBool::gpsposition() const {
  return gpsposition_;
}
inline void ESObservationsBool::set_gpsposition(bool value) {
  set_has_gpsposition();
  gpsposition_ = value;
}

// optional bool esExternalHit = 6;
inline bool ESObservationsBool::has_esexternalhit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ESObservationsBool::set_has_esexternalhit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ESObservationsBool::clear_has_esexternalhit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ESObservationsBool::clear_esexternalhit() {
  esexternalhit_ = false;
  clear_has_esexternalhit();
}
inline bool ESObservationsBool::esexternalhit() const {
  return esexternalhit_;
}
inline void ESObservationsBool::set_esexternalhit(bool value) {
  set_has_esexternalhit();
  esexternalhit_ = value;
}

// optional bool esInternalHit = 7;
inline bool ESObservationsBool::has_esinternalhit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ESObservationsBool::set_has_esinternalhit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ESObservationsBool::clear_has_esinternalhit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ESObservationsBool::clear_esinternalhit() {
  esinternalhit_ = false;
  clear_has_esinternalhit();
}
inline bool ESObservationsBool::esinternalhit() const {
  return esinternalhit_;
}
inline void ESObservationsBool::set_esinternalhit(bool value) {
  set_has_esinternalhit();
  esinternalhit_ = value;
}

// optional bool fisD = 8;
inline bool ESObservationsBool::has_fisd() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ESObservationsBool::set_has_fisd() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ESObservationsBool::clear_has_fisd() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ESObservationsBool::clear_fisd() {
  fisd_ = false;
  clear_has_fisd();
}
inline bool ESObservationsBool::fisd() const {
  return fisd_;
}
inline void ESObservationsBool::set_fisd(bool value) {
  set_has_fisd();
  fisd_ = value;
}

// optional bool sigFrame = 9;
inline bool ESObservationsBool::has_sigframe() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ESObservationsBool::set_has_sigframe() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ESObservationsBool::clear_has_sigframe() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ESObservationsBool::clear_sigframe() {
  sigframe_ = false;
  clear_has_sigframe();
}
inline bool ESObservationsBool::sigframe() const {
  return sigframe_;
}
inline void ESObservationsBool::set_sigframe(bool value) {
  set_has_sigframe();
  sigframe_ = value;
}

// optional bool imageAvailable = 10;
inline bool ESObservationsBool::has_imageavailable() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ESObservationsBool::set_has_imageavailable() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ESObservationsBool::clear_has_imageavailable() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ESObservationsBool::clear_imageavailable() {
  imageavailable_ = false;
  clear_has_imageavailable();
}
inline bool ESObservationsBool::imageavailable() const {
  return imageavailable_;
}
inline void ESObservationsBool::set_imageavailable(bool value) {
  set_has_imageavailable();
  imageavailable_ = value;
}

// optional bool audioAvailable = 11;
inline bool ESObservationsBool::has_audioavailable() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ESObservationsBool::set_has_audioavailable() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ESObservationsBool::clear_has_audioavailable() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ESObservationsBool::clear_audioavailable() {
  audioavailable_ = false;
  clear_has_audioavailable();
}
inline bool ESObservationsBool::audioavailable() const {
  return audioavailable_;
}
inline void ESObservationsBool::set_audioavailable(bool value) {
  set_has_audioavailable();
  audioavailable_ = value;
}

// optional bool dmrMeta = 12;
inline bool ESObservationsBool::has_dmrmeta() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ESObservationsBool::set_has_dmrmeta() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ESObservationsBool::clear_has_dmrmeta() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ESObservationsBool::clear_dmrmeta() {
  dmrmeta_ = false;
  clear_has_dmrmeta();
}
inline bool ESObservationsBool::dmrmeta() const {
  return dmrmeta_;
}
inline void ESObservationsBool::set_dmrmeta(bool value) {
  set_has_dmrmeta();
  dmrmeta_ = value;
}

// repeated string kvpl = 500;
inline int ESObservationsBool::kvpl_size() const {
  return kvpl_.size();
}
inline void ESObservationsBool::clear_kvpl() {
  kvpl_.Clear();
}
inline const ::std::string& ESObservationsBool::kvpl(int index) const {
  return kvpl_.Get(index);
}
inline ::std::string* ESObservationsBool::mutable_kvpl(int index) {
  return kvpl_.Mutable(index);
}
inline void ESObservationsBool::set_kvpl(int index, const ::std::string& value) {
  kvpl_.Mutable(index)->assign(value);
}
inline void ESObservationsBool::set_kvpl(int index, const char* value) {
  kvpl_.Mutable(index)->assign(value);
}
inline void ESObservationsBool::set_kvpl(int index, const char* value, size_t size) {
  kvpl_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ESObservationsBool::add_kvpl() {
  return kvpl_.Add();
}
inline void ESObservationsBool::add_kvpl(const ::std::string& value) {
  kvpl_.Add()->assign(value);
}
inline void ESObservationsBool::add_kvpl(const char* value) {
  kvpl_.Add()->assign(value);
}
inline void ESObservationsBool::add_kvpl(const char* value, size_t size) {
  kvpl_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ESObservationsBool::kvpl() const {
  return kvpl_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ESObservationsBool::mutable_kvpl() {
  return &kvpl_;
}

// -------------------------------------------------------------------

// ESObservationsTyped

// optional string msgName = 1 [default = "ES_OBSERVATIONS_BOOL"];
inline bool ESObservationsTyped::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ESObservationsTyped::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ESObservationsTyped::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ESObservationsTyped::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ESObservationsTyped::msgname() const {
  return *msgname_;
}
inline void ESObservationsTyped::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ESObservationsTyped::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ESObservationsTyped::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ESObservationsTyped::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ESObservationsTyped::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ESObservationsTyped::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional .es_product_msg.IQCollectionParameters iqCollectionParameters = 2;
inline bool ESObservationsTyped::has_iqcollectionparameters() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ESObservationsTyped::set_has_iqcollectionparameters() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ESObservationsTyped::clear_has_iqcollectionparameters() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ESObservationsTyped::clear_iqcollectionparameters() {
  if (iqcollectionparameters_ != NULL) iqcollectionparameters_->::es_product_msg::IQCollectionParameters::Clear();
  clear_has_iqcollectionparameters();
}
inline const ::es_product_msg::IQCollectionParameters& ESObservationsTyped::iqcollectionparameters() const {
  return iqcollectionparameters_ != NULL ? *iqcollectionparameters_ : *default_instance_->iqcollectionparameters_;
}
inline ::es_product_msg::IQCollectionParameters* ESObservationsTyped::mutable_iqcollectionparameters() {
  set_has_iqcollectionparameters();
  if (iqcollectionparameters_ == NULL) iqcollectionparameters_ = new ::es_product_msg::IQCollectionParameters;
  return iqcollectionparameters_;
}
inline ::es_product_msg::IQCollectionParameters* ESObservationsTyped::release_iqcollectionparameters() {
  clear_has_iqcollectionparameters();
  ::es_product_msg::IQCollectionParameters* temp = iqcollectionparameters_;
  iqcollectionparameters_ = NULL;
  return temp;
}
inline void ESObservationsTyped::set_allocated_iqcollectionparameters(::es_product_msg::IQCollectionParameters* iqcollectionparameters) {
  delete iqcollectionparameters_;
  iqcollectionparameters_ = iqcollectionparameters;
  if (iqcollectionparameters) {
    set_has_iqcollectionparameters();
  } else {
    clear_has_iqcollectionparameters();
  }
}

// optional .es_product_msg.CollectionFrontendParameters collectionFrontendParameters = 3;
inline bool ESObservationsTyped::has_collectionfrontendparameters() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ESObservationsTyped::set_has_collectionfrontendparameters() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ESObservationsTyped::clear_has_collectionfrontendparameters() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ESObservationsTyped::clear_collectionfrontendparameters() {
  if (collectionfrontendparameters_ != NULL) collectionfrontendparameters_->::es_product_msg::CollectionFrontendParameters::Clear();
  clear_has_collectionfrontendparameters();
}
inline const ::es_product_msg::CollectionFrontendParameters& ESObservationsTyped::collectionfrontendparameters() const {
  return collectionfrontendparameters_ != NULL ? *collectionfrontendparameters_ : *default_instance_->collectionfrontendparameters_;
}
inline ::es_product_msg::CollectionFrontendParameters* ESObservationsTyped::mutable_collectionfrontendparameters() {
  set_has_collectionfrontendparameters();
  if (collectionfrontendparameters_ == NULL) collectionfrontendparameters_ = new ::es_product_msg::CollectionFrontendParameters;
  return collectionfrontendparameters_;
}
inline ::es_product_msg::CollectionFrontendParameters* ESObservationsTyped::release_collectionfrontendparameters() {
  clear_has_collectionfrontendparameters();
  ::es_product_msg::CollectionFrontendParameters* temp = collectionfrontendparameters_;
  collectionfrontendparameters_ = NULL;
  return temp;
}
inline void ESObservationsTyped::set_allocated_collectionfrontendparameters(::es_product_msg::CollectionFrontendParameters* collectionfrontendparameters) {
  delete collectionfrontendparameters_;
  collectionfrontendparameters_ = collectionfrontendparameters;
  if (collectionfrontendparameters) {
    set_has_collectionfrontendparameters();
  } else {
    clear_has_collectionfrontendparameters();
  }
}

// optional .es_product_msg.SignalEvent signalEvent = 4;
inline bool ESObservationsTyped::has_signalevent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ESObservationsTyped::set_has_signalevent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ESObservationsTyped::clear_has_signalevent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ESObservationsTyped::clear_signalevent() {
  if (signalevent_ != NULL) signalevent_->::es_product_msg::SignalEvent::Clear();
  clear_has_signalevent();
}
inline const ::es_product_msg::SignalEvent& ESObservationsTyped::signalevent() const {
  return signalevent_ != NULL ? *signalevent_ : *default_instance_->signalevent_;
}
inline ::es_product_msg::SignalEvent* ESObservationsTyped::mutable_signalevent() {
  set_has_signalevent();
  if (signalevent_ == NULL) signalevent_ = new ::es_product_msg::SignalEvent;
  return signalevent_;
}
inline ::es_product_msg::SignalEvent* ESObservationsTyped::release_signalevent() {
  clear_has_signalevent();
  ::es_product_msg::SignalEvent* temp = signalevent_;
  signalevent_ = NULL;
  return temp;
}
inline void ESObservationsTyped::set_allocated_signalevent(::es_product_msg::SignalEvent* signalevent) {
  delete signalevent_;
  signalevent_ = signalevent;
  if (signalevent) {
    set_has_signalevent();
  } else {
    clear_has_signalevent();
  }
}

// optional .es_product_msg.GPSPosition gpsPosition = 5;
inline bool ESObservationsTyped::has_gpsposition() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ESObservationsTyped::set_has_gpsposition() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ESObservationsTyped::clear_has_gpsposition() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ESObservationsTyped::clear_gpsposition() {
  if (gpsposition_ != NULL) gpsposition_->::es_product_msg::GPSPosition::Clear();
  clear_has_gpsposition();
}
inline const ::es_product_msg::GPSPosition& ESObservationsTyped::gpsposition() const {
  return gpsposition_ != NULL ? *gpsposition_ : *default_instance_->gpsposition_;
}
inline ::es_product_msg::GPSPosition* ESObservationsTyped::mutable_gpsposition() {
  set_has_gpsposition();
  if (gpsposition_ == NULL) gpsposition_ = new ::es_product_msg::GPSPosition;
  return gpsposition_;
}
inline ::es_product_msg::GPSPosition* ESObservationsTyped::release_gpsposition() {
  clear_has_gpsposition();
  ::es_product_msg::GPSPosition* temp = gpsposition_;
  gpsposition_ = NULL;
  return temp;
}
inline void ESObservationsTyped::set_allocated_gpsposition(::es_product_msg::GPSPosition* gpsposition) {
  delete gpsposition_;
  gpsposition_ = gpsposition;
  if (gpsposition) {
    set_has_gpsposition();
  } else {
    clear_has_gpsposition();
  }
}

// optional .es_product_msg.ExternalHit externalHit = 6;
inline bool ESObservationsTyped::has_externalhit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ESObservationsTyped::set_has_externalhit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ESObservationsTyped::clear_has_externalhit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ESObservationsTyped::clear_externalhit() {
  if (externalhit_ != NULL) externalhit_->::es_product_msg::ExternalHit::Clear();
  clear_has_externalhit();
}
inline const ::es_product_msg::ExternalHit& ESObservationsTyped::externalhit() const {
  return externalhit_ != NULL ? *externalhit_ : *default_instance_->externalhit_;
}
inline ::es_product_msg::ExternalHit* ESObservationsTyped::mutable_externalhit() {
  set_has_externalhit();
  if (externalhit_ == NULL) externalhit_ = new ::es_product_msg::ExternalHit;
  return externalhit_;
}
inline ::es_product_msg::ExternalHit* ESObservationsTyped::release_externalhit() {
  clear_has_externalhit();
  ::es_product_msg::ExternalHit* temp = externalhit_;
  externalhit_ = NULL;
  return temp;
}
inline void ESObservationsTyped::set_allocated_externalhit(::es_product_msg::ExternalHit* externalhit) {
  delete externalhit_;
  externalhit_ = externalhit;
  if (externalhit) {
    set_has_externalhit();
  } else {
    clear_has_externalhit();
  }
}

// optional .es_product_msg.InternalHit internalHit = 7;
inline bool ESObservationsTyped::has_internalhit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ESObservationsTyped::set_has_internalhit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ESObservationsTyped::clear_has_internalhit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ESObservationsTyped::clear_internalhit() {
  if (internalhit_ != NULL) internalhit_->::es_product_msg::InternalHit::Clear();
  clear_has_internalhit();
}
inline const ::es_product_msg::InternalHit& ESObservationsTyped::internalhit() const {
  return internalhit_ != NULL ? *internalhit_ : *default_instance_->internalhit_;
}
inline ::es_product_msg::InternalHit* ESObservationsTyped::mutable_internalhit() {
  set_has_internalhit();
  if (internalhit_ == NULL) internalhit_ = new ::es_product_msg::InternalHit;
  return internalhit_;
}
inline ::es_product_msg::InternalHit* ESObservationsTyped::release_internalhit() {
  clear_has_internalhit();
  ::es_product_msg::InternalHit* temp = internalhit_;
  internalhit_ = NULL;
  return temp;
}
inline void ESObservationsTyped::set_allocated_internalhit(::es_product_msg::InternalHit* internalhit) {
  delete internalhit_;
  internalhit_ = internalhit;
  if (internalhit) {
    set_has_internalhit();
  } else {
    clear_has_internalhit();
  }
}

// optional .es_product_msg.FisD fisD = 8;
inline bool ESObservationsTyped::has_fisd() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ESObservationsTyped::set_has_fisd() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ESObservationsTyped::clear_has_fisd() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ESObservationsTyped::clear_fisd() {
  if (fisd_ != NULL) fisd_->::es_product_msg::FisD::Clear();
  clear_has_fisd();
}
inline const ::es_product_msg::FisD& ESObservationsTyped::fisd() const {
  return fisd_ != NULL ? *fisd_ : *default_instance_->fisd_;
}
inline ::es_product_msg::FisD* ESObservationsTyped::mutable_fisd() {
  set_has_fisd();
  if (fisd_ == NULL) fisd_ = new ::es_product_msg::FisD;
  return fisd_;
}
inline ::es_product_msg::FisD* ESObservationsTyped::release_fisd() {
  clear_has_fisd();
  ::es_product_msg::FisD* temp = fisd_;
  fisd_ = NULL;
  return temp;
}
inline void ESObservationsTyped::set_allocated_fisd(::es_product_msg::FisD* fisd) {
  delete fisd_;
  fisd_ = fisd;
  if (fisd) {
    set_has_fisd();
  } else {
    clear_has_fisd();
  }
}

// optional .es_product_msg.SIGFrame sigFrame = 9;
inline bool ESObservationsTyped::has_sigframe() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ESObservationsTyped::set_has_sigframe() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ESObservationsTyped::clear_has_sigframe() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ESObservationsTyped::clear_sigframe() {
  if (sigframe_ != NULL) sigframe_->::es_product_msg::SIGFrame::Clear();
  clear_has_sigframe();
}
inline const ::es_product_msg::SIGFrame& ESObservationsTyped::sigframe() const {
  return sigframe_ != NULL ? *sigframe_ : *default_instance_->sigframe_;
}
inline ::es_product_msg::SIGFrame* ESObservationsTyped::mutable_sigframe() {
  set_has_sigframe();
  if (sigframe_ == NULL) sigframe_ = new ::es_product_msg::SIGFrame;
  return sigframe_;
}
inline ::es_product_msg::SIGFrame* ESObservationsTyped::release_sigframe() {
  clear_has_sigframe();
  ::es_product_msg::SIGFrame* temp = sigframe_;
  sigframe_ = NULL;
  return temp;
}
inline void ESObservationsTyped::set_allocated_sigframe(::es_product_msg::SIGFrame* sigframe) {
  delete sigframe_;
  sigframe_ = sigframe;
  if (sigframe) {
    set_has_sigframe();
  } else {
    clear_has_sigframe();
  }
}

// optional .es_product_msg.ImageAvailable imageAvailable = 10;
inline bool ESObservationsTyped::has_imageavailable() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ESObservationsTyped::set_has_imageavailable() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ESObservationsTyped::clear_has_imageavailable() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ESObservationsTyped::clear_imageavailable() {
  if (imageavailable_ != NULL) imageavailable_->::es_product_msg::ImageAvailable::Clear();
  clear_has_imageavailable();
}
inline const ::es_product_msg::ImageAvailable& ESObservationsTyped::imageavailable() const {
  return imageavailable_ != NULL ? *imageavailable_ : *default_instance_->imageavailable_;
}
inline ::es_product_msg::ImageAvailable* ESObservationsTyped::mutable_imageavailable() {
  set_has_imageavailable();
  if (imageavailable_ == NULL) imageavailable_ = new ::es_product_msg::ImageAvailable;
  return imageavailable_;
}
inline ::es_product_msg::ImageAvailable* ESObservationsTyped::release_imageavailable() {
  clear_has_imageavailable();
  ::es_product_msg::ImageAvailable* temp = imageavailable_;
  imageavailable_ = NULL;
  return temp;
}
inline void ESObservationsTyped::set_allocated_imageavailable(::es_product_msg::ImageAvailable* imageavailable) {
  delete imageavailable_;
  imageavailable_ = imageavailable;
  if (imageavailable) {
    set_has_imageavailable();
  } else {
    clear_has_imageavailable();
  }
}

// optional .es_product_msg.AudioAvailable audioAvailable = 11;
inline bool ESObservationsTyped::has_audioavailable() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ESObservationsTyped::set_has_audioavailable() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ESObservationsTyped::clear_has_audioavailable() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ESObservationsTyped::clear_audioavailable() {
  if (audioavailable_ != NULL) audioavailable_->::es_product_msg::AudioAvailable::Clear();
  clear_has_audioavailable();
}
inline const ::es_product_msg::AudioAvailable& ESObservationsTyped::audioavailable() const {
  return audioavailable_ != NULL ? *audioavailable_ : *default_instance_->audioavailable_;
}
inline ::es_product_msg::AudioAvailable* ESObservationsTyped::mutable_audioavailable() {
  set_has_audioavailable();
  if (audioavailable_ == NULL) audioavailable_ = new ::es_product_msg::AudioAvailable;
  return audioavailable_;
}
inline ::es_product_msg::AudioAvailable* ESObservationsTyped::release_audioavailable() {
  clear_has_audioavailable();
  ::es_product_msg::AudioAvailable* temp = audioavailable_;
  audioavailable_ = NULL;
  return temp;
}
inline void ESObservationsTyped::set_allocated_audioavailable(::es_product_msg::AudioAvailable* audioavailable) {
  delete audioavailable_;
  audioavailable_ = audioavailable;
  if (audioavailable) {
    set_has_audioavailable();
  } else {
    clear_has_audioavailable();
  }
}

// optional .es_product_msg.DmrMeta dmrMeta = 12;
inline bool ESObservationsTyped::has_dmrmeta() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ESObservationsTyped::set_has_dmrmeta() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ESObservationsTyped::clear_has_dmrmeta() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ESObservationsTyped::clear_dmrmeta() {
  if (dmrmeta_ != NULL) dmrmeta_->::es_product_msg::DmrMeta::Clear();
  clear_has_dmrmeta();
}
inline const ::es_product_msg::DmrMeta& ESObservationsTyped::dmrmeta() const {
  return dmrmeta_ != NULL ? *dmrmeta_ : *default_instance_->dmrmeta_;
}
inline ::es_product_msg::DmrMeta* ESObservationsTyped::mutable_dmrmeta() {
  set_has_dmrmeta();
  if (dmrmeta_ == NULL) dmrmeta_ = new ::es_product_msg::DmrMeta;
  return dmrmeta_;
}
inline ::es_product_msg::DmrMeta* ESObservationsTyped::release_dmrmeta() {
  clear_has_dmrmeta();
  ::es_product_msg::DmrMeta* temp = dmrmeta_;
  dmrmeta_ = NULL;
  return temp;
}
inline void ESObservationsTyped::set_allocated_dmrmeta(::es_product_msg::DmrMeta* dmrmeta) {
  delete dmrmeta_;
  dmrmeta_ = dmrmeta;
  if (dmrmeta) {
    set_has_dmrmeta();
  } else {
    clear_has_dmrmeta();
  }
}

// repeated .falcon_common_msg.KeyValuePair kvps = 500;
inline int ESObservationsTyped::kvps_size() const {
  return kvps_.size();
}
inline void ESObservationsTyped::clear_kvps() {
  kvps_.Clear();
}
inline const ::falcon_common_msg::KeyValuePair& ESObservationsTyped::kvps(int index) const {
  return kvps_.Get(index);
}
inline ::falcon_common_msg::KeyValuePair* ESObservationsTyped::mutable_kvps(int index) {
  return kvps_.Mutable(index);
}
inline ::falcon_common_msg::KeyValuePair* ESObservationsTyped::add_kvps() {
  return kvps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::KeyValuePair >&
ESObservationsTyped::kvps() const {
  return kvps_;
}
inline ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::KeyValuePair >*
ESObservationsTyped::mutable_kvps() {
  return &kvps_;
}

// -------------------------------------------------------------------

// IQCollectionParameters

// optional string msgName = 1 [default = "IQ_COLLECTION_PARAMETERS"];
inline bool IQCollectionParameters::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IQCollectionParameters::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IQCollectionParameters::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IQCollectionParameters::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& IQCollectionParameters::msgname() const {
  return *msgname_;
}
inline void IQCollectionParameters::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void IQCollectionParameters::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void IQCollectionParameters::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IQCollectionParameters::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* IQCollectionParameters::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void IQCollectionParameters::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional double centerFreqMHz = 2;
inline bool IQCollectionParameters::has_centerfreqmhz() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IQCollectionParameters::set_has_centerfreqmhz() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IQCollectionParameters::clear_has_centerfreqmhz() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IQCollectionParameters::clear_centerfreqmhz() {
  centerfreqmhz_ = 0;
  clear_has_centerfreqmhz();
}
inline double IQCollectionParameters::centerfreqmhz() const {
  return centerfreqmhz_;
}
inline void IQCollectionParameters::set_centerfreqmhz(double value) {
  set_has_centerfreqmhz();
  centerfreqmhz_ = value;
}

// optional double sampleRateMHz = 3;
inline bool IQCollectionParameters::has_sampleratemhz() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IQCollectionParameters::set_has_sampleratemhz() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IQCollectionParameters::clear_has_sampleratemhz() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IQCollectionParameters::clear_sampleratemhz() {
  sampleratemhz_ = 0;
  clear_has_sampleratemhz();
}
inline double IQCollectionParameters::sampleratemhz() const {
  return sampleratemhz_;
}
inline void IQCollectionParameters::set_sampleratemhz(double value) {
  set_has_sampleratemhz();
  sampleratemhz_ = value;
}

// optional int32 channel = 4;
inline bool IQCollectionParameters::has_channel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IQCollectionParameters::set_has_channel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IQCollectionParameters::clear_has_channel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IQCollectionParameters::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 IQCollectionParameters::channel() const {
  return channel_;
}
inline void IQCollectionParameters::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// optional .falcon_common_msg.Timestamp timestamp = 5;
inline bool IQCollectionParameters::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IQCollectionParameters::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IQCollectionParameters::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IQCollectionParameters::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::falcon_common_msg::Timestamp::Clear();
  clear_has_timestamp();
}
inline const ::falcon_common_msg::Timestamp& IQCollectionParameters::timestamp() const {
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
inline ::falcon_common_msg::Timestamp* IQCollectionParameters::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) timestamp_ = new ::falcon_common_msg::Timestamp;
  return timestamp_;
}
inline ::falcon_common_msg::Timestamp* IQCollectionParameters::release_timestamp() {
  clear_has_timestamp();
  ::falcon_common_msg::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void IQCollectionParameters::set_allocated_timestamp(::falcon_common_msg::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
}

// -------------------------------------------------------------------

// CollectionFrontendParameters

// optional string msgName = 1 [default = "COLLECTION_FRONTEND_PARAMETERS"];
inline bool CollectionFrontendParameters::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CollectionFrontendParameters::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CollectionFrontendParameters::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CollectionFrontendParameters::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& CollectionFrontendParameters::msgname() const {
  return *msgname_;
}
inline void CollectionFrontendParameters::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void CollectionFrontendParameters::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void CollectionFrontendParameters::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CollectionFrontendParameters::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* CollectionFrontendParameters::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void CollectionFrontendParameters::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 antNum = 2;
inline bool CollectionFrontendParameters::has_antnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CollectionFrontendParameters::set_has_antnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CollectionFrontendParameters::clear_has_antnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CollectionFrontendParameters::clear_antnum() {
  antnum_ = 0;
  clear_has_antnum();
}
inline ::google::protobuf::int32 CollectionFrontendParameters::antnum() const {
  return antnum_;
}
inline void CollectionFrontendParameters::set_antnum(::google::protobuf::int32 value) {
  set_has_antnum();
  antnum_ = value;
}

// optional float antAz = 3;
inline bool CollectionFrontendParameters::has_antaz() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CollectionFrontendParameters::set_has_antaz() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CollectionFrontendParameters::clear_has_antaz() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CollectionFrontendParameters::clear_antaz() {
  antaz_ = 0;
  clear_has_antaz();
}
inline float CollectionFrontendParameters::antaz() const {
  return antaz_;
}
inline void CollectionFrontendParameters::set_antaz(float value) {
  set_has_antaz();
  antaz_ = value;
}

// optional float antEl = 4;
inline bool CollectionFrontendParameters::has_antel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CollectionFrontendParameters::set_has_antel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CollectionFrontendParameters::clear_has_antel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CollectionFrontendParameters::clear_antel() {
  antel_ = 0;
  clear_has_antel();
}
inline float CollectionFrontendParameters::antel() const {
  return antel_;
}
inline void CollectionFrontendParameters::set_antel(float value) {
  set_has_antel();
  antel_ = value;
}

// optional float bwMHz = 5;
inline bool CollectionFrontendParameters::has_bwmhz() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CollectionFrontendParameters::set_has_bwmhz() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CollectionFrontendParameters::clear_has_bwmhz() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CollectionFrontendParameters::clear_bwmhz() {
  bwmhz_ = 0;
  clear_has_bwmhz();
}
inline float CollectionFrontendParameters::bwmhz() const {
  return bwmhz_;
}
inline void CollectionFrontendParameters::set_bwmhz(float value) {
  set_has_bwmhz();
  bwmhz_ = value;
}

// -------------------------------------------------------------------

// SignalEvent

// optional string msgName = 1 [default = "SIGNAL_EVENT"];
inline bool SignalEvent::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignalEvent::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignalEvent::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignalEvent::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SignalEvent::msgname() const {
  return *msgname_;
}
inline void SignalEvent::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SignalEvent::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SignalEvent::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalEvent::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SignalEvent::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SignalEvent::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional .es_product_msg.SignalEvent.Type eventType = 2;
inline bool SignalEvent::has_eventtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignalEvent::set_has_eventtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignalEvent::clear_has_eventtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignalEvent::clear_eventtype() {
  eventtype_ = 0;
  clear_has_eventtype();
}
inline ::es_product_msg::SignalEvent_Type SignalEvent::eventtype() const {
  return static_cast< ::es_product_msg::SignalEvent_Type >(eventtype_);
}
inline void SignalEvent::set_eventtype(::es_product_msg::SignalEvent_Type value) {
  assert(::es_product_msg::SignalEvent_Type_IsValid(value));
  set_has_eventtype();
  eventtype_ = value;
}

// optional string eventID = 3;
inline bool SignalEvent::has_eventid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignalEvent::set_has_eventid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignalEvent::clear_has_eventid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignalEvent::clear_eventid() {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    eventid_->clear();
  }
  clear_has_eventid();
}
inline const ::std::string& SignalEvent::eventid() const {
  return *eventid_;
}
inline void SignalEvent::set_eventid(const ::std::string& value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void SignalEvent::set_eventid(const char* value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void SignalEvent::set_eventid(const char* value, size_t size) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalEvent::mutable_eventid() {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  return eventid_;
}
inline ::std::string* SignalEvent::release_eventid() {
  clear_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventid_;
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignalEvent::set_allocated_eventid(::std::string* eventid) {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    delete eventid_;
  }
  if (eventid) {
    set_has_eventid();
    eventid_ = eventid;
  } else {
    clear_has_eventid();
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .falcon_common_msg.Timestamp timestamp = 4;
inline bool SignalEvent::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignalEvent::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignalEvent::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignalEvent::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::falcon_common_msg::Timestamp::Clear();
  clear_has_timestamp();
}
inline const ::falcon_common_msg::Timestamp& SignalEvent::timestamp() const {
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
inline ::falcon_common_msg::Timestamp* SignalEvent::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) timestamp_ = new ::falcon_common_msg::Timestamp;
  return timestamp_;
}
inline ::falcon_common_msg::Timestamp* SignalEvent::release_timestamp() {
  clear_has_timestamp();
  ::falcon_common_msg::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void SignalEvent::set_allocated_timestamp(::falcon_common_msg::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
}

// optional float rfMHz = 5;
inline bool SignalEvent::has_rfmhz() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SignalEvent::set_has_rfmhz() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SignalEvent::clear_has_rfmhz() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SignalEvent::clear_rfmhz() {
  rfmhz_ = 0;
  clear_has_rfmhz();
}
inline float SignalEvent::rfmhz() const {
  return rfmhz_;
}
inline void SignalEvent::set_rfmhz(float value) {
  set_has_rfmhz();
  rfmhz_ = value;
}

// optional float subcarMHz = 6;
inline bool SignalEvent::has_subcarmhz() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SignalEvent::set_has_subcarmhz() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SignalEvent::clear_has_subcarmhz() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SignalEvent::clear_subcarmhz() {
  subcarmhz_ = 0;
  clear_has_subcarmhz();
}
inline float SignalEvent::subcarmhz() const {
  return subcarmhz_;
}
inline void SignalEvent::set_subcarmhz(float value) {
  set_has_subcarmhz();
  subcarmhz_ = value;
}

// optional float excurKHz = 7;
inline bool SignalEvent::has_excurkhz() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SignalEvent::set_has_excurkhz() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SignalEvent::clear_has_excurkhz() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SignalEvent::clear_excurkhz() {
  excurkhz_ = 0;
  clear_has_excurkhz();
}
inline float SignalEvent::excurkhz() const {
  return excurkhz_;
}
inline void SignalEvent::set_excurkhz(float value) {
  set_has_excurkhz();
  excurkhz_ = value;
}

// optional int32 appID = 8;
inline bool SignalEvent::has_appid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SignalEvent::set_has_appid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SignalEvent::clear_has_appid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SignalEvent::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 SignalEvent::appid() const {
  return appid_;
}
inline void SignalEvent::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional string scrypt = 9;
inline bool SignalEvent::has_scrypt() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SignalEvent::set_has_scrypt() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SignalEvent::clear_has_scrypt() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SignalEvent::clear_scrypt() {
  if (scrypt_ != &::google::protobuf::internal::kEmptyString) {
    scrypt_->clear();
  }
  clear_has_scrypt();
}
inline const ::std::string& SignalEvent::scrypt() const {
  return *scrypt_;
}
inline void SignalEvent::set_scrypt(const ::std::string& value) {
  set_has_scrypt();
  if (scrypt_ == &::google::protobuf::internal::kEmptyString) {
    scrypt_ = new ::std::string;
  }
  scrypt_->assign(value);
}
inline void SignalEvent::set_scrypt(const char* value) {
  set_has_scrypt();
  if (scrypt_ == &::google::protobuf::internal::kEmptyString) {
    scrypt_ = new ::std::string;
  }
  scrypt_->assign(value);
}
inline void SignalEvent::set_scrypt(const char* value, size_t size) {
  set_has_scrypt();
  if (scrypt_ == &::google::protobuf::internal::kEmptyString) {
    scrypt_ = new ::std::string;
  }
  scrypt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalEvent::mutable_scrypt() {
  set_has_scrypt();
  if (scrypt_ == &::google::protobuf::internal::kEmptyString) {
    scrypt_ = new ::std::string;
  }
  return scrypt_;
}
inline ::std::string* SignalEvent::release_scrypt() {
  clear_has_scrypt();
  if (scrypt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = scrypt_;
    scrypt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignalEvent::set_allocated_scrypt(::std::string* scrypt) {
  if (scrypt_ != &::google::protobuf::internal::kEmptyString) {
    delete scrypt_;
  }
  if (scrypt) {
    set_has_scrypt();
    scrypt_ = scrypt;
  } else {
    clear_has_scrypt();
    scrypt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 exportPort = 10;
inline bool SignalEvent::has_exportport() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SignalEvent::set_has_exportport() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SignalEvent::clear_has_exportport() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SignalEvent::clear_exportport() {
  exportport_ = 0;
  clear_has_exportport();
}
inline ::google::protobuf::int32 SignalEvent::exportport() const {
  return exportport_;
}
inline void SignalEvent::set_exportport(::google::protobuf::int32 value) {
  set_has_exportport();
  exportport_ = value;
}

// -------------------------------------------------------------------

// GPSPosition

// optional string msgName = 1 [default = "GPS_POSITION"];
inline bool GPSPosition::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPSPosition::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPSPosition::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPSPosition::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& GPSPosition::msgname() const {
  return *msgname_;
}
inline void GPSPosition::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GPSPosition::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GPSPosition::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSPosition::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* GPSPosition::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void GPSPosition::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string eventID = 2;
inline bool GPSPosition::has_eventid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GPSPosition::set_has_eventid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GPSPosition::clear_has_eventid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GPSPosition::clear_eventid() {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    eventid_->clear();
  }
  clear_has_eventid();
}
inline const ::std::string& GPSPosition::eventid() const {
  return *eventid_;
}
inline void GPSPosition::set_eventid(const ::std::string& value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void GPSPosition::set_eventid(const char* value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void GPSPosition::set_eventid(const char* value, size_t size) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSPosition::mutable_eventid() {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  return eventid_;
}
inline ::std::string* GPSPosition::release_eventid() {
  clear_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventid_;
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSPosition::set_allocated_eventid(::std::string* eventid) {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    delete eventid_;
  }
  if (eventid) {
    set_has_eventid();
    eventid_ = eventid;
  } else {
    clear_has_eventid();
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float latitude = 3;
inline bool GPSPosition::has_latitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GPSPosition::set_has_latitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GPSPosition::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GPSPosition::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline float GPSPosition::latitude() const {
  return latitude_;
}
inline void GPSPosition::set_latitude(float value) {
  set_has_latitude();
  latitude_ = value;
}

// optional float longitude = 4;
inline bool GPSPosition::has_longitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GPSPosition::set_has_longitude() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GPSPosition::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GPSPosition::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline float GPSPosition::longitude() const {
  return longitude_;
}
inline void GPSPosition::set_longitude(float value) {
  set_has_longitude();
  longitude_ = value;
}

// optional float altitude = 5;
inline bool GPSPosition::has_altitude() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GPSPosition::set_has_altitude() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GPSPosition::clear_has_altitude() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GPSPosition::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline float GPSPosition::altitude() const {
  return altitude_;
}
inline void GPSPosition::set_altitude(float value) {
  set_has_altitude();
  altitude_ = value;
}

// optional float wpLatitude = 6;
inline bool GPSPosition::has_wplatitude() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GPSPosition::set_has_wplatitude() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GPSPosition::clear_has_wplatitude() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GPSPosition::clear_wplatitude() {
  wplatitude_ = 0;
  clear_has_wplatitude();
}
inline float GPSPosition::wplatitude() const {
  return wplatitude_;
}
inline void GPSPosition::set_wplatitude(float value) {
  set_has_wplatitude();
  wplatitude_ = value;
}

// optional float wpLongitude = 7;
inline bool GPSPosition::has_wplongitude() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GPSPosition::set_has_wplongitude() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GPSPosition::clear_has_wplongitude() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GPSPosition::clear_wplongitude() {
  wplongitude_ = 0;
  clear_has_wplongitude();
}
inline float GPSPosition::wplongitude() const {
  return wplongitude_;
}
inline void GPSPosition::set_wplongitude(float value) {
  set_has_wplongitude();
  wplongitude_ = value;
}

// optional float velocity = 8;
inline bool GPSPosition::has_velocity() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GPSPosition::set_has_velocity() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GPSPosition::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GPSPosition::clear_velocity() {
  velocity_ = 0;
  clear_has_velocity();
}
inline float GPSPosition::velocity() const {
  return velocity_;
}
inline void GPSPosition::set_velocity(float value) {
  set_has_velocity();
  velocity_ = value;
}

// optional float bearing = 9;
inline bool GPSPosition::has_bearing() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GPSPosition::set_has_bearing() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GPSPosition::clear_has_bearing() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GPSPosition::clear_bearing() {
  bearing_ = 0;
  clear_has_bearing();
}
inline float GPSPosition::bearing() const {
  return bearing_;
}
inline void GPSPosition::set_bearing(float value) {
  set_has_bearing();
  bearing_ = value;
}

// optional float range = 10;
inline bool GPSPosition::has_range() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GPSPosition::set_has_range() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GPSPosition::clear_has_range() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GPSPosition::clear_range() {
  range_ = 0;
  clear_has_range();
}
inline float GPSPosition::range() const {
  return range_;
}
inline void GPSPosition::set_range(float value) {
  set_has_range();
  range_ = value;
}

// optional .falcon_common_msg.Timestamp timestamp = 11;
inline bool GPSPosition::has_timestamp() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GPSPosition::set_has_timestamp() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GPSPosition::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GPSPosition::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::falcon_common_msg::Timestamp::Clear();
  clear_has_timestamp();
}
inline const ::falcon_common_msg::Timestamp& GPSPosition::timestamp() const {
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
inline ::falcon_common_msg::Timestamp* GPSPosition::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) timestamp_ = new ::falcon_common_msg::Timestamp;
  return timestamp_;
}
inline ::falcon_common_msg::Timestamp* GPSPosition::release_timestamp() {
  clear_has_timestamp();
  ::falcon_common_msg::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void GPSPosition::set_allocated_timestamp(::falcon_common_msg::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
}

// optional float seqNum = 12;
inline bool GPSPosition::has_seqnum() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GPSPosition::set_has_seqnum() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GPSPosition::clear_has_seqnum() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GPSPosition::clear_seqnum() {
  seqnum_ = 0;
  clear_has_seqnum();
}
inline float GPSPosition::seqnum() const {
  return seqnum_;
}
inline void GPSPosition::set_seqnum(float value) {
  set_has_seqnum();
  seqnum_ = value;
}

// optional bool isPrediction = 13;
inline bool GPSPosition::has_isprediction() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GPSPosition::set_has_isprediction() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GPSPosition::clear_has_isprediction() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GPSPosition::clear_isprediction() {
  isprediction_ = false;
  clear_has_isprediction();
}
inline bool GPSPosition::isprediction() const {
  return isprediction_;
}
inline void GPSPosition::set_isprediction(bool value) {
  set_has_isprediction();
  isprediction_ = value;
}

// optional float major = 14;
inline bool GPSPosition::has_major() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GPSPosition::set_has_major() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GPSPosition::clear_has_major() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GPSPosition::clear_major() {
  major_ = 0;
  clear_has_major();
}
inline float GPSPosition::major() const {
  return major_;
}
inline void GPSPosition::set_major(float value) {
  set_has_major();
  major_ = value;
}

// optional float minor = 15;
inline bool GPSPosition::has_minor() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GPSPosition::set_has_minor() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GPSPosition::clear_has_minor() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GPSPosition::clear_minor() {
  minor_ = 0;
  clear_has_minor();
}
inline float GPSPosition::minor() const {
  return minor_;
}
inline void GPSPosition::set_minor(float value) {
  set_has_minor();
  minor_ = value;
}

// optional float vector = 16;
inline bool GPSPosition::has_vector() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GPSPosition::set_has_vector() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GPSPosition::clear_has_vector() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GPSPosition::clear_vector() {
  vector_ = 0;
  clear_has_vector();
}
inline float GPSPosition::vector() const {
  return vector_;
}
inline void GPSPosition::set_vector(float value) {
  set_has_vector();
  vector_ = value;
}

// optional int32 appID = 17;
inline bool GPSPosition::has_appid() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void GPSPosition::set_has_appid() {
  _has_bits_[0] |= 0x00010000u;
}
inline void GPSPosition::clear_has_appid() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void GPSPosition::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 GPSPosition::appid() const {
  return appid_;
}
inline void GPSPosition::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// -------------------------------------------------------------------

// ExternalHit

// optional string msgName = 1 [default = "EXTERNAL_HIT"];
inline bool ExternalHit::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExternalHit::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExternalHit::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExternalHit::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ExternalHit::msgname() const {
  return *msgname_;
}
inline void ExternalHit::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ExternalHit::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ExternalHit::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExternalHit::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ExternalHit::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ExternalHit::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional .es_product_msg.ExternalHit.Type threatType = 2;
inline bool ExternalHit::has_threattype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExternalHit::set_has_threattype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExternalHit::clear_has_threattype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExternalHit::clear_threattype() {
  threattype_ = 0;
  clear_has_threattype();
}
inline ::es_product_msg::ExternalHit_Type ExternalHit::threattype() const {
  return static_cast< ::es_product_msg::ExternalHit_Type >(threattype_);
}
inline void ExternalHit::set_threattype(::es_product_msg::ExternalHit_Type value) {
  assert(::es_product_msg::ExternalHit_Type_IsValid(value));
  set_has_threattype();
  threattype_ = value;
}

// optional double centerFreqMHz = 3;
inline bool ExternalHit::has_centerfreqmhz() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExternalHit::set_has_centerfreqmhz() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExternalHit::clear_has_centerfreqmhz() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExternalHit::clear_centerfreqmhz() {
  centerfreqmhz_ = 0;
  clear_has_centerfreqmhz();
}
inline double ExternalHit::centerfreqmhz() const {
  return centerfreqmhz_;
}
inline void ExternalHit::set_centerfreqmhz(double value) {
  set_has_centerfreqmhz();
  centerfreqmhz_ = value;
}

// optional int32 pseudoUniqueId = 4;
inline bool ExternalHit::has_pseudouniqueid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExternalHit::set_has_pseudouniqueid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExternalHit::clear_has_pseudouniqueid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExternalHit::clear_pseudouniqueid() {
  pseudouniqueid_ = 0;
  clear_has_pseudouniqueid();
}
inline ::google::protobuf::int32 ExternalHit::pseudouniqueid() const {
  return pseudouniqueid_;
}
inline void ExternalHit::set_pseudouniqueid(::google::protobuf::int32 value) {
  set_has_pseudouniqueid();
  pseudouniqueid_ = value;
}

// optional .falcon_common_msg.Timestamp timestamp = 5;
inline bool ExternalHit::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExternalHit::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExternalHit::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExternalHit::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::falcon_common_msg::Timestamp::Clear();
  clear_has_timestamp();
}
inline const ::falcon_common_msg::Timestamp& ExternalHit::timestamp() const {
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
inline ::falcon_common_msg::Timestamp* ExternalHit::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) timestamp_ = new ::falcon_common_msg::Timestamp;
  return timestamp_;
}
inline ::falcon_common_msg::Timestamp* ExternalHit::release_timestamp() {
  clear_has_timestamp();
  ::falcon_common_msg::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void ExternalHit::set_allocated_timestamp(::falcon_common_msg::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
}

// optional bool isTrigger = 6;
inline bool ExternalHit::has_istrigger() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ExternalHit::set_has_istrigger() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ExternalHit::clear_has_istrigger() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ExternalHit::clear_istrigger() {
  istrigger_ = false;
  clear_has_istrigger();
}
inline bool ExternalHit::istrigger() const {
  return istrigger_;
}
inline void ExternalHit::set_istrigger(bool value) {
  set_has_istrigger();
  istrigger_ = value;
}

// optional .falcon_externals_msg.HopDescriptor hopDescriptor = 7;
inline bool ExternalHit::has_hopdescriptor() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ExternalHit::set_has_hopdescriptor() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ExternalHit::clear_has_hopdescriptor() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ExternalHit::clear_hopdescriptor() {
  if (hopdescriptor_ != NULL) hopdescriptor_->::falcon_externals_msg::HopDescriptor::Clear();
  clear_has_hopdescriptor();
}
inline const ::falcon_externals_msg::HopDescriptor& ExternalHit::hopdescriptor() const {
  return hopdescriptor_ != NULL ? *hopdescriptor_ : *default_instance_->hopdescriptor_;
}
inline ::falcon_externals_msg::HopDescriptor* ExternalHit::mutable_hopdescriptor() {
  set_has_hopdescriptor();
  if (hopdescriptor_ == NULL) hopdescriptor_ = new ::falcon_externals_msg::HopDescriptor;
  return hopdescriptor_;
}
inline ::falcon_externals_msg::HopDescriptor* ExternalHit::release_hopdescriptor() {
  clear_has_hopdescriptor();
  ::falcon_externals_msg::HopDescriptor* temp = hopdescriptor_;
  hopdescriptor_ = NULL;
  return temp;
}
inline void ExternalHit::set_allocated_hopdescriptor(::falcon_externals_msg::HopDescriptor* hopdescriptor) {
  delete hopdescriptor_;
  hopdescriptor_ = hopdescriptor;
  if (hopdescriptor) {
    set_has_hopdescriptor();
  } else {
    clear_has_hopdescriptor();
  }
}

// optional .falcon_externals_msg.FSKDescriptor fskDescriptor = 8;
inline bool ExternalHit::has_fskdescriptor() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ExternalHit::set_has_fskdescriptor() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ExternalHit::clear_has_fskdescriptor() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ExternalHit::clear_fskdescriptor() {
  if (fskdescriptor_ != NULL) fskdescriptor_->::falcon_externals_msg::FSKDescriptor::Clear();
  clear_has_fskdescriptor();
}
inline const ::falcon_externals_msg::FSKDescriptor& ExternalHit::fskdescriptor() const {
  return fskdescriptor_ != NULL ? *fskdescriptor_ : *default_instance_->fskdescriptor_;
}
inline ::falcon_externals_msg::FSKDescriptor* ExternalHit::mutable_fskdescriptor() {
  set_has_fskdescriptor();
  if (fskdescriptor_ == NULL) fskdescriptor_ = new ::falcon_externals_msg::FSKDescriptor;
  return fskdescriptor_;
}
inline ::falcon_externals_msg::FSKDescriptor* ExternalHit::release_fskdescriptor() {
  clear_has_fskdescriptor();
  ::falcon_externals_msg::FSKDescriptor* temp = fskdescriptor_;
  fskdescriptor_ = NULL;
  return temp;
}
inline void ExternalHit::set_allocated_fskdescriptor(::falcon_externals_msg::FSKDescriptor* fskdescriptor) {
  delete fskdescriptor_;
  fskdescriptor_ = fskdescriptor;
  if (fskdescriptor) {
    set_has_fskdescriptor();
  } else {
    clear_has_fskdescriptor();
  }
}

// optional .falcon_externals_msg.CWDescriptor cwDescriptor = 9;
inline bool ExternalHit::has_cwdescriptor() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ExternalHit::set_has_cwdescriptor() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ExternalHit::clear_has_cwdescriptor() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ExternalHit::clear_cwdescriptor() {
  if (cwdescriptor_ != NULL) cwdescriptor_->::falcon_externals_msg::CWDescriptor::Clear();
  clear_has_cwdescriptor();
}
inline const ::falcon_externals_msg::CWDescriptor& ExternalHit::cwdescriptor() const {
  return cwdescriptor_ != NULL ? *cwdescriptor_ : *default_instance_->cwdescriptor_;
}
inline ::falcon_externals_msg::CWDescriptor* ExternalHit::mutable_cwdescriptor() {
  set_has_cwdescriptor();
  if (cwdescriptor_ == NULL) cwdescriptor_ = new ::falcon_externals_msg::CWDescriptor;
  return cwdescriptor_;
}
inline ::falcon_externals_msg::CWDescriptor* ExternalHit::release_cwdescriptor() {
  clear_has_cwdescriptor();
  ::falcon_externals_msg::CWDescriptor* temp = cwdescriptor_;
  cwdescriptor_ = NULL;
  return temp;
}
inline void ExternalHit::set_allocated_cwdescriptor(::falcon_externals_msg::CWDescriptor* cwdescriptor) {
  delete cwdescriptor_;
  cwdescriptor_ = cwdescriptor;
  if (cwdescriptor) {
    set_has_cwdescriptor();
  } else {
    clear_has_cwdescriptor();
  }
}

// optional .falcon_externals_msg.SpreadDescriptor spreadDescriptor = 10;
inline bool ExternalHit::has_spreaddescriptor() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ExternalHit::set_has_spreaddescriptor() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ExternalHit::clear_has_spreaddescriptor() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ExternalHit::clear_spreaddescriptor() {
  if (spreaddescriptor_ != NULL) spreaddescriptor_->::falcon_externals_msg::SpreadDescriptor::Clear();
  clear_has_spreaddescriptor();
}
inline const ::falcon_externals_msg::SpreadDescriptor& ExternalHit::spreaddescriptor() const {
  return spreaddescriptor_ != NULL ? *spreaddescriptor_ : *default_instance_->spreaddescriptor_;
}
inline ::falcon_externals_msg::SpreadDescriptor* ExternalHit::mutable_spreaddescriptor() {
  set_has_spreaddescriptor();
  if (spreaddescriptor_ == NULL) spreaddescriptor_ = new ::falcon_externals_msg::SpreadDescriptor;
  return spreaddescriptor_;
}
inline ::falcon_externals_msg::SpreadDescriptor* ExternalHit::release_spreaddescriptor() {
  clear_has_spreaddescriptor();
  ::falcon_externals_msg::SpreadDescriptor* temp = spreaddescriptor_;
  spreaddescriptor_ = NULL;
  return temp;
}
inline void ExternalHit::set_allocated_spreaddescriptor(::falcon_externals_msg::SpreadDescriptor* spreaddescriptor) {
  delete spreaddescriptor_;
  spreaddescriptor_ = spreaddescriptor;
  if (spreaddescriptor) {
    set_has_spreaddescriptor();
  } else {
    clear_has_spreaddescriptor();
  }
}

// optional .falcon_externals_msg.AVDescriptor avDescriptor = 11;
inline bool ExternalHit::has_avdescriptor() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ExternalHit::set_has_avdescriptor() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ExternalHit::clear_has_avdescriptor() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ExternalHit::clear_avdescriptor() {
  if (avdescriptor_ != NULL) avdescriptor_->::falcon_externals_msg::AVDescriptor::Clear();
  clear_has_avdescriptor();
}
inline const ::falcon_externals_msg::AVDescriptor& ExternalHit::avdescriptor() const {
  return avdescriptor_ != NULL ? *avdescriptor_ : *default_instance_->avdescriptor_;
}
inline ::falcon_externals_msg::AVDescriptor* ExternalHit::mutable_avdescriptor() {
  set_has_avdescriptor();
  if (avdescriptor_ == NULL) avdescriptor_ = new ::falcon_externals_msg::AVDescriptor;
  return avdescriptor_;
}
inline ::falcon_externals_msg::AVDescriptor* ExternalHit::release_avdescriptor() {
  clear_has_avdescriptor();
  ::falcon_externals_msg::AVDescriptor* temp = avdescriptor_;
  avdescriptor_ = NULL;
  return temp;
}
inline void ExternalHit::set_allocated_avdescriptor(::falcon_externals_msg::AVDescriptor* avdescriptor) {
  delete avdescriptor_;
  avdescriptor_ = avdescriptor;
  if (avdescriptor) {
    set_has_avdescriptor();
  } else {
    clear_has_avdescriptor();
  }
}

// optional .falcon_externals_msg.DsssDescriptor dsssDescriptor = 12;
inline bool ExternalHit::has_dsssdescriptor() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ExternalHit::set_has_dsssdescriptor() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ExternalHit::clear_has_dsssdescriptor() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ExternalHit::clear_dsssdescriptor() {
  if (dsssdescriptor_ != NULL) dsssdescriptor_->::falcon_externals_msg::DsssDescriptor::Clear();
  clear_has_dsssdescriptor();
}
inline const ::falcon_externals_msg::DsssDescriptor& ExternalHit::dsssdescriptor() const {
  return dsssdescriptor_ != NULL ? *dsssdescriptor_ : *default_instance_->dsssdescriptor_;
}
inline ::falcon_externals_msg::DsssDescriptor* ExternalHit::mutable_dsssdescriptor() {
  set_has_dsssdescriptor();
  if (dsssdescriptor_ == NULL) dsssdescriptor_ = new ::falcon_externals_msg::DsssDescriptor;
  return dsssdescriptor_;
}
inline ::falcon_externals_msg::DsssDescriptor* ExternalHit::release_dsssdescriptor() {
  clear_has_dsssdescriptor();
  ::falcon_externals_msg::DsssDescriptor* temp = dsssdescriptor_;
  dsssdescriptor_ = NULL;
  return temp;
}
inline void ExternalHit::set_allocated_dsssdescriptor(::falcon_externals_msg::DsssDescriptor* dsssdescriptor) {
  delete dsssdescriptor_;
  dsssdescriptor_ = dsssdescriptor;
  if (dsssdescriptor) {
    set_has_dsssdescriptor();
  } else {
    clear_has_dsssdescriptor();
  }
}

// optional int32 updateValues = 13;
inline bool ExternalHit::has_updatevalues() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ExternalHit::set_has_updatevalues() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ExternalHit::clear_has_updatevalues() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ExternalHit::clear_updatevalues() {
  updatevalues_ = 0;
  clear_has_updatevalues();
}
inline ::google::protobuf::int32 ExternalHit::updatevalues() const {
  return updatevalues_;
}
inline void ExternalHit::set_updatevalues(::google::protobuf::int32 value) {
  set_has_updatevalues();
  updatevalues_ = value;
}

// -------------------------------------------------------------------

// InternalHit

// optional string msgName = 1 [default = "INTERNAL_HIT"];
inline bool InternalHit::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalHit::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalHit::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalHit::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& InternalHit::msgname() const {
  return *msgname_;
}
inline void InternalHit::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void InternalHit::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void InternalHit::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InternalHit::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* InternalHit::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void InternalHit::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional double centerFreqMHz = 2;
inline bool InternalHit::has_centerfreqmhz() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalHit::set_has_centerfreqmhz() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalHit::clear_has_centerfreqmhz() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalHit::clear_centerfreqmhz() {
  centerfreqmhz_ = 0;
  clear_has_centerfreqmhz();
}
inline double InternalHit::centerfreqmhz() const {
  return centerfreqmhz_;
}
inline void InternalHit::set_centerfreqmhz(double value) {
  set_has_centerfreqmhz();
  centerfreqmhz_ = value;
}

// optional int32 pseudoUniqueId = 3;
inline bool InternalHit::has_pseudouniqueid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InternalHit::set_has_pseudouniqueid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InternalHit::clear_has_pseudouniqueid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InternalHit::clear_pseudouniqueid() {
  pseudouniqueid_ = 0;
  clear_has_pseudouniqueid();
}
inline ::google::protobuf::int32 InternalHit::pseudouniqueid() const {
  return pseudouniqueid_;
}
inline void InternalHit::set_pseudouniqueid(::google::protobuf::int32 value) {
  set_has_pseudouniqueid();
  pseudouniqueid_ = value;
}

// optional .falcon_common_msg.Timestamp timestamp = 4;
inline bool InternalHit::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InternalHit::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InternalHit::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InternalHit::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::falcon_common_msg::Timestamp::Clear();
  clear_has_timestamp();
}
inline const ::falcon_common_msg::Timestamp& InternalHit::timestamp() const {
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
inline ::falcon_common_msg::Timestamp* InternalHit::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) timestamp_ = new ::falcon_common_msg::Timestamp;
  return timestamp_;
}
inline ::falcon_common_msg::Timestamp* InternalHit::release_timestamp() {
  clear_has_timestamp();
  ::falcon_common_msg::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void InternalHit::set_allocated_timestamp(::falcon_common_msg::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
}

// optional bool isTrigger = 5;
inline bool InternalHit::has_istrigger() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InternalHit::set_has_istrigger() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InternalHit::clear_has_istrigger() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InternalHit::clear_istrigger() {
  istrigger_ = false;
  clear_has_istrigger();
}
inline bool InternalHit::istrigger() const {
  return istrigger_;
}
inline void InternalHit::set_istrigger(bool value) {
  set_has_istrigger();
  istrigger_ = value;
}

// optional .falcon_externals_msg.HopDescriptor hopDescriptor = 6;
inline bool InternalHit::has_hopdescriptor() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InternalHit::set_has_hopdescriptor() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InternalHit::clear_has_hopdescriptor() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InternalHit::clear_hopdescriptor() {
  if (hopdescriptor_ != NULL) hopdescriptor_->::falcon_externals_msg::HopDescriptor::Clear();
  clear_has_hopdescriptor();
}
inline const ::falcon_externals_msg::HopDescriptor& InternalHit::hopdescriptor() const {
  return hopdescriptor_ != NULL ? *hopdescriptor_ : *default_instance_->hopdescriptor_;
}
inline ::falcon_externals_msg::HopDescriptor* InternalHit::mutable_hopdescriptor() {
  set_has_hopdescriptor();
  if (hopdescriptor_ == NULL) hopdescriptor_ = new ::falcon_externals_msg::HopDescriptor;
  return hopdescriptor_;
}
inline ::falcon_externals_msg::HopDescriptor* InternalHit::release_hopdescriptor() {
  clear_has_hopdescriptor();
  ::falcon_externals_msg::HopDescriptor* temp = hopdescriptor_;
  hopdescriptor_ = NULL;
  return temp;
}
inline void InternalHit::set_allocated_hopdescriptor(::falcon_externals_msg::HopDescriptor* hopdescriptor) {
  delete hopdescriptor_;
  hopdescriptor_ = hopdescriptor;
  if (hopdescriptor) {
    set_has_hopdescriptor();
  } else {
    clear_has_hopdescriptor();
  }
}

// optional .falcon_externals_msg.FSKDescriptor fskDescriptor = 7;
inline bool InternalHit::has_fskdescriptor() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InternalHit::set_has_fskdescriptor() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InternalHit::clear_has_fskdescriptor() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InternalHit::clear_fskdescriptor() {
  if (fskdescriptor_ != NULL) fskdescriptor_->::falcon_externals_msg::FSKDescriptor::Clear();
  clear_has_fskdescriptor();
}
inline const ::falcon_externals_msg::FSKDescriptor& InternalHit::fskdescriptor() const {
  return fskdescriptor_ != NULL ? *fskdescriptor_ : *default_instance_->fskdescriptor_;
}
inline ::falcon_externals_msg::FSKDescriptor* InternalHit::mutable_fskdescriptor() {
  set_has_fskdescriptor();
  if (fskdescriptor_ == NULL) fskdescriptor_ = new ::falcon_externals_msg::FSKDescriptor;
  return fskdescriptor_;
}
inline ::falcon_externals_msg::FSKDescriptor* InternalHit::release_fskdescriptor() {
  clear_has_fskdescriptor();
  ::falcon_externals_msg::FSKDescriptor* temp = fskdescriptor_;
  fskdescriptor_ = NULL;
  return temp;
}
inline void InternalHit::set_allocated_fskdescriptor(::falcon_externals_msg::FSKDescriptor* fskdescriptor) {
  delete fskdescriptor_;
  fskdescriptor_ = fskdescriptor;
  if (fskdescriptor) {
    set_has_fskdescriptor();
  } else {
    clear_has_fskdescriptor();
  }
}

// optional .falcon_externals_msg.CWDescriptor cwDescriptor = 8;
inline bool InternalHit::has_cwdescriptor() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InternalHit::set_has_cwdescriptor() {
  _has_bits_[0] |= 0x00000080u;
}
inline void InternalHit::clear_has_cwdescriptor() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void InternalHit::clear_cwdescriptor() {
  if (cwdescriptor_ != NULL) cwdescriptor_->::falcon_externals_msg::CWDescriptor::Clear();
  clear_has_cwdescriptor();
}
inline const ::falcon_externals_msg::CWDescriptor& InternalHit::cwdescriptor() const {
  return cwdescriptor_ != NULL ? *cwdescriptor_ : *default_instance_->cwdescriptor_;
}
inline ::falcon_externals_msg::CWDescriptor* InternalHit::mutable_cwdescriptor() {
  set_has_cwdescriptor();
  if (cwdescriptor_ == NULL) cwdescriptor_ = new ::falcon_externals_msg::CWDescriptor;
  return cwdescriptor_;
}
inline ::falcon_externals_msg::CWDescriptor* InternalHit::release_cwdescriptor() {
  clear_has_cwdescriptor();
  ::falcon_externals_msg::CWDescriptor* temp = cwdescriptor_;
  cwdescriptor_ = NULL;
  return temp;
}
inline void InternalHit::set_allocated_cwdescriptor(::falcon_externals_msg::CWDescriptor* cwdescriptor) {
  delete cwdescriptor_;
  cwdescriptor_ = cwdescriptor;
  if (cwdescriptor) {
    set_has_cwdescriptor();
  } else {
    clear_has_cwdescriptor();
  }
}

// optional .falcon_externals_msg.SpreadDescriptor spreadDescriptor = 9;
inline bool InternalHit::has_spreaddescriptor() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void InternalHit::set_has_spreaddescriptor() {
  _has_bits_[0] |= 0x00000100u;
}
inline void InternalHit::clear_has_spreaddescriptor() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void InternalHit::clear_spreaddescriptor() {
  if (spreaddescriptor_ != NULL) spreaddescriptor_->::falcon_externals_msg::SpreadDescriptor::Clear();
  clear_has_spreaddescriptor();
}
inline const ::falcon_externals_msg::SpreadDescriptor& InternalHit::spreaddescriptor() const {
  return spreaddescriptor_ != NULL ? *spreaddescriptor_ : *default_instance_->spreaddescriptor_;
}
inline ::falcon_externals_msg::SpreadDescriptor* InternalHit::mutable_spreaddescriptor() {
  set_has_spreaddescriptor();
  if (spreaddescriptor_ == NULL) spreaddescriptor_ = new ::falcon_externals_msg::SpreadDescriptor;
  return spreaddescriptor_;
}
inline ::falcon_externals_msg::SpreadDescriptor* InternalHit::release_spreaddescriptor() {
  clear_has_spreaddescriptor();
  ::falcon_externals_msg::SpreadDescriptor* temp = spreaddescriptor_;
  spreaddescriptor_ = NULL;
  return temp;
}
inline void InternalHit::set_allocated_spreaddescriptor(::falcon_externals_msg::SpreadDescriptor* spreaddescriptor) {
  delete spreaddescriptor_;
  spreaddescriptor_ = spreaddescriptor;
  if (spreaddescriptor) {
    set_has_spreaddescriptor();
  } else {
    clear_has_spreaddescriptor();
  }
}

// optional .falcon_externals_msg.AVDescriptor avDescriptor = 10;
inline bool InternalHit::has_avdescriptor() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void InternalHit::set_has_avdescriptor() {
  _has_bits_[0] |= 0x00000200u;
}
inline void InternalHit::clear_has_avdescriptor() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void InternalHit::clear_avdescriptor() {
  if (avdescriptor_ != NULL) avdescriptor_->::falcon_externals_msg::AVDescriptor::Clear();
  clear_has_avdescriptor();
}
inline const ::falcon_externals_msg::AVDescriptor& InternalHit::avdescriptor() const {
  return avdescriptor_ != NULL ? *avdescriptor_ : *default_instance_->avdescriptor_;
}
inline ::falcon_externals_msg::AVDescriptor* InternalHit::mutable_avdescriptor() {
  set_has_avdescriptor();
  if (avdescriptor_ == NULL) avdescriptor_ = new ::falcon_externals_msg::AVDescriptor;
  return avdescriptor_;
}
inline ::falcon_externals_msg::AVDescriptor* InternalHit::release_avdescriptor() {
  clear_has_avdescriptor();
  ::falcon_externals_msg::AVDescriptor* temp = avdescriptor_;
  avdescriptor_ = NULL;
  return temp;
}
inline void InternalHit::set_allocated_avdescriptor(::falcon_externals_msg::AVDescriptor* avdescriptor) {
  delete avdescriptor_;
  avdescriptor_ = avdescriptor;
  if (avdescriptor) {
    set_has_avdescriptor();
  } else {
    clear_has_avdescriptor();
  }
}

// optional .falcon_externals_msg.DsssDescriptor dsssDescriptor = 11;
inline bool InternalHit::has_dsssdescriptor() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void InternalHit::set_has_dsssdescriptor() {
  _has_bits_[0] |= 0x00000400u;
}
inline void InternalHit::clear_has_dsssdescriptor() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void InternalHit::clear_dsssdescriptor() {
  if (dsssdescriptor_ != NULL) dsssdescriptor_->::falcon_externals_msg::DsssDescriptor::Clear();
  clear_has_dsssdescriptor();
}
inline const ::falcon_externals_msg::DsssDescriptor& InternalHit::dsssdescriptor() const {
  return dsssdescriptor_ != NULL ? *dsssdescriptor_ : *default_instance_->dsssdescriptor_;
}
inline ::falcon_externals_msg::DsssDescriptor* InternalHit::mutable_dsssdescriptor() {
  set_has_dsssdescriptor();
  if (dsssdescriptor_ == NULL) dsssdescriptor_ = new ::falcon_externals_msg::DsssDescriptor;
  return dsssdescriptor_;
}
inline ::falcon_externals_msg::DsssDescriptor* InternalHit::release_dsssdescriptor() {
  clear_has_dsssdescriptor();
  ::falcon_externals_msg::DsssDescriptor* temp = dsssdescriptor_;
  dsssdescriptor_ = NULL;
  return temp;
}
inline void InternalHit::set_allocated_dsssdescriptor(::falcon_externals_msg::DsssDescriptor* dsssdescriptor) {
  delete dsssdescriptor_;
  dsssdescriptor_ = dsssdescriptor;
  if (dsssdescriptor) {
    set_has_dsssdescriptor();
  } else {
    clear_has_dsssdescriptor();
  }
}

// optional int32 updateValues = 12;
inline bool InternalHit::has_updatevalues() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void InternalHit::set_has_updatevalues() {
  _has_bits_[0] |= 0x00000800u;
}
inline void InternalHit::clear_has_updatevalues() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void InternalHit::clear_updatevalues() {
  updatevalues_ = 0;
  clear_has_updatevalues();
}
inline ::google::protobuf::int32 InternalHit::updatevalues() const {
  return updatevalues_;
}
inline void InternalHit::set_updatevalues(::google::protobuf::int32 value) {
  set_has_updatevalues();
  updatevalues_ = value;
}

// -------------------------------------------------------------------

// FisD

// optional string msgName = 1 [default = "FIS_D"];
inline bool FisD::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FisD::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FisD::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FisD::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& FisD::msgname() const {
  return *msgname_;
}
inline void FisD::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void FisD::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void FisD::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FisD::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* FisD::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void FisD::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional .es_product_msg.FisD.FileType fileType = 2;
inline bool FisD::has_filetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FisD::set_has_filetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FisD::clear_has_filetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FisD::clear_filetype() {
  filetype_ = 0;
  clear_has_filetype();
}
inline ::es_product_msg::FisD_FileType FisD::filetype() const {
  return static_cast< ::es_product_msg::FisD_FileType >(filetype_);
}
inline void FisD::set_filetype(::es_product_msg::FisD_FileType value) {
  assert(::es_product_msg::FisD_FileType_IsValid(value));
  set_has_filetype();
  filetype_ = value;
}

// optional string fileName = 3;
inline bool FisD::has_filename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FisD::set_has_filename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FisD::clear_has_filename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FisD::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& FisD::filename() const {
  return *filename_;
}
inline void FisD::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void FisD::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void FisD::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FisD::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* FisD::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FisD::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes file = 4;
inline bool FisD::has_file() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FisD::set_has_file() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FisD::clear_has_file() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FisD::clear_file() {
  if (file_ != &::google::protobuf::internal::kEmptyString) {
    file_->clear();
  }
  clear_has_file();
}
inline const ::std::string& FisD::file() const {
  return *file_;
}
inline void FisD::set_file(const ::std::string& value) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    file_ = new ::std::string;
  }
  file_->assign(value);
}
inline void FisD::set_file(const char* value) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    file_ = new ::std::string;
  }
  file_->assign(value);
}
inline void FisD::set_file(const void* value, size_t size) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    file_ = new ::std::string;
  }
  file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FisD::mutable_file() {
  set_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    file_ = new ::std::string;
  }
  return file_;
}
inline ::std::string* FisD::release_file() {
  clear_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_;
    file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FisD::set_allocated_file(::std::string* file) {
  if (file_ != &::google::protobuf::internal::kEmptyString) {
    delete file_;
  }
  if (file) {
    set_has_file();
    file_ = file;
  } else {
    clear_has_file();
    file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string eventID = 5;
inline bool FisD::has_eventid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FisD::set_has_eventid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FisD::clear_has_eventid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FisD::clear_eventid() {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    eventid_->clear();
  }
  clear_has_eventid();
}
inline const ::std::string& FisD::eventid() const {
  return *eventid_;
}
inline void FisD::set_eventid(const ::std::string& value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void FisD::set_eventid(const char* value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void FisD::set_eventid(const char* value, size_t size) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FisD::mutable_eventid() {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  return eventid_;
}
inline ::std::string* FisD::release_eventid() {
  clear_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventid_;
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FisD::set_allocated_eventid(::std::string* eventid) {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    delete eventid_;
  }
  if (eventid) {
    set_has_eventid();
    eventid_ = eventid;
  } else {
    clear_has_eventid();
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SIGFrame

// optional string msgName = 1 [default = "SIG_FRAME"];
inline bool SIGFrame::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SIGFrame::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SIGFrame::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SIGFrame::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SIGFrame::msgname() const {
  return *msgname_;
}
inline void SIGFrame::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SIGFrame::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SIGFrame::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SIGFrame::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SIGFrame::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SIGFrame::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string signalID = 2;
inline bool SIGFrame::has_signalid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SIGFrame::set_has_signalid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SIGFrame::clear_has_signalid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SIGFrame::clear_signalid() {
  if (signalid_ != &::google::protobuf::internal::kEmptyString) {
    signalid_->clear();
  }
  clear_has_signalid();
}
inline const ::std::string& SIGFrame::signalid() const {
  return *signalid_;
}
inline void SIGFrame::set_signalid(const ::std::string& value) {
  set_has_signalid();
  if (signalid_ == &::google::protobuf::internal::kEmptyString) {
    signalid_ = new ::std::string;
  }
  signalid_->assign(value);
}
inline void SIGFrame::set_signalid(const char* value) {
  set_has_signalid();
  if (signalid_ == &::google::protobuf::internal::kEmptyString) {
    signalid_ = new ::std::string;
  }
  signalid_->assign(value);
}
inline void SIGFrame::set_signalid(const char* value, size_t size) {
  set_has_signalid();
  if (signalid_ == &::google::protobuf::internal::kEmptyString) {
    signalid_ = new ::std::string;
  }
  signalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SIGFrame::mutable_signalid() {
  set_has_signalid();
  if (signalid_ == &::google::protobuf::internal::kEmptyString) {
    signalid_ = new ::std::string;
  }
  return signalid_;
}
inline ::std::string* SIGFrame::release_signalid() {
  clear_has_signalid();
  if (signalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signalid_;
    signalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SIGFrame::set_allocated_signalid(::std::string* signalid) {
  if (signalid_ != &::google::protobuf::internal::kEmptyString) {
    delete signalid_;
  }
  if (signalid) {
    set_has_signalid();
    signalid_ = signalid;
  } else {
    clear_has_signalid();
    signalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .falcon_common_msg.Timestamp timestamp = 3;
inline bool SIGFrame::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SIGFrame::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SIGFrame::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SIGFrame::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::falcon_common_msg::Timestamp::Clear();
  clear_has_timestamp();
}
inline const ::falcon_common_msg::Timestamp& SIGFrame::timestamp() const {
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
inline ::falcon_common_msg::Timestamp* SIGFrame::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) timestamp_ = new ::falcon_common_msg::Timestamp;
  return timestamp_;
}
inline ::falcon_common_msg::Timestamp* SIGFrame::release_timestamp() {
  clear_has_timestamp();
  ::falcon_common_msg::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void SIGFrame::set_allocated_timestamp(::falcon_common_msg::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
}

// optional double duration = 4;
inline bool SIGFrame::has_duration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SIGFrame::set_has_duration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SIGFrame::clear_has_duration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SIGFrame::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline double SIGFrame::duration() const {
  return duration_;
}
inline void SIGFrame::set_duration(double value) {
  set_has_duration();
  duration_ = value;
}

// optional double centerFreqMHz = 5;
inline bool SIGFrame::has_centerfreqmhz() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SIGFrame::set_has_centerfreqmhz() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SIGFrame::clear_has_centerfreqmhz() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SIGFrame::clear_centerfreqmhz() {
  centerfreqmhz_ = 0;
  clear_has_centerfreqmhz();
}
inline double SIGFrame::centerfreqmhz() const {
  return centerfreqmhz_;
}
inline void SIGFrame::set_centerfreqmhz(double value) {
  set_has_centerfreqmhz();
  centerfreqmhz_ = value;
}

// optional double centerFreqOffsetHz = 6;
inline bool SIGFrame::has_centerfreqoffsethz() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SIGFrame::set_has_centerfreqoffsethz() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SIGFrame::clear_has_centerfreqoffsethz() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SIGFrame::clear_centerfreqoffsethz() {
  centerfreqoffsethz_ = 0;
  clear_has_centerfreqoffsethz();
}
inline double SIGFrame::centerfreqoffsethz() const {
  return centerfreqoffsethz_;
}
inline void SIGFrame::set_centerfreqoffsethz(double value) {
  set_has_centerfreqoffsethz();
  centerfreqoffsethz_ = value;
}

// optional double sampleRate = 7;
inline bool SIGFrame::has_samplerate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SIGFrame::set_has_samplerate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SIGFrame::clear_has_samplerate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SIGFrame::clear_samplerate() {
  samplerate_ = 0;
  clear_has_samplerate();
}
inline double SIGFrame::samplerate() const {
  return samplerate_;
}
inline void SIGFrame::set_samplerate(double value) {
  set_has_samplerate();
  samplerate_ = value;
}

// optional double bandwidth = 8;
inline bool SIGFrame::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SIGFrame::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SIGFrame::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SIGFrame::clear_bandwidth() {
  bandwidth_ = 0;
  clear_has_bandwidth();
}
inline double SIGFrame::bandwidth() const {
  return bandwidth_;
}
inline void SIGFrame::set_bandwidth(double value) {
  set_has_bandwidth();
  bandwidth_ = value;
}

// optional double power = 9;
inline bool SIGFrame::has_power() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SIGFrame::set_has_power() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SIGFrame::clear_has_power() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SIGFrame::clear_power() {
  power_ = 0;
  clear_has_power();
}
inline double SIGFrame::power() const {
  return power_;
}
inline void SIGFrame::set_power(double value) {
  set_has_power();
  power_ = value;
}

// optional double ber = 10;
inline bool SIGFrame::has_ber() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SIGFrame::set_has_ber() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SIGFrame::clear_has_ber() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SIGFrame::clear_ber() {
  ber_ = 0;
  clear_has_ber();
}
inline double SIGFrame::ber() const {
  return ber_;
}
inline void SIGFrame::set_ber(double value) {
  set_has_ber();
  ber_ = value;
}

// optional int32 frameLength = 11;
inline bool SIGFrame::has_framelength() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SIGFrame::set_has_framelength() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SIGFrame::clear_has_framelength() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SIGFrame::clear_framelength() {
  framelength_ = 0;
  clear_has_framelength();
}
inline ::google::protobuf::int32 SIGFrame::framelength() const {
  return framelength_;
}
inline void SIGFrame::set_framelength(::google::protobuf::int32 value) {
  set_has_framelength();
  framelength_ = value;
}

// optional bytes frame = 12;
inline bool SIGFrame::has_frame() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SIGFrame::set_has_frame() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SIGFrame::clear_has_frame() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SIGFrame::clear_frame() {
  if (frame_ != &::google::protobuf::internal::kEmptyString) {
    frame_->clear();
  }
  clear_has_frame();
}
inline const ::std::string& SIGFrame::frame() const {
  return *frame_;
}
inline void SIGFrame::set_frame(const ::std::string& value) {
  set_has_frame();
  if (frame_ == &::google::protobuf::internal::kEmptyString) {
    frame_ = new ::std::string;
  }
  frame_->assign(value);
}
inline void SIGFrame::set_frame(const char* value) {
  set_has_frame();
  if (frame_ == &::google::protobuf::internal::kEmptyString) {
    frame_ = new ::std::string;
  }
  frame_->assign(value);
}
inline void SIGFrame::set_frame(const void* value, size_t size) {
  set_has_frame();
  if (frame_ == &::google::protobuf::internal::kEmptyString) {
    frame_ = new ::std::string;
  }
  frame_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SIGFrame::mutable_frame() {
  set_has_frame();
  if (frame_ == &::google::protobuf::internal::kEmptyString) {
    frame_ = new ::std::string;
  }
  return frame_;
}
inline ::std::string* SIGFrame::release_frame() {
  clear_has_frame();
  if (frame_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = frame_;
    frame_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SIGFrame::set_allocated_frame(::std::string* frame) {
  if (frame_ != &::google::protobuf::internal::kEmptyString) {
    delete frame_;
  }
  if (frame) {
    set_has_frame();
    frame_ = frame;
  } else {
    clear_has_frame();
    frame_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 tailID = 13;
inline bool SIGFrame::has_tailid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SIGFrame::set_has_tailid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SIGFrame::clear_has_tailid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SIGFrame::clear_tailid() {
  tailid_ = 0;
  clear_has_tailid();
}
inline ::google::protobuf::int32 SIGFrame::tailid() const {
  return tailid_;
}
inline void SIGFrame::set_tailid(::google::protobuf::int32 value) {
  set_has_tailid();
  tailid_ = value;
}

// -------------------------------------------------------------------

// ImageAvailable

// optional string msgName = 1 [default = "IMAGE_AVAILABLE"];
inline bool ImageAvailable::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageAvailable::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageAvailable::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageAvailable::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ImageAvailable::msgname() const {
  return *msgname_;
}
inline void ImageAvailable::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ImageAvailable::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ImageAvailable::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImageAvailable::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ImageAvailable::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ImageAvailable::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 imageWidth = 2;
inline bool ImageAvailable::has_imagewidth() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageAvailable::set_has_imagewidth() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageAvailable::clear_has_imagewidth() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageAvailable::clear_imagewidth() {
  imagewidth_ = 0;
  clear_has_imagewidth();
}
inline ::google::protobuf::int32 ImageAvailable::imagewidth() const {
  return imagewidth_;
}
inline void ImageAvailable::set_imagewidth(::google::protobuf::int32 value) {
  set_has_imagewidth();
  imagewidth_ = value;
}

// optional int32 imageHeight = 3;
inline bool ImageAvailable::has_imageheight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageAvailable::set_has_imageheight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageAvailable::clear_has_imageheight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageAvailable::clear_imageheight() {
  imageheight_ = 0;
  clear_has_imageheight();
}
inline ::google::protobuf::int32 ImageAvailable::imageheight() const {
  return imageheight_;
}
inline void ImageAvailable::set_imageheight(::google::protobuf::int32 value) {
  set_has_imageheight();
  imageheight_ = value;
}

// optional int32 videoPort = 4;
inline bool ImageAvailable::has_videoport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImageAvailable::set_has_videoport() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImageAvailable::clear_has_videoport() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImageAvailable::clear_videoport() {
  videoport_ = 0;
  clear_has_videoport();
}
inline ::google::protobuf::int32 ImageAvailable::videoport() const {
  return videoport_;
}
inline void ImageAvailable::set_videoport(::google::protobuf::int32 value) {
  set_has_videoport();
  videoport_ = value;
}

// optional int32 framerate = 5;
inline bool ImageAvailable::has_framerate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ImageAvailable::set_has_framerate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ImageAvailable::clear_has_framerate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ImageAvailable::clear_framerate() {
  framerate_ = 0;
  clear_has_framerate();
}
inline ::google::protobuf::int32 ImageAvailable::framerate() const {
  return framerate_;
}
inline void ImageAvailable::set_framerate(::google::protobuf::int32 value) {
  set_has_framerate();
  framerate_ = value;
}

// optional bytes byteArray = 6;
inline bool ImageAvailable::has_bytearray() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ImageAvailable::set_has_bytearray() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ImageAvailable::clear_has_bytearray() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ImageAvailable::clear_bytearray() {
  if (bytearray_ != &::google::protobuf::internal::kEmptyString) {
    bytearray_->clear();
  }
  clear_has_bytearray();
}
inline const ::std::string& ImageAvailable::bytearray() const {
  return *bytearray_;
}
inline void ImageAvailable::set_bytearray(const ::std::string& value) {
  set_has_bytearray();
  if (bytearray_ == &::google::protobuf::internal::kEmptyString) {
    bytearray_ = new ::std::string;
  }
  bytearray_->assign(value);
}
inline void ImageAvailable::set_bytearray(const char* value) {
  set_has_bytearray();
  if (bytearray_ == &::google::protobuf::internal::kEmptyString) {
    bytearray_ = new ::std::string;
  }
  bytearray_->assign(value);
}
inline void ImageAvailable::set_bytearray(const void* value, size_t size) {
  set_has_bytearray();
  if (bytearray_ == &::google::protobuf::internal::kEmptyString) {
    bytearray_ = new ::std::string;
  }
  bytearray_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImageAvailable::mutable_bytearray() {
  set_has_bytearray();
  if (bytearray_ == &::google::protobuf::internal::kEmptyString) {
    bytearray_ = new ::std::string;
  }
  return bytearray_;
}
inline ::std::string* ImageAvailable::release_bytearray() {
  clear_has_bytearray();
  if (bytearray_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bytearray_;
    bytearray_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ImageAvailable::set_allocated_bytearray(::std::string* bytearray) {
  if (bytearray_ != &::google::protobuf::internal::kEmptyString) {
    delete bytearray_;
  }
  if (bytearray) {
    set_has_bytearray();
    bytearray_ = bytearray;
  } else {
    clear_has_bytearray();
    bytearray_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .es_product_msg.ImageAvailable.Status status = 7;
inline bool ImageAvailable::has_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ImageAvailable::set_has_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ImageAvailable::clear_has_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ImageAvailable::clear_status() {
  status_ = -1;
  clear_has_status();
}
inline ::es_product_msg::ImageAvailable_Status ImageAvailable::status() const {
  return static_cast< ::es_product_msg::ImageAvailable_Status >(status_);
}
inline void ImageAvailable::set_status(::es_product_msg::ImageAvailable_Status value) {
  assert(::es_product_msg::ImageAvailable_Status_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional int32 msgID = 8;
inline bool ImageAvailable::has_msgid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ImageAvailable::set_has_msgid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ImageAvailable::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ImageAvailable::clear_msgid() {
  msgid_ = 0;
  clear_has_msgid();
}
inline ::google::protobuf::int32 ImageAvailable::msgid() const {
  return msgid_;
}
inline void ImageAvailable::set_msgid(::google::protobuf::int32 value) {
  set_has_msgid();
  msgid_ = value;
}

// optional string eventID = 9;
inline bool ImageAvailable::has_eventid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ImageAvailable::set_has_eventid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ImageAvailable::clear_has_eventid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ImageAvailable::clear_eventid() {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    eventid_->clear();
  }
  clear_has_eventid();
}
inline const ::std::string& ImageAvailable::eventid() const {
  return *eventid_;
}
inline void ImageAvailable::set_eventid(const ::std::string& value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void ImageAvailable::set_eventid(const char* value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void ImageAvailable::set_eventid(const char* value, size_t size) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImageAvailable::mutable_eventid() {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  return eventid_;
}
inline ::std::string* ImageAvailable::release_eventid() {
  clear_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventid_;
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ImageAvailable::set_allocated_eventid(::std::string* eventid) {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    delete eventid_;
  }
  if (eventid) {
    set_has_eventid();
    eventid_ = eventid;
  } else {
    clear_has_eventid();
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AudioAvailable

// optional string msgName = 1 [default = "AUDIO_AVAILABLE"];
inline bool AudioAvailable::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AudioAvailable::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AudioAvailable::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AudioAvailable::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& AudioAvailable::msgname() const {
  return *msgname_;
}
inline void AudioAvailable::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AudioAvailable::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AudioAvailable::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AudioAvailable::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* AudioAvailable::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void AudioAvailable::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional double centerFreqMHz = 2;
inline bool AudioAvailable::has_centerfreqmhz() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AudioAvailable::set_has_centerfreqmhz() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AudioAvailable::clear_has_centerfreqmhz() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AudioAvailable::clear_centerfreqmhz() {
  centerfreqmhz_ = 0;
  clear_has_centerfreqmhz();
}
inline double AudioAvailable::centerfreqmhz() const {
  return centerfreqmhz_;
}
inline void AudioAvailable::set_centerfreqmhz(double value) {
  set_has_centerfreqmhz();
  centerfreqmhz_ = value;
}

// optional .es_product_msg.AudioAvailable.Status status = 3;
inline bool AudioAvailable::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AudioAvailable::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AudioAvailable::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AudioAvailable::clear_status() {
  status_ = -1;
  clear_has_status();
}
inline ::es_product_msg::AudioAvailable_Status AudioAvailable::status() const {
  return static_cast< ::es_product_msg::AudioAvailable_Status >(status_);
}
inline void AudioAvailable::set_status(::es_product_msg::AudioAvailable_Status value) {
  assert(::es_product_msg::AudioAvailable_Status_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional string audiofile = 4;
inline bool AudioAvailable::has_audiofile() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AudioAvailable::set_has_audiofile() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AudioAvailable::clear_has_audiofile() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AudioAvailable::clear_audiofile() {
  if (audiofile_ != &::google::protobuf::internal::kEmptyString) {
    audiofile_->clear();
  }
  clear_has_audiofile();
}
inline const ::std::string& AudioAvailable::audiofile() const {
  return *audiofile_;
}
inline void AudioAvailable::set_audiofile(const ::std::string& value) {
  set_has_audiofile();
  if (audiofile_ == &::google::protobuf::internal::kEmptyString) {
    audiofile_ = new ::std::string;
  }
  audiofile_->assign(value);
}
inline void AudioAvailable::set_audiofile(const char* value) {
  set_has_audiofile();
  if (audiofile_ == &::google::protobuf::internal::kEmptyString) {
    audiofile_ = new ::std::string;
  }
  audiofile_->assign(value);
}
inline void AudioAvailable::set_audiofile(const char* value, size_t size) {
  set_has_audiofile();
  if (audiofile_ == &::google::protobuf::internal::kEmptyString) {
    audiofile_ = new ::std::string;
  }
  audiofile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AudioAvailable::mutable_audiofile() {
  set_has_audiofile();
  if (audiofile_ == &::google::protobuf::internal::kEmptyString) {
    audiofile_ = new ::std::string;
  }
  return audiofile_;
}
inline ::std::string* AudioAvailable::release_audiofile() {
  clear_has_audiofile();
  if (audiofile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = audiofile_;
    audiofile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AudioAvailable::set_allocated_audiofile(::std::string* audiofile) {
  if (audiofile_ != &::google::protobuf::internal::kEmptyString) {
    delete audiofile_;
  }
  if (audiofile) {
    set_has_audiofile();
    audiofile_ = audiofile;
  } else {
    clear_has_audiofile();
    audiofile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 msgID = 5;
inline bool AudioAvailable::has_msgid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AudioAvailable::set_has_msgid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AudioAvailable::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AudioAvailable::clear_msgid() {
  msgid_ = 0;
  clear_has_msgid();
}
inline ::google::protobuf::int32 AudioAvailable::msgid() const {
  return msgid_;
}
inline void AudioAvailable::set_msgid(::google::protobuf::int32 value) {
  set_has_msgid();
  msgid_ = value;
}

// optional string soiNum = 6;
inline bool AudioAvailable::has_soinum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AudioAvailable::set_has_soinum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AudioAvailable::clear_has_soinum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AudioAvailable::clear_soinum() {
  if (soinum_ != &::google::protobuf::internal::kEmptyString) {
    soinum_->clear();
  }
  clear_has_soinum();
}
inline const ::std::string& AudioAvailable::soinum() const {
  return *soinum_;
}
inline void AudioAvailable::set_soinum(const ::std::string& value) {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  soinum_->assign(value);
}
inline void AudioAvailable::set_soinum(const char* value) {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  soinum_->assign(value);
}
inline void AudioAvailable::set_soinum(const char* value, size_t size) {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  soinum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AudioAvailable::mutable_soinum() {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  return soinum_;
}
inline ::std::string* AudioAvailable::release_soinum() {
  clear_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = soinum_;
    soinum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AudioAvailable::set_allocated_soinum(::std::string* soinum) {
  if (soinum_ != &::google::protobuf::internal::kEmptyString) {
    delete soinum_;
  }
  if (soinum) {
    set_has_soinum();
    soinum_ = soinum;
  } else {
    clear_has_soinum();
    soinum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DmrMeta

// optional string msgName = 1 [default = "DMR_META"];
inline bool DmrMeta::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DmrMeta::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DmrMeta::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DmrMeta::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& DmrMeta::msgname() const {
  return *msgname_;
}
inline void DmrMeta::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void DmrMeta::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void DmrMeta::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DmrMeta::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* DmrMeta::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void DmrMeta::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional double centerFreqMHz = 2;
inline bool DmrMeta::has_centerfreqmhz() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DmrMeta::set_has_centerfreqmhz() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DmrMeta::clear_has_centerfreqmhz() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DmrMeta::clear_centerfreqmhz() {
  centerfreqmhz_ = 0;
  clear_has_centerfreqmhz();
}
inline double DmrMeta::centerfreqmhz() const {
  return centerfreqmhz_;
}
inline void DmrMeta::set_centerfreqmhz(double value) {
  set_has_centerfreqmhz();
  centerfreqmhz_ = value;
}

// optional string srcType = 3;
inline bool DmrMeta::has_srctype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DmrMeta::set_has_srctype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DmrMeta::clear_has_srctype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DmrMeta::clear_srctype() {
  if (srctype_ != &::google::protobuf::internal::kEmptyString) {
    srctype_->clear();
  }
  clear_has_srctype();
}
inline const ::std::string& DmrMeta::srctype() const {
  return *srctype_;
}
inline void DmrMeta::set_srctype(const ::std::string& value) {
  set_has_srctype();
  if (srctype_ == &::google::protobuf::internal::kEmptyString) {
    srctype_ = new ::std::string;
  }
  srctype_->assign(value);
}
inline void DmrMeta::set_srctype(const char* value) {
  set_has_srctype();
  if (srctype_ == &::google::protobuf::internal::kEmptyString) {
    srctype_ = new ::std::string;
  }
  srctype_->assign(value);
}
inline void DmrMeta::set_srctype(const char* value, size_t size) {
  set_has_srctype();
  if (srctype_ == &::google::protobuf::internal::kEmptyString) {
    srctype_ = new ::std::string;
  }
  srctype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DmrMeta::mutable_srctype() {
  set_has_srctype();
  if (srctype_ == &::google::protobuf::internal::kEmptyString) {
    srctype_ = new ::std::string;
  }
  return srctype_;
}
inline ::std::string* DmrMeta::release_srctype() {
  clear_has_srctype();
  if (srctype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srctype_;
    srctype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DmrMeta::set_allocated_srctype(::std::string* srctype) {
  if (srctype_ != &::google::protobuf::internal::kEmptyString) {
    delete srctype_;
  }
  if (srctype) {
    set_has_srctype();
    srctype_ = srctype;
  } else {
    clear_has_srctype();
    srctype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 srcAddr = 4;
inline bool DmrMeta::has_srcaddr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DmrMeta::set_has_srcaddr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DmrMeta::clear_has_srcaddr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DmrMeta::clear_srcaddr() {
  srcaddr_ = 0;
  clear_has_srcaddr();
}
inline ::google::protobuf::int32 DmrMeta::srcaddr() const {
  return srcaddr_;
}
inline void DmrMeta::set_srcaddr(::google::protobuf::int32 value) {
  set_has_srcaddr();
  srcaddr_ = value;
}

// optional string destType = 5;
inline bool DmrMeta::has_desttype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DmrMeta::set_has_desttype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DmrMeta::clear_has_desttype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DmrMeta::clear_desttype() {
  if (desttype_ != &::google::protobuf::internal::kEmptyString) {
    desttype_->clear();
  }
  clear_has_desttype();
}
inline const ::std::string& DmrMeta::desttype() const {
  return *desttype_;
}
inline void DmrMeta::set_desttype(const ::std::string& value) {
  set_has_desttype();
  if (desttype_ == &::google::protobuf::internal::kEmptyString) {
    desttype_ = new ::std::string;
  }
  desttype_->assign(value);
}
inline void DmrMeta::set_desttype(const char* value) {
  set_has_desttype();
  if (desttype_ == &::google::protobuf::internal::kEmptyString) {
    desttype_ = new ::std::string;
  }
  desttype_->assign(value);
}
inline void DmrMeta::set_desttype(const char* value, size_t size) {
  set_has_desttype();
  if (desttype_ == &::google::protobuf::internal::kEmptyString) {
    desttype_ = new ::std::string;
  }
  desttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DmrMeta::mutable_desttype() {
  set_has_desttype();
  if (desttype_ == &::google::protobuf::internal::kEmptyString) {
    desttype_ = new ::std::string;
  }
  return desttype_;
}
inline ::std::string* DmrMeta::release_desttype() {
  clear_has_desttype();
  if (desttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desttype_;
    desttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DmrMeta::set_allocated_desttype(::std::string* desttype) {
  if (desttype_ != &::google::protobuf::internal::kEmptyString) {
    delete desttype_;
  }
  if (desttype) {
    set_has_desttype();
    desttype_ = desttype;
  } else {
    clear_has_desttype();
    desttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 destAddr = 6;
inline bool DmrMeta::has_destaddr() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DmrMeta::set_has_destaddr() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DmrMeta::clear_has_destaddr() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DmrMeta::clear_destaddr() {
  destaddr_ = 0;
  clear_has_destaddr();
}
inline ::google::protobuf::int32 DmrMeta::destaddr() const {
  return destaddr_;
}
inline void DmrMeta::set_destaddr(::google::protobuf::int32 value) {
  set_has_destaddr();
  destaddr_ = value;
}

// optional int32 timeSlot = 7;
inline bool DmrMeta::has_timeslot() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DmrMeta::set_has_timeslot() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DmrMeta::clear_has_timeslot() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DmrMeta::clear_timeslot() {
  timeslot_ = 0;
  clear_has_timeslot();
}
inline ::google::protobuf::int32 DmrMeta::timeslot() const {
  return timeslot_;
}
inline void DmrMeta::set_timeslot(::google::protobuf::int32 value) {
  set_has_timeslot();
  timeslot_ = value;
}

// optional string callType = 8;
inline bool DmrMeta::has_calltype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DmrMeta::set_has_calltype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DmrMeta::clear_has_calltype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DmrMeta::clear_calltype() {
  if (calltype_ != &::google::protobuf::internal::kEmptyString) {
    calltype_->clear();
  }
  clear_has_calltype();
}
inline const ::std::string& DmrMeta::calltype() const {
  return *calltype_;
}
inline void DmrMeta::set_calltype(const ::std::string& value) {
  set_has_calltype();
  if (calltype_ == &::google::protobuf::internal::kEmptyString) {
    calltype_ = new ::std::string;
  }
  calltype_->assign(value);
}
inline void DmrMeta::set_calltype(const char* value) {
  set_has_calltype();
  if (calltype_ == &::google::protobuf::internal::kEmptyString) {
    calltype_ = new ::std::string;
  }
  calltype_->assign(value);
}
inline void DmrMeta::set_calltype(const char* value, size_t size) {
  set_has_calltype();
  if (calltype_ == &::google::protobuf::internal::kEmptyString) {
    calltype_ = new ::std::string;
  }
  calltype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DmrMeta::mutable_calltype() {
  set_has_calltype();
  if (calltype_ == &::google::protobuf::internal::kEmptyString) {
    calltype_ = new ::std::string;
  }
  return calltype_;
}
inline ::std::string* DmrMeta::release_calltype() {
  clear_has_calltype();
  if (calltype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = calltype_;
    calltype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DmrMeta::set_allocated_calltype(::std::string* calltype) {
  if (calltype_ != &::google::protobuf::internal::kEmptyString) {
    delete calltype_;
  }
  if (calltype) {
    set_has_calltype();
    calltype_ = calltype;
  } else {
    clear_has_calltype();
    calltype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 colorCode = 9;
inline bool DmrMeta::has_colorcode() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DmrMeta::set_has_colorcode() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DmrMeta::clear_has_colorcode() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DmrMeta::clear_colorcode() {
  colorcode_ = 0;
  clear_has_colorcode();
}
inline ::google::protobuf::int32 DmrMeta::colorcode() const {
  return colorcode_;
}
inline void DmrMeta::set_colorcode(::google::protobuf::int32 value) {
  set_has_colorcode();
  colorcode_ = value;
}

// optional string text = 10;
inline bool DmrMeta::has_text() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DmrMeta::set_has_text() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DmrMeta::clear_has_text() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DmrMeta::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& DmrMeta::text() const {
  return *text_;
}
inline void DmrMeta::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void DmrMeta::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void DmrMeta::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DmrMeta::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* DmrMeta::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DmrMeta::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .falcon_common_msg.GeodeticPosition geo = 11;
inline bool DmrMeta::has_geo() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DmrMeta::set_has_geo() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DmrMeta::clear_has_geo() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DmrMeta::clear_geo() {
  if (geo_ != NULL) geo_->::falcon_common_msg::GeodeticPosition::Clear();
  clear_has_geo();
}
inline const ::falcon_common_msg::GeodeticPosition& DmrMeta::geo() const {
  return geo_ != NULL ? *geo_ : *default_instance_->geo_;
}
inline ::falcon_common_msg::GeodeticPosition* DmrMeta::mutable_geo() {
  set_has_geo();
  if (geo_ == NULL) geo_ = new ::falcon_common_msg::GeodeticPosition;
  return geo_;
}
inline ::falcon_common_msg::GeodeticPosition* DmrMeta::release_geo() {
  clear_has_geo();
  ::falcon_common_msg::GeodeticPosition* temp = geo_;
  geo_ = NULL;
  return temp;
}
inline void DmrMeta::set_allocated_geo(::falcon_common_msg::GeodeticPosition* geo) {
  delete geo_;
  geo_ = geo;
  if (geo) {
    set_has_geo();
  } else {
    clear_has_geo();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace es_product_msg

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::es_product_msg::SignalEvent_Type>() {
  return ::es_product_msg::SignalEvent_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::es_product_msg::ExternalHit_Type>() {
  return ::es_product_msg::ExternalHit_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::es_product_msg::FisD_FileType>() {
  return ::es_product_msg::FisD_FileType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::es_product_msg::ImageAvailable_Status>() {
  return ::es_product_msg::ImageAvailable_Status_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::es_product_msg::AudioAvailable_Status>() {
  return ::es_product_msg::AudioAvailable_Status_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ESProductMessages_2eproto__INCLUDED
