// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FalconVcnMessages.proto

#ifndef PROTOBUF_FalconVcnMessages_2eproto__INCLUDED
#define PROTOBUF_FalconVcnMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace fv {
namespace vcn {
namespace protos {
namespace VcnProtos {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_FalconVcnMessages_2eproto();
void protobuf_AssignDesc_FalconVcnMessages_2eproto();
void protobuf_ShutdownFile_FalconVcnMessages_2eproto();

class Signal;
class Suggestion;
class VcnPlatform;
class HardwareStatus;
class VcnStatus;
class VcnPlatformRequest;
class VcnStatusRequest;
class VcnCommandRequest;
class VcnOutput;
class VcnResponse;
class ZapperStatus;
class StopAll;
class ToneJam;
class ToneJamOff;
class Zap;
class ZapOff;
class Detect;
class ZapperOptions;
class ZapPing;
class ZapPong;
class InfoMsg;

enum HardwareStatus_HardwareState {
  HardwareStatus_HardwareState_READY = 0,
  HardwareStatus_HardwareState_NOT_READY = 1,
  HardwareStatus_HardwareState_NOT_INSTALLED = 3
};
bool HardwareStatus_HardwareState_IsValid(int value);
const HardwareStatus_HardwareState HardwareStatus_HardwareState_HardwareState_MIN = HardwareStatus_HardwareState_READY;
const HardwareStatus_HardwareState HardwareStatus_HardwareState_HardwareState_MAX = HardwareStatus_HardwareState_NOT_INSTALLED;
const int HardwareStatus_HardwareState_HardwareState_ARRAYSIZE = HardwareStatus_HardwareState_HardwareState_MAX + 1;

const ::google::protobuf::EnumDescriptor* HardwareStatus_HardwareState_descriptor();
inline const ::std::string& HardwareStatus_HardwareState_Name(HardwareStatus_HardwareState value) {
  return ::google::protobuf::internal::NameOfEnum(
    HardwareStatus_HardwareState_descriptor(), value);
}
inline bool HardwareStatus_HardwareState_Parse(
    const ::std::string& name, HardwareStatus_HardwareState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HardwareStatus_HardwareState>(
    HardwareStatus_HardwareState_descriptor(), name, value);
}
// ===================================================================

class Signal : public ::google::protobuf::Message {
 public:
  Signal();
  virtual ~Signal();

  Signal(const Signal& from);

  inline Signal& operator=(const Signal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Signal& default_instance();

  void Swap(Signal* other);

  // implements Message ----------------------------------------------

  Signal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Signal& from);
  void MergeFrom(const Signal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string signal_name = 1;
  inline bool has_signal_name() const;
  inline void clear_signal_name();
  static const int kSignalNameFieldNumber = 1;
  inline const ::std::string& signal_name() const;
  inline void set_signal_name(const ::std::string& value);
  inline void set_signal_name(const char* value);
  inline void set_signal_name(const char* value, size_t size);
  inline ::std::string* mutable_signal_name();
  inline ::std::string* release_signal_name();
  inline void set_allocated_signal_name(::std::string* signal_name);

  // repeated string command = 2;
  inline int command_size() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 2;
  inline const ::std::string& command(int index) const;
  inline ::std::string* mutable_command(int index);
  inline void set_command(int index, const ::std::string& value);
  inline void set_command(int index, const char* value);
  inline void set_command(int index, const char* value, size_t size);
  inline ::std::string* add_command();
  inline void add_command(const ::std::string& value);
  inline void add_command(const char* value);
  inline void add_command(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& command() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_command();

  // repeated .fv.vcn.protos.VcnProtos.Suggestion suggestion = 3;
  inline int suggestion_size() const;
  inline void clear_suggestion();
  static const int kSuggestionFieldNumber = 3;
  inline const ::fv::vcn::protos::VcnProtos::Suggestion& suggestion(int index) const;
  inline ::fv::vcn::protos::VcnProtos::Suggestion* mutable_suggestion(int index);
  inline ::fv::vcn::protos::VcnProtos::Suggestion* add_suggestion();
  inline const ::google::protobuf::RepeatedPtrField< ::fv::vcn::protos::VcnProtos::Suggestion >&
      suggestion() const;
  inline ::google::protobuf::RepeatedPtrField< ::fv::vcn::protos::VcnProtos::Suggestion >*
      mutable_suggestion();

  // @@protoc_insertion_point(class_scope:fv.vcn.protos.VcnProtos.Signal)
 private:
  inline void set_has_signal_name();
  inline void clear_has_signal_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* signal_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> command_;
  ::google::protobuf::RepeatedPtrField< ::fv::vcn::protos::VcnProtos::Suggestion > suggestion_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconVcnMessages_2eproto();
  friend void protobuf_AssignDesc_FalconVcnMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconVcnMessages_2eproto();

  void InitAsDefaultInstance();
  static Signal* default_instance_;
};
// -------------------------------------------------------------------

class Suggestion : public ::google::protobuf::Message {
 public:
  Suggestion();
  virtual ~Suggestion();

  Suggestion(const Suggestion& from);

  inline Suggestion& operator=(const Suggestion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Suggestion& default_instance();

  void Swap(Suggestion* other);

  // implements Message ----------------------------------------------

  Suggestion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Suggestion& from);
  void MergeFrom(const Suggestion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double detected_center_frequency = 1;
  inline bool has_detected_center_frequency() const;
  inline void clear_detected_center_frequency();
  static const int kDetectedCenterFrequencyFieldNumber = 1;
  inline double detected_center_frequency() const;
  inline void set_detected_center_frequency(double value);

  // optional double center_frequency = 2;
  inline bool has_center_frequency() const;
  inline void clear_center_frequency();
  static const int kCenterFrequencyFieldNumber = 2;
  inline double center_frequency() const;
  inline void set_center_frequency(double value);

  // optional double frequency_excursion = 3;
  inline bool has_frequency_excursion() const;
  inline void clear_frequency_excursion();
  static const int kFrequencyExcursionFieldNumber = 3;
  inline double frequency_excursion() const;
  inline void set_frequency_excursion(double value);

  // @@protoc_insertion_point(class_scope:fv.vcn.protos.VcnProtos.Suggestion)
 private:
  inline void set_has_detected_center_frequency();
  inline void clear_has_detected_center_frequency();
  inline void set_has_center_frequency();
  inline void clear_has_center_frequency();
  inline void set_has_frequency_excursion();
  inline void clear_has_frequency_excursion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double detected_center_frequency_;
  double center_frequency_;
  double frequency_excursion_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconVcnMessages_2eproto();
  friend void protobuf_AssignDesc_FalconVcnMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconVcnMessages_2eproto();

  void InitAsDefaultInstance();
  static Suggestion* default_instance_;
};
// -------------------------------------------------------------------

class VcnPlatform : public ::google::protobuf::Message {
 public:
  VcnPlatform();
  virtual ~VcnPlatform();

  VcnPlatform(const VcnPlatform& from);

  inline VcnPlatform& operator=(const VcnPlatform& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VcnPlatform& default_instance();

  void Swap(VcnPlatform* other);

  // implements Message ----------------------------------------------

  VcnPlatform* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VcnPlatform& from);
  void MergeFrom(const VcnPlatform& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fv.vcn.protos.VcnProtos.Signal signal = 1;
  inline int signal_size() const;
  inline void clear_signal();
  static const int kSignalFieldNumber = 1;
  inline const ::fv::vcn::protos::VcnProtos::Signal& signal(int index) const;
  inline ::fv::vcn::protos::VcnProtos::Signal* mutable_signal(int index);
  inline ::fv::vcn::protos::VcnProtos::Signal* add_signal();
  inline const ::google::protobuf::RepeatedPtrField< ::fv::vcn::protos::VcnProtos::Signal >&
      signal() const;
  inline ::google::protobuf::RepeatedPtrField< ::fv::vcn::protos::VcnProtos::Signal >*
      mutable_signal();

  // @@protoc_insertion_point(class_scope:fv.vcn.protos.VcnProtos.VcnPlatform)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::fv::vcn::protos::VcnProtos::Signal > signal_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_FalconVcnMessages_2eproto();
  friend void protobuf_AssignDesc_FalconVcnMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconVcnMessages_2eproto();

  void InitAsDefaultInstance();
  static VcnPlatform* default_instance_;
};
// -------------------------------------------------------------------

class HardwareStatus : public ::google::protobuf::Message {
 public:
  HardwareStatus();
  virtual ~HardwareStatus();

  HardwareStatus(const HardwareStatus& from);

  inline HardwareStatus& operator=(const HardwareStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HardwareStatus& default_instance();

  void Swap(HardwareStatus* other);

  // implements Message ----------------------------------------------

  HardwareStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HardwareStatus& from);
  void MergeFrom(const HardwareStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef HardwareStatus_HardwareState HardwareState;
  static const HardwareState READY = HardwareStatus_HardwareState_READY;
  static const HardwareState NOT_READY = HardwareStatus_HardwareState_NOT_READY;
  static const HardwareState NOT_INSTALLED = HardwareStatus_HardwareState_NOT_INSTALLED;
  static inline bool HardwareState_IsValid(int value) {
    return HardwareStatus_HardwareState_IsValid(value);
  }
  static const HardwareState HardwareState_MIN =
    HardwareStatus_HardwareState_HardwareState_MIN;
  static const HardwareState HardwareState_MAX =
    HardwareStatus_HardwareState_HardwareState_MAX;
  static const int HardwareState_ARRAYSIZE =
    HardwareStatus_HardwareState_HardwareState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HardwareState_descriptor() {
    return HardwareStatus_HardwareState_descriptor();
  }
  static inline const ::std::string& HardwareState_Name(HardwareState value) {
    return HardwareStatus_HardwareState_Name(value);
  }
  static inline bool HardwareState_Parse(const ::std::string& name,
      HardwareState* value) {
    return HardwareStatus_HardwareState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .fv.vcn.protos.VcnProtos.HardwareStatus.HardwareState mta_status = 1;
  inline bool has_mta_status() const;
  inline void clear_mta_status();
  static const int kMtaStatusFieldNumber = 1;
  inline ::fv::vcn::protos::VcnProtos::HardwareStatus_HardwareState mta_status() const;
  inline void set_mta_status(::fv::vcn::protos::VcnProtos::HardwareStatus_HardwareState value);

  // optional bool is_sg_ready = 2;
  inline bool has_is_sg_ready() const;
  inline void clear_is_sg_ready();
  static const int kIsSgReadyFieldNumber = 2;
  inline bool is_sg_ready() const;
  inline void set_is_sg_ready(bool value);

  // required string message = 4;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 4;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:fv.vcn.protos.VcnProtos.HardwareStatus)
 private:
  inline void set_has_mta_status();
  inline void clear_has_mta_status();
  inline void set_has_is_sg_ready();
  inline void clear_has_is_sg_ready();
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int mta_status_;
  bool is_sg_ready_;
  ::std::string* message_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconVcnMessages_2eproto();
  friend void protobuf_AssignDesc_FalconVcnMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconVcnMessages_2eproto();

  void InitAsDefaultInstance();
  static HardwareStatus* default_instance_;
};
// -------------------------------------------------------------------

class VcnStatus : public ::google::protobuf::Message {
 public:
  VcnStatus();
  virtual ~VcnStatus();

  VcnStatus(const VcnStatus& from);

  inline VcnStatus& operator=(const VcnStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VcnStatus& default_instance();

  void Swap(VcnStatus* other);

  // implements Message ----------------------------------------------

  VcnStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VcnStatus& from);
  void MergeFrom(const VcnStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .fv.vcn.protos.VcnProtos.HardwareStatus hardware_status = 1;
  inline bool has_hardware_status() const;
  inline void clear_hardware_status();
  static const int kHardwareStatusFieldNumber = 1;
  inline const ::fv::vcn::protos::VcnProtos::HardwareStatus& hardware_status() const;
  inline ::fv::vcn::protos::VcnProtos::HardwareStatus* mutable_hardware_status();
  inline ::fv::vcn::protos::VcnProtos::HardwareStatus* release_hardware_status();
  inline void set_allocated_hardware_status(::fv::vcn::protos::VcnProtos::HardwareStatus* hardware_status);

  // required bool is_active = 2;
  inline bool has_is_active() const;
  inline void clear_is_active();
  static const int kIsActiveFieldNumber = 2;
  inline bool is_active() const;
  inline void set_is_active(bool value);

  // @@protoc_insertion_point(class_scope:fv.vcn.protos.VcnProtos.VcnStatus)
 private:
  inline void set_has_hardware_status();
  inline void clear_has_hardware_status();
  inline void set_has_is_active();
  inline void clear_has_is_active();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::fv::vcn::protos::VcnProtos::HardwareStatus* hardware_status_;
  bool is_active_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconVcnMessages_2eproto();
  friend void protobuf_AssignDesc_FalconVcnMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconVcnMessages_2eproto();

  void InitAsDefaultInstance();
  static VcnStatus* default_instance_;
};
// -------------------------------------------------------------------

class VcnPlatformRequest : public ::google::protobuf::Message {
 public:
  VcnPlatformRequest();
  virtual ~VcnPlatformRequest();

  VcnPlatformRequest(const VcnPlatformRequest& from);

  inline VcnPlatformRequest& operator=(const VcnPlatformRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VcnPlatformRequest& default_instance();

  void Swap(VcnPlatformRequest* other);

  // implements Message ----------------------------------------------

  VcnPlatformRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VcnPlatformRequest& from);
  void MergeFrom(const VcnPlatformRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fv.vcn.protos.VcnProtos.VcnPlatformRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_FalconVcnMessages_2eproto();
  friend void protobuf_AssignDesc_FalconVcnMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconVcnMessages_2eproto();

  void InitAsDefaultInstance();
  static VcnPlatformRequest* default_instance_;
};
// -------------------------------------------------------------------

class VcnStatusRequest : public ::google::protobuf::Message {
 public:
  VcnStatusRequest();
  virtual ~VcnStatusRequest();

  VcnStatusRequest(const VcnStatusRequest& from);

  inline VcnStatusRequest& operator=(const VcnStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VcnStatusRequest& default_instance();

  void Swap(VcnStatusRequest* other);

  // implements Message ----------------------------------------------

  VcnStatusRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VcnStatusRequest& from);
  void MergeFrom(const VcnStatusRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fv.vcn.protos.VcnProtos.VcnStatusRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_FalconVcnMessages_2eproto();
  friend void protobuf_AssignDesc_FalconVcnMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconVcnMessages_2eproto();

  void InitAsDefaultInstance();
  static VcnStatusRequest* default_instance_;
};
// -------------------------------------------------------------------

class VcnCommandRequest : public ::google::protobuf::Message {
 public:
  VcnCommandRequest();
  virtual ~VcnCommandRequest();

  VcnCommandRequest(const VcnCommandRequest& from);

  inline VcnCommandRequest& operator=(const VcnCommandRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VcnCommandRequest& default_instance();

  void Swap(VcnCommandRequest* other);

  // implements Message ----------------------------------------------

  VcnCommandRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VcnCommandRequest& from);
  void MergeFrom(const VcnCommandRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string signal = 2;
  inline bool has_signal() const;
  inline void clear_signal();
  static const int kSignalFieldNumber = 2;
  inline const ::std::string& signal() const;
  inline void set_signal(const ::std::string& value);
  inline void set_signal(const char* value);
  inline void set_signal(const char* value, size_t size);
  inline ::std::string* mutable_signal();
  inline ::std::string* release_signal();
  inline void set_allocated_signal(::std::string* signal);

  // required string command = 3;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 3;
  inline const ::std::string& command() const;
  inline void set_command(const ::std::string& value);
  inline void set_command(const char* value);
  inline void set_command(const char* value, size_t size);
  inline ::std::string* mutable_command();
  inline ::std::string* release_command();
  inline void set_allocated_command(::std::string* command);

  // required double center_frequency = 4;
  inline bool has_center_frequency() const;
  inline void clear_center_frequency();
  static const int kCenterFrequencyFieldNumber = 4;
  inline double center_frequency() const;
  inline void set_center_frequency(double value);

  // optional double frequency_excursion = 5 [default = 0];
  inline bool has_frequency_excursion() const;
  inline void clear_frequency_excursion();
  static const int kFrequencyExcursionFieldNumber = 5;
  inline double frequency_excursion() const;
  inline void set_frequency_excursion(double value);

  // @@protoc_insertion_point(class_scope:fv.vcn.protos.VcnProtos.VcnCommandRequest)
 private:
  inline void set_has_signal();
  inline void clear_has_signal();
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_center_frequency();
  inline void clear_has_center_frequency();
  inline void set_has_frequency_excursion();
  inline void clear_has_frequency_excursion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* signal_;
  ::std::string* command_;
  double center_frequency_;
  double frequency_excursion_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_FalconVcnMessages_2eproto();
  friend void protobuf_AssignDesc_FalconVcnMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconVcnMessages_2eproto();

  void InitAsDefaultInstance();
  static VcnCommandRequest* default_instance_;
};
// -------------------------------------------------------------------

class VcnOutput : public ::google::protobuf::Message {
 public:
  VcnOutput();
  virtual ~VcnOutput();

  VcnOutput(const VcnOutput& from);

  inline VcnOutput& operator=(const VcnOutput& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VcnOutput& default_instance();

  void Swap(VcnOutput* other);

  // implements Message ----------------------------------------------

  VcnOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VcnOutput& from);
  void MergeFrom(const VcnOutput& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline bool state() const;
  inline void set_state(bool value);

  // @@protoc_insertion_point(class_scope:fv.vcn.protos.VcnProtos.VcnOutput)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_FalconVcnMessages_2eproto();
  friend void protobuf_AssignDesc_FalconVcnMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconVcnMessages_2eproto();

  void InitAsDefaultInstance();
  static VcnOutput* default_instance_;
};
// -------------------------------------------------------------------

class VcnResponse : public ::google::protobuf::Message {
 public:
  VcnResponse();
  virtual ~VcnResponse();

  VcnResponse(const VcnResponse& from);

  inline VcnResponse& operator=(const VcnResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VcnResponse& default_instance();

  void Swap(VcnResponse* other);

  // implements Message ----------------------------------------------

  VcnResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VcnResponse& from);
  void MergeFrom(const VcnResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);

  // optional string description = 2;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 2;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // @@protoc_insertion_point(class_scope:fv.vcn.protos.VcnProtos.VcnResponse)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_description();
  inline void clear_has_description();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* description_;
  bool success_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconVcnMessages_2eproto();
  friend void protobuf_AssignDesc_FalconVcnMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconVcnMessages_2eproto();

  void InitAsDefaultInstance();
  static VcnResponse* default_instance_;
};
// -------------------------------------------------------------------

class ZapperStatus : public ::google::protobuf::Message {
 public:
  ZapperStatus();
  virtual ~ZapperStatus();

  ZapperStatus(const ZapperStatus& from);

  inline ZapperStatus& operator=(const ZapperStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ZapperStatus& default_instance();

  void Swap(ZapperStatus* other);

  // implements Message ----------------------------------------------

  ZapperStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ZapperStatus& from);
  void MergeFrom(const ZapperStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ZAPPERSTAT"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string chan1Stat = 2 [default = "OFF"];
  inline bool has_chan1stat() const;
  inline void clear_chan1stat();
  static const int kChan1StatFieldNumber = 2;
  inline const ::std::string& chan1stat() const;
  inline void set_chan1stat(const ::std::string& value);
  inline void set_chan1stat(const char* value);
  inline void set_chan1stat(const char* value, size_t size);
  inline ::std::string* mutable_chan1stat();
  inline ::std::string* release_chan1stat();
  inline void set_allocated_chan1stat(::std::string* chan1stat);

  // optional string chan2Stat = 3 [default = "OFF"];
  inline bool has_chan2stat() const;
  inline void clear_chan2stat();
  static const int kChan2StatFieldNumber = 3;
  inline const ::std::string& chan2stat() const;
  inline void set_chan2stat(const ::std::string& value);
  inline void set_chan2stat(const char* value);
  inline void set_chan2stat(const char* value, size_t size);
  inline ::std::string* mutable_chan2stat();
  inline ::std::string* release_chan2stat();
  inline void set_allocated_chan2stat(::std::string* chan2stat);

  // optional string rx1Freq = 4 [default = "2440"];
  inline bool has_rx1freq() const;
  inline void clear_rx1freq();
  static const int kRx1FreqFieldNumber = 4;
  inline const ::std::string& rx1freq() const;
  inline void set_rx1freq(const ::std::string& value);
  inline void set_rx1freq(const char* value);
  inline void set_rx1freq(const char* value, size_t size);
  inline ::std::string* mutable_rx1freq();
  inline ::std::string* release_rx1freq();
  inline void set_allocated_rx1freq(::std::string* rx1freq);

  // optional string rx2Freq = 5 [default = "2440"];
  inline bool has_rx2freq() const;
  inline void clear_rx2freq();
  static const int kRx2FreqFieldNumber = 5;
  inline const ::std::string& rx2freq() const;
  inline void set_rx2freq(const ::std::string& value);
  inline void set_rx2freq(const char* value);
  inline void set_rx2freq(const char* value, size_t size);
  inline ::std::string* mutable_rx2freq();
  inline ::std::string* release_rx2freq();
  inline void set_allocated_rx2freq(::std::string* rx2freq);

  // optional string rx3Freq = 6 [default = "2440"];
  inline bool has_rx3freq() const;
  inline void clear_rx3freq();
  static const int kRx3FreqFieldNumber = 6;
  inline const ::std::string& rx3freq() const;
  inline void set_rx3freq(const ::std::string& value);
  inline void set_rx3freq(const char* value);
  inline void set_rx3freq(const char* value, size_t size);
  inline ::std::string* mutable_rx3freq();
  inline ::std::string* release_rx3freq();
  inline void set_allocated_rx3freq(::std::string* rx3freq);

  // optional string rx4Freq = 7 [default = "2440"];
  inline bool has_rx4freq() const;
  inline void clear_rx4freq();
  static const int kRx4FreqFieldNumber = 7;
  inline const ::std::string& rx4freq() const;
  inline void set_rx4freq(const ::std::string& value);
  inline void set_rx4freq(const char* value);
  inline void set_rx4freq(const char* value, size_t size);
  inline ::std::string* mutable_rx4freq();
  inline ::std::string* release_rx4freq();
  inline void set_allocated_rx4freq(::std::string* rx4freq);

  // optional string tx1Freq = 8 [default = "2440"];
  inline bool has_tx1freq() const;
  inline void clear_tx1freq();
  static const int kTx1FreqFieldNumber = 8;
  inline const ::std::string& tx1freq() const;
  inline void set_tx1freq(const ::std::string& value);
  inline void set_tx1freq(const char* value);
  inline void set_tx1freq(const char* value, size_t size);
  inline ::std::string* mutable_tx1freq();
  inline ::std::string* release_tx1freq();
  inline void set_allocated_tx1freq(::std::string* tx1freq);

  // optional string tx2Freq = 9 [default = "2440"];
  inline bool has_tx2freq() const;
  inline void clear_tx2freq();
  static const int kTx2FreqFieldNumber = 9;
  inline const ::std::string& tx2freq() const;
  inline void set_tx2freq(const ::std::string& value);
  inline void set_tx2freq(const char* value);
  inline void set_tx2freq(const char* value, size_t size);
  inline ::std::string* mutable_tx2freq();
  inline ::std::string* release_tx2freq();
  inline void set_allocated_tx2freq(::std::string* tx2freq);

  // optional string amp1 = 10 [default = "0"];
  inline bool has_amp1() const;
  inline void clear_amp1();
  static const int kAmp1FieldNumber = 10;
  inline const ::std::string& amp1() const;
  inline void set_amp1(const ::std::string& value);
  inline void set_amp1(const char* value);
  inline void set_amp1(const char* value, size_t size);
  inline ::std::string* mutable_amp1();
  inline ::std::string* release_amp1();
  inline void set_allocated_amp1(::std::string* amp1);

  // optional string amp2 = 11 [default = "0"];
  inline bool has_amp2() const;
  inline void clear_amp2();
  static const int kAmp2FieldNumber = 11;
  inline const ::std::string& amp2() const;
  inline void set_amp2(const ::std::string& value);
  inline void set_amp2(const char* value);
  inline void set_amp2(const char* value, size_t size);
  inline ::std::string* mutable_amp2();
  inline ::std::string* release_amp2();
  inline void set_allocated_amp2(::std::string* amp2);

  // optional string amp3 = 12 [default = "0"];
  inline bool has_amp3() const;
  inline void clear_amp3();
  static const int kAmp3FieldNumber = 12;
  inline const ::std::string& amp3() const;
  inline void set_amp3(const ::std::string& value);
  inline void set_amp3(const char* value);
  inline void set_amp3(const char* value, size_t size);
  inline ::std::string* mutable_amp3();
  inline ::std::string* release_amp3();
  inline void set_allocated_amp3(::std::string* amp3);

  // optional string meterChan = 13 [default = "-1"];
  inline bool has_meterchan() const;
  inline void clear_meterchan();
  static const int kMeterChanFieldNumber = 13;
  inline const ::std::string& meterchan() const;
  inline void set_meterchan(const ::std::string& value);
  inline void set_meterchan(const char* value);
  inline void set_meterchan(const char* value, size_t size);
  inline ::std::string* mutable_meterchan();
  inline ::std::string* release_meterchan();
  inline void set_allocated_meterchan(::std::string* meterchan);

  // optional string meterPower = 14 [default = "-99"];
  inline bool has_meterpower() const;
  inline void clear_meterpower();
  static const int kMeterPowerFieldNumber = 14;
  inline const ::std::string& meterpower() const;
  inline void set_meterpower(const ::std::string& value);
  inline void set_meterpower(const char* value);
  inline void set_meterpower(const char* value, size_t size);
  inline ::std::string* mutable_meterpower();
  inline ::std::string* release_meterpower();
  inline void set_allocated_meterpower(::std::string* meterpower);

  // @@protoc_insertion_point(class_scope:fv.vcn.protos.VcnProtos.ZapperStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_chan1stat();
  inline void clear_has_chan1stat();
  inline void set_has_chan2stat();
  inline void clear_has_chan2stat();
  inline void set_has_rx1freq();
  inline void clear_has_rx1freq();
  inline void set_has_rx2freq();
  inline void clear_has_rx2freq();
  inline void set_has_rx3freq();
  inline void clear_has_rx3freq();
  inline void set_has_rx4freq();
  inline void clear_has_rx4freq();
  inline void set_has_tx1freq();
  inline void clear_has_tx1freq();
  inline void set_has_tx2freq();
  inline void clear_has_tx2freq();
  inline void set_has_amp1();
  inline void clear_has_amp1();
  inline void set_has_amp2();
  inline void clear_has_amp2();
  inline void set_has_amp3();
  inline void clear_has_amp3();
  inline void set_has_meterchan();
  inline void clear_has_meterchan();
  inline void set_has_meterpower();
  inline void clear_has_meterpower();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* chan1stat_;
  static ::std::string* _default_chan1stat_;
  ::std::string* chan2stat_;
  static ::std::string* _default_chan2stat_;
  ::std::string* rx1freq_;
  static ::std::string* _default_rx1freq_;
  ::std::string* rx2freq_;
  static ::std::string* _default_rx2freq_;
  ::std::string* rx3freq_;
  static ::std::string* _default_rx3freq_;
  ::std::string* rx4freq_;
  static ::std::string* _default_rx4freq_;
  ::std::string* tx1freq_;
  static ::std::string* _default_tx1freq_;
  ::std::string* tx2freq_;
  static ::std::string* _default_tx2freq_;
  ::std::string* amp1_;
  static ::std::string* _default_amp1_;
  ::std::string* amp2_;
  static ::std::string* _default_amp2_;
  ::std::string* amp3_;
  static ::std::string* _default_amp3_;
  ::std::string* meterchan_;
  static ::std::string* _default_meterchan_;
  ::std::string* meterpower_;
  static ::std::string* _default_meterpower_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_FalconVcnMessages_2eproto();
  friend void protobuf_AssignDesc_FalconVcnMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconVcnMessages_2eproto();

  void InitAsDefaultInstance();
  static ZapperStatus* default_instance_;
};
// -------------------------------------------------------------------

class StopAll : public ::google::protobuf::Message {
 public:
  StopAll();
  virtual ~StopAll();

  StopAll(const StopAll& from);

  inline StopAll& operator=(const StopAll& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StopAll& default_instance();

  void Swap(StopAll* other);

  // implements Message ----------------------------------------------

  StopAll* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StopAll& from);
  void MergeFrom(const StopAll& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "STOPALL"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // @@protoc_insertion_point(class_scope:fv.vcn.protos.VcnProtos.StopAll)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_FalconVcnMessages_2eproto();
  friend void protobuf_AssignDesc_FalconVcnMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconVcnMessages_2eproto();

  void InitAsDefaultInstance();
  static StopAll* default_instance_;
};
// -------------------------------------------------------------------

class ToneJam : public ::google::protobuf::Message {
 public:
  ToneJam();
  virtual ~ToneJam();

  ToneJam(const ToneJam& from);

  inline ToneJam& operator=(const ToneJam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ToneJam& default_instance();

  void Swap(ToneJam* other);

  // implements Message ----------------------------------------------

  ToneJam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ToneJam& from);
  void MergeFrom(const ToneJam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "TONEJAM"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string platform = 2 [default = "NONE"];
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 2;
  inline const ::std::string& platform() const;
  inline void set_platform(const ::std::string& value);
  inline void set_platform(const char* value);
  inline void set_platform(const char* value, size_t size);
  inline ::std::string* mutable_platform();
  inline ::std::string* release_platform();
  inline void set_allocated_platform(::std::string* platform);

  // optional int32 targetID = 3 [default = -1];
  inline bool has_targetid() const;
  inline void clear_targetid();
  static const int kTargetIDFieldNumber = 3;
  inline ::google::protobuf::int32 targetid() const;
  inline void set_targetid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fv.vcn.protos.VcnProtos.ToneJam)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_targetid();
  inline void clear_has_targetid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* platform_;
  static ::std::string* _default_platform_;
  ::google::protobuf::int32 targetid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconVcnMessages_2eproto();
  friend void protobuf_AssignDesc_FalconVcnMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconVcnMessages_2eproto();

  void InitAsDefaultInstance();
  static ToneJam* default_instance_;
};
// -------------------------------------------------------------------

class ToneJamOff : public ::google::protobuf::Message {
 public:
  ToneJamOff();
  virtual ~ToneJamOff();

  ToneJamOff(const ToneJamOff& from);

  inline ToneJamOff& operator=(const ToneJamOff& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ToneJamOff& default_instance();

  void Swap(ToneJamOff* other);

  // implements Message ----------------------------------------------

  ToneJamOff* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ToneJamOff& from);
  void MergeFrom(const ToneJamOff& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "TONEJAMOFF"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 targetID = 2 [default = -1];
  inline bool has_targetid() const;
  inline void clear_targetid();
  static const int kTargetIDFieldNumber = 2;
  inline ::google::protobuf::int32 targetid() const;
  inline void set_targetid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fv.vcn.protos.VcnProtos.ToneJamOff)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_targetid();
  inline void clear_has_targetid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 targetid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconVcnMessages_2eproto();
  friend void protobuf_AssignDesc_FalconVcnMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconVcnMessages_2eproto();

  void InitAsDefaultInstance();
  static ToneJamOff* default_instance_;
};
// -------------------------------------------------------------------

class Zap : public ::google::protobuf::Message {
 public:
  Zap();
  virtual ~Zap();

  Zap(const Zap& from);

  inline Zap& operator=(const Zap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Zap& default_instance();

  void Swap(Zap* other);

  // implements Message ----------------------------------------------

  Zap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Zap& from);
  void MergeFrom(const Zap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ZAP"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 targetID = 3 [default = -1];
  inline bool has_targetid() const;
  inline void clear_targetid();
  static const int kTargetIDFieldNumber = 3;
  inline ::google::protobuf::int32 targetid() const;
  inline void set_targetid(::google::protobuf::int32 value);

  // optional string platform = 2 [default = "NONE"];
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 2;
  inline const ::std::string& platform() const;
  inline void set_platform(const ::std::string& value);
  inline void set_platform(const char* value);
  inline void set_platform(const char* value, size_t size);
  inline ::std::string* mutable_platform();
  inline ::std::string* release_platform();
  inline void set_allocated_platform(::std::string* platform);

  // @@protoc_insertion_point(class_scope:fv.vcn.protos.VcnProtos.Zap)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_targetid();
  inline void clear_has_targetid();
  inline void set_has_platform();
  inline void clear_has_platform();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* platform_;
  static ::std::string* _default_platform_;
  ::google::protobuf::int32 targetid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconVcnMessages_2eproto();
  friend void protobuf_AssignDesc_FalconVcnMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconVcnMessages_2eproto();

  void InitAsDefaultInstance();
  static Zap* default_instance_;
};
// -------------------------------------------------------------------

class ZapOff : public ::google::protobuf::Message {
 public:
  ZapOff();
  virtual ~ZapOff();

  ZapOff(const ZapOff& from);

  inline ZapOff& operator=(const ZapOff& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ZapOff& default_instance();

  void Swap(ZapOff* other);

  // implements Message ----------------------------------------------

  ZapOff* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ZapOff& from);
  void MergeFrom(const ZapOff& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ZAPOFF"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 targetID = 2 [default = -1];
  inline bool has_targetid() const;
  inline void clear_targetid();
  static const int kTargetIDFieldNumber = 2;
  inline ::google::protobuf::int32 targetid() const;
  inline void set_targetid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fv.vcn.protos.VcnProtos.ZapOff)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_targetid();
  inline void clear_has_targetid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int32 targetid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconVcnMessages_2eproto();
  friend void protobuf_AssignDesc_FalconVcnMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconVcnMessages_2eproto();

  void InitAsDefaultInstance();
  static ZapOff* default_instance_;
};
// -------------------------------------------------------------------

class Detect : public ::google::protobuf::Message {
 public:
  Detect();
  virtual ~Detect();

  Detect(const Detect& from);

  inline Detect& operator=(const Detect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Detect& default_instance();

  void Swap(Detect* other);

  // implements Message ----------------------------------------------

  Detect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Detect& from);
  void MergeFrom(const Detect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "DETECT"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string platform = 2 [default = "NONE"];
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 2;
  inline const ::std::string& platform() const;
  inline void set_platform(const ::std::string& value);
  inline void set_platform(const char* value);
  inline void set_platform(const char* value, size_t size);
  inline ::std::string* mutable_platform();
  inline ::std::string* release_platform();
  inline void set_allocated_platform(::std::string* platform);

  // optional double freq = 3 [default = 2440];
  inline bool has_freq() const;
  inline void clear_freq();
  static const int kFreqFieldNumber = 3;
  inline double freq() const;
  inline void set_freq(double value);

  // @@protoc_insertion_point(class_scope:fv.vcn.protos.VcnProtos.Detect)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_freq();
  inline void clear_has_freq();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* platform_;
  static ::std::string* _default_platform_;
  double freq_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconVcnMessages_2eproto();
  friend void protobuf_AssignDesc_FalconVcnMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconVcnMessages_2eproto();

  void InitAsDefaultInstance();
  static Detect* default_instance_;
};
// -------------------------------------------------------------------

class ZapperOptions : public ::google::protobuf::Message {
 public:
  ZapperOptions();
  virtual ~ZapperOptions();

  ZapperOptions(const ZapperOptions& from);

  inline ZapperOptions& operator=(const ZapperOptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ZapperOptions& default_instance();

  void Swap(ZapperOptions* other);

  // implements Message ----------------------------------------------

  ZapperOptions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ZapperOptions& from);
  void MergeFrom(const ZapperOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ZAPPEROPTIONS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string options = 2 [default = "NONE"];
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 2;
  inline const ::std::string& options() const;
  inline void set_options(const ::std::string& value);
  inline void set_options(const char* value);
  inline void set_options(const char* value, size_t size);
  inline ::std::string* mutable_options();
  inline ::std::string* release_options();
  inline void set_allocated_options(::std::string* options);

  // optional int32 targetID = 3 [default = -1];
  inline bool has_targetid() const;
  inline void clear_targetid();
  static const int kTargetIDFieldNumber = 3;
  inline ::google::protobuf::int32 targetid() const;
  inline void set_targetid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fv.vcn.protos.VcnProtos.ZapperOptions)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_options();
  inline void clear_has_options();
  inline void set_has_targetid();
  inline void clear_has_targetid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* options_;
  static ::std::string* _default_options_;
  ::google::protobuf::int32 targetid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconVcnMessages_2eproto();
  friend void protobuf_AssignDesc_FalconVcnMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconVcnMessages_2eproto();

  void InitAsDefaultInstance();
  static ZapperOptions* default_instance_;
};
// -------------------------------------------------------------------

class ZapPing : public ::google::protobuf::Message {
 public:
  ZapPing();
  virtual ~ZapPing();

  ZapPing(const ZapPing& from);

  inline ZapPing& operator=(const ZapPing& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ZapPing& default_instance();

  void Swap(ZapPing* other);

  // implements Message ----------------------------------------------

  ZapPing* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ZapPing& from);
  void MergeFrom(const ZapPing& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ZAPPING"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // @@protoc_insertion_point(class_scope:fv.vcn.protos.VcnProtos.ZapPing)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_FalconVcnMessages_2eproto();
  friend void protobuf_AssignDesc_FalconVcnMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconVcnMessages_2eproto();

  void InitAsDefaultInstance();
  static ZapPing* default_instance_;
};
// -------------------------------------------------------------------

class ZapPong : public ::google::protobuf::Message {
 public:
  ZapPong();
  virtual ~ZapPong();

  ZapPong(const ZapPong& from);

  inline ZapPong& operator=(const ZapPong& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ZapPong& default_instance();

  void Swap(ZapPong* other);

  // implements Message ----------------------------------------------

  ZapPong* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ZapPong& from);
  void MergeFrom(const ZapPong& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ZAPPONG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // @@protoc_insertion_point(class_scope:fv.vcn.protos.VcnProtos.ZapPong)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_FalconVcnMessages_2eproto();
  friend void protobuf_AssignDesc_FalconVcnMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconVcnMessages_2eproto();

  void InitAsDefaultInstance();
  static ZapPong* default_instance_;
};
// -------------------------------------------------------------------

class InfoMsg : public ::google::protobuf::Message {
 public:
  InfoMsg();
  virtual ~InfoMsg();

  InfoMsg(const InfoMsg& from);

  inline InfoMsg& operator=(const InfoMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InfoMsg& default_instance();

  void Swap(InfoMsg* other);

  // implements Message ----------------------------------------------

  InfoMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InfoMsg& from);
  void MergeFrom(const InfoMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "INFOMSG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string info = 2 [default = "NONE"];
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const char* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  inline void set_allocated_info(::std::string* info);

  // @@protoc_insertion_point(class_scope:fv.vcn.protos.VcnProtos.InfoMsg)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* info_;
  static ::std::string* _default_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconVcnMessages_2eproto();
  friend void protobuf_AssignDesc_FalconVcnMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconVcnMessages_2eproto();

  void InitAsDefaultInstance();
  static InfoMsg* default_instance_;
};
// ===================================================================


// ===================================================================

// Signal

// required string signal_name = 1;
inline bool Signal::has_signal_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Signal::set_has_signal_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Signal::clear_has_signal_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Signal::clear_signal_name() {
  if (signal_name_ != &::google::protobuf::internal::kEmptyString) {
    signal_name_->clear();
  }
  clear_has_signal_name();
}
inline const ::std::string& Signal::signal_name() const {
  return *signal_name_;
}
inline void Signal::set_signal_name(const ::std::string& value) {
  set_has_signal_name();
  if (signal_name_ == &::google::protobuf::internal::kEmptyString) {
    signal_name_ = new ::std::string;
  }
  signal_name_->assign(value);
}
inline void Signal::set_signal_name(const char* value) {
  set_has_signal_name();
  if (signal_name_ == &::google::protobuf::internal::kEmptyString) {
    signal_name_ = new ::std::string;
  }
  signal_name_->assign(value);
}
inline void Signal::set_signal_name(const char* value, size_t size) {
  set_has_signal_name();
  if (signal_name_ == &::google::protobuf::internal::kEmptyString) {
    signal_name_ = new ::std::string;
  }
  signal_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Signal::mutable_signal_name() {
  set_has_signal_name();
  if (signal_name_ == &::google::protobuf::internal::kEmptyString) {
    signal_name_ = new ::std::string;
  }
  return signal_name_;
}
inline ::std::string* Signal::release_signal_name() {
  clear_has_signal_name();
  if (signal_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signal_name_;
    signal_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Signal::set_allocated_signal_name(::std::string* signal_name) {
  if (signal_name_ != &::google::protobuf::internal::kEmptyString) {
    delete signal_name_;
  }
  if (signal_name) {
    set_has_signal_name();
    signal_name_ = signal_name;
  } else {
    clear_has_signal_name();
    signal_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string command = 2;
inline int Signal::command_size() const {
  return command_.size();
}
inline void Signal::clear_command() {
  command_.Clear();
}
inline const ::std::string& Signal::command(int index) const {
  return command_.Get(index);
}
inline ::std::string* Signal::mutable_command(int index) {
  return command_.Mutable(index);
}
inline void Signal::set_command(int index, const ::std::string& value) {
  command_.Mutable(index)->assign(value);
}
inline void Signal::set_command(int index, const char* value) {
  command_.Mutable(index)->assign(value);
}
inline void Signal::set_command(int index, const char* value, size_t size) {
  command_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Signal::add_command() {
  return command_.Add();
}
inline void Signal::add_command(const ::std::string& value) {
  command_.Add()->assign(value);
}
inline void Signal::add_command(const char* value) {
  command_.Add()->assign(value);
}
inline void Signal::add_command(const char* value, size_t size) {
  command_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Signal::command() const {
  return command_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Signal::mutable_command() {
  return &command_;
}

// repeated .fv.vcn.protos.VcnProtos.Suggestion suggestion = 3;
inline int Signal::suggestion_size() const {
  return suggestion_.size();
}
inline void Signal::clear_suggestion() {
  suggestion_.Clear();
}
inline const ::fv::vcn::protos::VcnProtos::Suggestion& Signal::suggestion(int index) const {
  return suggestion_.Get(index);
}
inline ::fv::vcn::protos::VcnProtos::Suggestion* Signal::mutable_suggestion(int index) {
  return suggestion_.Mutable(index);
}
inline ::fv::vcn::protos::VcnProtos::Suggestion* Signal::add_suggestion() {
  return suggestion_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fv::vcn::protos::VcnProtos::Suggestion >&
Signal::suggestion() const {
  return suggestion_;
}
inline ::google::protobuf::RepeatedPtrField< ::fv::vcn::protos::VcnProtos::Suggestion >*
Signal::mutable_suggestion() {
  return &suggestion_;
}

// -------------------------------------------------------------------

// Suggestion

// optional double detected_center_frequency = 1;
inline bool Suggestion::has_detected_center_frequency() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Suggestion::set_has_detected_center_frequency() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Suggestion::clear_has_detected_center_frequency() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Suggestion::clear_detected_center_frequency() {
  detected_center_frequency_ = 0;
  clear_has_detected_center_frequency();
}
inline double Suggestion::detected_center_frequency() const {
  return detected_center_frequency_;
}
inline void Suggestion::set_detected_center_frequency(double value) {
  set_has_detected_center_frequency();
  detected_center_frequency_ = value;
}

// optional double center_frequency = 2;
inline bool Suggestion::has_center_frequency() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Suggestion::set_has_center_frequency() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Suggestion::clear_has_center_frequency() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Suggestion::clear_center_frequency() {
  center_frequency_ = 0;
  clear_has_center_frequency();
}
inline double Suggestion::center_frequency() const {
  return center_frequency_;
}
inline void Suggestion::set_center_frequency(double value) {
  set_has_center_frequency();
  center_frequency_ = value;
}

// optional double frequency_excursion = 3;
inline bool Suggestion::has_frequency_excursion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Suggestion::set_has_frequency_excursion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Suggestion::clear_has_frequency_excursion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Suggestion::clear_frequency_excursion() {
  frequency_excursion_ = 0;
  clear_has_frequency_excursion();
}
inline double Suggestion::frequency_excursion() const {
  return frequency_excursion_;
}
inline void Suggestion::set_frequency_excursion(double value) {
  set_has_frequency_excursion();
  frequency_excursion_ = value;
}

// -------------------------------------------------------------------

// VcnPlatform

// repeated .fv.vcn.protos.VcnProtos.Signal signal = 1;
inline int VcnPlatform::signal_size() const {
  return signal_.size();
}
inline void VcnPlatform::clear_signal() {
  signal_.Clear();
}
inline const ::fv::vcn::protos::VcnProtos::Signal& VcnPlatform::signal(int index) const {
  return signal_.Get(index);
}
inline ::fv::vcn::protos::VcnProtos::Signal* VcnPlatform::mutable_signal(int index) {
  return signal_.Mutable(index);
}
inline ::fv::vcn::protos::VcnProtos::Signal* VcnPlatform::add_signal() {
  return signal_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fv::vcn::protos::VcnProtos::Signal >&
VcnPlatform::signal() const {
  return signal_;
}
inline ::google::protobuf::RepeatedPtrField< ::fv::vcn::protos::VcnProtos::Signal >*
VcnPlatform::mutable_signal() {
  return &signal_;
}

// -------------------------------------------------------------------

// HardwareStatus

// optional .fv.vcn.protos.VcnProtos.HardwareStatus.HardwareState mta_status = 1;
inline bool HardwareStatus::has_mta_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HardwareStatus::set_has_mta_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HardwareStatus::clear_has_mta_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HardwareStatus::clear_mta_status() {
  mta_status_ = 0;
  clear_has_mta_status();
}
inline ::fv::vcn::protos::VcnProtos::HardwareStatus_HardwareState HardwareStatus::mta_status() const {
  return static_cast< ::fv::vcn::protos::VcnProtos::HardwareStatus_HardwareState >(mta_status_);
}
inline void HardwareStatus::set_mta_status(::fv::vcn::protos::VcnProtos::HardwareStatus_HardwareState value) {
  assert(::fv::vcn::protos::VcnProtos::HardwareStatus_HardwareState_IsValid(value));
  set_has_mta_status();
  mta_status_ = value;
}

// optional bool is_sg_ready = 2;
inline bool HardwareStatus::has_is_sg_ready() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HardwareStatus::set_has_is_sg_ready() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HardwareStatus::clear_has_is_sg_ready() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HardwareStatus::clear_is_sg_ready() {
  is_sg_ready_ = false;
  clear_has_is_sg_ready();
}
inline bool HardwareStatus::is_sg_ready() const {
  return is_sg_ready_;
}
inline void HardwareStatus::set_is_sg_ready(bool value) {
  set_has_is_sg_ready();
  is_sg_ready_ = value;
}

// required string message = 4;
inline bool HardwareStatus::has_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HardwareStatus::set_has_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HardwareStatus::clear_has_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HardwareStatus::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& HardwareStatus::message() const {
  return *message_;
}
inline void HardwareStatus::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void HardwareStatus::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void HardwareStatus::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HardwareStatus::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* HardwareStatus::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HardwareStatus::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// VcnStatus

// required .fv.vcn.protos.VcnProtos.HardwareStatus hardware_status = 1;
inline bool VcnStatus::has_hardware_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VcnStatus::set_has_hardware_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VcnStatus::clear_has_hardware_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VcnStatus::clear_hardware_status() {
  if (hardware_status_ != NULL) hardware_status_->::fv::vcn::protos::VcnProtos::HardwareStatus::Clear();
  clear_has_hardware_status();
}
inline const ::fv::vcn::protos::VcnProtos::HardwareStatus& VcnStatus::hardware_status() const {
  return hardware_status_ != NULL ? *hardware_status_ : *default_instance_->hardware_status_;
}
inline ::fv::vcn::protos::VcnProtos::HardwareStatus* VcnStatus::mutable_hardware_status() {
  set_has_hardware_status();
  if (hardware_status_ == NULL) hardware_status_ = new ::fv::vcn::protos::VcnProtos::HardwareStatus;
  return hardware_status_;
}
inline ::fv::vcn::protos::VcnProtos::HardwareStatus* VcnStatus::release_hardware_status() {
  clear_has_hardware_status();
  ::fv::vcn::protos::VcnProtos::HardwareStatus* temp = hardware_status_;
  hardware_status_ = NULL;
  return temp;
}
inline void VcnStatus::set_allocated_hardware_status(::fv::vcn::protos::VcnProtos::HardwareStatus* hardware_status) {
  delete hardware_status_;
  hardware_status_ = hardware_status;
  if (hardware_status) {
    set_has_hardware_status();
  } else {
    clear_has_hardware_status();
  }
}

// required bool is_active = 2;
inline bool VcnStatus::has_is_active() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VcnStatus::set_has_is_active() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VcnStatus::clear_has_is_active() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VcnStatus::clear_is_active() {
  is_active_ = false;
  clear_has_is_active();
}
inline bool VcnStatus::is_active() const {
  return is_active_;
}
inline void VcnStatus::set_is_active(bool value) {
  set_has_is_active();
  is_active_ = value;
}

// -------------------------------------------------------------------

// VcnPlatformRequest

// -------------------------------------------------------------------

// VcnStatusRequest

// -------------------------------------------------------------------

// VcnCommandRequest

// required string signal = 2;
inline bool VcnCommandRequest::has_signal() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VcnCommandRequest::set_has_signal() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VcnCommandRequest::clear_has_signal() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VcnCommandRequest::clear_signal() {
  if (signal_ != &::google::protobuf::internal::kEmptyString) {
    signal_->clear();
  }
  clear_has_signal();
}
inline const ::std::string& VcnCommandRequest::signal() const {
  return *signal_;
}
inline void VcnCommandRequest::set_signal(const ::std::string& value) {
  set_has_signal();
  if (signal_ == &::google::protobuf::internal::kEmptyString) {
    signal_ = new ::std::string;
  }
  signal_->assign(value);
}
inline void VcnCommandRequest::set_signal(const char* value) {
  set_has_signal();
  if (signal_ == &::google::protobuf::internal::kEmptyString) {
    signal_ = new ::std::string;
  }
  signal_->assign(value);
}
inline void VcnCommandRequest::set_signal(const char* value, size_t size) {
  set_has_signal();
  if (signal_ == &::google::protobuf::internal::kEmptyString) {
    signal_ = new ::std::string;
  }
  signal_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VcnCommandRequest::mutable_signal() {
  set_has_signal();
  if (signal_ == &::google::protobuf::internal::kEmptyString) {
    signal_ = new ::std::string;
  }
  return signal_;
}
inline ::std::string* VcnCommandRequest::release_signal() {
  clear_has_signal();
  if (signal_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signal_;
    signal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VcnCommandRequest::set_allocated_signal(::std::string* signal) {
  if (signal_ != &::google::protobuf::internal::kEmptyString) {
    delete signal_;
  }
  if (signal) {
    set_has_signal();
    signal_ = signal;
  } else {
    clear_has_signal();
    signal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string command = 3;
inline bool VcnCommandRequest::has_command() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VcnCommandRequest::set_has_command() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VcnCommandRequest::clear_has_command() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VcnCommandRequest::clear_command() {
  if (command_ != &::google::protobuf::internal::kEmptyString) {
    command_->clear();
  }
  clear_has_command();
}
inline const ::std::string& VcnCommandRequest::command() const {
  return *command_;
}
inline void VcnCommandRequest::set_command(const ::std::string& value) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::kEmptyString) {
    command_ = new ::std::string;
  }
  command_->assign(value);
}
inline void VcnCommandRequest::set_command(const char* value) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::kEmptyString) {
    command_ = new ::std::string;
  }
  command_->assign(value);
}
inline void VcnCommandRequest::set_command(const char* value, size_t size) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::kEmptyString) {
    command_ = new ::std::string;
  }
  command_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VcnCommandRequest::mutable_command() {
  set_has_command();
  if (command_ == &::google::protobuf::internal::kEmptyString) {
    command_ = new ::std::string;
  }
  return command_;
}
inline ::std::string* VcnCommandRequest::release_command() {
  clear_has_command();
  if (command_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = command_;
    command_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VcnCommandRequest::set_allocated_command(::std::string* command) {
  if (command_ != &::google::protobuf::internal::kEmptyString) {
    delete command_;
  }
  if (command) {
    set_has_command();
    command_ = command;
  } else {
    clear_has_command();
    command_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double center_frequency = 4;
inline bool VcnCommandRequest::has_center_frequency() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VcnCommandRequest::set_has_center_frequency() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VcnCommandRequest::clear_has_center_frequency() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VcnCommandRequest::clear_center_frequency() {
  center_frequency_ = 0;
  clear_has_center_frequency();
}
inline double VcnCommandRequest::center_frequency() const {
  return center_frequency_;
}
inline void VcnCommandRequest::set_center_frequency(double value) {
  set_has_center_frequency();
  center_frequency_ = value;
}

// optional double frequency_excursion = 5 [default = 0];
inline bool VcnCommandRequest::has_frequency_excursion() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VcnCommandRequest::set_has_frequency_excursion() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VcnCommandRequest::clear_has_frequency_excursion() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VcnCommandRequest::clear_frequency_excursion() {
  frequency_excursion_ = 0;
  clear_has_frequency_excursion();
}
inline double VcnCommandRequest::frequency_excursion() const {
  return frequency_excursion_;
}
inline void VcnCommandRequest::set_frequency_excursion(double value) {
  set_has_frequency_excursion();
  frequency_excursion_ = value;
}

// -------------------------------------------------------------------

// VcnOutput

// required bool state = 1;
inline bool VcnOutput::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VcnOutput::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VcnOutput::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VcnOutput::clear_state() {
  state_ = false;
  clear_has_state();
}
inline bool VcnOutput::state() const {
  return state_;
}
inline void VcnOutput::set_state(bool value) {
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// VcnResponse

// required bool success = 1;
inline bool VcnResponse::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VcnResponse::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VcnResponse::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VcnResponse::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool VcnResponse::success() const {
  return success_;
}
inline void VcnResponse::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// optional string description = 2;
inline bool VcnResponse::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VcnResponse::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VcnResponse::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VcnResponse::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& VcnResponse::description() const {
  return *description_;
}
inline void VcnResponse::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void VcnResponse::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void VcnResponse::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VcnResponse::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* VcnResponse::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VcnResponse::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ZapperStatus

// optional string msgName = 1 [default = "ZAPPERSTAT"];
inline bool ZapperStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ZapperStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ZapperStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ZapperStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ZapperStatus::msgname() const {
  return *msgname_;
}
inline void ZapperStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ZapperStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ZapperStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZapperStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ZapperStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ZapperStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string chan1Stat = 2 [default = "OFF"];
inline bool ZapperStatus::has_chan1stat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ZapperStatus::set_has_chan1stat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ZapperStatus::clear_has_chan1stat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ZapperStatus::clear_chan1stat() {
  if (chan1stat_ != _default_chan1stat_) {
    chan1stat_->assign(*_default_chan1stat_);
  }
  clear_has_chan1stat();
}
inline const ::std::string& ZapperStatus::chan1stat() const {
  return *chan1stat_;
}
inline void ZapperStatus::set_chan1stat(const ::std::string& value) {
  set_has_chan1stat();
  if (chan1stat_ == _default_chan1stat_) {
    chan1stat_ = new ::std::string;
  }
  chan1stat_->assign(value);
}
inline void ZapperStatus::set_chan1stat(const char* value) {
  set_has_chan1stat();
  if (chan1stat_ == _default_chan1stat_) {
    chan1stat_ = new ::std::string;
  }
  chan1stat_->assign(value);
}
inline void ZapperStatus::set_chan1stat(const char* value, size_t size) {
  set_has_chan1stat();
  if (chan1stat_ == _default_chan1stat_) {
    chan1stat_ = new ::std::string;
  }
  chan1stat_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZapperStatus::mutable_chan1stat() {
  set_has_chan1stat();
  if (chan1stat_ == _default_chan1stat_) {
    chan1stat_ = new ::std::string(*_default_chan1stat_);
  }
  return chan1stat_;
}
inline ::std::string* ZapperStatus::release_chan1stat() {
  clear_has_chan1stat();
  if (chan1stat_ == _default_chan1stat_) {
    return NULL;
  } else {
    ::std::string* temp = chan1stat_;
    chan1stat_ = const_cast< ::std::string*>(_default_chan1stat_);
    return temp;
  }
}
inline void ZapperStatus::set_allocated_chan1stat(::std::string* chan1stat) {
  if (chan1stat_ != _default_chan1stat_) {
    delete chan1stat_;
  }
  if (chan1stat) {
    set_has_chan1stat();
    chan1stat_ = chan1stat;
  } else {
    clear_has_chan1stat();
    chan1stat_ = const_cast< ::std::string*>(_default_chan1stat_);
  }
}

// optional string chan2Stat = 3 [default = "OFF"];
inline bool ZapperStatus::has_chan2stat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ZapperStatus::set_has_chan2stat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ZapperStatus::clear_has_chan2stat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ZapperStatus::clear_chan2stat() {
  if (chan2stat_ != _default_chan2stat_) {
    chan2stat_->assign(*_default_chan2stat_);
  }
  clear_has_chan2stat();
}
inline const ::std::string& ZapperStatus::chan2stat() const {
  return *chan2stat_;
}
inline void ZapperStatus::set_chan2stat(const ::std::string& value) {
  set_has_chan2stat();
  if (chan2stat_ == _default_chan2stat_) {
    chan2stat_ = new ::std::string;
  }
  chan2stat_->assign(value);
}
inline void ZapperStatus::set_chan2stat(const char* value) {
  set_has_chan2stat();
  if (chan2stat_ == _default_chan2stat_) {
    chan2stat_ = new ::std::string;
  }
  chan2stat_->assign(value);
}
inline void ZapperStatus::set_chan2stat(const char* value, size_t size) {
  set_has_chan2stat();
  if (chan2stat_ == _default_chan2stat_) {
    chan2stat_ = new ::std::string;
  }
  chan2stat_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZapperStatus::mutable_chan2stat() {
  set_has_chan2stat();
  if (chan2stat_ == _default_chan2stat_) {
    chan2stat_ = new ::std::string(*_default_chan2stat_);
  }
  return chan2stat_;
}
inline ::std::string* ZapperStatus::release_chan2stat() {
  clear_has_chan2stat();
  if (chan2stat_ == _default_chan2stat_) {
    return NULL;
  } else {
    ::std::string* temp = chan2stat_;
    chan2stat_ = const_cast< ::std::string*>(_default_chan2stat_);
    return temp;
  }
}
inline void ZapperStatus::set_allocated_chan2stat(::std::string* chan2stat) {
  if (chan2stat_ != _default_chan2stat_) {
    delete chan2stat_;
  }
  if (chan2stat) {
    set_has_chan2stat();
    chan2stat_ = chan2stat;
  } else {
    clear_has_chan2stat();
    chan2stat_ = const_cast< ::std::string*>(_default_chan2stat_);
  }
}

// optional string rx1Freq = 4 [default = "2440"];
inline bool ZapperStatus::has_rx1freq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ZapperStatus::set_has_rx1freq() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ZapperStatus::clear_has_rx1freq() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ZapperStatus::clear_rx1freq() {
  if (rx1freq_ != _default_rx1freq_) {
    rx1freq_->assign(*_default_rx1freq_);
  }
  clear_has_rx1freq();
}
inline const ::std::string& ZapperStatus::rx1freq() const {
  return *rx1freq_;
}
inline void ZapperStatus::set_rx1freq(const ::std::string& value) {
  set_has_rx1freq();
  if (rx1freq_ == _default_rx1freq_) {
    rx1freq_ = new ::std::string;
  }
  rx1freq_->assign(value);
}
inline void ZapperStatus::set_rx1freq(const char* value) {
  set_has_rx1freq();
  if (rx1freq_ == _default_rx1freq_) {
    rx1freq_ = new ::std::string;
  }
  rx1freq_->assign(value);
}
inline void ZapperStatus::set_rx1freq(const char* value, size_t size) {
  set_has_rx1freq();
  if (rx1freq_ == _default_rx1freq_) {
    rx1freq_ = new ::std::string;
  }
  rx1freq_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZapperStatus::mutable_rx1freq() {
  set_has_rx1freq();
  if (rx1freq_ == _default_rx1freq_) {
    rx1freq_ = new ::std::string(*_default_rx1freq_);
  }
  return rx1freq_;
}
inline ::std::string* ZapperStatus::release_rx1freq() {
  clear_has_rx1freq();
  if (rx1freq_ == _default_rx1freq_) {
    return NULL;
  } else {
    ::std::string* temp = rx1freq_;
    rx1freq_ = const_cast< ::std::string*>(_default_rx1freq_);
    return temp;
  }
}
inline void ZapperStatus::set_allocated_rx1freq(::std::string* rx1freq) {
  if (rx1freq_ != _default_rx1freq_) {
    delete rx1freq_;
  }
  if (rx1freq) {
    set_has_rx1freq();
    rx1freq_ = rx1freq;
  } else {
    clear_has_rx1freq();
    rx1freq_ = const_cast< ::std::string*>(_default_rx1freq_);
  }
}

// optional string rx2Freq = 5 [default = "2440"];
inline bool ZapperStatus::has_rx2freq() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ZapperStatus::set_has_rx2freq() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ZapperStatus::clear_has_rx2freq() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ZapperStatus::clear_rx2freq() {
  if (rx2freq_ != _default_rx2freq_) {
    rx2freq_->assign(*_default_rx2freq_);
  }
  clear_has_rx2freq();
}
inline const ::std::string& ZapperStatus::rx2freq() const {
  return *rx2freq_;
}
inline void ZapperStatus::set_rx2freq(const ::std::string& value) {
  set_has_rx2freq();
  if (rx2freq_ == _default_rx2freq_) {
    rx2freq_ = new ::std::string;
  }
  rx2freq_->assign(value);
}
inline void ZapperStatus::set_rx2freq(const char* value) {
  set_has_rx2freq();
  if (rx2freq_ == _default_rx2freq_) {
    rx2freq_ = new ::std::string;
  }
  rx2freq_->assign(value);
}
inline void ZapperStatus::set_rx2freq(const char* value, size_t size) {
  set_has_rx2freq();
  if (rx2freq_ == _default_rx2freq_) {
    rx2freq_ = new ::std::string;
  }
  rx2freq_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZapperStatus::mutable_rx2freq() {
  set_has_rx2freq();
  if (rx2freq_ == _default_rx2freq_) {
    rx2freq_ = new ::std::string(*_default_rx2freq_);
  }
  return rx2freq_;
}
inline ::std::string* ZapperStatus::release_rx2freq() {
  clear_has_rx2freq();
  if (rx2freq_ == _default_rx2freq_) {
    return NULL;
  } else {
    ::std::string* temp = rx2freq_;
    rx2freq_ = const_cast< ::std::string*>(_default_rx2freq_);
    return temp;
  }
}
inline void ZapperStatus::set_allocated_rx2freq(::std::string* rx2freq) {
  if (rx2freq_ != _default_rx2freq_) {
    delete rx2freq_;
  }
  if (rx2freq) {
    set_has_rx2freq();
    rx2freq_ = rx2freq;
  } else {
    clear_has_rx2freq();
    rx2freq_ = const_cast< ::std::string*>(_default_rx2freq_);
  }
}

// optional string rx3Freq = 6 [default = "2440"];
inline bool ZapperStatus::has_rx3freq() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ZapperStatus::set_has_rx3freq() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ZapperStatus::clear_has_rx3freq() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ZapperStatus::clear_rx3freq() {
  if (rx3freq_ != _default_rx3freq_) {
    rx3freq_->assign(*_default_rx3freq_);
  }
  clear_has_rx3freq();
}
inline const ::std::string& ZapperStatus::rx3freq() const {
  return *rx3freq_;
}
inline void ZapperStatus::set_rx3freq(const ::std::string& value) {
  set_has_rx3freq();
  if (rx3freq_ == _default_rx3freq_) {
    rx3freq_ = new ::std::string;
  }
  rx3freq_->assign(value);
}
inline void ZapperStatus::set_rx3freq(const char* value) {
  set_has_rx3freq();
  if (rx3freq_ == _default_rx3freq_) {
    rx3freq_ = new ::std::string;
  }
  rx3freq_->assign(value);
}
inline void ZapperStatus::set_rx3freq(const char* value, size_t size) {
  set_has_rx3freq();
  if (rx3freq_ == _default_rx3freq_) {
    rx3freq_ = new ::std::string;
  }
  rx3freq_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZapperStatus::mutable_rx3freq() {
  set_has_rx3freq();
  if (rx3freq_ == _default_rx3freq_) {
    rx3freq_ = new ::std::string(*_default_rx3freq_);
  }
  return rx3freq_;
}
inline ::std::string* ZapperStatus::release_rx3freq() {
  clear_has_rx3freq();
  if (rx3freq_ == _default_rx3freq_) {
    return NULL;
  } else {
    ::std::string* temp = rx3freq_;
    rx3freq_ = const_cast< ::std::string*>(_default_rx3freq_);
    return temp;
  }
}
inline void ZapperStatus::set_allocated_rx3freq(::std::string* rx3freq) {
  if (rx3freq_ != _default_rx3freq_) {
    delete rx3freq_;
  }
  if (rx3freq) {
    set_has_rx3freq();
    rx3freq_ = rx3freq;
  } else {
    clear_has_rx3freq();
    rx3freq_ = const_cast< ::std::string*>(_default_rx3freq_);
  }
}

// optional string rx4Freq = 7 [default = "2440"];
inline bool ZapperStatus::has_rx4freq() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ZapperStatus::set_has_rx4freq() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ZapperStatus::clear_has_rx4freq() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ZapperStatus::clear_rx4freq() {
  if (rx4freq_ != _default_rx4freq_) {
    rx4freq_->assign(*_default_rx4freq_);
  }
  clear_has_rx4freq();
}
inline const ::std::string& ZapperStatus::rx4freq() const {
  return *rx4freq_;
}
inline void ZapperStatus::set_rx4freq(const ::std::string& value) {
  set_has_rx4freq();
  if (rx4freq_ == _default_rx4freq_) {
    rx4freq_ = new ::std::string;
  }
  rx4freq_->assign(value);
}
inline void ZapperStatus::set_rx4freq(const char* value) {
  set_has_rx4freq();
  if (rx4freq_ == _default_rx4freq_) {
    rx4freq_ = new ::std::string;
  }
  rx4freq_->assign(value);
}
inline void ZapperStatus::set_rx4freq(const char* value, size_t size) {
  set_has_rx4freq();
  if (rx4freq_ == _default_rx4freq_) {
    rx4freq_ = new ::std::string;
  }
  rx4freq_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZapperStatus::mutable_rx4freq() {
  set_has_rx4freq();
  if (rx4freq_ == _default_rx4freq_) {
    rx4freq_ = new ::std::string(*_default_rx4freq_);
  }
  return rx4freq_;
}
inline ::std::string* ZapperStatus::release_rx4freq() {
  clear_has_rx4freq();
  if (rx4freq_ == _default_rx4freq_) {
    return NULL;
  } else {
    ::std::string* temp = rx4freq_;
    rx4freq_ = const_cast< ::std::string*>(_default_rx4freq_);
    return temp;
  }
}
inline void ZapperStatus::set_allocated_rx4freq(::std::string* rx4freq) {
  if (rx4freq_ != _default_rx4freq_) {
    delete rx4freq_;
  }
  if (rx4freq) {
    set_has_rx4freq();
    rx4freq_ = rx4freq;
  } else {
    clear_has_rx4freq();
    rx4freq_ = const_cast< ::std::string*>(_default_rx4freq_);
  }
}

// optional string tx1Freq = 8 [default = "2440"];
inline bool ZapperStatus::has_tx1freq() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ZapperStatus::set_has_tx1freq() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ZapperStatus::clear_has_tx1freq() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ZapperStatus::clear_tx1freq() {
  if (tx1freq_ != _default_tx1freq_) {
    tx1freq_->assign(*_default_tx1freq_);
  }
  clear_has_tx1freq();
}
inline const ::std::string& ZapperStatus::tx1freq() const {
  return *tx1freq_;
}
inline void ZapperStatus::set_tx1freq(const ::std::string& value) {
  set_has_tx1freq();
  if (tx1freq_ == _default_tx1freq_) {
    tx1freq_ = new ::std::string;
  }
  tx1freq_->assign(value);
}
inline void ZapperStatus::set_tx1freq(const char* value) {
  set_has_tx1freq();
  if (tx1freq_ == _default_tx1freq_) {
    tx1freq_ = new ::std::string;
  }
  tx1freq_->assign(value);
}
inline void ZapperStatus::set_tx1freq(const char* value, size_t size) {
  set_has_tx1freq();
  if (tx1freq_ == _default_tx1freq_) {
    tx1freq_ = new ::std::string;
  }
  tx1freq_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZapperStatus::mutable_tx1freq() {
  set_has_tx1freq();
  if (tx1freq_ == _default_tx1freq_) {
    tx1freq_ = new ::std::string(*_default_tx1freq_);
  }
  return tx1freq_;
}
inline ::std::string* ZapperStatus::release_tx1freq() {
  clear_has_tx1freq();
  if (tx1freq_ == _default_tx1freq_) {
    return NULL;
  } else {
    ::std::string* temp = tx1freq_;
    tx1freq_ = const_cast< ::std::string*>(_default_tx1freq_);
    return temp;
  }
}
inline void ZapperStatus::set_allocated_tx1freq(::std::string* tx1freq) {
  if (tx1freq_ != _default_tx1freq_) {
    delete tx1freq_;
  }
  if (tx1freq) {
    set_has_tx1freq();
    tx1freq_ = tx1freq;
  } else {
    clear_has_tx1freq();
    tx1freq_ = const_cast< ::std::string*>(_default_tx1freq_);
  }
}

// optional string tx2Freq = 9 [default = "2440"];
inline bool ZapperStatus::has_tx2freq() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ZapperStatus::set_has_tx2freq() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ZapperStatus::clear_has_tx2freq() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ZapperStatus::clear_tx2freq() {
  if (tx2freq_ != _default_tx2freq_) {
    tx2freq_->assign(*_default_tx2freq_);
  }
  clear_has_tx2freq();
}
inline const ::std::string& ZapperStatus::tx2freq() const {
  return *tx2freq_;
}
inline void ZapperStatus::set_tx2freq(const ::std::string& value) {
  set_has_tx2freq();
  if (tx2freq_ == _default_tx2freq_) {
    tx2freq_ = new ::std::string;
  }
  tx2freq_->assign(value);
}
inline void ZapperStatus::set_tx2freq(const char* value) {
  set_has_tx2freq();
  if (tx2freq_ == _default_tx2freq_) {
    tx2freq_ = new ::std::string;
  }
  tx2freq_->assign(value);
}
inline void ZapperStatus::set_tx2freq(const char* value, size_t size) {
  set_has_tx2freq();
  if (tx2freq_ == _default_tx2freq_) {
    tx2freq_ = new ::std::string;
  }
  tx2freq_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZapperStatus::mutable_tx2freq() {
  set_has_tx2freq();
  if (tx2freq_ == _default_tx2freq_) {
    tx2freq_ = new ::std::string(*_default_tx2freq_);
  }
  return tx2freq_;
}
inline ::std::string* ZapperStatus::release_tx2freq() {
  clear_has_tx2freq();
  if (tx2freq_ == _default_tx2freq_) {
    return NULL;
  } else {
    ::std::string* temp = tx2freq_;
    tx2freq_ = const_cast< ::std::string*>(_default_tx2freq_);
    return temp;
  }
}
inline void ZapperStatus::set_allocated_tx2freq(::std::string* tx2freq) {
  if (tx2freq_ != _default_tx2freq_) {
    delete tx2freq_;
  }
  if (tx2freq) {
    set_has_tx2freq();
    tx2freq_ = tx2freq;
  } else {
    clear_has_tx2freq();
    tx2freq_ = const_cast< ::std::string*>(_default_tx2freq_);
  }
}

// optional string amp1 = 10 [default = "0"];
inline bool ZapperStatus::has_amp1() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ZapperStatus::set_has_amp1() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ZapperStatus::clear_has_amp1() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ZapperStatus::clear_amp1() {
  if (amp1_ != _default_amp1_) {
    amp1_->assign(*_default_amp1_);
  }
  clear_has_amp1();
}
inline const ::std::string& ZapperStatus::amp1() const {
  return *amp1_;
}
inline void ZapperStatus::set_amp1(const ::std::string& value) {
  set_has_amp1();
  if (amp1_ == _default_amp1_) {
    amp1_ = new ::std::string;
  }
  amp1_->assign(value);
}
inline void ZapperStatus::set_amp1(const char* value) {
  set_has_amp1();
  if (amp1_ == _default_amp1_) {
    amp1_ = new ::std::string;
  }
  amp1_->assign(value);
}
inline void ZapperStatus::set_amp1(const char* value, size_t size) {
  set_has_amp1();
  if (amp1_ == _default_amp1_) {
    amp1_ = new ::std::string;
  }
  amp1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZapperStatus::mutable_amp1() {
  set_has_amp1();
  if (amp1_ == _default_amp1_) {
    amp1_ = new ::std::string(*_default_amp1_);
  }
  return amp1_;
}
inline ::std::string* ZapperStatus::release_amp1() {
  clear_has_amp1();
  if (amp1_ == _default_amp1_) {
    return NULL;
  } else {
    ::std::string* temp = amp1_;
    amp1_ = const_cast< ::std::string*>(_default_amp1_);
    return temp;
  }
}
inline void ZapperStatus::set_allocated_amp1(::std::string* amp1) {
  if (amp1_ != _default_amp1_) {
    delete amp1_;
  }
  if (amp1) {
    set_has_amp1();
    amp1_ = amp1;
  } else {
    clear_has_amp1();
    amp1_ = const_cast< ::std::string*>(_default_amp1_);
  }
}

// optional string amp2 = 11 [default = "0"];
inline bool ZapperStatus::has_amp2() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ZapperStatus::set_has_amp2() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ZapperStatus::clear_has_amp2() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ZapperStatus::clear_amp2() {
  if (amp2_ != _default_amp2_) {
    amp2_->assign(*_default_amp2_);
  }
  clear_has_amp2();
}
inline const ::std::string& ZapperStatus::amp2() const {
  return *amp2_;
}
inline void ZapperStatus::set_amp2(const ::std::string& value) {
  set_has_amp2();
  if (amp2_ == _default_amp2_) {
    amp2_ = new ::std::string;
  }
  amp2_->assign(value);
}
inline void ZapperStatus::set_amp2(const char* value) {
  set_has_amp2();
  if (amp2_ == _default_amp2_) {
    amp2_ = new ::std::string;
  }
  amp2_->assign(value);
}
inline void ZapperStatus::set_amp2(const char* value, size_t size) {
  set_has_amp2();
  if (amp2_ == _default_amp2_) {
    amp2_ = new ::std::string;
  }
  amp2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZapperStatus::mutable_amp2() {
  set_has_amp2();
  if (amp2_ == _default_amp2_) {
    amp2_ = new ::std::string(*_default_amp2_);
  }
  return amp2_;
}
inline ::std::string* ZapperStatus::release_amp2() {
  clear_has_amp2();
  if (amp2_ == _default_amp2_) {
    return NULL;
  } else {
    ::std::string* temp = amp2_;
    amp2_ = const_cast< ::std::string*>(_default_amp2_);
    return temp;
  }
}
inline void ZapperStatus::set_allocated_amp2(::std::string* amp2) {
  if (amp2_ != _default_amp2_) {
    delete amp2_;
  }
  if (amp2) {
    set_has_amp2();
    amp2_ = amp2;
  } else {
    clear_has_amp2();
    amp2_ = const_cast< ::std::string*>(_default_amp2_);
  }
}

// optional string amp3 = 12 [default = "0"];
inline bool ZapperStatus::has_amp3() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ZapperStatus::set_has_amp3() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ZapperStatus::clear_has_amp3() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ZapperStatus::clear_amp3() {
  if (amp3_ != _default_amp3_) {
    amp3_->assign(*_default_amp3_);
  }
  clear_has_amp3();
}
inline const ::std::string& ZapperStatus::amp3() const {
  return *amp3_;
}
inline void ZapperStatus::set_amp3(const ::std::string& value) {
  set_has_amp3();
  if (amp3_ == _default_amp3_) {
    amp3_ = new ::std::string;
  }
  amp3_->assign(value);
}
inline void ZapperStatus::set_amp3(const char* value) {
  set_has_amp3();
  if (amp3_ == _default_amp3_) {
    amp3_ = new ::std::string;
  }
  amp3_->assign(value);
}
inline void ZapperStatus::set_amp3(const char* value, size_t size) {
  set_has_amp3();
  if (amp3_ == _default_amp3_) {
    amp3_ = new ::std::string;
  }
  amp3_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZapperStatus::mutable_amp3() {
  set_has_amp3();
  if (amp3_ == _default_amp3_) {
    amp3_ = new ::std::string(*_default_amp3_);
  }
  return amp3_;
}
inline ::std::string* ZapperStatus::release_amp3() {
  clear_has_amp3();
  if (amp3_ == _default_amp3_) {
    return NULL;
  } else {
    ::std::string* temp = amp3_;
    amp3_ = const_cast< ::std::string*>(_default_amp3_);
    return temp;
  }
}
inline void ZapperStatus::set_allocated_amp3(::std::string* amp3) {
  if (amp3_ != _default_amp3_) {
    delete amp3_;
  }
  if (amp3) {
    set_has_amp3();
    amp3_ = amp3;
  } else {
    clear_has_amp3();
    amp3_ = const_cast< ::std::string*>(_default_amp3_);
  }
}

// optional string meterChan = 13 [default = "-1"];
inline bool ZapperStatus::has_meterchan() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ZapperStatus::set_has_meterchan() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ZapperStatus::clear_has_meterchan() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ZapperStatus::clear_meterchan() {
  if (meterchan_ != _default_meterchan_) {
    meterchan_->assign(*_default_meterchan_);
  }
  clear_has_meterchan();
}
inline const ::std::string& ZapperStatus::meterchan() const {
  return *meterchan_;
}
inline void ZapperStatus::set_meterchan(const ::std::string& value) {
  set_has_meterchan();
  if (meterchan_ == _default_meterchan_) {
    meterchan_ = new ::std::string;
  }
  meterchan_->assign(value);
}
inline void ZapperStatus::set_meterchan(const char* value) {
  set_has_meterchan();
  if (meterchan_ == _default_meterchan_) {
    meterchan_ = new ::std::string;
  }
  meterchan_->assign(value);
}
inline void ZapperStatus::set_meterchan(const char* value, size_t size) {
  set_has_meterchan();
  if (meterchan_ == _default_meterchan_) {
    meterchan_ = new ::std::string;
  }
  meterchan_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZapperStatus::mutable_meterchan() {
  set_has_meterchan();
  if (meterchan_ == _default_meterchan_) {
    meterchan_ = new ::std::string(*_default_meterchan_);
  }
  return meterchan_;
}
inline ::std::string* ZapperStatus::release_meterchan() {
  clear_has_meterchan();
  if (meterchan_ == _default_meterchan_) {
    return NULL;
  } else {
    ::std::string* temp = meterchan_;
    meterchan_ = const_cast< ::std::string*>(_default_meterchan_);
    return temp;
  }
}
inline void ZapperStatus::set_allocated_meterchan(::std::string* meterchan) {
  if (meterchan_ != _default_meterchan_) {
    delete meterchan_;
  }
  if (meterchan) {
    set_has_meterchan();
    meterchan_ = meterchan;
  } else {
    clear_has_meterchan();
    meterchan_ = const_cast< ::std::string*>(_default_meterchan_);
  }
}

// optional string meterPower = 14 [default = "-99"];
inline bool ZapperStatus::has_meterpower() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ZapperStatus::set_has_meterpower() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ZapperStatus::clear_has_meterpower() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ZapperStatus::clear_meterpower() {
  if (meterpower_ != _default_meterpower_) {
    meterpower_->assign(*_default_meterpower_);
  }
  clear_has_meterpower();
}
inline const ::std::string& ZapperStatus::meterpower() const {
  return *meterpower_;
}
inline void ZapperStatus::set_meterpower(const ::std::string& value) {
  set_has_meterpower();
  if (meterpower_ == _default_meterpower_) {
    meterpower_ = new ::std::string;
  }
  meterpower_->assign(value);
}
inline void ZapperStatus::set_meterpower(const char* value) {
  set_has_meterpower();
  if (meterpower_ == _default_meterpower_) {
    meterpower_ = new ::std::string;
  }
  meterpower_->assign(value);
}
inline void ZapperStatus::set_meterpower(const char* value, size_t size) {
  set_has_meterpower();
  if (meterpower_ == _default_meterpower_) {
    meterpower_ = new ::std::string;
  }
  meterpower_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZapperStatus::mutable_meterpower() {
  set_has_meterpower();
  if (meterpower_ == _default_meterpower_) {
    meterpower_ = new ::std::string(*_default_meterpower_);
  }
  return meterpower_;
}
inline ::std::string* ZapperStatus::release_meterpower() {
  clear_has_meterpower();
  if (meterpower_ == _default_meterpower_) {
    return NULL;
  } else {
    ::std::string* temp = meterpower_;
    meterpower_ = const_cast< ::std::string*>(_default_meterpower_);
    return temp;
  }
}
inline void ZapperStatus::set_allocated_meterpower(::std::string* meterpower) {
  if (meterpower_ != _default_meterpower_) {
    delete meterpower_;
  }
  if (meterpower) {
    set_has_meterpower();
    meterpower_ = meterpower;
  } else {
    clear_has_meterpower();
    meterpower_ = const_cast< ::std::string*>(_default_meterpower_);
  }
}

// -------------------------------------------------------------------

// StopAll

// optional string msgName = 1 [default = "STOPALL"];
inline bool StopAll::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopAll::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StopAll::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StopAll::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& StopAll::msgname() const {
  return *msgname_;
}
inline void StopAll::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void StopAll::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void StopAll::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StopAll::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* StopAll::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void StopAll::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// -------------------------------------------------------------------

// ToneJam

// optional string msgName = 1 [default = "TONEJAM"];
inline bool ToneJam::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ToneJam::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ToneJam::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ToneJam::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ToneJam::msgname() const {
  return *msgname_;
}
inline void ToneJam::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ToneJam::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ToneJam::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ToneJam::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ToneJam::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ToneJam::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string platform = 2 [default = "NONE"];
inline bool ToneJam::has_platform() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ToneJam::set_has_platform() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ToneJam::clear_has_platform() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ToneJam::clear_platform() {
  if (platform_ != _default_platform_) {
    platform_->assign(*_default_platform_);
  }
  clear_has_platform();
}
inline const ::std::string& ToneJam::platform() const {
  return *platform_;
}
inline void ToneJam::set_platform(const ::std::string& value) {
  set_has_platform();
  if (platform_ == _default_platform_) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void ToneJam::set_platform(const char* value) {
  set_has_platform();
  if (platform_ == _default_platform_) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void ToneJam::set_platform(const char* value, size_t size) {
  set_has_platform();
  if (platform_ == _default_platform_) {
    platform_ = new ::std::string;
  }
  platform_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ToneJam::mutable_platform() {
  set_has_platform();
  if (platform_ == _default_platform_) {
    platform_ = new ::std::string(*_default_platform_);
  }
  return platform_;
}
inline ::std::string* ToneJam::release_platform() {
  clear_has_platform();
  if (platform_ == _default_platform_) {
    return NULL;
  } else {
    ::std::string* temp = platform_;
    platform_ = const_cast< ::std::string*>(_default_platform_);
    return temp;
  }
}
inline void ToneJam::set_allocated_platform(::std::string* platform) {
  if (platform_ != _default_platform_) {
    delete platform_;
  }
  if (platform) {
    set_has_platform();
    platform_ = platform;
  } else {
    clear_has_platform();
    platform_ = const_cast< ::std::string*>(_default_platform_);
  }
}

// optional int32 targetID = 3 [default = -1];
inline bool ToneJam::has_targetid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ToneJam::set_has_targetid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ToneJam::clear_has_targetid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ToneJam::clear_targetid() {
  targetid_ = -1;
  clear_has_targetid();
}
inline ::google::protobuf::int32 ToneJam::targetid() const {
  return targetid_;
}
inline void ToneJam::set_targetid(::google::protobuf::int32 value) {
  set_has_targetid();
  targetid_ = value;
}

// -------------------------------------------------------------------

// ToneJamOff

// optional string msgName = 1 [default = "TONEJAMOFF"];
inline bool ToneJamOff::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ToneJamOff::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ToneJamOff::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ToneJamOff::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ToneJamOff::msgname() const {
  return *msgname_;
}
inline void ToneJamOff::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ToneJamOff::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ToneJamOff::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ToneJamOff::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ToneJamOff::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ToneJamOff::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 targetID = 2 [default = -1];
inline bool ToneJamOff::has_targetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ToneJamOff::set_has_targetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ToneJamOff::clear_has_targetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ToneJamOff::clear_targetid() {
  targetid_ = -1;
  clear_has_targetid();
}
inline ::google::protobuf::int32 ToneJamOff::targetid() const {
  return targetid_;
}
inline void ToneJamOff::set_targetid(::google::protobuf::int32 value) {
  set_has_targetid();
  targetid_ = value;
}

// -------------------------------------------------------------------

// Zap

// optional string msgName = 1 [default = "ZAP"];
inline bool Zap::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Zap::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Zap::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Zap::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& Zap::msgname() const {
  return *msgname_;
}
inline void Zap::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void Zap::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void Zap::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Zap::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* Zap::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void Zap::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 targetID = 3 [default = -1];
inline bool Zap::has_targetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Zap::set_has_targetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Zap::clear_has_targetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Zap::clear_targetid() {
  targetid_ = -1;
  clear_has_targetid();
}
inline ::google::protobuf::int32 Zap::targetid() const {
  return targetid_;
}
inline void Zap::set_targetid(::google::protobuf::int32 value) {
  set_has_targetid();
  targetid_ = value;
}

// optional string platform = 2 [default = "NONE"];
inline bool Zap::has_platform() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Zap::set_has_platform() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Zap::clear_has_platform() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Zap::clear_platform() {
  if (platform_ != _default_platform_) {
    platform_->assign(*_default_platform_);
  }
  clear_has_platform();
}
inline const ::std::string& Zap::platform() const {
  return *platform_;
}
inline void Zap::set_platform(const ::std::string& value) {
  set_has_platform();
  if (platform_ == _default_platform_) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void Zap::set_platform(const char* value) {
  set_has_platform();
  if (platform_ == _default_platform_) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void Zap::set_platform(const char* value, size_t size) {
  set_has_platform();
  if (platform_ == _default_platform_) {
    platform_ = new ::std::string;
  }
  platform_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Zap::mutable_platform() {
  set_has_platform();
  if (platform_ == _default_platform_) {
    platform_ = new ::std::string(*_default_platform_);
  }
  return platform_;
}
inline ::std::string* Zap::release_platform() {
  clear_has_platform();
  if (platform_ == _default_platform_) {
    return NULL;
  } else {
    ::std::string* temp = platform_;
    platform_ = const_cast< ::std::string*>(_default_platform_);
    return temp;
  }
}
inline void Zap::set_allocated_platform(::std::string* platform) {
  if (platform_ != _default_platform_) {
    delete platform_;
  }
  if (platform) {
    set_has_platform();
    platform_ = platform;
  } else {
    clear_has_platform();
    platform_ = const_cast< ::std::string*>(_default_platform_);
  }
}

// -------------------------------------------------------------------

// ZapOff

// optional string msgName = 1 [default = "ZAPOFF"];
inline bool ZapOff::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ZapOff::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ZapOff::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ZapOff::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ZapOff::msgname() const {
  return *msgname_;
}
inline void ZapOff::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ZapOff::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ZapOff::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZapOff::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ZapOff::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ZapOff::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 targetID = 2 [default = -1];
inline bool ZapOff::has_targetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ZapOff::set_has_targetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ZapOff::clear_has_targetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ZapOff::clear_targetid() {
  targetid_ = -1;
  clear_has_targetid();
}
inline ::google::protobuf::int32 ZapOff::targetid() const {
  return targetid_;
}
inline void ZapOff::set_targetid(::google::protobuf::int32 value) {
  set_has_targetid();
  targetid_ = value;
}

// -------------------------------------------------------------------

// Detect

// optional string msgName = 1 [default = "DETECT"];
inline bool Detect::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Detect::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Detect::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Detect::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& Detect::msgname() const {
  return *msgname_;
}
inline void Detect::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void Detect::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void Detect::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Detect::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* Detect::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void Detect::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string platform = 2 [default = "NONE"];
inline bool Detect::has_platform() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Detect::set_has_platform() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Detect::clear_has_platform() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Detect::clear_platform() {
  if (platform_ != _default_platform_) {
    platform_->assign(*_default_platform_);
  }
  clear_has_platform();
}
inline const ::std::string& Detect::platform() const {
  return *platform_;
}
inline void Detect::set_platform(const ::std::string& value) {
  set_has_platform();
  if (platform_ == _default_platform_) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void Detect::set_platform(const char* value) {
  set_has_platform();
  if (platform_ == _default_platform_) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void Detect::set_platform(const char* value, size_t size) {
  set_has_platform();
  if (platform_ == _default_platform_) {
    platform_ = new ::std::string;
  }
  platform_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Detect::mutable_platform() {
  set_has_platform();
  if (platform_ == _default_platform_) {
    platform_ = new ::std::string(*_default_platform_);
  }
  return platform_;
}
inline ::std::string* Detect::release_platform() {
  clear_has_platform();
  if (platform_ == _default_platform_) {
    return NULL;
  } else {
    ::std::string* temp = platform_;
    platform_ = const_cast< ::std::string*>(_default_platform_);
    return temp;
  }
}
inline void Detect::set_allocated_platform(::std::string* platform) {
  if (platform_ != _default_platform_) {
    delete platform_;
  }
  if (platform) {
    set_has_platform();
    platform_ = platform;
  } else {
    clear_has_platform();
    platform_ = const_cast< ::std::string*>(_default_platform_);
  }
}

// optional double freq = 3 [default = 2440];
inline bool Detect::has_freq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Detect::set_has_freq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Detect::clear_has_freq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Detect::clear_freq() {
  freq_ = 2440;
  clear_has_freq();
}
inline double Detect::freq() const {
  return freq_;
}
inline void Detect::set_freq(double value) {
  set_has_freq();
  freq_ = value;
}

// -------------------------------------------------------------------

// ZapperOptions

// optional string msgName = 1 [default = "ZAPPEROPTIONS"];
inline bool ZapperOptions::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ZapperOptions::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ZapperOptions::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ZapperOptions::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ZapperOptions::msgname() const {
  return *msgname_;
}
inline void ZapperOptions::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ZapperOptions::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ZapperOptions::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZapperOptions::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ZapperOptions::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ZapperOptions::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string options = 2 [default = "NONE"];
inline bool ZapperOptions::has_options() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ZapperOptions::set_has_options() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ZapperOptions::clear_has_options() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ZapperOptions::clear_options() {
  if (options_ != _default_options_) {
    options_->assign(*_default_options_);
  }
  clear_has_options();
}
inline const ::std::string& ZapperOptions::options() const {
  return *options_;
}
inline void ZapperOptions::set_options(const ::std::string& value) {
  set_has_options();
  if (options_ == _default_options_) {
    options_ = new ::std::string;
  }
  options_->assign(value);
}
inline void ZapperOptions::set_options(const char* value) {
  set_has_options();
  if (options_ == _default_options_) {
    options_ = new ::std::string;
  }
  options_->assign(value);
}
inline void ZapperOptions::set_options(const char* value, size_t size) {
  set_has_options();
  if (options_ == _default_options_) {
    options_ = new ::std::string;
  }
  options_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZapperOptions::mutable_options() {
  set_has_options();
  if (options_ == _default_options_) {
    options_ = new ::std::string(*_default_options_);
  }
  return options_;
}
inline ::std::string* ZapperOptions::release_options() {
  clear_has_options();
  if (options_ == _default_options_) {
    return NULL;
  } else {
    ::std::string* temp = options_;
    options_ = const_cast< ::std::string*>(_default_options_);
    return temp;
  }
}
inline void ZapperOptions::set_allocated_options(::std::string* options) {
  if (options_ != _default_options_) {
    delete options_;
  }
  if (options) {
    set_has_options();
    options_ = options;
  } else {
    clear_has_options();
    options_ = const_cast< ::std::string*>(_default_options_);
  }
}

// optional int32 targetID = 3 [default = -1];
inline bool ZapperOptions::has_targetid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ZapperOptions::set_has_targetid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ZapperOptions::clear_has_targetid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ZapperOptions::clear_targetid() {
  targetid_ = -1;
  clear_has_targetid();
}
inline ::google::protobuf::int32 ZapperOptions::targetid() const {
  return targetid_;
}
inline void ZapperOptions::set_targetid(::google::protobuf::int32 value) {
  set_has_targetid();
  targetid_ = value;
}

// -------------------------------------------------------------------

// ZapPing

// optional string msgName = 1 [default = "ZAPPING"];
inline bool ZapPing::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ZapPing::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ZapPing::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ZapPing::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ZapPing::msgname() const {
  return *msgname_;
}
inline void ZapPing::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ZapPing::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ZapPing::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZapPing::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ZapPing::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ZapPing::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// -------------------------------------------------------------------

// ZapPong

// optional string msgName = 1 [default = "ZAPPONG"];
inline bool ZapPong::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ZapPong::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ZapPong::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ZapPong::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ZapPong::msgname() const {
  return *msgname_;
}
inline void ZapPong::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ZapPong::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ZapPong::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZapPong::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ZapPong::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ZapPong::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// -------------------------------------------------------------------

// InfoMsg

// optional string msgName = 1 [default = "INFOMSG"];
inline bool InfoMsg::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InfoMsg::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InfoMsg::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InfoMsg::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& InfoMsg::msgname() const {
  return *msgname_;
}
inline void InfoMsg::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void InfoMsg::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void InfoMsg::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InfoMsg::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* InfoMsg::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void InfoMsg::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string info = 2 [default = "NONE"];
inline bool InfoMsg::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InfoMsg::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InfoMsg::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InfoMsg::clear_info() {
  if (info_ != _default_info_) {
    info_->assign(*_default_info_);
  }
  clear_has_info();
}
inline const ::std::string& InfoMsg::info() const {
  return *info_;
}
inline void InfoMsg::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == _default_info_) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void InfoMsg::set_info(const char* value) {
  set_has_info();
  if (info_ == _default_info_) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void InfoMsg::set_info(const char* value, size_t size) {
  set_has_info();
  if (info_ == _default_info_) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InfoMsg::mutable_info() {
  set_has_info();
  if (info_ == _default_info_) {
    info_ = new ::std::string(*_default_info_);
  }
  return info_;
}
inline ::std::string* InfoMsg::release_info() {
  clear_has_info();
  if (info_ == _default_info_) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(_default_info_);
    return temp;
  }
}
inline void InfoMsg::set_allocated_info(::std::string* info) {
  if (info_ != _default_info_) {
    delete info_;
  }
  if (info) {
    set_has_info();
    info_ = info;
  } else {
    clear_has_info();
    info_ = const_cast< ::std::string*>(_default_info_);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace VcnProtos
}  // namespace protos
}  // namespace vcn
}  // namespace fv

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fv::vcn::protos::VcnProtos::HardwareStatus_HardwareState>() {
  return ::fv::vcn::protos::VcnProtos::HardwareStatus_HardwareState_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_FalconVcnMessages_2eproto__INCLUDED
