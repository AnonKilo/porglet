// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AutoKillMessages.proto

#ifndef PROTOBUF_AutoKillMessages_2eproto__INCLUDED
#define PROTOBUF_AutoKillMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace auto_kill_msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_AutoKillMessages_2eproto();
void protobuf_AssignDesc_AutoKillMessages_2eproto();
void protobuf_ShutdownFile_AutoKillMessages_2eproto();

class StateResponse;
class OverrideState;
class COAConfig;
class AutoKillGUI;

// ===================================================================

class StateResponse : public ::google::protobuf::Message {
 public:
  StateResponse();
  virtual ~StateResponse();

  StateResponse(const StateResponse& from);

  inline StateResponse& operator=(const StateResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StateResponse& default_instance();

  void Swap(StateResponse* other);

  // implements Message ----------------------------------------------

  StateResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StateResponse& from);
  void MergeFrom(const StateResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "STATERESPONSE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional bool success = 2 [default = false];
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 2;
  inline bool success() const;
  inline void set_success(bool value);

  // optional int32 errorValue = 3 [default = 0];
  inline bool has_errorvalue() const;
  inline void clear_errorvalue();
  static const int kErrorValueFieldNumber = 3;
  inline ::google::protobuf::int32 errorvalue() const;
  inline void set_errorvalue(::google::protobuf::int32 value);

  // optional string taskName = 4;
  inline bool has_taskname() const;
  inline void clear_taskname();
  static const int kTaskNameFieldNumber = 4;
  inline const ::std::string& taskname() const;
  inline void set_taskname(const ::std::string& value);
  inline void set_taskname(const char* value);
  inline void set_taskname(const char* value, size_t size);
  inline ::std::string* mutable_taskname();
  inline ::std::string* release_taskname();
  inline void set_allocated_taskname(::std::string* taskname);

  // @@protoc_insertion_point(class_scope:auto_kill_msg.StateResponse)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_errorvalue();
  inline void clear_has_errorvalue();
  inline void set_has_taskname();
  inline void clear_has_taskname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  bool success_;
  ::google::protobuf::int32 errorvalue_;
  ::std::string* taskname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_AutoKillMessages_2eproto();
  friend void protobuf_AssignDesc_AutoKillMessages_2eproto();
  friend void protobuf_ShutdownFile_AutoKillMessages_2eproto();

  void InitAsDefaultInstance();
  static StateResponse* default_instance_;
};
// -------------------------------------------------------------------

class OverrideState : public ::google::protobuf::Message {
 public:
  OverrideState();
  virtual ~OverrideState();

  OverrideState(const OverrideState& from);

  inline OverrideState& operator=(const OverrideState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OverrideState& default_instance();

  void Swap(OverrideState* other);

  // implements Message ----------------------------------------------

  OverrideState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OverrideState& from);
  void MergeFrom(const OverrideState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "OVERRIDESTATE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 appID = 2;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 2;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional string newState = 3;
  inline bool has_newstate() const;
  inline void clear_newstate();
  static const int kNewStateFieldNumber = 3;
  inline const ::std::string& newstate() const;
  inline void set_newstate(const ::std::string& value);
  inline void set_newstate(const char* value);
  inline void set_newstate(const char* value, size_t size);
  inline ::std::string* mutable_newstate();
  inline ::std::string* release_newstate();
  inline void set_allocated_newstate(::std::string* newstate);

  // @@protoc_insertion_point(class_scope:auto_kill_msg.OverrideState)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_newstate();
  inline void clear_has_newstate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* newstate_;
  ::google::protobuf::int32 appid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_AutoKillMessages_2eproto();
  friend void protobuf_AssignDesc_AutoKillMessages_2eproto();
  friend void protobuf_ShutdownFile_AutoKillMessages_2eproto();

  void InitAsDefaultInstance();
  static OverrideState* default_instance_;
};
// -------------------------------------------------------------------

class COAConfig : public ::google::protobuf::Message {
 public:
  COAConfig();
  virtual ~COAConfig();

  COAConfig(const COAConfig& from);

  inline COAConfig& operator=(const COAConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const COAConfig& default_instance();

  void Swap(COAConfig* other);

  // implements Message ----------------------------------------------

  COAConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const COAConfig& from);
  void MergeFrom(const COAConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "COACONFIG"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // repeated string xmlCOA = 2;
  inline int xmlcoa_size() const;
  inline void clear_xmlcoa();
  static const int kXmlCOAFieldNumber = 2;
  inline const ::std::string& xmlcoa(int index) const;
  inline ::std::string* mutable_xmlcoa(int index);
  inline void set_xmlcoa(int index, const ::std::string& value);
  inline void set_xmlcoa(int index, const char* value);
  inline void set_xmlcoa(int index, const char* value, size_t size);
  inline ::std::string* add_xmlcoa();
  inline void add_xmlcoa(const ::std::string& value);
  inline void add_xmlcoa(const char* value);
  inline void add_xmlcoa(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& xmlcoa() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_xmlcoa();

  // @@protoc_insertion_point(class_scope:auto_kill_msg.COAConfig)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::RepeatedPtrField< ::std::string> xmlcoa_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AutoKillMessages_2eproto();
  friend void protobuf_AssignDesc_AutoKillMessages_2eproto();
  friend void protobuf_ShutdownFile_AutoKillMessages_2eproto();

  void InitAsDefaultInstance();
  static COAConfig* default_instance_;
};
// -------------------------------------------------------------------

class AutoKillGUI : public ::google::protobuf::Message {
 public:
  AutoKillGUI();
  virtual ~AutoKillGUI();

  AutoKillGUI(const AutoKillGUI& from);

  inline AutoKillGUI& operator=(const AutoKillGUI& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AutoKillGUI& default_instance();

  void Swap(AutoKillGUI* other);

  // implements Message ----------------------------------------------

  AutoKillGUI* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AutoKillGUI& from);
  void MergeFrom(const AutoKillGUI& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "AUTOKILLGUI"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline const ::std::string& state() const;
  inline void set_state(const ::std::string& value);
  inline void set_state(const char* value);
  inline void set_state(const char* value, size_t size);
  inline ::std::string* mutable_state();
  inline ::std::string* release_state();
  inline void set_allocated_state(::std::string* state);

  // optional string transition = 3;
  inline bool has_transition() const;
  inline void clear_transition();
  static const int kTransitionFieldNumber = 3;
  inline const ::std::string& transition() const;
  inline void set_transition(const ::std::string& value);
  inline void set_transition(const char* value);
  inline void set_transition(const char* value, size_t size);
  inline ::std::string* mutable_transition();
  inline ::std::string* release_transition();
  inline void set_allocated_transition(::std::string* transition);

  // @@protoc_insertion_point(class_scope:auto_kill_msg.AutoKillGUI)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_transition();
  inline void clear_has_transition();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* state_;
  ::std::string* transition_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_AutoKillMessages_2eproto();
  friend void protobuf_AssignDesc_AutoKillMessages_2eproto();
  friend void protobuf_ShutdownFile_AutoKillMessages_2eproto();

  void InitAsDefaultInstance();
  static AutoKillGUI* default_instance_;
};
// ===================================================================


// ===================================================================

// StateResponse

// optional string msgName = 1 [default = "STATERESPONSE"];
inline bool StateResponse::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StateResponse::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StateResponse::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StateResponse::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& StateResponse::msgname() const {
  return *msgname_;
}
inline void StateResponse::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void StateResponse::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void StateResponse::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StateResponse::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* StateResponse::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void StateResponse::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional bool success = 2 [default = false];
inline bool StateResponse::has_success() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StateResponse::set_has_success() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StateResponse::clear_has_success() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StateResponse::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool StateResponse::success() const {
  return success_;
}
inline void StateResponse::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// optional int32 errorValue = 3 [default = 0];
inline bool StateResponse::has_errorvalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StateResponse::set_has_errorvalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StateResponse::clear_has_errorvalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StateResponse::clear_errorvalue() {
  errorvalue_ = 0;
  clear_has_errorvalue();
}
inline ::google::protobuf::int32 StateResponse::errorvalue() const {
  return errorvalue_;
}
inline void StateResponse::set_errorvalue(::google::protobuf::int32 value) {
  set_has_errorvalue();
  errorvalue_ = value;
}

// optional string taskName = 4;
inline bool StateResponse::has_taskname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StateResponse::set_has_taskname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StateResponse::clear_has_taskname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StateResponse::clear_taskname() {
  if (taskname_ != &::google::protobuf::internal::kEmptyString) {
    taskname_->clear();
  }
  clear_has_taskname();
}
inline const ::std::string& StateResponse::taskname() const {
  return *taskname_;
}
inline void StateResponse::set_taskname(const ::std::string& value) {
  set_has_taskname();
  if (taskname_ == &::google::protobuf::internal::kEmptyString) {
    taskname_ = new ::std::string;
  }
  taskname_->assign(value);
}
inline void StateResponse::set_taskname(const char* value) {
  set_has_taskname();
  if (taskname_ == &::google::protobuf::internal::kEmptyString) {
    taskname_ = new ::std::string;
  }
  taskname_->assign(value);
}
inline void StateResponse::set_taskname(const char* value, size_t size) {
  set_has_taskname();
  if (taskname_ == &::google::protobuf::internal::kEmptyString) {
    taskname_ = new ::std::string;
  }
  taskname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StateResponse::mutable_taskname() {
  set_has_taskname();
  if (taskname_ == &::google::protobuf::internal::kEmptyString) {
    taskname_ = new ::std::string;
  }
  return taskname_;
}
inline ::std::string* StateResponse::release_taskname() {
  clear_has_taskname();
  if (taskname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskname_;
    taskname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StateResponse::set_allocated_taskname(::std::string* taskname) {
  if (taskname_ != &::google::protobuf::internal::kEmptyString) {
    delete taskname_;
  }
  if (taskname) {
    set_has_taskname();
    taskname_ = taskname;
  } else {
    clear_has_taskname();
    taskname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// OverrideState

// optional string msgName = 1 [default = "OVERRIDESTATE"];
inline bool OverrideState::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OverrideState::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OverrideState::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OverrideState::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& OverrideState::msgname() const {
  return *msgname_;
}
inline void OverrideState::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void OverrideState::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void OverrideState::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OverrideState::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* OverrideState::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void OverrideState::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 appID = 2;
inline bool OverrideState::has_appid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OverrideState::set_has_appid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OverrideState::clear_has_appid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OverrideState::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 OverrideState::appid() const {
  return appid_;
}
inline void OverrideState::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional string newState = 3;
inline bool OverrideState::has_newstate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OverrideState::set_has_newstate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OverrideState::clear_has_newstate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OverrideState::clear_newstate() {
  if (newstate_ != &::google::protobuf::internal::kEmptyString) {
    newstate_->clear();
  }
  clear_has_newstate();
}
inline const ::std::string& OverrideState::newstate() const {
  return *newstate_;
}
inline void OverrideState::set_newstate(const ::std::string& value) {
  set_has_newstate();
  if (newstate_ == &::google::protobuf::internal::kEmptyString) {
    newstate_ = new ::std::string;
  }
  newstate_->assign(value);
}
inline void OverrideState::set_newstate(const char* value) {
  set_has_newstate();
  if (newstate_ == &::google::protobuf::internal::kEmptyString) {
    newstate_ = new ::std::string;
  }
  newstate_->assign(value);
}
inline void OverrideState::set_newstate(const char* value, size_t size) {
  set_has_newstate();
  if (newstate_ == &::google::protobuf::internal::kEmptyString) {
    newstate_ = new ::std::string;
  }
  newstate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OverrideState::mutable_newstate() {
  set_has_newstate();
  if (newstate_ == &::google::protobuf::internal::kEmptyString) {
    newstate_ = new ::std::string;
  }
  return newstate_;
}
inline ::std::string* OverrideState::release_newstate() {
  clear_has_newstate();
  if (newstate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = newstate_;
    newstate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OverrideState::set_allocated_newstate(::std::string* newstate) {
  if (newstate_ != &::google::protobuf::internal::kEmptyString) {
    delete newstate_;
  }
  if (newstate) {
    set_has_newstate();
    newstate_ = newstate;
  } else {
    clear_has_newstate();
    newstate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// COAConfig

// optional string msgName = 1 [default = "COACONFIG"];
inline bool COAConfig::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void COAConfig::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void COAConfig::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void COAConfig::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& COAConfig::msgname() const {
  return *msgname_;
}
inline void COAConfig::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void COAConfig::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void COAConfig::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* COAConfig::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* COAConfig::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void COAConfig::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// repeated string xmlCOA = 2;
inline int COAConfig::xmlcoa_size() const {
  return xmlcoa_.size();
}
inline void COAConfig::clear_xmlcoa() {
  xmlcoa_.Clear();
}
inline const ::std::string& COAConfig::xmlcoa(int index) const {
  return xmlcoa_.Get(index);
}
inline ::std::string* COAConfig::mutable_xmlcoa(int index) {
  return xmlcoa_.Mutable(index);
}
inline void COAConfig::set_xmlcoa(int index, const ::std::string& value) {
  xmlcoa_.Mutable(index)->assign(value);
}
inline void COAConfig::set_xmlcoa(int index, const char* value) {
  xmlcoa_.Mutable(index)->assign(value);
}
inline void COAConfig::set_xmlcoa(int index, const char* value, size_t size) {
  xmlcoa_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* COAConfig::add_xmlcoa() {
  return xmlcoa_.Add();
}
inline void COAConfig::add_xmlcoa(const ::std::string& value) {
  xmlcoa_.Add()->assign(value);
}
inline void COAConfig::add_xmlcoa(const char* value) {
  xmlcoa_.Add()->assign(value);
}
inline void COAConfig::add_xmlcoa(const char* value, size_t size) {
  xmlcoa_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
COAConfig::xmlcoa() const {
  return xmlcoa_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
COAConfig::mutable_xmlcoa() {
  return &xmlcoa_;
}

// -------------------------------------------------------------------

// AutoKillGUI

// optional string msgName = 1 [default = "AUTOKILLGUI"];
inline bool AutoKillGUI::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AutoKillGUI::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AutoKillGUI::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AutoKillGUI::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& AutoKillGUI::msgname() const {
  return *msgname_;
}
inline void AutoKillGUI::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AutoKillGUI::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void AutoKillGUI::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AutoKillGUI::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* AutoKillGUI::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void AutoKillGUI::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string state = 2;
inline bool AutoKillGUI::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AutoKillGUI::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AutoKillGUI::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AutoKillGUI::clear_state() {
  if (state_ != &::google::protobuf::internal::kEmptyString) {
    state_->clear();
  }
  clear_has_state();
}
inline const ::std::string& AutoKillGUI::state() const {
  return *state_;
}
inline void AutoKillGUI::set_state(const ::std::string& value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(value);
}
inline void AutoKillGUI::set_state(const char* value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(value);
}
inline void AutoKillGUI::set_state(const char* value, size_t size) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AutoKillGUI::mutable_state() {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  return state_;
}
inline ::std::string* AutoKillGUI::release_state() {
  clear_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = state_;
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AutoKillGUI::set_allocated_state(::std::string* state) {
  if (state_ != &::google::protobuf::internal::kEmptyString) {
    delete state_;
  }
  if (state) {
    set_has_state();
    state_ = state;
  } else {
    clear_has_state();
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string transition = 3;
inline bool AutoKillGUI::has_transition() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AutoKillGUI::set_has_transition() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AutoKillGUI::clear_has_transition() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AutoKillGUI::clear_transition() {
  if (transition_ != &::google::protobuf::internal::kEmptyString) {
    transition_->clear();
  }
  clear_has_transition();
}
inline const ::std::string& AutoKillGUI::transition() const {
  return *transition_;
}
inline void AutoKillGUI::set_transition(const ::std::string& value) {
  set_has_transition();
  if (transition_ == &::google::protobuf::internal::kEmptyString) {
    transition_ = new ::std::string;
  }
  transition_->assign(value);
}
inline void AutoKillGUI::set_transition(const char* value) {
  set_has_transition();
  if (transition_ == &::google::protobuf::internal::kEmptyString) {
    transition_ = new ::std::string;
  }
  transition_->assign(value);
}
inline void AutoKillGUI::set_transition(const char* value, size_t size) {
  set_has_transition();
  if (transition_ == &::google::protobuf::internal::kEmptyString) {
    transition_ = new ::std::string;
  }
  transition_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AutoKillGUI::mutable_transition() {
  set_has_transition();
  if (transition_ == &::google::protobuf::internal::kEmptyString) {
    transition_ = new ::std::string;
  }
  return transition_;
}
inline ::std::string* AutoKillGUI::release_transition() {
  clear_has_transition();
  if (transition_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = transition_;
    transition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AutoKillGUI::set_allocated_transition(::std::string* transition) {
  if (transition_ != &::google::protobuf::internal::kEmptyString) {
    delete transition_;
  }
  if (transition) {
    set_has_transition();
    transition_ = transition;
  } else {
    clear_has_transition();
    transition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace auto_kill_msg

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_AutoKillMessages_2eproto__INCLUDED
