// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FalconCommonMessages.proto

#ifndef PROTOBUF_FalconCommonMessages_2eproto__INCLUDED
#define PROTOBUF_FalconCommonMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace falcon_common_msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_FalconCommonMessages_2eproto();
void protobuf_AssignDesc_FalconCommonMessages_2eproto();
void protobuf_ShutdownFile_FalconCommonMessages_2eproto();

class BlacklistEntry;
class ExtraForkChannel;
class InterceptGoActive;
class GeoTip;
class PreDSource;
class MetaData;
class GeoResult;
class ClipRequest;
class ClipResponse;
class DetectionTip;
class Hop;
class Burst;
class SensorStatus;
class ReceiverStatus;
class Timestamp;
class ServiceReinitialize;
class SensorHeading;
class KeyValuePair;
class ValueContainer;
class GeodeticPosition;

// ===================================================================

class BlacklistEntry : public ::google::protobuf::Message {
 public:
  BlacklistEntry();
  virtual ~BlacklistEntry();

  BlacklistEntry(const BlacklistEntry& from);

  inline BlacklistEntry& operator=(const BlacklistEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlacklistEntry& default_instance();

  void Swap(BlacklistEntry* other);

  // implements Message ----------------------------------------------

  BlacklistEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlacklistEntry& from);
  void MergeFrom(const BlacklistEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional double minRF = 2 [default = -1];
  inline bool has_minrf() const;
  inline void clear_minrf();
  static const int kMinRFFieldNumber = 2;
  inline double minrf() const;
  inline void set_minrf(double value);

  // optional double maxRF = 3 [default = -1];
  inline bool has_maxrf() const;
  inline void clear_maxrf();
  static const int kMaxRFFieldNumber = 3;
  inline double maxrf() const;
  inline void set_maxrf(double value);

  // optional string scrypt = 4;
  inline bool has_scrypt() const;
  inline void clear_scrypt();
  static const int kScryptFieldNumber = 4;
  inline const ::std::string& scrypt() const;
  inline void set_scrypt(const ::std::string& value);
  inline void set_scrypt(const char* value);
  inline void set_scrypt(const char* value, size_t size);
  inline ::std::string* mutable_scrypt();
  inline ::std::string* release_scrypt();
  inline void set_allocated_scrypt(::std::string* scrypt);

  // optional float timeout = 5 [default = -1];
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 5;
  inline float timeout() const;
  inline void set_timeout(float value);

  // optional string uniqueID = 6 [default = ""];
  inline bool has_uniqueid() const;
  inline void clear_uniqueid();
  static const int kUniqueIDFieldNumber = 6;
  inline const ::std::string& uniqueid() const;
  inline void set_uniqueid(const ::std::string& value);
  inline void set_uniqueid(const char* value);
  inline void set_uniqueid(const char* value, size_t size);
  inline ::std::string* mutable_uniqueid();
  inline ::std::string* release_uniqueid();
  inline void set_allocated_uniqueid(::std::string* uniqueid);

  // @@protoc_insertion_point(class_scope:falcon_common_msg.BlacklistEntry)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_minrf();
  inline void clear_has_minrf();
  inline void set_has_maxrf();
  inline void clear_has_maxrf();
  inline void set_has_scrypt();
  inline void clear_has_scrypt();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_uniqueid();
  inline void clear_has_uniqueid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  double minrf_;
  double maxrf_;
  ::std::string* scrypt_;
  ::std::string* uniqueid_;
  float timeout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_FalconCommonMessages_2eproto();
  friend void protobuf_AssignDesc_FalconCommonMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconCommonMessages_2eproto();

  void InitAsDefaultInstance();
  static BlacklistEntry* default_instance_;
};
// -------------------------------------------------------------------

class ExtraForkChannel : public ::google::protobuf::Message {
 public:
  ExtraForkChannel();
  virtual ~ExtraForkChannel();

  ExtraForkChannel(const ExtraForkChannel& from);

  inline ExtraForkChannel& operator=(const ExtraForkChannel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExtraForkChannel& default_instance();

  void Swap(ExtraForkChannel* other);

  // implements Message ----------------------------------------------

  ExtraForkChannel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExtraForkChannel& from);
  void MergeFrom(const ExtraForkChannel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 channelID = 1;
  inline bool has_channelid() const;
  inline void clear_channelid();
  static const int kChannelIDFieldNumber = 1;
  inline ::google::protobuf::int32 channelid() const;
  inline void set_channelid(::google::protobuf::int32 value);

  // optional int32 inputPort = 2;
  inline bool has_inputport() const;
  inline void clear_inputport();
  static const int kInputPortFieldNumber = 2;
  inline ::google::protobuf::int32 inputport() const;
  inline void set_inputport(::google::protobuf::int32 value);

  // optional int32 outputPort = 3;
  inline bool has_outputport() const;
  inline void clear_outputport();
  static const int kOutputPortFieldNumber = 3;
  inline ::google::protobuf::int32 outputport() const;
  inline void set_outputport(::google::protobuf::int32 value);

  // optional int32 videoPort = 4;
  inline bool has_videoport() const;
  inline void clear_videoport();
  static const int kVideoPortFieldNumber = 4;
  inline ::google::protobuf::int32 videoport() const;
  inline void set_videoport(::google::protobuf::int32 value);

  // optional int32 launch_on_start = 5;
  inline bool has_launch_on_start() const;
  inline void clear_launch_on_start();
  static const int kLaunchOnStartFieldNumber = 5;
  inline ::google::protobuf::int32 launch_on_start() const;
  inline void set_launch_on_start(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_common_msg.ExtraForkChannel)
 private:
  inline void set_has_channelid();
  inline void clear_has_channelid();
  inline void set_has_inputport();
  inline void clear_has_inputport();
  inline void set_has_outputport();
  inline void clear_has_outputport();
  inline void set_has_videoport();
  inline void clear_has_videoport();
  inline void set_has_launch_on_start();
  inline void clear_has_launch_on_start();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 channelid_;
  ::google::protobuf::int32 inputport_;
  ::google::protobuf::int32 outputport_;
  ::google::protobuf::int32 videoport_;
  ::google::protobuf::int32 launch_on_start_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_FalconCommonMessages_2eproto();
  friend void protobuf_AssignDesc_FalconCommonMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconCommonMessages_2eproto();

  void InitAsDefaultInstance();
  static ExtraForkChannel* default_instance_;
};
// -------------------------------------------------------------------

class InterceptGoActive : public ::google::protobuf::Message {
 public:
  InterceptGoActive();
  virtual ~InterceptGoActive();

  InterceptGoActive(const InterceptGoActive& from);

  inline InterceptGoActive& operator=(const InterceptGoActive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InterceptGoActive& default_instance();

  void Swap(InterceptGoActive* other);

  // implements Message ----------------------------------------------

  InterceptGoActive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InterceptGoActive& from);
  void MergeFrom(const InterceptGoActive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "INTERCEPT_GO_ACTIVE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string hostname = 2 [default = ""];
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 2;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional double j1970Time = 3;
  inline bool has_j1970time() const;
  inline void clear_j1970time();
  static const int kJ1970TimeFieldNumber = 3;
  inline double j1970time() const;
  inline void set_j1970time(double value);

  // optional string uniqueID = 4 [default = ""];
  inline bool has_uniqueid() const;
  inline void clear_uniqueid();
  static const int kUniqueIDFieldNumber = 4;
  inline const ::std::string& uniqueid() const;
  inline void set_uniqueid(const ::std::string& value);
  inline void set_uniqueid(const char* value);
  inline void set_uniqueid(const char* value, size_t size);
  inline ::std::string* mutable_uniqueid();
  inline ::std::string* release_uniqueid();
  inline void set_allocated_uniqueid(::std::string* uniqueid);

  // optional bool jam = 5 [default = false];
  inline bool has_jam() const;
  inline void clear_jam();
  static const int kJamFieldNumber = 5;
  inline bool jam() const;
  inline void set_jam(bool value);

  // @@protoc_insertion_point(class_scope:falcon_common_msg.InterceptGoActive)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_j1970time();
  inline void clear_has_j1970time();
  inline void set_has_uniqueid();
  inline void clear_has_uniqueid();
  inline void set_has_jam();
  inline void clear_has_jam();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* hostname_;
  double j1970time_;
  ::std::string* uniqueid_;
  bool jam_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_FalconCommonMessages_2eproto();
  friend void protobuf_AssignDesc_FalconCommonMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconCommonMessages_2eproto();

  void InitAsDefaultInstance();
  static InterceptGoActive* default_instance_;
};
// -------------------------------------------------------------------

class GeoTip : public ::google::protobuf::Message {
 public:
  GeoTip();
  virtual ~GeoTip();

  GeoTip(const GeoTip& from);

  inline GeoTip& operator=(const GeoTip& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GeoTip& default_instance();

  void Swap(GeoTip* other);

  // implements Message ----------------------------------------------

  GeoTip* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GeoTip& from);
  void MergeFrom(const GeoTip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .falcon_common_msg.PreDSource pred_source = 1;
  inline int pred_source_size() const;
  inline void clear_pred_source();
  static const int kPredSourceFieldNumber = 1;
  inline const ::falcon_common_msg::PreDSource& pred_source(int index) const;
  inline ::falcon_common_msg::PreDSource* mutable_pred_source(int index);
  inline ::falcon_common_msg::PreDSource* add_pred_source();
  inline const ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::PreDSource >&
      pred_source() const;
  inline ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::PreDSource >*
      mutable_pred_source();

  // optional string tip_id = 4;
  inline bool has_tip_id() const;
  inline void clear_tip_id();
  static const int kTipIdFieldNumber = 4;
  inline const ::std::string& tip_id() const;
  inline void set_tip_id(const ::std::string& value);
  inline void set_tip_id(const char* value);
  inline void set_tip_id(const char* value, size_t size);
  inline ::std::string* mutable_tip_id();
  inline ::std::string* release_tip_id();
  inline void set_allocated_tip_id(::std::string* tip_id);

  // @@protoc_insertion_point(class_scope:falcon_common_msg.GeoTip)
 private:
  inline void set_has_tip_id();
  inline void clear_has_tip_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::PreDSource > pred_source_;
  ::std::string* tip_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconCommonMessages_2eproto();
  friend void protobuf_AssignDesc_FalconCommonMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconCommonMessages_2eproto();

  void InitAsDefaultInstance();
  static GeoTip* default_instance_;
};
// -------------------------------------------------------------------

class PreDSource : public ::google::protobuf::Message {
 public:
  PreDSource();
  virtual ~PreDSource();

  PreDSource(const PreDSource& from);

  inline PreDSource& operator=(const PreDSource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PreDSource& default_instance();

  void Swap(PreDSource* other);

  // implements Message ----------------------------------------------

  PreDSource* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PreDSource& from);
  void MergeFrom(const PreDSource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string filename = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional string hostname = 2;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 2;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional .falcon_common_msg.MetaData meta_data = 3;
  inline bool has_meta_data() const;
  inline void clear_meta_data();
  static const int kMetaDataFieldNumber = 3;
  inline const ::falcon_common_msg::MetaData& meta_data() const;
  inline ::falcon_common_msg::MetaData* mutable_meta_data();
  inline ::falcon_common_msg::MetaData* release_meta_data();
  inline void set_allocated_meta_data(::falcon_common_msg::MetaData* meta_data);

  // @@protoc_insertion_point(class_scope:falcon_common_msg.PreDSource)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_meta_data();
  inline void clear_has_meta_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* filename_;
  ::std::string* hostname_;
  ::falcon_common_msg::MetaData* meta_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconCommonMessages_2eproto();
  friend void protobuf_AssignDesc_FalconCommonMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconCommonMessages_2eproto();

  void InitAsDefaultInstance();
  static PreDSource* default_instance_;
};
// -------------------------------------------------------------------

class MetaData : public ::google::protobuf::Message {
 public:
  MetaData();
  virtual ~MetaData();

  MetaData(const MetaData& from);

  inline MetaData& operator=(const MetaData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MetaData& default_instance();

  void Swap(MetaData* other);

  // implements Message ----------------------------------------------

  MetaData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MetaData& from);
  void MergeFrom(const MetaData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double wholeSec = 1;
  inline bool has_wholesec() const;
  inline void clear_wholesec();
  static const int kWholeSecFieldNumber = 1;
  inline double wholesec() const;
  inline void set_wholesec(double value);

  // optional double fracSec = 2;
  inline bool has_fracsec() const;
  inline void clear_fracsec();
  static const int kFracSecFieldNumber = 2;
  inline double fracsec() const;
  inline void set_fracsec(double value);

  // optional double duration = 3;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 3;
  inline double duration() const;
  inline void set_duration(double value);

  // optional double centerFrequency = 10;
  inline bool has_centerfrequency() const;
  inline void clear_centerfrequency();
  static const int kCenterFrequencyFieldNumber = 10;
  inline double centerfrequency() const;
  inline void set_centerfrequency(double value);

  // optional double sampleRate = 11;
  inline bool has_samplerate() const;
  inline void clear_samplerate();
  static const int kSampleRateFieldNumber = 11;
  inline double samplerate() const;
  inline void set_samplerate(double value);

  // optional double bandwidth = 12;
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandwidthFieldNumber = 12;
  inline double bandwidth() const;
  inline void set_bandwidth(double value);

  // optional string eltex = 20;
  inline bool has_eltex() const;
  inline void clear_eltex();
  static const int kEltexFieldNumber = 20;
  inline const ::std::string& eltex() const;
  inline void set_eltex(const ::std::string& value);
  inline void set_eltex(const char* value);
  inline void set_eltex(const char* value, size_t size);
  inline ::std::string* mutable_eltex();
  inline ::std::string* release_eltex();
  inline void set_allocated_eltex(::std::string* eltex);

  // optional string soiNum = 21;
  inline bool has_soinum() const;
  inline void clear_soinum();
  static const int kSoiNumFieldNumber = 21;
  inline const ::std::string& soinum() const;
  inline void set_soinum(const ::std::string& value);
  inline void set_soinum(const char* value);
  inline void set_soinum(const char* value, size_t size);
  inline ::std::string* mutable_soinum();
  inline ::std::string* release_soinum();
  inline void set_allocated_soinum(::std::string* soinum);

  // optional string globalId = 22;
  inline bool has_globalid() const;
  inline void clear_globalid();
  static const int kGlobalIdFieldNumber = 22;
  inline const ::std::string& globalid() const;
  inline void set_globalid(const ::std::string& value);
  inline void set_globalid(const char* value);
  inline void set_globalid(const char* value, size_t size);
  inline ::std::string* mutable_globalid();
  inline ::std::string* release_globalid();
  inline void set_allocated_globalid(::std::string* globalid);

  // @@protoc_insertion_point(class_scope:falcon_common_msg.MetaData)
 private:
  inline void set_has_wholesec();
  inline void clear_has_wholesec();
  inline void set_has_fracsec();
  inline void clear_has_fracsec();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_centerfrequency();
  inline void clear_has_centerfrequency();
  inline void set_has_samplerate();
  inline void clear_has_samplerate();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();
  inline void set_has_eltex();
  inline void clear_has_eltex();
  inline void set_has_soinum();
  inline void clear_has_soinum();
  inline void set_has_globalid();
  inline void clear_has_globalid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double wholesec_;
  double fracsec_;
  double duration_;
  double centerfrequency_;
  double samplerate_;
  double bandwidth_;
  ::std::string* eltex_;
  ::std::string* soinum_;
  ::std::string* globalid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_FalconCommonMessages_2eproto();
  friend void protobuf_AssignDesc_FalconCommonMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconCommonMessages_2eproto();

  void InitAsDefaultInstance();
  static MetaData* default_instance_;
};
// -------------------------------------------------------------------

class GeoResult : public ::google::protobuf::Message {
 public:
  GeoResult();
  virtual ~GeoResult();

  GeoResult(const GeoResult& from);

  inline GeoResult& operator=(const GeoResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GeoResult& default_instance();

  void Swap(GeoResult* other);

  // implements Message ----------------------------------------------

  GeoResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GeoResult& from);
  void MergeFrom(const GeoResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "GEO_RESULT"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string hostname = 2;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 2;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional double j1970Time = 3;
  inline bool has_j1970time() const;
  inline void clear_j1970time();
  static const int kJ1970TimeFieldNumber = 3;
  inline double j1970time() const;
  inline void set_j1970time(double value);

  // optional double x = 4;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 4;
  inline double x() const;
  inline void set_x(double value);

  // optional double y = 5;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 5;
  inline double y() const;
  inline void set_y(double value);

  // optional double z = 6;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 6;
  inline double z() const;
  inline void set_z(double value);

  // optional double alt = 7;
  inline bool has_alt() const;
  inline void clear_alt();
  static const int kAltFieldNumber = 7;
  inline double alt() const;
  inline void set_alt(double value);

  // optional double lat = 8;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 8;
  inline double lat() const;
  inline void set_lat(double value);

  // optional double lon = 9;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 9;
  inline double lon() const;
  inline void set_lon(double value);

  // optional double semiMajor = 10;
  inline bool has_semimajor() const;
  inline void clear_semimajor();
  static const int kSemiMajorFieldNumber = 10;
  inline double semimajor() const;
  inline void set_semimajor(double value);

  // optional double semiMinor = 11;
  inline bool has_semiminor() const;
  inline void clear_semiminor();
  static const int kSemiMinorFieldNumber = 11;
  inline double semiminor() const;
  inline void set_semiminor(double value);

  // optional double orientation = 12;
  inline bool has_orientation() const;
  inline void clear_orientation();
  static const int kOrientationFieldNumber = 12;
  inline double orientation() const;
  inline void set_orientation(double value);

  // optional string soi = 13;
  inline bool has_soi() const;
  inline void clear_soi();
  static const int kSoiFieldNumber = 13;
  inline const ::std::string& soi() const;
  inline void set_soi(const ::std::string& value);
  inline void set_soi(const char* value);
  inline void set_soi(const char* value, size_t size);
  inline ::std::string* mutable_soi();
  inline ::std::string* release_soi();
  inline void set_allocated_soi(::std::string* soi);

  // optional string uniqueID = 14 [default = ""];
  inline bool has_uniqueid() const;
  inline void clear_uniqueid();
  static const int kUniqueIDFieldNumber = 14;
  inline const ::std::string& uniqueid() const;
  inline void set_uniqueid(const ::std::string& value);
  inline void set_uniqueid(const char* value);
  inline void set_uniqueid(const char* value, size_t size);
  inline ::std::string* mutable_uniqueid();
  inline ::std::string* release_uniqueid();
  inline void set_allocated_uniqueid(::std::string* uniqueid);

  // optional int32 channel = 15 [default = 1];
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 15;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional string eventID = 16;
  inline bool has_eventid() const;
  inline void clear_eventid();
  static const int kEventIDFieldNumber = 16;
  inline const ::std::string& eventid() const;
  inline void set_eventid(const ::std::string& value);
  inline void set_eventid(const char* value);
  inline void set_eventid(const char* value, size_t size);
  inline ::std::string* mutable_eventid();
  inline ::std::string* release_eventid();
  inline void set_allocated_eventid(::std::string* eventid);

  // optional float wpLatitude = 17;
  inline bool has_wplatitude() const;
  inline void clear_wplatitude();
  static const int kWpLatitudeFieldNumber = 17;
  inline float wplatitude() const;
  inline void set_wplatitude(float value);

  // optional float wpLongitude = 18;
  inline bool has_wplongitude() const;
  inline void clear_wplongitude();
  static const int kWpLongitudeFieldNumber = 18;
  inline float wplongitude() const;
  inline void set_wplongitude(float value);

  // optional float velocity = 19;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 19;
  inline float velocity() const;
  inline void set_velocity(float value);

  // optional float bearing = 20;
  inline bool has_bearing() const;
  inline void clear_bearing();
  static const int kBearingFieldNumber = 20;
  inline float bearing() const;
  inline void set_bearing(float value);

  // optional float seqnum = 21;
  inline bool has_seqnum() const;
  inline void clear_seqnum();
  static const int kSeqnumFieldNumber = 21;
  inline float seqnum() const;
  inline void set_seqnum(float value);

  // optional bool valid = 26;
  inline bool has_valid() const;
  inline void clear_valid();
  static const int kValidFieldNumber = 26;
  inline bool valid() const;
  inline void set_valid(bool value);

  // optional double cep = 27;
  inline bool has_cep() const;
  inline void clear_cep();
  static const int kCepFieldNumber = 27;
  inline double cep() const;
  inline void set_cep(double value);

  // optional double freq_hz = 28;
  inline bool has_freq_hz() const;
  inline void clear_freq_hz();
  static const int kFreqHzFieldNumber = 28;
  inline double freq_hz() const;
  inline void set_freq_hz(double value);

  // optional double bw_hz = 29;
  inline bool has_bw_hz() const;
  inline void clear_bw_hz();
  static const int kBwHzFieldNumber = 29;
  inline double bw_hz() const;
  inline void set_bw_hz(double value);

  // optional string combining_type = 30;
  inline bool has_combining_type() const;
  inline void clear_combining_type();
  static const int kCombiningTypeFieldNumber = 30;
  inline const ::std::string& combining_type() const;
  inline void set_combining_type(const ::std::string& value);
  inline void set_combining_type(const char* value);
  inline void set_combining_type(const char* value, size_t size);
  inline ::std::string* mutable_combining_type();
  inline ::std::string* release_combining_type();
  inline void set_allocated_combining_type(::std::string* combining_type);

  // optional string diagnostic = 31;
  inline bool has_diagnostic() const;
  inline void clear_diagnostic();
  static const int kDiagnosticFieldNumber = 31;
  inline const ::std::string& diagnostic() const;
  inline void set_diagnostic(const ::std::string& value);
  inline void set_diagnostic(const char* value);
  inline void set_diagnostic(const char* value, size_t size);
  inline ::std::string* mutable_diagnostic();
  inline ::std::string* release_diagnostic();
  inline void set_allocated_diagnostic(::std::string* diagnostic);

  // optional string qualifier = 32;
  inline bool has_qualifier() const;
  inline void clear_qualifier();
  static const int kQualifierFieldNumber = 32;
  inline const ::std::string& qualifier() const;
  inline void set_qualifier(const ::std::string& value);
  inline void set_qualifier(const char* value);
  inline void set_qualifier(const char* value, size_t size);
  inline ::std::string* mutable_qualifier();
  inline ::std::string* release_qualifier();
  inline void set_allocated_qualifier(::std::string* qualifier);

  // optional string tip_id = 33;
  inline bool has_tip_id() const;
  inline void clear_tip_id();
  static const int kTipIdFieldNumber = 33;
  inline const ::std::string& tip_id() const;
  inline void set_tip_id(const ::std::string& value);
  inline void set_tip_id(const char* value);
  inline void set_tip_id(const char* value, size_t size);
  inline ::std::string* mutable_tip_id();
  inline ::std::string* release_tip_id();
  inline void set_allocated_tip_id(::std::string* tip_id);

  // @@protoc_insertion_point(class_scope:falcon_common_msg.GeoResult)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_j1970time();
  inline void clear_has_j1970time();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_alt();
  inline void clear_has_alt();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_semimajor();
  inline void clear_has_semimajor();
  inline void set_has_semiminor();
  inline void clear_has_semiminor();
  inline void set_has_orientation();
  inline void clear_has_orientation();
  inline void set_has_soi();
  inline void clear_has_soi();
  inline void set_has_uniqueid();
  inline void clear_has_uniqueid();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_eventid();
  inline void clear_has_eventid();
  inline void set_has_wplatitude();
  inline void clear_has_wplatitude();
  inline void set_has_wplongitude();
  inline void clear_has_wplongitude();
  inline void set_has_velocity();
  inline void clear_has_velocity();
  inline void set_has_bearing();
  inline void clear_has_bearing();
  inline void set_has_seqnum();
  inline void clear_has_seqnum();
  inline void set_has_valid();
  inline void clear_has_valid();
  inline void set_has_cep();
  inline void clear_has_cep();
  inline void set_has_freq_hz();
  inline void clear_has_freq_hz();
  inline void set_has_bw_hz();
  inline void clear_has_bw_hz();
  inline void set_has_combining_type();
  inline void clear_has_combining_type();
  inline void set_has_diagnostic();
  inline void clear_has_diagnostic();
  inline void set_has_qualifier();
  inline void clear_has_qualifier();
  inline void set_has_tip_id();
  inline void clear_has_tip_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* hostname_;
  double j1970time_;
  double x_;
  double y_;
  double z_;
  double alt_;
  double lat_;
  double lon_;
  double semimajor_;
  double semiminor_;
  double orientation_;
  ::std::string* soi_;
  ::std::string* uniqueid_;
  ::std::string* eventid_;
  ::google::protobuf::int32 channel_;
  float wplatitude_;
  float wplongitude_;
  float velocity_;
  float bearing_;
  float seqnum_;
  double cep_;
  double freq_hz_;
  double bw_hz_;
  ::std::string* combining_type_;
  ::std::string* diagnostic_;
  ::std::string* qualifier_;
  ::std::string* tip_id_;
  bool valid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(29 + 31) / 32];

  friend void  protobuf_AddDesc_FalconCommonMessages_2eproto();
  friend void protobuf_AssignDesc_FalconCommonMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconCommonMessages_2eproto();

  void InitAsDefaultInstance();
  static GeoResult* default_instance_;
};
// -------------------------------------------------------------------

class ClipRequest : public ::google::protobuf::Message {
 public:
  ClipRequest();
  virtual ~ClipRequest();

  ClipRequest(const ClipRequest& from);

  inline ClipRequest& operator=(const ClipRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClipRequest& default_instance();

  void Swap(ClipRequest* other);

  // implements Message ----------------------------------------------

  ClipRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClipRequest& from);
  void MergeFrom(const ClipRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "CLIPREQUEST"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional double timeWhole = 2;
  inline bool has_timewhole() const;
  inline void clear_timewhole();
  static const int kTimeWholeFieldNumber = 2;
  inline double timewhole() const;
  inline void set_timewhole(double value);

  // optional double timeFractional = 3;
  inline bool has_timefractional() const;
  inline void clear_timefractional();
  static const int kTimeFractionalFieldNumber = 3;
  inline double timefractional() const;
  inline void set_timefractional(double value);

  // optional double duration = 4;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 4;
  inline double duration() const;
  inline void set_duration(double value);

  // optional double centerFrequency = 5;
  inline bool has_centerfrequency() const;
  inline void clear_centerfrequency();
  static const int kCenterFrequencyFieldNumber = 5;
  inline double centerfrequency() const;
  inline void set_centerfrequency(double value);

  // optional double freqOffset = 6;
  inline bool has_freqoffset() const;
  inline void clear_freqoffset();
  static const int kFreqOffsetFieldNumber = 6;
  inline double freqoffset() const;
  inline void set_freqoffset(double value);

  // optional double sampleRate = 7;
  inline bool has_samplerate() const;
  inline void clear_samplerate();
  static const int kSampleRateFieldNumber = 7;
  inline double samplerate() const;
  inline void set_samplerate(double value);

  // optional double bandwidth = 8;
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandwidthFieldNumber = 8;
  inline double bandwidth() const;
  inline void set_bandwidth(double value);

  // optional string soiNum = 9;
  inline bool has_soinum() const;
  inline void clear_soinum();
  static const int kSoiNumFieldNumber = 9;
  inline const ::std::string& soinum() const;
  inline void set_soinum(const ::std::string& value);
  inline void set_soinum(const char* value);
  inline void set_soinum(const char* value, size_t size);
  inline ::std::string* mutable_soinum();
  inline ::std::string* release_soinum();
  inline void set_allocated_soinum(::std::string* soinum);

  // optional string globalId = 10;
  inline bool has_globalid() const;
  inline void clear_globalid();
  static const int kGlobalIdFieldNumber = 10;
  inline const ::std::string& globalid() const;
  inline void set_globalid(const ::std::string& value);
  inline void set_globalid(const char* value);
  inline void set_globalid(const char* value, size_t size);
  inline ::std::string* mutable_globalid();
  inline ::std::string* release_globalid();
  inline void set_allocated_globalid(::std::string* globalid);

  // optional int64 idNumber = 11;
  inline bool has_idnumber() const;
  inline void clear_idnumber();
  static const int kIdNumberFieldNumber = 11;
  inline ::google::protobuf::int64 idnumber() const;
  inline void set_idnumber(::google::protobuf::int64 value);

  // optional string sensorName = 12;
  inline bool has_sensorname() const;
  inline void clear_sensorname();
  static const int kSensorNameFieldNumber = 12;
  inline const ::std::string& sensorname() const;
  inline void set_sensorname(const ::std::string& value);
  inline void set_sensorname(const char* value);
  inline void set_sensorname(const char* value, size_t size);
  inline ::std::string* mutable_sensorname();
  inline ::std::string* release_sensorname();
  inline void set_allocated_sensorname(::std::string* sensorname);

  // @@protoc_insertion_point(class_scope:falcon_common_msg.ClipRequest)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_timewhole();
  inline void clear_has_timewhole();
  inline void set_has_timefractional();
  inline void clear_has_timefractional();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_centerfrequency();
  inline void clear_has_centerfrequency();
  inline void set_has_freqoffset();
  inline void clear_has_freqoffset();
  inline void set_has_samplerate();
  inline void clear_has_samplerate();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();
  inline void set_has_soinum();
  inline void clear_has_soinum();
  inline void set_has_globalid();
  inline void clear_has_globalid();
  inline void set_has_idnumber();
  inline void clear_has_idnumber();
  inline void set_has_sensorname();
  inline void clear_has_sensorname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  double timewhole_;
  double timefractional_;
  double duration_;
  double centerfrequency_;
  double freqoffset_;
  double samplerate_;
  double bandwidth_;
  ::std::string* soinum_;
  ::std::string* globalid_;
  ::google::protobuf::int64 idnumber_;
  ::std::string* sensorname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_FalconCommonMessages_2eproto();
  friend void protobuf_AssignDesc_FalconCommonMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconCommonMessages_2eproto();

  void InitAsDefaultInstance();
  static ClipRequest* default_instance_;
};
// -------------------------------------------------------------------

class ClipResponse : public ::google::protobuf::Message {
 public:
  ClipResponse();
  virtual ~ClipResponse();

  ClipResponse(const ClipResponse& from);

  inline ClipResponse& operator=(const ClipResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClipResponse& default_instance();

  void Swap(ClipResponse* other);

  // implements Message ----------------------------------------------

  ClipResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClipResponse& from);
  void MergeFrom(const ClipResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "CLIPRESPONSE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional .falcon_common_msg.GeoTip geoTip = 2;
  inline bool has_geotip() const;
  inline void clear_geotip();
  static const int kGeoTipFieldNumber = 2;
  inline const ::falcon_common_msg::GeoTip& geotip() const;
  inline ::falcon_common_msg::GeoTip* mutable_geotip();
  inline ::falcon_common_msg::GeoTip* release_geotip();
  inline void set_allocated_geotip(::falcon_common_msg::GeoTip* geotip);

  // optional int64 idNumber = 3;
  inline bool has_idnumber() const;
  inline void clear_idnumber();
  static const int kIdNumberFieldNumber = 3;
  inline ::google::protobuf::int64 idnumber() const;
  inline void set_idnumber(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:falcon_common_msg.ClipResponse)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_geotip();
  inline void clear_has_geotip();
  inline void set_has_idnumber();
  inline void clear_has_idnumber();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::falcon_common_msg::GeoTip* geotip_;
  ::google::protobuf::int64 idnumber_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconCommonMessages_2eproto();
  friend void protobuf_AssignDesc_FalconCommonMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconCommonMessages_2eproto();

  void InitAsDefaultInstance();
  static ClipResponse* default_instance_;
};
// -------------------------------------------------------------------

class DetectionTip : public ::google::protobuf::Message {
 public:
  DetectionTip();
  virtual ~DetectionTip();

  DetectionTip(const DetectionTip& from);

  inline DetectionTip& operator=(const DetectionTip& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DetectionTip& default_instance();

  void Swap(DetectionTip* other);

  // implements Message ----------------------------------------------

  DetectionTip* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DetectionTip& from);
  void MergeFrom(const DetectionTip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "DETECTIONTIP"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string det_id = 2;
  inline bool has_det_id() const;
  inline void clear_det_id();
  static const int kDetIdFieldNumber = 2;
  inline const ::std::string& det_id() const;
  inline void set_det_id(const ::std::string& value);
  inline void set_det_id(const char* value);
  inline void set_det_id(const char* value, size_t size);
  inline ::std::string* mutable_det_id();
  inline ::std::string* release_det_id();
  inline void set_allocated_det_id(::std::string* det_id);

  // optional string sensor_id = 3;
  inline bool has_sensor_id() const;
  inline void clear_sensor_id();
  static const int kSensorIdFieldNumber = 3;
  inline const ::std::string& sensor_id() const;
  inline void set_sensor_id(const ::std::string& value);
  inline void set_sensor_id(const char* value);
  inline void set_sensor_id(const char* value, size_t size);
  inline ::std::string* mutable_sensor_id();
  inline ::std::string* release_sensor_id();
  inline void set_allocated_sensor_id(::std::string* sensor_id);

  // optional bool has_pred = 4;
  inline bool has_has_pred() const;
  inline void clear_has_pred();
  static const int kHasPredFieldNumber = 4;
  inline bool has_pred() const;
  inline void set_has_pred(bool value);

  // optional string file_location = 5;
  inline bool has_file_location() const;
  inline void clear_file_location();
  static const int kFileLocationFieldNumber = 5;
  inline const ::std::string& file_location() const;
  inline void set_file_location(const ::std::string& value);
  inline void set_file_location(const char* value);
  inline void set_file_location(const char* value, size_t size);
  inline ::std::string* mutable_file_location();
  inline ::std::string* release_file_location();
  inline void set_allocated_file_location(::std::string* file_location);

  // optional double start_time_whole = 6;
  inline bool has_start_time_whole() const;
  inline void clear_start_time_whole();
  static const int kStartTimeWholeFieldNumber = 6;
  inline double start_time_whole() const;
  inline void set_start_time_whole(double value);

  // optional double start_time_frac = 7;
  inline bool has_start_time_frac() const;
  inline void clear_start_time_frac();
  static const int kStartTimeFracFieldNumber = 7;
  inline double start_time_frac() const;
  inline void set_start_time_frac(double value);

  // optional double duration_millisec = 8;
  inline bool has_duration_millisec() const;
  inline void clear_duration_millisec();
  static const int kDurationMillisecFieldNumber = 8;
  inline double duration_millisec() const;
  inline void set_duration_millisec(double value);

  // optional double center_tune_freq_hz = 9;
  inline bool has_center_tune_freq_hz() const;
  inline void clear_center_tune_freq_hz();
  static const int kCenterTuneFreqHzFieldNumber = 9;
  inline double center_tune_freq_hz() const;
  inline void set_center_tune_freq_hz(double value);

  // optional double bandwidth_hz = 10;
  inline bool has_bandwidth_hz() const;
  inline void clear_bandwidth_hz();
  static const int kBandwidthHzFieldNumber = 10;
  inline double bandwidth_hz() const;
  inline void set_bandwidth_hz(double value);

  // repeated .falcon_common_msg.Hop hops = 11;
  inline int hops_size() const;
  inline void clear_hops();
  static const int kHopsFieldNumber = 11;
  inline const ::falcon_common_msg::Hop& hops(int index) const;
  inline ::falcon_common_msg::Hop* mutable_hops(int index);
  inline ::falcon_common_msg::Hop* add_hops();
  inline const ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::Hop >&
      hops() const;
  inline ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::Hop >*
      mutable_hops();

  // repeated .falcon_common_msg.Burst bursts = 12;
  inline int bursts_size() const;
  inline void clear_bursts();
  static const int kBurstsFieldNumber = 12;
  inline const ::falcon_common_msg::Burst& bursts(int index) const;
  inline ::falcon_common_msg::Burst* mutable_bursts(int index);
  inline ::falcon_common_msg::Burst* add_bursts();
  inline const ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::Burst >&
      bursts() const;
  inline ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::Burst >*
      mutable_bursts();

  // @@protoc_insertion_point(class_scope:falcon_common_msg.DetectionTip)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_det_id();
  inline void clear_has_det_id();
  inline void set_has_sensor_id();
  inline void clear_has_sensor_id();
  inline void set_has_has_pred();
  inline void clear_has_has_pred();
  inline void set_has_file_location();
  inline void clear_has_file_location();
  inline void set_has_start_time_whole();
  inline void clear_has_start_time_whole();
  inline void set_has_start_time_frac();
  inline void clear_has_start_time_frac();
  inline void set_has_duration_millisec();
  inline void clear_has_duration_millisec();
  inline void set_has_center_tune_freq_hz();
  inline void clear_has_center_tune_freq_hz();
  inline void set_has_bandwidth_hz();
  inline void clear_has_bandwidth_hz();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* det_id_;
  ::std::string* sensor_id_;
  ::std::string* file_location_;
  double start_time_whole_;
  double start_time_frac_;
  double duration_millisec_;
  double center_tune_freq_hz_;
  double bandwidth_hz_;
  ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::Hop > hops_;
  ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::Burst > bursts_;
  bool has_pred_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_FalconCommonMessages_2eproto();
  friend void protobuf_AssignDesc_FalconCommonMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconCommonMessages_2eproto();

  void InitAsDefaultInstance();
  static DetectionTip* default_instance_;
};
// -------------------------------------------------------------------

class Hop : public ::google::protobuf::Message {
 public:
  Hop();
  virtual ~Hop();

  Hop(const Hop& from);

  inline Hop& operator=(const Hop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Hop& default_instance();

  void Swap(Hop* other);

  // implements Message ----------------------------------------------

  Hop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Hop& from);
  void MergeFrom(const Hop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string hop_id = 1;
  inline bool has_hop_id() const;
  inline void clear_hop_id();
  static const int kHopIdFieldNumber = 1;
  inline const ::std::string& hop_id() const;
  inline void set_hop_id(const ::std::string& value);
  inline void set_hop_id(const char* value);
  inline void set_hop_id(const char* value, size_t size);
  inline ::std::string* mutable_hop_id();
  inline ::std::string* release_hop_id();
  inline void set_allocated_hop_id(::std::string* hop_id);

  // optional double start_time_whole = 2;
  inline bool has_start_time_whole() const;
  inline void clear_start_time_whole();
  static const int kStartTimeWholeFieldNumber = 2;
  inline double start_time_whole() const;
  inline void set_start_time_whole(double value);

  // optional double start_time_frac = 3;
  inline bool has_start_time_frac() const;
  inline void clear_start_time_frac();
  static const int kStartTimeFracFieldNumber = 3;
  inline double start_time_frac() const;
  inline void set_start_time_frac(double value);

  // optional double duration_millisec = 4;
  inline bool has_duration_millisec() const;
  inline void clear_duration_millisec();
  static const int kDurationMillisecFieldNumber = 4;
  inline double duration_millisec() const;
  inline void set_duration_millisec(double value);

  // optional double hop_center_freq_hz = 5;
  inline bool has_hop_center_freq_hz() const;
  inline void clear_hop_center_freq_hz();
  static const int kHopCenterFreqHzFieldNumber = 5;
  inline double hop_center_freq_hz() const;
  inline void set_hop_center_freq_hz(double value);

  // optional double hop_bw_hz = 6;
  inline bool has_hop_bw_hz() const;
  inline void clear_hop_bw_hz();
  static const int kHopBwHzFieldNumber = 6;
  inline double hop_bw_hz() const;
  inline void set_hop_bw_hz(double value);

  // @@protoc_insertion_point(class_scope:falcon_common_msg.Hop)
 private:
  inline void set_has_hop_id();
  inline void clear_has_hop_id();
  inline void set_has_start_time_whole();
  inline void clear_has_start_time_whole();
  inline void set_has_start_time_frac();
  inline void clear_has_start_time_frac();
  inline void set_has_duration_millisec();
  inline void clear_has_duration_millisec();
  inline void set_has_hop_center_freq_hz();
  inline void clear_has_hop_center_freq_hz();
  inline void set_has_hop_bw_hz();
  inline void clear_has_hop_bw_hz();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* hop_id_;
  double start_time_whole_;
  double start_time_frac_;
  double duration_millisec_;
  double hop_center_freq_hz_;
  double hop_bw_hz_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_FalconCommonMessages_2eproto();
  friend void protobuf_AssignDesc_FalconCommonMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconCommonMessages_2eproto();

  void InitAsDefaultInstance();
  static Hop* default_instance_;
};
// -------------------------------------------------------------------

class Burst : public ::google::protobuf::Message {
 public:
  Burst();
  virtual ~Burst();

  Burst(const Burst& from);

  inline Burst& operator=(const Burst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Burst& default_instance();

  void Swap(Burst* other);

  // implements Message ----------------------------------------------

  Burst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Burst& from);
  void MergeFrom(const Burst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string burst_id = 1;
  inline bool has_burst_id() const;
  inline void clear_burst_id();
  static const int kBurstIdFieldNumber = 1;
  inline const ::std::string& burst_id() const;
  inline void set_burst_id(const ::std::string& value);
  inline void set_burst_id(const char* value);
  inline void set_burst_id(const char* value, size_t size);
  inline ::std::string* mutable_burst_id();
  inline ::std::string* release_burst_id();
  inline void set_allocated_burst_id(::std::string* burst_id);

  // optional double start_time_whole = 2;
  inline bool has_start_time_whole() const;
  inline void clear_start_time_whole();
  static const int kStartTimeWholeFieldNumber = 2;
  inline double start_time_whole() const;
  inline void set_start_time_whole(double value);

  // optional double start_time_frac = 3;
  inline bool has_start_time_frac() const;
  inline void clear_start_time_frac();
  static const int kStartTimeFracFieldNumber = 3;
  inline double start_time_frac() const;
  inline void set_start_time_frac(double value);

  // optional double duration_millisec = 4;
  inline bool has_duration_millisec() const;
  inline void clear_duration_millisec();
  static const int kDurationMillisecFieldNumber = 4;
  inline double duration_millisec() const;
  inline void set_duration_millisec(double value);

  // optional double burst_center_freq_hz = 5;
  inline bool has_burst_center_freq_hz() const;
  inline void clear_burst_center_freq_hz();
  static const int kBurstCenterFreqHzFieldNumber = 5;
  inline double burst_center_freq_hz() const;
  inline void set_burst_center_freq_hz(double value);

  // optional double burst_bw_hz = 6;
  inline bool has_burst_bw_hz() const;
  inline void clear_burst_bw_hz();
  static const int kBurstBwHzFieldNumber = 6;
  inline double burst_bw_hz() const;
  inline void set_burst_bw_hz(double value);

  // @@protoc_insertion_point(class_scope:falcon_common_msg.Burst)
 private:
  inline void set_has_burst_id();
  inline void clear_has_burst_id();
  inline void set_has_start_time_whole();
  inline void clear_has_start_time_whole();
  inline void set_has_start_time_frac();
  inline void clear_has_start_time_frac();
  inline void set_has_duration_millisec();
  inline void clear_has_duration_millisec();
  inline void set_has_burst_center_freq_hz();
  inline void clear_has_burst_center_freq_hz();
  inline void set_has_burst_bw_hz();
  inline void clear_has_burst_bw_hz();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* burst_id_;
  double start_time_whole_;
  double start_time_frac_;
  double duration_millisec_;
  double burst_center_freq_hz_;
  double burst_bw_hz_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_FalconCommonMessages_2eproto();
  friend void protobuf_AssignDesc_FalconCommonMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconCommonMessages_2eproto();

  void InitAsDefaultInstance();
  static Burst* default_instance_;
};
// -------------------------------------------------------------------

class SensorStatus : public ::google::protobuf::Message {
 public:
  SensorStatus();
  virtual ~SensorStatus();

  SensorStatus(const SensorStatus& from);

  inline SensorStatus& operator=(const SensorStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorStatus& default_instance();

  void Swap(SensorStatus* other);

  // implements Message ----------------------------------------------

  SensorStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SensorStatus& from);
  void MergeFrom(const SensorStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SENSOR_STATUS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional float lat = 2;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 2;
  inline float lat() const;
  inline void set_lat(float value);

  // optional float lon = 3;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 3;
  inline float lon() const;
  inline void set_lon(float value);

  // optional float alt = 4;
  inline bool has_alt() const;
  inline void clear_alt();
  static const int kAltFieldNumber = 4;
  inline float alt() const;
  inline void set_alt(float value);

  // optional int64 timestamp = 5;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // optional string sensorName = 6 [default = ""];
  inline bool has_sensorname() const;
  inline void clear_sensorname();
  static const int kSensorNameFieldNumber = 6;
  inline const ::std::string& sensorname() const;
  inline void set_sensorname(const ::std::string& value);
  inline void set_sensorname(const char* value);
  inline void set_sensorname(const char* value, size_t size);
  inline ::std::string* mutable_sensorname();
  inline ::std::string* release_sensorname();
  inline void set_allocated_sensorname(::std::string* sensorname);

  // repeated .falcon_common_msg.ReceiverStatus rxStatus = 7;
  inline int rxstatus_size() const;
  inline void clear_rxstatus();
  static const int kRxStatusFieldNumber = 7;
  inline const ::falcon_common_msg::ReceiverStatus& rxstatus(int index) const;
  inline ::falcon_common_msg::ReceiverStatus* mutable_rxstatus(int index);
  inline ::falcon_common_msg::ReceiverStatus* add_rxstatus();
  inline const ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::ReceiverStatus >&
      rxstatus() const;
  inline ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::ReceiverStatus >*
      mutable_rxstatus();

  // @@protoc_insertion_point(class_scope:falcon_common_msg.SensorStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_alt();
  inline void clear_has_alt();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_sensorname();
  inline void clear_has_sensorname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  float lat_;
  float lon_;
  ::google::protobuf::int64 timestamp_;
  ::std::string* sensorname_;
  ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::ReceiverStatus > rxstatus_;
  float alt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_FalconCommonMessages_2eproto();
  friend void protobuf_AssignDesc_FalconCommonMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconCommonMessages_2eproto();

  void InitAsDefaultInstance();
  static SensorStatus* default_instance_;
};
// -------------------------------------------------------------------

class ReceiverStatus : public ::google::protobuf::Message {
 public:
  ReceiverStatus();
  virtual ~ReceiverStatus();

  ReceiverStatus(const ReceiverStatus& from);

  inline ReceiverStatus& operator=(const ReceiverStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiverStatus& default_instance();

  void Swap(ReceiverStatus* other);

  // implements Message ----------------------------------------------

  ReceiverStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReceiverStatus& from);
  void MergeFrom(const ReceiverStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "RECEIVER_STATUS"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int32 idNum = 2;
  inline bool has_idnum() const;
  inline void clear_idnum();
  static const int kIdNumFieldNumber = 2;
  inline ::google::protobuf::int32 idnum() const;
  inline void set_idnum(::google::protobuf::int32 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional float rxFreq = 5;
  inline bool has_rxfreq() const;
  inline void clear_rxfreq();
  static const int kRxFreqFieldNumber = 5;
  inline float rxfreq() const;
  inline void set_rxfreq(float value);

  // optional float rxBandwidth = 6;
  inline bool has_rxbandwidth() const;
  inline void clear_rxbandwidth();
  static const int kRxBandwidthFieldNumber = 6;
  inline float rxbandwidth() const;
  inline void set_rxbandwidth(float value);

  // @@protoc_insertion_point(class_scope:falcon_common_msg.ReceiverStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_idnum();
  inline void clear_has_idnum();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_rxfreq();
  inline void clear_has_rxfreq();
  inline void set_has_rxbandwidth();
  inline void clear_has_rxbandwidth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* name_;
  ::google::protobuf::int32 idnum_;
  float rxfreq_;
  ::std::string* type_;
  float rxbandwidth_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_FalconCommonMessages_2eproto();
  friend void protobuf_AssignDesc_FalconCommonMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconCommonMessages_2eproto();

  void InitAsDefaultInstance();
  static ReceiverStatus* default_instance_;
};
// -------------------------------------------------------------------

class Timestamp : public ::google::protobuf::Message {
 public:
  Timestamp();
  virtual ~Timestamp();

  Timestamp(const Timestamp& from);

  inline Timestamp& operator=(const Timestamp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Timestamp& default_instance();

  void Swap(Timestamp* other);

  // implements Message ----------------------------------------------

  Timestamp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Timestamp& from);
  void MergeFrom(const Timestamp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 seconds = 1;
  inline bool has_seconds() const;
  inline void clear_seconds();
  static const int kSecondsFieldNumber = 1;
  inline ::google::protobuf::int64 seconds() const;
  inline void set_seconds(::google::protobuf::int64 value);

  // optional float fseconds = 2;
  inline bool has_fseconds() const;
  inline void clear_fseconds();
  static const int kFsecondsFieldNumber = 2;
  inline float fseconds() const;
  inline void set_fseconds(float value);

  // @@protoc_insertion_point(class_scope:falcon_common_msg.Timestamp)
 private:
  inline void set_has_seconds();
  inline void clear_has_seconds();
  inline void set_has_fseconds();
  inline void clear_has_fseconds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 seconds_;
  float fseconds_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconCommonMessages_2eproto();
  friend void protobuf_AssignDesc_FalconCommonMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconCommonMessages_2eproto();

  void InitAsDefaultInstance();
  static Timestamp* default_instance_;
};
// -------------------------------------------------------------------

class ServiceReinitialize : public ::google::protobuf::Message {
 public:
  ServiceReinitialize();
  virtual ~ServiceReinitialize();

  ServiceReinitialize(const ServiceReinitialize& from);

  inline ServiceReinitialize& operator=(const ServiceReinitialize& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceReinitialize& default_instance();

  void Swap(ServiceReinitialize* other);

  // implements Message ----------------------------------------------

  ServiceReinitialize* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceReinitialize& from);
  void MergeFrom(const ServiceReinitialize& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SERVICE_REINITIALIZE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // @@protoc_insertion_point(class_scope:falcon_common_msg.ServiceReinitialize)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_FalconCommonMessages_2eproto();
  friend void protobuf_AssignDesc_FalconCommonMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconCommonMessages_2eproto();

  void InitAsDefaultInstance();
  static ServiceReinitialize* default_instance_;
};
// -------------------------------------------------------------------

class SensorHeading : public ::google::protobuf::Message {
 public:
  SensorHeading();
  virtual ~SensorHeading();

  SensorHeading(const SensorHeading& from);

  inline SensorHeading& operator=(const SensorHeading& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorHeading& default_instance();

  void Swap(SensorHeading* other);

  // implements Message ----------------------------------------------

  SensorHeading* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SensorHeading& from);
  void MergeFrom(const SensorHeading& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SENSOR_HEADING"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string hostname = 2;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 2;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional double j1970Time = 3;
  inline bool has_j1970time() const;
  inline void clear_j1970time();
  static const int kJ1970TimeFieldNumber = 3;
  inline double j1970time() const;
  inline void set_j1970time(double value);

  // optional double heading = 4;
  inline bool has_heading() const;
  inline void clear_heading();
  static const int kHeadingFieldNumber = 4;
  inline double heading() const;
  inline void set_heading(double value);

  // optional double pitch = 5;
  inline bool has_pitch() const;
  inline void clear_pitch();
  static const int kPitchFieldNumber = 5;
  inline double pitch() const;
  inline void set_pitch(double value);

  // optional double roll = 6;
  inline bool has_roll() const;
  inline void clear_roll();
  static const int kRollFieldNumber = 6;
  inline double roll() const;
  inline void set_roll(double value);

  // @@protoc_insertion_point(class_scope:falcon_common_msg.SensorHeading)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_j1970time();
  inline void clear_has_j1970time();
  inline void set_has_heading();
  inline void clear_has_heading();
  inline void set_has_pitch();
  inline void clear_has_pitch();
  inline void set_has_roll();
  inline void clear_has_roll();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* hostname_;
  double j1970time_;
  double heading_;
  double pitch_;
  double roll_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_FalconCommonMessages_2eproto();
  friend void protobuf_AssignDesc_FalconCommonMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconCommonMessages_2eproto();

  void InitAsDefaultInstance();
  static SensorHeading* default_instance_;
};
// -------------------------------------------------------------------

class KeyValuePair : public ::google::protobuf::Message {
 public:
  KeyValuePair();
  virtual ~KeyValuePair();

  KeyValuePair(const KeyValuePair& from);

  inline KeyValuePair& operator=(const KeyValuePair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyValuePair& default_instance();

  void Swap(KeyValuePair* other);

  // implements Message ----------------------------------------------

  KeyValuePair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeyValuePair& from);
  void MergeFrom(const KeyValuePair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string label = 1;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 1;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  inline void set_allocated_label(::std::string* label);

  // optional .falcon_common_msg.ValueContainer value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::falcon_common_msg::ValueContainer& value() const;
  inline ::falcon_common_msg::ValueContainer* mutable_value();
  inline ::falcon_common_msg::ValueContainer* release_value();
  inline void set_allocated_value(::falcon_common_msg::ValueContainer* value);

  // @@protoc_insertion_point(class_scope:falcon_common_msg.KeyValuePair)
 private:
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* label_;
  ::falcon_common_msg::ValueContainer* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconCommonMessages_2eproto();
  friend void protobuf_AssignDesc_FalconCommonMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconCommonMessages_2eproto();

  void InitAsDefaultInstance();
  static KeyValuePair* default_instance_;
};
// -------------------------------------------------------------------

class ValueContainer : public ::google::protobuf::Message {
 public:
  ValueContainer();
  virtual ~ValueContainer();

  ValueContainer(const ValueContainer& from);

  inline ValueContainer& operator=(const ValueContainer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ValueContainer& default_instance();

  void Swap(ValueContainer* other);

  // implements Message ----------------------------------------------

  ValueContainer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ValueContainer& from);
  void MergeFrom(const ValueContainer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool bool_value = 1;
  inline bool has_bool_value() const;
  inline void clear_bool_value();
  static const int kBoolValueFieldNumber = 1;
  inline bool bool_value() const;
  inline void set_bool_value(bool value);

  // optional int32 int_value = 2;
  inline bool has_int_value() const;
  inline void clear_int_value();
  static const int kIntValueFieldNumber = 2;
  inline ::google::protobuf::int32 int_value() const;
  inline void set_int_value(::google::protobuf::int32 value);

  // optional float float_value = 3;
  inline bool has_float_value() const;
  inline void clear_float_value();
  static const int kFloatValueFieldNumber = 3;
  inline float float_value() const;
  inline void set_float_value(float value);

  // optional string string_value = 4;
  inline bool has_string_value() const;
  inline void clear_string_value();
  static const int kStringValueFieldNumber = 4;
  inline const ::std::string& string_value() const;
  inline void set_string_value(const ::std::string& value);
  inline void set_string_value(const char* value);
  inline void set_string_value(const char* value, size_t size);
  inline ::std::string* mutable_string_value();
  inline ::std::string* release_string_value();
  inline void set_allocated_string_value(::std::string* string_value);

  // optional .falcon_common_msg.GeodeticPosition position_value = 5;
  inline bool has_position_value() const;
  inline void clear_position_value();
  static const int kPositionValueFieldNumber = 5;
  inline const ::falcon_common_msg::GeodeticPosition& position_value() const;
  inline ::falcon_common_msg::GeodeticPosition* mutable_position_value();
  inline ::falcon_common_msg::GeodeticPosition* release_position_value();
  inline void set_allocated_position_value(::falcon_common_msg::GeodeticPosition* position_value);

  // @@protoc_insertion_point(class_scope:falcon_common_msg.ValueContainer)
 private:
  inline void set_has_bool_value();
  inline void clear_has_bool_value();
  inline void set_has_int_value();
  inline void clear_has_int_value();
  inline void set_has_float_value();
  inline void clear_has_float_value();
  inline void set_has_string_value();
  inline void clear_has_string_value();
  inline void set_has_position_value();
  inline void clear_has_position_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool bool_value_;
  ::google::protobuf::int32 int_value_;
  ::std::string* string_value_;
  ::falcon_common_msg::GeodeticPosition* position_value_;
  float float_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_FalconCommonMessages_2eproto();
  friend void protobuf_AssignDesc_FalconCommonMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconCommonMessages_2eproto();

  void InitAsDefaultInstance();
  static ValueContainer* default_instance_;
};
// -------------------------------------------------------------------

class GeodeticPosition : public ::google::protobuf::Message {
 public:
  GeodeticPosition();
  virtual ~GeodeticPosition();

  GeodeticPosition(const GeodeticPosition& from);

  inline GeodeticPosition& operator=(const GeodeticPosition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GeodeticPosition& default_instance();

  void Swap(GeodeticPosition* other);

  // implements Message ----------------------------------------------

  GeodeticPosition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GeodeticPosition& from);
  void MergeFrom(const GeodeticPosition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float lat = 1;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 1;
  inline float lat() const;
  inline void set_lat(float value);

  // optional float lon = 2;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 2;
  inline float lon() const;
  inline void set_lon(float value);

  // optional int64 alt = 3;
  inline bool has_alt() const;
  inline void clear_alt();
  static const int kAltFieldNumber = 3;
  inline ::google::protobuf::int64 alt() const;
  inline void set_alt(::google::protobuf::int64 value);

  // optional int64 alt_meters_hae = 4;
  inline bool has_alt_meters_hae() const;
  inline void clear_alt_meters_hae();
  static const int kAltMetersHaeFieldNumber = 4;
  inline ::google::protobuf::int64 alt_meters_hae() const;
  inline void set_alt_meters_hae(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:falcon_common_msg.GeodeticPosition)
 private:
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_alt();
  inline void clear_has_alt();
  inline void set_has_alt_meters_hae();
  inline void clear_has_alt_meters_hae();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float lat_;
  float lon_;
  ::google::protobuf::int64 alt_;
  ::google::protobuf::int64 alt_meters_hae_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_FalconCommonMessages_2eproto();
  friend void protobuf_AssignDesc_FalconCommonMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconCommonMessages_2eproto();

  void InitAsDefaultInstance();
  static GeodeticPosition* default_instance_;
};
// ===================================================================


// ===================================================================

// BlacklistEntry

// optional string name = 1;
inline bool BlacklistEntry::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlacklistEntry::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlacklistEntry::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlacklistEntry::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& BlacklistEntry::name() const {
  return *name_;
}
inline void BlacklistEntry::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BlacklistEntry::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BlacklistEntry::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlacklistEntry::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* BlacklistEntry::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlacklistEntry::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double minRF = 2 [default = -1];
inline bool BlacklistEntry::has_minrf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlacklistEntry::set_has_minrf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlacklistEntry::clear_has_minrf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlacklistEntry::clear_minrf() {
  minrf_ = -1;
  clear_has_minrf();
}
inline double BlacklistEntry::minrf() const {
  return minrf_;
}
inline void BlacklistEntry::set_minrf(double value) {
  set_has_minrf();
  minrf_ = value;
}

// optional double maxRF = 3 [default = -1];
inline bool BlacklistEntry::has_maxrf() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlacklistEntry::set_has_maxrf() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlacklistEntry::clear_has_maxrf() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlacklistEntry::clear_maxrf() {
  maxrf_ = -1;
  clear_has_maxrf();
}
inline double BlacklistEntry::maxrf() const {
  return maxrf_;
}
inline void BlacklistEntry::set_maxrf(double value) {
  set_has_maxrf();
  maxrf_ = value;
}

// optional string scrypt = 4;
inline bool BlacklistEntry::has_scrypt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BlacklistEntry::set_has_scrypt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BlacklistEntry::clear_has_scrypt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BlacklistEntry::clear_scrypt() {
  if (scrypt_ != &::google::protobuf::internal::kEmptyString) {
    scrypt_->clear();
  }
  clear_has_scrypt();
}
inline const ::std::string& BlacklistEntry::scrypt() const {
  return *scrypt_;
}
inline void BlacklistEntry::set_scrypt(const ::std::string& value) {
  set_has_scrypt();
  if (scrypt_ == &::google::protobuf::internal::kEmptyString) {
    scrypt_ = new ::std::string;
  }
  scrypt_->assign(value);
}
inline void BlacklistEntry::set_scrypt(const char* value) {
  set_has_scrypt();
  if (scrypt_ == &::google::protobuf::internal::kEmptyString) {
    scrypt_ = new ::std::string;
  }
  scrypt_->assign(value);
}
inline void BlacklistEntry::set_scrypt(const char* value, size_t size) {
  set_has_scrypt();
  if (scrypt_ == &::google::protobuf::internal::kEmptyString) {
    scrypt_ = new ::std::string;
  }
  scrypt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlacklistEntry::mutable_scrypt() {
  set_has_scrypt();
  if (scrypt_ == &::google::protobuf::internal::kEmptyString) {
    scrypt_ = new ::std::string;
  }
  return scrypt_;
}
inline ::std::string* BlacklistEntry::release_scrypt() {
  clear_has_scrypt();
  if (scrypt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = scrypt_;
    scrypt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlacklistEntry::set_allocated_scrypt(::std::string* scrypt) {
  if (scrypt_ != &::google::protobuf::internal::kEmptyString) {
    delete scrypt_;
  }
  if (scrypt) {
    set_has_scrypt();
    scrypt_ = scrypt;
  } else {
    clear_has_scrypt();
    scrypt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float timeout = 5 [default = -1];
inline bool BlacklistEntry::has_timeout() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BlacklistEntry::set_has_timeout() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BlacklistEntry::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BlacklistEntry::clear_timeout() {
  timeout_ = -1;
  clear_has_timeout();
}
inline float BlacklistEntry::timeout() const {
  return timeout_;
}
inline void BlacklistEntry::set_timeout(float value) {
  set_has_timeout();
  timeout_ = value;
}

// optional string uniqueID = 6 [default = ""];
inline bool BlacklistEntry::has_uniqueid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BlacklistEntry::set_has_uniqueid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BlacklistEntry::clear_has_uniqueid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BlacklistEntry::clear_uniqueid() {
  if (uniqueid_ != &::google::protobuf::internal::kEmptyString) {
    uniqueid_->clear();
  }
  clear_has_uniqueid();
}
inline const ::std::string& BlacklistEntry::uniqueid() const {
  return *uniqueid_;
}
inline void BlacklistEntry::set_uniqueid(const ::std::string& value) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(value);
}
inline void BlacklistEntry::set_uniqueid(const char* value) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(value);
}
inline void BlacklistEntry::set_uniqueid(const char* value, size_t size) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlacklistEntry::mutable_uniqueid() {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  return uniqueid_;
}
inline ::std::string* BlacklistEntry::release_uniqueid() {
  clear_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uniqueid_;
    uniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlacklistEntry::set_allocated_uniqueid(::std::string* uniqueid) {
  if (uniqueid_ != &::google::protobuf::internal::kEmptyString) {
    delete uniqueid_;
  }
  if (uniqueid) {
    set_has_uniqueid();
    uniqueid_ = uniqueid;
  } else {
    clear_has_uniqueid();
    uniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ExtraForkChannel

// optional int32 channelID = 1;
inline bool ExtraForkChannel::has_channelid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExtraForkChannel::set_has_channelid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExtraForkChannel::clear_has_channelid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExtraForkChannel::clear_channelid() {
  channelid_ = 0;
  clear_has_channelid();
}
inline ::google::protobuf::int32 ExtraForkChannel::channelid() const {
  return channelid_;
}
inline void ExtraForkChannel::set_channelid(::google::protobuf::int32 value) {
  set_has_channelid();
  channelid_ = value;
}

// optional int32 inputPort = 2;
inline bool ExtraForkChannel::has_inputport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExtraForkChannel::set_has_inputport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExtraForkChannel::clear_has_inputport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExtraForkChannel::clear_inputport() {
  inputport_ = 0;
  clear_has_inputport();
}
inline ::google::protobuf::int32 ExtraForkChannel::inputport() const {
  return inputport_;
}
inline void ExtraForkChannel::set_inputport(::google::protobuf::int32 value) {
  set_has_inputport();
  inputport_ = value;
}

// optional int32 outputPort = 3;
inline bool ExtraForkChannel::has_outputport() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExtraForkChannel::set_has_outputport() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExtraForkChannel::clear_has_outputport() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExtraForkChannel::clear_outputport() {
  outputport_ = 0;
  clear_has_outputport();
}
inline ::google::protobuf::int32 ExtraForkChannel::outputport() const {
  return outputport_;
}
inline void ExtraForkChannel::set_outputport(::google::protobuf::int32 value) {
  set_has_outputport();
  outputport_ = value;
}

// optional int32 videoPort = 4;
inline bool ExtraForkChannel::has_videoport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExtraForkChannel::set_has_videoport() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExtraForkChannel::clear_has_videoport() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExtraForkChannel::clear_videoport() {
  videoport_ = 0;
  clear_has_videoport();
}
inline ::google::protobuf::int32 ExtraForkChannel::videoport() const {
  return videoport_;
}
inline void ExtraForkChannel::set_videoport(::google::protobuf::int32 value) {
  set_has_videoport();
  videoport_ = value;
}

// optional int32 launch_on_start = 5;
inline bool ExtraForkChannel::has_launch_on_start() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExtraForkChannel::set_has_launch_on_start() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExtraForkChannel::clear_has_launch_on_start() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExtraForkChannel::clear_launch_on_start() {
  launch_on_start_ = 0;
  clear_has_launch_on_start();
}
inline ::google::protobuf::int32 ExtraForkChannel::launch_on_start() const {
  return launch_on_start_;
}
inline void ExtraForkChannel::set_launch_on_start(::google::protobuf::int32 value) {
  set_has_launch_on_start();
  launch_on_start_ = value;
}

// -------------------------------------------------------------------

// InterceptGoActive

// optional string msgName = 1 [default = "INTERCEPT_GO_ACTIVE"];
inline bool InterceptGoActive::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InterceptGoActive::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InterceptGoActive::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InterceptGoActive::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& InterceptGoActive::msgname() const {
  return *msgname_;
}
inline void InterceptGoActive::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void InterceptGoActive::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void InterceptGoActive::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InterceptGoActive::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* InterceptGoActive::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void InterceptGoActive::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string hostname = 2 [default = ""];
inline bool InterceptGoActive::has_hostname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InterceptGoActive::set_has_hostname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InterceptGoActive::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InterceptGoActive::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& InterceptGoActive::hostname() const {
  return *hostname_;
}
inline void InterceptGoActive::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void InterceptGoActive::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void InterceptGoActive::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InterceptGoActive::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* InterceptGoActive::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InterceptGoActive::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double j1970Time = 3;
inline bool InterceptGoActive::has_j1970time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InterceptGoActive::set_has_j1970time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InterceptGoActive::clear_has_j1970time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InterceptGoActive::clear_j1970time() {
  j1970time_ = 0;
  clear_has_j1970time();
}
inline double InterceptGoActive::j1970time() const {
  return j1970time_;
}
inline void InterceptGoActive::set_j1970time(double value) {
  set_has_j1970time();
  j1970time_ = value;
}

// optional string uniqueID = 4 [default = ""];
inline bool InterceptGoActive::has_uniqueid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InterceptGoActive::set_has_uniqueid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InterceptGoActive::clear_has_uniqueid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InterceptGoActive::clear_uniqueid() {
  if (uniqueid_ != &::google::protobuf::internal::kEmptyString) {
    uniqueid_->clear();
  }
  clear_has_uniqueid();
}
inline const ::std::string& InterceptGoActive::uniqueid() const {
  return *uniqueid_;
}
inline void InterceptGoActive::set_uniqueid(const ::std::string& value) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(value);
}
inline void InterceptGoActive::set_uniqueid(const char* value) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(value);
}
inline void InterceptGoActive::set_uniqueid(const char* value, size_t size) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InterceptGoActive::mutable_uniqueid() {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  return uniqueid_;
}
inline ::std::string* InterceptGoActive::release_uniqueid() {
  clear_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uniqueid_;
    uniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InterceptGoActive::set_allocated_uniqueid(::std::string* uniqueid) {
  if (uniqueid_ != &::google::protobuf::internal::kEmptyString) {
    delete uniqueid_;
  }
  if (uniqueid) {
    set_has_uniqueid();
    uniqueid_ = uniqueid;
  } else {
    clear_has_uniqueid();
    uniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool jam = 5 [default = false];
inline bool InterceptGoActive::has_jam() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InterceptGoActive::set_has_jam() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InterceptGoActive::clear_has_jam() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InterceptGoActive::clear_jam() {
  jam_ = false;
  clear_has_jam();
}
inline bool InterceptGoActive::jam() const {
  return jam_;
}
inline void InterceptGoActive::set_jam(bool value) {
  set_has_jam();
  jam_ = value;
}

// -------------------------------------------------------------------

// GeoTip

// repeated .falcon_common_msg.PreDSource pred_source = 1;
inline int GeoTip::pred_source_size() const {
  return pred_source_.size();
}
inline void GeoTip::clear_pred_source() {
  pred_source_.Clear();
}
inline const ::falcon_common_msg::PreDSource& GeoTip::pred_source(int index) const {
  return pred_source_.Get(index);
}
inline ::falcon_common_msg::PreDSource* GeoTip::mutable_pred_source(int index) {
  return pred_source_.Mutable(index);
}
inline ::falcon_common_msg::PreDSource* GeoTip::add_pred_source() {
  return pred_source_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::PreDSource >&
GeoTip::pred_source() const {
  return pred_source_;
}
inline ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::PreDSource >*
GeoTip::mutable_pred_source() {
  return &pred_source_;
}

// optional string tip_id = 4;
inline bool GeoTip::has_tip_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GeoTip::set_has_tip_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GeoTip::clear_has_tip_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GeoTip::clear_tip_id() {
  if (tip_id_ != &::google::protobuf::internal::kEmptyString) {
    tip_id_->clear();
  }
  clear_has_tip_id();
}
inline const ::std::string& GeoTip::tip_id() const {
  return *tip_id_;
}
inline void GeoTip::set_tip_id(const ::std::string& value) {
  set_has_tip_id();
  if (tip_id_ == &::google::protobuf::internal::kEmptyString) {
    tip_id_ = new ::std::string;
  }
  tip_id_->assign(value);
}
inline void GeoTip::set_tip_id(const char* value) {
  set_has_tip_id();
  if (tip_id_ == &::google::protobuf::internal::kEmptyString) {
    tip_id_ = new ::std::string;
  }
  tip_id_->assign(value);
}
inline void GeoTip::set_tip_id(const char* value, size_t size) {
  set_has_tip_id();
  if (tip_id_ == &::google::protobuf::internal::kEmptyString) {
    tip_id_ = new ::std::string;
  }
  tip_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoTip::mutable_tip_id() {
  set_has_tip_id();
  if (tip_id_ == &::google::protobuf::internal::kEmptyString) {
    tip_id_ = new ::std::string;
  }
  return tip_id_;
}
inline ::std::string* GeoTip::release_tip_id() {
  clear_has_tip_id();
  if (tip_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tip_id_;
    tip_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeoTip::set_allocated_tip_id(::std::string* tip_id) {
  if (tip_id_ != &::google::protobuf::internal::kEmptyString) {
    delete tip_id_;
  }
  if (tip_id) {
    set_has_tip_id();
    tip_id_ = tip_id;
  } else {
    clear_has_tip_id();
    tip_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PreDSource

// optional string filename = 1;
inline bool PreDSource::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PreDSource::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PreDSource::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PreDSource::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& PreDSource::filename() const {
  return *filename_;
}
inline void PreDSource::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void PreDSource::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void PreDSource::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PreDSource::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* PreDSource::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PreDSource::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string hostname = 2;
inline bool PreDSource::has_hostname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PreDSource::set_has_hostname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PreDSource::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PreDSource::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& PreDSource::hostname() const {
  return *hostname_;
}
inline void PreDSource::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void PreDSource::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void PreDSource::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PreDSource::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* PreDSource::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PreDSource::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .falcon_common_msg.MetaData meta_data = 3;
inline bool PreDSource::has_meta_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PreDSource::set_has_meta_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PreDSource::clear_has_meta_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PreDSource::clear_meta_data() {
  if (meta_data_ != NULL) meta_data_->::falcon_common_msg::MetaData::Clear();
  clear_has_meta_data();
}
inline const ::falcon_common_msg::MetaData& PreDSource::meta_data() const {
  return meta_data_ != NULL ? *meta_data_ : *default_instance_->meta_data_;
}
inline ::falcon_common_msg::MetaData* PreDSource::mutable_meta_data() {
  set_has_meta_data();
  if (meta_data_ == NULL) meta_data_ = new ::falcon_common_msg::MetaData;
  return meta_data_;
}
inline ::falcon_common_msg::MetaData* PreDSource::release_meta_data() {
  clear_has_meta_data();
  ::falcon_common_msg::MetaData* temp = meta_data_;
  meta_data_ = NULL;
  return temp;
}
inline void PreDSource::set_allocated_meta_data(::falcon_common_msg::MetaData* meta_data) {
  delete meta_data_;
  meta_data_ = meta_data;
  if (meta_data) {
    set_has_meta_data();
  } else {
    clear_has_meta_data();
  }
}

// -------------------------------------------------------------------

// MetaData

// optional double wholeSec = 1;
inline bool MetaData::has_wholesec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MetaData::set_has_wholesec() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MetaData::clear_has_wholesec() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MetaData::clear_wholesec() {
  wholesec_ = 0;
  clear_has_wholesec();
}
inline double MetaData::wholesec() const {
  return wholesec_;
}
inline void MetaData::set_wholesec(double value) {
  set_has_wholesec();
  wholesec_ = value;
}

// optional double fracSec = 2;
inline bool MetaData::has_fracsec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MetaData::set_has_fracsec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MetaData::clear_has_fracsec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MetaData::clear_fracsec() {
  fracsec_ = 0;
  clear_has_fracsec();
}
inline double MetaData::fracsec() const {
  return fracsec_;
}
inline void MetaData::set_fracsec(double value) {
  set_has_fracsec();
  fracsec_ = value;
}

// optional double duration = 3;
inline bool MetaData::has_duration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MetaData::set_has_duration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MetaData::clear_has_duration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MetaData::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline double MetaData::duration() const {
  return duration_;
}
inline void MetaData::set_duration(double value) {
  set_has_duration();
  duration_ = value;
}

// optional double centerFrequency = 10;
inline bool MetaData::has_centerfrequency() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MetaData::set_has_centerfrequency() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MetaData::clear_has_centerfrequency() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MetaData::clear_centerfrequency() {
  centerfrequency_ = 0;
  clear_has_centerfrequency();
}
inline double MetaData::centerfrequency() const {
  return centerfrequency_;
}
inline void MetaData::set_centerfrequency(double value) {
  set_has_centerfrequency();
  centerfrequency_ = value;
}

// optional double sampleRate = 11;
inline bool MetaData::has_samplerate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MetaData::set_has_samplerate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MetaData::clear_has_samplerate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MetaData::clear_samplerate() {
  samplerate_ = 0;
  clear_has_samplerate();
}
inline double MetaData::samplerate() const {
  return samplerate_;
}
inline void MetaData::set_samplerate(double value) {
  set_has_samplerate();
  samplerate_ = value;
}

// optional double bandwidth = 12;
inline bool MetaData::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MetaData::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MetaData::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MetaData::clear_bandwidth() {
  bandwidth_ = 0;
  clear_has_bandwidth();
}
inline double MetaData::bandwidth() const {
  return bandwidth_;
}
inline void MetaData::set_bandwidth(double value) {
  set_has_bandwidth();
  bandwidth_ = value;
}

// optional string eltex = 20;
inline bool MetaData::has_eltex() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MetaData::set_has_eltex() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MetaData::clear_has_eltex() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MetaData::clear_eltex() {
  if (eltex_ != &::google::protobuf::internal::kEmptyString) {
    eltex_->clear();
  }
  clear_has_eltex();
}
inline const ::std::string& MetaData::eltex() const {
  return *eltex_;
}
inline void MetaData::set_eltex(const ::std::string& value) {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  eltex_->assign(value);
}
inline void MetaData::set_eltex(const char* value) {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  eltex_->assign(value);
}
inline void MetaData::set_eltex(const char* value, size_t size) {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  eltex_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaData::mutable_eltex() {
  set_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    eltex_ = new ::std::string;
  }
  return eltex_;
}
inline ::std::string* MetaData::release_eltex() {
  clear_has_eltex();
  if (eltex_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eltex_;
    eltex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MetaData::set_allocated_eltex(::std::string* eltex) {
  if (eltex_ != &::google::protobuf::internal::kEmptyString) {
    delete eltex_;
  }
  if (eltex) {
    set_has_eltex();
    eltex_ = eltex;
  } else {
    clear_has_eltex();
    eltex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string soiNum = 21;
inline bool MetaData::has_soinum() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MetaData::set_has_soinum() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MetaData::clear_has_soinum() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MetaData::clear_soinum() {
  if (soinum_ != &::google::protobuf::internal::kEmptyString) {
    soinum_->clear();
  }
  clear_has_soinum();
}
inline const ::std::string& MetaData::soinum() const {
  return *soinum_;
}
inline void MetaData::set_soinum(const ::std::string& value) {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  soinum_->assign(value);
}
inline void MetaData::set_soinum(const char* value) {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  soinum_->assign(value);
}
inline void MetaData::set_soinum(const char* value, size_t size) {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  soinum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaData::mutable_soinum() {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  return soinum_;
}
inline ::std::string* MetaData::release_soinum() {
  clear_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = soinum_;
    soinum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MetaData::set_allocated_soinum(::std::string* soinum) {
  if (soinum_ != &::google::protobuf::internal::kEmptyString) {
    delete soinum_;
  }
  if (soinum) {
    set_has_soinum();
    soinum_ = soinum;
  } else {
    clear_has_soinum();
    soinum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string globalId = 22;
inline bool MetaData::has_globalid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MetaData::set_has_globalid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MetaData::clear_has_globalid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MetaData::clear_globalid() {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    globalid_->clear();
  }
  clear_has_globalid();
}
inline const ::std::string& MetaData::globalid() const {
  return *globalid_;
}
inline void MetaData::set_globalid(const ::std::string& value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void MetaData::set_globalid(const char* value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void MetaData::set_globalid(const char* value, size_t size) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaData::mutable_globalid() {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  return globalid_;
}
inline ::std::string* MetaData::release_globalid() {
  clear_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalid_;
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MetaData::set_allocated_globalid(::std::string* globalid) {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    delete globalid_;
  }
  if (globalid) {
    set_has_globalid();
    globalid_ = globalid;
  } else {
    clear_has_globalid();
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GeoResult

// optional string msgName = 1 [default = "GEO_RESULT"];
inline bool GeoResult::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GeoResult::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GeoResult::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GeoResult::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& GeoResult::msgname() const {
  return *msgname_;
}
inline void GeoResult::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GeoResult::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GeoResult::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoResult::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* GeoResult::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void GeoResult::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string hostname = 2;
inline bool GeoResult::has_hostname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GeoResult::set_has_hostname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GeoResult::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GeoResult::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& GeoResult::hostname() const {
  return *hostname_;
}
inline void GeoResult::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void GeoResult::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void GeoResult::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoResult::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* GeoResult::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeoResult::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double j1970Time = 3;
inline bool GeoResult::has_j1970time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GeoResult::set_has_j1970time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GeoResult::clear_has_j1970time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GeoResult::clear_j1970time() {
  j1970time_ = 0;
  clear_has_j1970time();
}
inline double GeoResult::j1970time() const {
  return j1970time_;
}
inline void GeoResult::set_j1970time(double value) {
  set_has_j1970time();
  j1970time_ = value;
}

// optional double x = 4;
inline bool GeoResult::has_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GeoResult::set_has_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GeoResult::clear_has_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GeoResult::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double GeoResult::x() const {
  return x_;
}
inline void GeoResult::set_x(double value) {
  set_has_x();
  x_ = value;
}

// optional double y = 5;
inline bool GeoResult::has_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GeoResult::set_has_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GeoResult::clear_has_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GeoResult::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double GeoResult::y() const {
  return y_;
}
inline void GeoResult::set_y(double value) {
  set_has_y();
  y_ = value;
}

// optional double z = 6;
inline bool GeoResult::has_z() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GeoResult::set_has_z() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GeoResult::clear_has_z() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GeoResult::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double GeoResult::z() const {
  return z_;
}
inline void GeoResult::set_z(double value) {
  set_has_z();
  z_ = value;
}

// optional double alt = 7;
inline bool GeoResult::has_alt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GeoResult::set_has_alt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GeoResult::clear_has_alt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GeoResult::clear_alt() {
  alt_ = 0;
  clear_has_alt();
}
inline double GeoResult::alt() const {
  return alt_;
}
inline void GeoResult::set_alt(double value) {
  set_has_alt();
  alt_ = value;
}

// optional double lat = 8;
inline bool GeoResult::has_lat() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GeoResult::set_has_lat() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GeoResult::clear_has_lat() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GeoResult::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline double GeoResult::lat() const {
  return lat_;
}
inline void GeoResult::set_lat(double value) {
  set_has_lat();
  lat_ = value;
}

// optional double lon = 9;
inline bool GeoResult::has_lon() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GeoResult::set_has_lon() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GeoResult::clear_has_lon() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GeoResult::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline double GeoResult::lon() const {
  return lon_;
}
inline void GeoResult::set_lon(double value) {
  set_has_lon();
  lon_ = value;
}

// optional double semiMajor = 10;
inline bool GeoResult::has_semimajor() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GeoResult::set_has_semimajor() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GeoResult::clear_has_semimajor() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GeoResult::clear_semimajor() {
  semimajor_ = 0;
  clear_has_semimajor();
}
inline double GeoResult::semimajor() const {
  return semimajor_;
}
inline void GeoResult::set_semimajor(double value) {
  set_has_semimajor();
  semimajor_ = value;
}

// optional double semiMinor = 11;
inline bool GeoResult::has_semiminor() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GeoResult::set_has_semiminor() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GeoResult::clear_has_semiminor() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GeoResult::clear_semiminor() {
  semiminor_ = 0;
  clear_has_semiminor();
}
inline double GeoResult::semiminor() const {
  return semiminor_;
}
inline void GeoResult::set_semiminor(double value) {
  set_has_semiminor();
  semiminor_ = value;
}

// optional double orientation = 12;
inline bool GeoResult::has_orientation() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GeoResult::set_has_orientation() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GeoResult::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GeoResult::clear_orientation() {
  orientation_ = 0;
  clear_has_orientation();
}
inline double GeoResult::orientation() const {
  return orientation_;
}
inline void GeoResult::set_orientation(double value) {
  set_has_orientation();
  orientation_ = value;
}

// optional string soi = 13;
inline bool GeoResult::has_soi() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GeoResult::set_has_soi() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GeoResult::clear_has_soi() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GeoResult::clear_soi() {
  if (soi_ != &::google::protobuf::internal::kEmptyString) {
    soi_->clear();
  }
  clear_has_soi();
}
inline const ::std::string& GeoResult::soi() const {
  return *soi_;
}
inline void GeoResult::set_soi(const ::std::string& value) {
  set_has_soi();
  if (soi_ == &::google::protobuf::internal::kEmptyString) {
    soi_ = new ::std::string;
  }
  soi_->assign(value);
}
inline void GeoResult::set_soi(const char* value) {
  set_has_soi();
  if (soi_ == &::google::protobuf::internal::kEmptyString) {
    soi_ = new ::std::string;
  }
  soi_->assign(value);
}
inline void GeoResult::set_soi(const char* value, size_t size) {
  set_has_soi();
  if (soi_ == &::google::protobuf::internal::kEmptyString) {
    soi_ = new ::std::string;
  }
  soi_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoResult::mutable_soi() {
  set_has_soi();
  if (soi_ == &::google::protobuf::internal::kEmptyString) {
    soi_ = new ::std::string;
  }
  return soi_;
}
inline ::std::string* GeoResult::release_soi() {
  clear_has_soi();
  if (soi_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = soi_;
    soi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeoResult::set_allocated_soi(::std::string* soi) {
  if (soi_ != &::google::protobuf::internal::kEmptyString) {
    delete soi_;
  }
  if (soi) {
    set_has_soi();
    soi_ = soi;
  } else {
    clear_has_soi();
    soi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string uniqueID = 14 [default = ""];
inline bool GeoResult::has_uniqueid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GeoResult::set_has_uniqueid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GeoResult::clear_has_uniqueid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GeoResult::clear_uniqueid() {
  if (uniqueid_ != &::google::protobuf::internal::kEmptyString) {
    uniqueid_->clear();
  }
  clear_has_uniqueid();
}
inline const ::std::string& GeoResult::uniqueid() const {
  return *uniqueid_;
}
inline void GeoResult::set_uniqueid(const ::std::string& value) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(value);
}
inline void GeoResult::set_uniqueid(const char* value) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(value);
}
inline void GeoResult::set_uniqueid(const char* value, size_t size) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoResult::mutable_uniqueid() {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  return uniqueid_;
}
inline ::std::string* GeoResult::release_uniqueid() {
  clear_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uniqueid_;
    uniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeoResult::set_allocated_uniqueid(::std::string* uniqueid) {
  if (uniqueid_ != &::google::protobuf::internal::kEmptyString) {
    delete uniqueid_;
  }
  if (uniqueid) {
    set_has_uniqueid();
    uniqueid_ = uniqueid;
  } else {
    clear_has_uniqueid();
    uniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 channel = 15 [default = 1];
inline bool GeoResult::has_channel() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GeoResult::set_has_channel() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GeoResult::clear_has_channel() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GeoResult::clear_channel() {
  channel_ = 1;
  clear_has_channel();
}
inline ::google::protobuf::int32 GeoResult::channel() const {
  return channel_;
}
inline void GeoResult::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// optional string eventID = 16;
inline bool GeoResult::has_eventid() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GeoResult::set_has_eventid() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GeoResult::clear_has_eventid() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GeoResult::clear_eventid() {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    eventid_->clear();
  }
  clear_has_eventid();
}
inline const ::std::string& GeoResult::eventid() const {
  return *eventid_;
}
inline void GeoResult::set_eventid(const ::std::string& value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void GeoResult::set_eventid(const char* value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void GeoResult::set_eventid(const char* value, size_t size) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoResult::mutable_eventid() {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  return eventid_;
}
inline ::std::string* GeoResult::release_eventid() {
  clear_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventid_;
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeoResult::set_allocated_eventid(::std::string* eventid) {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    delete eventid_;
  }
  if (eventid) {
    set_has_eventid();
    eventid_ = eventid;
  } else {
    clear_has_eventid();
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float wpLatitude = 17;
inline bool GeoResult::has_wplatitude() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void GeoResult::set_has_wplatitude() {
  _has_bits_[0] |= 0x00010000u;
}
inline void GeoResult::clear_has_wplatitude() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void GeoResult::clear_wplatitude() {
  wplatitude_ = 0;
  clear_has_wplatitude();
}
inline float GeoResult::wplatitude() const {
  return wplatitude_;
}
inline void GeoResult::set_wplatitude(float value) {
  set_has_wplatitude();
  wplatitude_ = value;
}

// optional float wpLongitude = 18;
inline bool GeoResult::has_wplongitude() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void GeoResult::set_has_wplongitude() {
  _has_bits_[0] |= 0x00020000u;
}
inline void GeoResult::clear_has_wplongitude() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void GeoResult::clear_wplongitude() {
  wplongitude_ = 0;
  clear_has_wplongitude();
}
inline float GeoResult::wplongitude() const {
  return wplongitude_;
}
inline void GeoResult::set_wplongitude(float value) {
  set_has_wplongitude();
  wplongitude_ = value;
}

// optional float velocity = 19;
inline bool GeoResult::has_velocity() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void GeoResult::set_has_velocity() {
  _has_bits_[0] |= 0x00040000u;
}
inline void GeoResult::clear_has_velocity() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void GeoResult::clear_velocity() {
  velocity_ = 0;
  clear_has_velocity();
}
inline float GeoResult::velocity() const {
  return velocity_;
}
inline void GeoResult::set_velocity(float value) {
  set_has_velocity();
  velocity_ = value;
}

// optional float bearing = 20;
inline bool GeoResult::has_bearing() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void GeoResult::set_has_bearing() {
  _has_bits_[0] |= 0x00080000u;
}
inline void GeoResult::clear_has_bearing() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void GeoResult::clear_bearing() {
  bearing_ = 0;
  clear_has_bearing();
}
inline float GeoResult::bearing() const {
  return bearing_;
}
inline void GeoResult::set_bearing(float value) {
  set_has_bearing();
  bearing_ = value;
}

// optional float seqnum = 21;
inline bool GeoResult::has_seqnum() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void GeoResult::set_has_seqnum() {
  _has_bits_[0] |= 0x00100000u;
}
inline void GeoResult::clear_has_seqnum() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void GeoResult::clear_seqnum() {
  seqnum_ = 0;
  clear_has_seqnum();
}
inline float GeoResult::seqnum() const {
  return seqnum_;
}
inline void GeoResult::set_seqnum(float value) {
  set_has_seqnum();
  seqnum_ = value;
}

// optional bool valid = 26;
inline bool GeoResult::has_valid() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void GeoResult::set_has_valid() {
  _has_bits_[0] |= 0x00200000u;
}
inline void GeoResult::clear_has_valid() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void GeoResult::clear_valid() {
  valid_ = false;
  clear_has_valid();
}
inline bool GeoResult::valid() const {
  return valid_;
}
inline void GeoResult::set_valid(bool value) {
  set_has_valid();
  valid_ = value;
}

// optional double cep = 27;
inline bool GeoResult::has_cep() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void GeoResult::set_has_cep() {
  _has_bits_[0] |= 0x00400000u;
}
inline void GeoResult::clear_has_cep() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void GeoResult::clear_cep() {
  cep_ = 0;
  clear_has_cep();
}
inline double GeoResult::cep() const {
  return cep_;
}
inline void GeoResult::set_cep(double value) {
  set_has_cep();
  cep_ = value;
}

// optional double freq_hz = 28;
inline bool GeoResult::has_freq_hz() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void GeoResult::set_has_freq_hz() {
  _has_bits_[0] |= 0x00800000u;
}
inline void GeoResult::clear_has_freq_hz() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void GeoResult::clear_freq_hz() {
  freq_hz_ = 0;
  clear_has_freq_hz();
}
inline double GeoResult::freq_hz() const {
  return freq_hz_;
}
inline void GeoResult::set_freq_hz(double value) {
  set_has_freq_hz();
  freq_hz_ = value;
}

// optional double bw_hz = 29;
inline bool GeoResult::has_bw_hz() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void GeoResult::set_has_bw_hz() {
  _has_bits_[0] |= 0x01000000u;
}
inline void GeoResult::clear_has_bw_hz() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void GeoResult::clear_bw_hz() {
  bw_hz_ = 0;
  clear_has_bw_hz();
}
inline double GeoResult::bw_hz() const {
  return bw_hz_;
}
inline void GeoResult::set_bw_hz(double value) {
  set_has_bw_hz();
  bw_hz_ = value;
}

// optional string combining_type = 30;
inline bool GeoResult::has_combining_type() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void GeoResult::set_has_combining_type() {
  _has_bits_[0] |= 0x02000000u;
}
inline void GeoResult::clear_has_combining_type() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void GeoResult::clear_combining_type() {
  if (combining_type_ != &::google::protobuf::internal::kEmptyString) {
    combining_type_->clear();
  }
  clear_has_combining_type();
}
inline const ::std::string& GeoResult::combining_type() const {
  return *combining_type_;
}
inline void GeoResult::set_combining_type(const ::std::string& value) {
  set_has_combining_type();
  if (combining_type_ == &::google::protobuf::internal::kEmptyString) {
    combining_type_ = new ::std::string;
  }
  combining_type_->assign(value);
}
inline void GeoResult::set_combining_type(const char* value) {
  set_has_combining_type();
  if (combining_type_ == &::google::protobuf::internal::kEmptyString) {
    combining_type_ = new ::std::string;
  }
  combining_type_->assign(value);
}
inline void GeoResult::set_combining_type(const char* value, size_t size) {
  set_has_combining_type();
  if (combining_type_ == &::google::protobuf::internal::kEmptyString) {
    combining_type_ = new ::std::string;
  }
  combining_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoResult::mutable_combining_type() {
  set_has_combining_type();
  if (combining_type_ == &::google::protobuf::internal::kEmptyString) {
    combining_type_ = new ::std::string;
  }
  return combining_type_;
}
inline ::std::string* GeoResult::release_combining_type() {
  clear_has_combining_type();
  if (combining_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = combining_type_;
    combining_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeoResult::set_allocated_combining_type(::std::string* combining_type) {
  if (combining_type_ != &::google::protobuf::internal::kEmptyString) {
    delete combining_type_;
  }
  if (combining_type) {
    set_has_combining_type();
    combining_type_ = combining_type;
  } else {
    clear_has_combining_type();
    combining_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string diagnostic = 31;
inline bool GeoResult::has_diagnostic() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void GeoResult::set_has_diagnostic() {
  _has_bits_[0] |= 0x04000000u;
}
inline void GeoResult::clear_has_diagnostic() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void GeoResult::clear_diagnostic() {
  if (diagnostic_ != &::google::protobuf::internal::kEmptyString) {
    diagnostic_->clear();
  }
  clear_has_diagnostic();
}
inline const ::std::string& GeoResult::diagnostic() const {
  return *diagnostic_;
}
inline void GeoResult::set_diagnostic(const ::std::string& value) {
  set_has_diagnostic();
  if (diagnostic_ == &::google::protobuf::internal::kEmptyString) {
    diagnostic_ = new ::std::string;
  }
  diagnostic_->assign(value);
}
inline void GeoResult::set_diagnostic(const char* value) {
  set_has_diagnostic();
  if (diagnostic_ == &::google::protobuf::internal::kEmptyString) {
    diagnostic_ = new ::std::string;
  }
  diagnostic_->assign(value);
}
inline void GeoResult::set_diagnostic(const char* value, size_t size) {
  set_has_diagnostic();
  if (diagnostic_ == &::google::protobuf::internal::kEmptyString) {
    diagnostic_ = new ::std::string;
  }
  diagnostic_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoResult::mutable_diagnostic() {
  set_has_diagnostic();
  if (diagnostic_ == &::google::protobuf::internal::kEmptyString) {
    diagnostic_ = new ::std::string;
  }
  return diagnostic_;
}
inline ::std::string* GeoResult::release_diagnostic() {
  clear_has_diagnostic();
  if (diagnostic_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = diagnostic_;
    diagnostic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeoResult::set_allocated_diagnostic(::std::string* diagnostic) {
  if (diagnostic_ != &::google::protobuf::internal::kEmptyString) {
    delete diagnostic_;
  }
  if (diagnostic) {
    set_has_diagnostic();
    diagnostic_ = diagnostic;
  } else {
    clear_has_diagnostic();
    diagnostic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string qualifier = 32;
inline bool GeoResult::has_qualifier() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void GeoResult::set_has_qualifier() {
  _has_bits_[0] |= 0x08000000u;
}
inline void GeoResult::clear_has_qualifier() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void GeoResult::clear_qualifier() {
  if (qualifier_ != &::google::protobuf::internal::kEmptyString) {
    qualifier_->clear();
  }
  clear_has_qualifier();
}
inline const ::std::string& GeoResult::qualifier() const {
  return *qualifier_;
}
inline void GeoResult::set_qualifier(const ::std::string& value) {
  set_has_qualifier();
  if (qualifier_ == &::google::protobuf::internal::kEmptyString) {
    qualifier_ = new ::std::string;
  }
  qualifier_->assign(value);
}
inline void GeoResult::set_qualifier(const char* value) {
  set_has_qualifier();
  if (qualifier_ == &::google::protobuf::internal::kEmptyString) {
    qualifier_ = new ::std::string;
  }
  qualifier_->assign(value);
}
inline void GeoResult::set_qualifier(const char* value, size_t size) {
  set_has_qualifier();
  if (qualifier_ == &::google::protobuf::internal::kEmptyString) {
    qualifier_ = new ::std::string;
  }
  qualifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoResult::mutable_qualifier() {
  set_has_qualifier();
  if (qualifier_ == &::google::protobuf::internal::kEmptyString) {
    qualifier_ = new ::std::string;
  }
  return qualifier_;
}
inline ::std::string* GeoResult::release_qualifier() {
  clear_has_qualifier();
  if (qualifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = qualifier_;
    qualifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeoResult::set_allocated_qualifier(::std::string* qualifier) {
  if (qualifier_ != &::google::protobuf::internal::kEmptyString) {
    delete qualifier_;
  }
  if (qualifier) {
    set_has_qualifier();
    qualifier_ = qualifier;
  } else {
    clear_has_qualifier();
    qualifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string tip_id = 33;
inline bool GeoResult::has_tip_id() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void GeoResult::set_has_tip_id() {
  _has_bits_[0] |= 0x10000000u;
}
inline void GeoResult::clear_has_tip_id() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void GeoResult::clear_tip_id() {
  if (tip_id_ != &::google::protobuf::internal::kEmptyString) {
    tip_id_->clear();
  }
  clear_has_tip_id();
}
inline const ::std::string& GeoResult::tip_id() const {
  return *tip_id_;
}
inline void GeoResult::set_tip_id(const ::std::string& value) {
  set_has_tip_id();
  if (tip_id_ == &::google::protobuf::internal::kEmptyString) {
    tip_id_ = new ::std::string;
  }
  tip_id_->assign(value);
}
inline void GeoResult::set_tip_id(const char* value) {
  set_has_tip_id();
  if (tip_id_ == &::google::protobuf::internal::kEmptyString) {
    tip_id_ = new ::std::string;
  }
  tip_id_->assign(value);
}
inline void GeoResult::set_tip_id(const char* value, size_t size) {
  set_has_tip_id();
  if (tip_id_ == &::google::protobuf::internal::kEmptyString) {
    tip_id_ = new ::std::string;
  }
  tip_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoResult::mutable_tip_id() {
  set_has_tip_id();
  if (tip_id_ == &::google::protobuf::internal::kEmptyString) {
    tip_id_ = new ::std::string;
  }
  return tip_id_;
}
inline ::std::string* GeoResult::release_tip_id() {
  clear_has_tip_id();
  if (tip_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tip_id_;
    tip_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeoResult::set_allocated_tip_id(::std::string* tip_id) {
  if (tip_id_ != &::google::protobuf::internal::kEmptyString) {
    delete tip_id_;
  }
  if (tip_id) {
    set_has_tip_id();
    tip_id_ = tip_id;
  } else {
    clear_has_tip_id();
    tip_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClipRequest

// optional string msgName = 1 [default = "CLIPREQUEST"];
inline bool ClipRequest::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClipRequest::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClipRequest::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClipRequest::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ClipRequest::msgname() const {
  return *msgname_;
}
inline void ClipRequest::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ClipRequest::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ClipRequest::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClipRequest::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ClipRequest::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ClipRequest::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional double timeWhole = 2;
inline bool ClipRequest::has_timewhole() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClipRequest::set_has_timewhole() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClipRequest::clear_has_timewhole() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClipRequest::clear_timewhole() {
  timewhole_ = 0;
  clear_has_timewhole();
}
inline double ClipRequest::timewhole() const {
  return timewhole_;
}
inline void ClipRequest::set_timewhole(double value) {
  set_has_timewhole();
  timewhole_ = value;
}

// optional double timeFractional = 3;
inline bool ClipRequest::has_timefractional() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClipRequest::set_has_timefractional() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClipRequest::clear_has_timefractional() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClipRequest::clear_timefractional() {
  timefractional_ = 0;
  clear_has_timefractional();
}
inline double ClipRequest::timefractional() const {
  return timefractional_;
}
inline void ClipRequest::set_timefractional(double value) {
  set_has_timefractional();
  timefractional_ = value;
}

// optional double duration = 4;
inline bool ClipRequest::has_duration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClipRequest::set_has_duration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClipRequest::clear_has_duration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClipRequest::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline double ClipRequest::duration() const {
  return duration_;
}
inline void ClipRequest::set_duration(double value) {
  set_has_duration();
  duration_ = value;
}

// optional double centerFrequency = 5;
inline bool ClipRequest::has_centerfrequency() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClipRequest::set_has_centerfrequency() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClipRequest::clear_has_centerfrequency() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClipRequest::clear_centerfrequency() {
  centerfrequency_ = 0;
  clear_has_centerfrequency();
}
inline double ClipRequest::centerfrequency() const {
  return centerfrequency_;
}
inline void ClipRequest::set_centerfrequency(double value) {
  set_has_centerfrequency();
  centerfrequency_ = value;
}

// optional double freqOffset = 6;
inline bool ClipRequest::has_freqoffset() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClipRequest::set_has_freqoffset() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClipRequest::clear_has_freqoffset() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClipRequest::clear_freqoffset() {
  freqoffset_ = 0;
  clear_has_freqoffset();
}
inline double ClipRequest::freqoffset() const {
  return freqoffset_;
}
inline void ClipRequest::set_freqoffset(double value) {
  set_has_freqoffset();
  freqoffset_ = value;
}

// optional double sampleRate = 7;
inline bool ClipRequest::has_samplerate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClipRequest::set_has_samplerate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClipRequest::clear_has_samplerate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClipRequest::clear_samplerate() {
  samplerate_ = 0;
  clear_has_samplerate();
}
inline double ClipRequest::samplerate() const {
  return samplerate_;
}
inline void ClipRequest::set_samplerate(double value) {
  set_has_samplerate();
  samplerate_ = value;
}

// optional double bandwidth = 8;
inline bool ClipRequest::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClipRequest::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClipRequest::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClipRequest::clear_bandwidth() {
  bandwidth_ = 0;
  clear_has_bandwidth();
}
inline double ClipRequest::bandwidth() const {
  return bandwidth_;
}
inline void ClipRequest::set_bandwidth(double value) {
  set_has_bandwidth();
  bandwidth_ = value;
}

// optional string soiNum = 9;
inline bool ClipRequest::has_soinum() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClipRequest::set_has_soinum() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ClipRequest::clear_has_soinum() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ClipRequest::clear_soinum() {
  if (soinum_ != &::google::protobuf::internal::kEmptyString) {
    soinum_->clear();
  }
  clear_has_soinum();
}
inline const ::std::string& ClipRequest::soinum() const {
  return *soinum_;
}
inline void ClipRequest::set_soinum(const ::std::string& value) {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  soinum_->assign(value);
}
inline void ClipRequest::set_soinum(const char* value) {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  soinum_->assign(value);
}
inline void ClipRequest::set_soinum(const char* value, size_t size) {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  soinum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClipRequest::mutable_soinum() {
  set_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    soinum_ = new ::std::string;
  }
  return soinum_;
}
inline ::std::string* ClipRequest::release_soinum() {
  clear_has_soinum();
  if (soinum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = soinum_;
    soinum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClipRequest::set_allocated_soinum(::std::string* soinum) {
  if (soinum_ != &::google::protobuf::internal::kEmptyString) {
    delete soinum_;
  }
  if (soinum) {
    set_has_soinum();
    soinum_ = soinum;
  } else {
    clear_has_soinum();
    soinum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string globalId = 10;
inline bool ClipRequest::has_globalid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ClipRequest::set_has_globalid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ClipRequest::clear_has_globalid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ClipRequest::clear_globalid() {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    globalid_->clear();
  }
  clear_has_globalid();
}
inline const ::std::string& ClipRequest::globalid() const {
  return *globalid_;
}
inline void ClipRequest::set_globalid(const ::std::string& value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void ClipRequest::set_globalid(const char* value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void ClipRequest::set_globalid(const char* value, size_t size) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClipRequest::mutable_globalid() {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  return globalid_;
}
inline ::std::string* ClipRequest::release_globalid() {
  clear_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalid_;
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClipRequest::set_allocated_globalid(::std::string* globalid) {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    delete globalid_;
  }
  if (globalid) {
    set_has_globalid();
    globalid_ = globalid;
  } else {
    clear_has_globalid();
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 idNumber = 11;
inline bool ClipRequest::has_idnumber() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ClipRequest::set_has_idnumber() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ClipRequest::clear_has_idnumber() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ClipRequest::clear_idnumber() {
  idnumber_ = GOOGLE_LONGLONG(0);
  clear_has_idnumber();
}
inline ::google::protobuf::int64 ClipRequest::idnumber() const {
  return idnumber_;
}
inline void ClipRequest::set_idnumber(::google::protobuf::int64 value) {
  set_has_idnumber();
  idnumber_ = value;
}

// optional string sensorName = 12;
inline bool ClipRequest::has_sensorname() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ClipRequest::set_has_sensorname() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ClipRequest::clear_has_sensorname() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ClipRequest::clear_sensorname() {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    sensorname_->clear();
  }
  clear_has_sensorname();
}
inline const ::std::string& ClipRequest::sensorname() const {
  return *sensorname_;
}
inline void ClipRequest::set_sensorname(const ::std::string& value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void ClipRequest::set_sensorname(const char* value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void ClipRequest::set_sensorname(const char* value, size_t size) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClipRequest::mutable_sensorname() {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  return sensorname_;
}
inline ::std::string* ClipRequest::release_sensorname() {
  clear_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sensorname_;
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClipRequest::set_allocated_sensorname(::std::string* sensorname) {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    delete sensorname_;
  }
  if (sensorname) {
    set_has_sensorname();
    sensorname_ = sensorname;
  } else {
    clear_has_sensorname();
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClipResponse

// optional string msgName = 1 [default = "CLIPRESPONSE"];
inline bool ClipResponse::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClipResponse::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClipResponse::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClipResponse::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ClipResponse::msgname() const {
  return *msgname_;
}
inline void ClipResponse::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ClipResponse::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ClipResponse::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClipResponse::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ClipResponse::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ClipResponse::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional .falcon_common_msg.GeoTip geoTip = 2;
inline bool ClipResponse::has_geotip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClipResponse::set_has_geotip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClipResponse::clear_has_geotip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClipResponse::clear_geotip() {
  if (geotip_ != NULL) geotip_->::falcon_common_msg::GeoTip::Clear();
  clear_has_geotip();
}
inline const ::falcon_common_msg::GeoTip& ClipResponse::geotip() const {
  return geotip_ != NULL ? *geotip_ : *default_instance_->geotip_;
}
inline ::falcon_common_msg::GeoTip* ClipResponse::mutable_geotip() {
  set_has_geotip();
  if (geotip_ == NULL) geotip_ = new ::falcon_common_msg::GeoTip;
  return geotip_;
}
inline ::falcon_common_msg::GeoTip* ClipResponse::release_geotip() {
  clear_has_geotip();
  ::falcon_common_msg::GeoTip* temp = geotip_;
  geotip_ = NULL;
  return temp;
}
inline void ClipResponse::set_allocated_geotip(::falcon_common_msg::GeoTip* geotip) {
  delete geotip_;
  geotip_ = geotip;
  if (geotip) {
    set_has_geotip();
  } else {
    clear_has_geotip();
  }
}

// optional int64 idNumber = 3;
inline bool ClipResponse::has_idnumber() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClipResponse::set_has_idnumber() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClipResponse::clear_has_idnumber() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClipResponse::clear_idnumber() {
  idnumber_ = GOOGLE_LONGLONG(0);
  clear_has_idnumber();
}
inline ::google::protobuf::int64 ClipResponse::idnumber() const {
  return idnumber_;
}
inline void ClipResponse::set_idnumber(::google::protobuf::int64 value) {
  set_has_idnumber();
  idnumber_ = value;
}

// -------------------------------------------------------------------

// DetectionTip

// optional string msgName = 1 [default = "DETECTIONTIP"];
inline bool DetectionTip::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DetectionTip::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DetectionTip::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DetectionTip::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& DetectionTip::msgname() const {
  return *msgname_;
}
inline void DetectionTip::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void DetectionTip::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void DetectionTip::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DetectionTip::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* DetectionTip::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void DetectionTip::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string det_id = 2;
inline bool DetectionTip::has_det_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DetectionTip::set_has_det_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DetectionTip::clear_has_det_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DetectionTip::clear_det_id() {
  if (det_id_ != &::google::protobuf::internal::kEmptyString) {
    det_id_->clear();
  }
  clear_has_det_id();
}
inline const ::std::string& DetectionTip::det_id() const {
  return *det_id_;
}
inline void DetectionTip::set_det_id(const ::std::string& value) {
  set_has_det_id();
  if (det_id_ == &::google::protobuf::internal::kEmptyString) {
    det_id_ = new ::std::string;
  }
  det_id_->assign(value);
}
inline void DetectionTip::set_det_id(const char* value) {
  set_has_det_id();
  if (det_id_ == &::google::protobuf::internal::kEmptyString) {
    det_id_ = new ::std::string;
  }
  det_id_->assign(value);
}
inline void DetectionTip::set_det_id(const char* value, size_t size) {
  set_has_det_id();
  if (det_id_ == &::google::protobuf::internal::kEmptyString) {
    det_id_ = new ::std::string;
  }
  det_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DetectionTip::mutable_det_id() {
  set_has_det_id();
  if (det_id_ == &::google::protobuf::internal::kEmptyString) {
    det_id_ = new ::std::string;
  }
  return det_id_;
}
inline ::std::string* DetectionTip::release_det_id() {
  clear_has_det_id();
  if (det_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = det_id_;
    det_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DetectionTip::set_allocated_det_id(::std::string* det_id) {
  if (det_id_ != &::google::protobuf::internal::kEmptyString) {
    delete det_id_;
  }
  if (det_id) {
    set_has_det_id();
    det_id_ = det_id;
  } else {
    clear_has_det_id();
    det_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sensor_id = 3;
inline bool DetectionTip::has_sensor_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DetectionTip::set_has_sensor_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DetectionTip::clear_has_sensor_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DetectionTip::clear_sensor_id() {
  if (sensor_id_ != &::google::protobuf::internal::kEmptyString) {
    sensor_id_->clear();
  }
  clear_has_sensor_id();
}
inline const ::std::string& DetectionTip::sensor_id() const {
  return *sensor_id_;
}
inline void DetectionTip::set_sensor_id(const ::std::string& value) {
  set_has_sensor_id();
  if (sensor_id_ == &::google::protobuf::internal::kEmptyString) {
    sensor_id_ = new ::std::string;
  }
  sensor_id_->assign(value);
}
inline void DetectionTip::set_sensor_id(const char* value) {
  set_has_sensor_id();
  if (sensor_id_ == &::google::protobuf::internal::kEmptyString) {
    sensor_id_ = new ::std::string;
  }
  sensor_id_->assign(value);
}
inline void DetectionTip::set_sensor_id(const char* value, size_t size) {
  set_has_sensor_id();
  if (sensor_id_ == &::google::protobuf::internal::kEmptyString) {
    sensor_id_ = new ::std::string;
  }
  sensor_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DetectionTip::mutable_sensor_id() {
  set_has_sensor_id();
  if (sensor_id_ == &::google::protobuf::internal::kEmptyString) {
    sensor_id_ = new ::std::string;
  }
  return sensor_id_;
}
inline ::std::string* DetectionTip::release_sensor_id() {
  clear_has_sensor_id();
  if (sensor_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sensor_id_;
    sensor_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DetectionTip::set_allocated_sensor_id(::std::string* sensor_id) {
  if (sensor_id_ != &::google::protobuf::internal::kEmptyString) {
    delete sensor_id_;
  }
  if (sensor_id) {
    set_has_sensor_id();
    sensor_id_ = sensor_id;
  } else {
    clear_has_sensor_id();
    sensor_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool has_pred = 4;
inline bool DetectionTip::has_has_pred() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DetectionTip::set_has_has_pred() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DetectionTip::clear_has_has_pred() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DetectionTip::clear_has_pred() {
  has_pred_ = false;
  clear_has_has_pred();
}
inline bool DetectionTip::has_pred() const {
  return has_pred_;
}
inline void DetectionTip::set_has_pred(bool value) {
  set_has_has_pred();
  has_pred_ = value;
}

// optional string file_location = 5;
inline bool DetectionTip::has_file_location() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DetectionTip::set_has_file_location() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DetectionTip::clear_has_file_location() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DetectionTip::clear_file_location() {
  if (file_location_ != &::google::protobuf::internal::kEmptyString) {
    file_location_->clear();
  }
  clear_has_file_location();
}
inline const ::std::string& DetectionTip::file_location() const {
  return *file_location_;
}
inline void DetectionTip::set_file_location(const ::std::string& value) {
  set_has_file_location();
  if (file_location_ == &::google::protobuf::internal::kEmptyString) {
    file_location_ = new ::std::string;
  }
  file_location_->assign(value);
}
inline void DetectionTip::set_file_location(const char* value) {
  set_has_file_location();
  if (file_location_ == &::google::protobuf::internal::kEmptyString) {
    file_location_ = new ::std::string;
  }
  file_location_->assign(value);
}
inline void DetectionTip::set_file_location(const char* value, size_t size) {
  set_has_file_location();
  if (file_location_ == &::google::protobuf::internal::kEmptyString) {
    file_location_ = new ::std::string;
  }
  file_location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DetectionTip::mutable_file_location() {
  set_has_file_location();
  if (file_location_ == &::google::protobuf::internal::kEmptyString) {
    file_location_ = new ::std::string;
  }
  return file_location_;
}
inline ::std::string* DetectionTip::release_file_location() {
  clear_has_file_location();
  if (file_location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_location_;
    file_location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DetectionTip::set_allocated_file_location(::std::string* file_location) {
  if (file_location_ != &::google::protobuf::internal::kEmptyString) {
    delete file_location_;
  }
  if (file_location) {
    set_has_file_location();
    file_location_ = file_location;
  } else {
    clear_has_file_location();
    file_location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double start_time_whole = 6;
inline bool DetectionTip::has_start_time_whole() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DetectionTip::set_has_start_time_whole() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DetectionTip::clear_has_start_time_whole() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DetectionTip::clear_start_time_whole() {
  start_time_whole_ = 0;
  clear_has_start_time_whole();
}
inline double DetectionTip::start_time_whole() const {
  return start_time_whole_;
}
inline void DetectionTip::set_start_time_whole(double value) {
  set_has_start_time_whole();
  start_time_whole_ = value;
}

// optional double start_time_frac = 7;
inline bool DetectionTip::has_start_time_frac() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DetectionTip::set_has_start_time_frac() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DetectionTip::clear_has_start_time_frac() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DetectionTip::clear_start_time_frac() {
  start_time_frac_ = 0;
  clear_has_start_time_frac();
}
inline double DetectionTip::start_time_frac() const {
  return start_time_frac_;
}
inline void DetectionTip::set_start_time_frac(double value) {
  set_has_start_time_frac();
  start_time_frac_ = value;
}

// optional double duration_millisec = 8;
inline bool DetectionTip::has_duration_millisec() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DetectionTip::set_has_duration_millisec() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DetectionTip::clear_has_duration_millisec() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DetectionTip::clear_duration_millisec() {
  duration_millisec_ = 0;
  clear_has_duration_millisec();
}
inline double DetectionTip::duration_millisec() const {
  return duration_millisec_;
}
inline void DetectionTip::set_duration_millisec(double value) {
  set_has_duration_millisec();
  duration_millisec_ = value;
}

// optional double center_tune_freq_hz = 9;
inline bool DetectionTip::has_center_tune_freq_hz() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DetectionTip::set_has_center_tune_freq_hz() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DetectionTip::clear_has_center_tune_freq_hz() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DetectionTip::clear_center_tune_freq_hz() {
  center_tune_freq_hz_ = 0;
  clear_has_center_tune_freq_hz();
}
inline double DetectionTip::center_tune_freq_hz() const {
  return center_tune_freq_hz_;
}
inline void DetectionTip::set_center_tune_freq_hz(double value) {
  set_has_center_tune_freq_hz();
  center_tune_freq_hz_ = value;
}

// optional double bandwidth_hz = 10;
inline bool DetectionTip::has_bandwidth_hz() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DetectionTip::set_has_bandwidth_hz() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DetectionTip::clear_has_bandwidth_hz() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DetectionTip::clear_bandwidth_hz() {
  bandwidth_hz_ = 0;
  clear_has_bandwidth_hz();
}
inline double DetectionTip::bandwidth_hz() const {
  return bandwidth_hz_;
}
inline void DetectionTip::set_bandwidth_hz(double value) {
  set_has_bandwidth_hz();
  bandwidth_hz_ = value;
}

// repeated .falcon_common_msg.Hop hops = 11;
inline int DetectionTip::hops_size() const {
  return hops_.size();
}
inline void DetectionTip::clear_hops() {
  hops_.Clear();
}
inline const ::falcon_common_msg::Hop& DetectionTip::hops(int index) const {
  return hops_.Get(index);
}
inline ::falcon_common_msg::Hop* DetectionTip::mutable_hops(int index) {
  return hops_.Mutable(index);
}
inline ::falcon_common_msg::Hop* DetectionTip::add_hops() {
  return hops_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::Hop >&
DetectionTip::hops() const {
  return hops_;
}
inline ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::Hop >*
DetectionTip::mutable_hops() {
  return &hops_;
}

// repeated .falcon_common_msg.Burst bursts = 12;
inline int DetectionTip::bursts_size() const {
  return bursts_.size();
}
inline void DetectionTip::clear_bursts() {
  bursts_.Clear();
}
inline const ::falcon_common_msg::Burst& DetectionTip::bursts(int index) const {
  return bursts_.Get(index);
}
inline ::falcon_common_msg::Burst* DetectionTip::mutable_bursts(int index) {
  return bursts_.Mutable(index);
}
inline ::falcon_common_msg::Burst* DetectionTip::add_bursts() {
  return bursts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::Burst >&
DetectionTip::bursts() const {
  return bursts_;
}
inline ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::Burst >*
DetectionTip::mutable_bursts() {
  return &bursts_;
}

// -------------------------------------------------------------------

// Hop

// optional string hop_id = 1;
inline bool Hop::has_hop_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Hop::set_has_hop_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Hop::clear_has_hop_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Hop::clear_hop_id() {
  if (hop_id_ != &::google::protobuf::internal::kEmptyString) {
    hop_id_->clear();
  }
  clear_has_hop_id();
}
inline const ::std::string& Hop::hop_id() const {
  return *hop_id_;
}
inline void Hop::set_hop_id(const ::std::string& value) {
  set_has_hop_id();
  if (hop_id_ == &::google::protobuf::internal::kEmptyString) {
    hop_id_ = new ::std::string;
  }
  hop_id_->assign(value);
}
inline void Hop::set_hop_id(const char* value) {
  set_has_hop_id();
  if (hop_id_ == &::google::protobuf::internal::kEmptyString) {
    hop_id_ = new ::std::string;
  }
  hop_id_->assign(value);
}
inline void Hop::set_hop_id(const char* value, size_t size) {
  set_has_hop_id();
  if (hop_id_ == &::google::protobuf::internal::kEmptyString) {
    hop_id_ = new ::std::string;
  }
  hop_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Hop::mutable_hop_id() {
  set_has_hop_id();
  if (hop_id_ == &::google::protobuf::internal::kEmptyString) {
    hop_id_ = new ::std::string;
  }
  return hop_id_;
}
inline ::std::string* Hop::release_hop_id() {
  clear_has_hop_id();
  if (hop_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hop_id_;
    hop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Hop::set_allocated_hop_id(::std::string* hop_id) {
  if (hop_id_ != &::google::protobuf::internal::kEmptyString) {
    delete hop_id_;
  }
  if (hop_id) {
    set_has_hop_id();
    hop_id_ = hop_id;
  } else {
    clear_has_hop_id();
    hop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double start_time_whole = 2;
inline bool Hop::has_start_time_whole() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Hop::set_has_start_time_whole() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Hop::clear_has_start_time_whole() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Hop::clear_start_time_whole() {
  start_time_whole_ = 0;
  clear_has_start_time_whole();
}
inline double Hop::start_time_whole() const {
  return start_time_whole_;
}
inline void Hop::set_start_time_whole(double value) {
  set_has_start_time_whole();
  start_time_whole_ = value;
}

// optional double start_time_frac = 3;
inline bool Hop::has_start_time_frac() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Hop::set_has_start_time_frac() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Hop::clear_has_start_time_frac() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Hop::clear_start_time_frac() {
  start_time_frac_ = 0;
  clear_has_start_time_frac();
}
inline double Hop::start_time_frac() const {
  return start_time_frac_;
}
inline void Hop::set_start_time_frac(double value) {
  set_has_start_time_frac();
  start_time_frac_ = value;
}

// optional double duration_millisec = 4;
inline bool Hop::has_duration_millisec() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Hop::set_has_duration_millisec() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Hop::clear_has_duration_millisec() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Hop::clear_duration_millisec() {
  duration_millisec_ = 0;
  clear_has_duration_millisec();
}
inline double Hop::duration_millisec() const {
  return duration_millisec_;
}
inline void Hop::set_duration_millisec(double value) {
  set_has_duration_millisec();
  duration_millisec_ = value;
}

// optional double hop_center_freq_hz = 5;
inline bool Hop::has_hop_center_freq_hz() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Hop::set_has_hop_center_freq_hz() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Hop::clear_has_hop_center_freq_hz() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Hop::clear_hop_center_freq_hz() {
  hop_center_freq_hz_ = 0;
  clear_has_hop_center_freq_hz();
}
inline double Hop::hop_center_freq_hz() const {
  return hop_center_freq_hz_;
}
inline void Hop::set_hop_center_freq_hz(double value) {
  set_has_hop_center_freq_hz();
  hop_center_freq_hz_ = value;
}

// optional double hop_bw_hz = 6;
inline bool Hop::has_hop_bw_hz() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Hop::set_has_hop_bw_hz() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Hop::clear_has_hop_bw_hz() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Hop::clear_hop_bw_hz() {
  hop_bw_hz_ = 0;
  clear_has_hop_bw_hz();
}
inline double Hop::hop_bw_hz() const {
  return hop_bw_hz_;
}
inline void Hop::set_hop_bw_hz(double value) {
  set_has_hop_bw_hz();
  hop_bw_hz_ = value;
}

// -------------------------------------------------------------------

// Burst

// optional string burst_id = 1;
inline bool Burst::has_burst_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Burst::set_has_burst_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Burst::clear_has_burst_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Burst::clear_burst_id() {
  if (burst_id_ != &::google::protobuf::internal::kEmptyString) {
    burst_id_->clear();
  }
  clear_has_burst_id();
}
inline const ::std::string& Burst::burst_id() const {
  return *burst_id_;
}
inline void Burst::set_burst_id(const ::std::string& value) {
  set_has_burst_id();
  if (burst_id_ == &::google::protobuf::internal::kEmptyString) {
    burst_id_ = new ::std::string;
  }
  burst_id_->assign(value);
}
inline void Burst::set_burst_id(const char* value) {
  set_has_burst_id();
  if (burst_id_ == &::google::protobuf::internal::kEmptyString) {
    burst_id_ = new ::std::string;
  }
  burst_id_->assign(value);
}
inline void Burst::set_burst_id(const char* value, size_t size) {
  set_has_burst_id();
  if (burst_id_ == &::google::protobuf::internal::kEmptyString) {
    burst_id_ = new ::std::string;
  }
  burst_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Burst::mutable_burst_id() {
  set_has_burst_id();
  if (burst_id_ == &::google::protobuf::internal::kEmptyString) {
    burst_id_ = new ::std::string;
  }
  return burst_id_;
}
inline ::std::string* Burst::release_burst_id() {
  clear_has_burst_id();
  if (burst_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = burst_id_;
    burst_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Burst::set_allocated_burst_id(::std::string* burst_id) {
  if (burst_id_ != &::google::protobuf::internal::kEmptyString) {
    delete burst_id_;
  }
  if (burst_id) {
    set_has_burst_id();
    burst_id_ = burst_id;
  } else {
    clear_has_burst_id();
    burst_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double start_time_whole = 2;
inline bool Burst::has_start_time_whole() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Burst::set_has_start_time_whole() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Burst::clear_has_start_time_whole() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Burst::clear_start_time_whole() {
  start_time_whole_ = 0;
  clear_has_start_time_whole();
}
inline double Burst::start_time_whole() const {
  return start_time_whole_;
}
inline void Burst::set_start_time_whole(double value) {
  set_has_start_time_whole();
  start_time_whole_ = value;
}

// optional double start_time_frac = 3;
inline bool Burst::has_start_time_frac() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Burst::set_has_start_time_frac() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Burst::clear_has_start_time_frac() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Burst::clear_start_time_frac() {
  start_time_frac_ = 0;
  clear_has_start_time_frac();
}
inline double Burst::start_time_frac() const {
  return start_time_frac_;
}
inline void Burst::set_start_time_frac(double value) {
  set_has_start_time_frac();
  start_time_frac_ = value;
}

// optional double duration_millisec = 4;
inline bool Burst::has_duration_millisec() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Burst::set_has_duration_millisec() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Burst::clear_has_duration_millisec() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Burst::clear_duration_millisec() {
  duration_millisec_ = 0;
  clear_has_duration_millisec();
}
inline double Burst::duration_millisec() const {
  return duration_millisec_;
}
inline void Burst::set_duration_millisec(double value) {
  set_has_duration_millisec();
  duration_millisec_ = value;
}

// optional double burst_center_freq_hz = 5;
inline bool Burst::has_burst_center_freq_hz() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Burst::set_has_burst_center_freq_hz() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Burst::clear_has_burst_center_freq_hz() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Burst::clear_burst_center_freq_hz() {
  burst_center_freq_hz_ = 0;
  clear_has_burst_center_freq_hz();
}
inline double Burst::burst_center_freq_hz() const {
  return burst_center_freq_hz_;
}
inline void Burst::set_burst_center_freq_hz(double value) {
  set_has_burst_center_freq_hz();
  burst_center_freq_hz_ = value;
}

// optional double burst_bw_hz = 6;
inline bool Burst::has_burst_bw_hz() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Burst::set_has_burst_bw_hz() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Burst::clear_has_burst_bw_hz() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Burst::clear_burst_bw_hz() {
  burst_bw_hz_ = 0;
  clear_has_burst_bw_hz();
}
inline double Burst::burst_bw_hz() const {
  return burst_bw_hz_;
}
inline void Burst::set_burst_bw_hz(double value) {
  set_has_burst_bw_hz();
  burst_bw_hz_ = value;
}

// -------------------------------------------------------------------

// SensorStatus

// optional string msgName = 1 [default = "SENSOR_STATUS"];
inline bool SensorStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SensorStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SensorStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SensorStatus::msgname() const {
  return *msgname_;
}
inline void SensorStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SensorStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SensorStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SensorStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SensorStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SensorStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional float lat = 2;
inline bool SensorStatus::has_lat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorStatus::set_has_lat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SensorStatus::clear_has_lat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SensorStatus::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline float SensorStatus::lat() const {
  return lat_;
}
inline void SensorStatus::set_lat(float value) {
  set_has_lat();
  lat_ = value;
}

// optional float lon = 3;
inline bool SensorStatus::has_lon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SensorStatus::set_has_lon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SensorStatus::clear_has_lon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SensorStatus::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline float SensorStatus::lon() const {
  return lon_;
}
inline void SensorStatus::set_lon(float value) {
  set_has_lon();
  lon_ = value;
}

// optional float alt = 4;
inline bool SensorStatus::has_alt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SensorStatus::set_has_alt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SensorStatus::clear_has_alt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SensorStatus::clear_alt() {
  alt_ = 0;
  clear_has_alt();
}
inline float SensorStatus::alt() const {
  return alt_;
}
inline void SensorStatus::set_alt(float value) {
  set_has_alt();
  alt_ = value;
}

// optional int64 timestamp = 5;
inline bool SensorStatus::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SensorStatus::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SensorStatus::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SensorStatus::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 SensorStatus::timestamp() const {
  return timestamp_;
}
inline void SensorStatus::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional string sensorName = 6 [default = ""];
inline bool SensorStatus::has_sensorname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SensorStatus::set_has_sensorname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SensorStatus::clear_has_sensorname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SensorStatus::clear_sensorname() {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    sensorname_->clear();
  }
  clear_has_sensorname();
}
inline const ::std::string& SensorStatus::sensorname() const {
  return *sensorname_;
}
inline void SensorStatus::set_sensorname(const ::std::string& value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void SensorStatus::set_sensorname(const char* value) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(value);
}
inline void SensorStatus::set_sensorname(const char* value, size_t size) {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  sensorname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SensorStatus::mutable_sensorname() {
  set_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    sensorname_ = new ::std::string;
  }
  return sensorname_;
}
inline ::std::string* SensorStatus::release_sensorname() {
  clear_has_sensorname();
  if (sensorname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sensorname_;
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SensorStatus::set_allocated_sensorname(::std::string* sensorname) {
  if (sensorname_ != &::google::protobuf::internal::kEmptyString) {
    delete sensorname_;
  }
  if (sensorname) {
    set_has_sensorname();
    sensorname_ = sensorname;
  } else {
    clear_has_sensorname();
    sensorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .falcon_common_msg.ReceiverStatus rxStatus = 7;
inline int SensorStatus::rxstatus_size() const {
  return rxstatus_.size();
}
inline void SensorStatus::clear_rxstatus() {
  rxstatus_.Clear();
}
inline const ::falcon_common_msg::ReceiverStatus& SensorStatus::rxstatus(int index) const {
  return rxstatus_.Get(index);
}
inline ::falcon_common_msg::ReceiverStatus* SensorStatus::mutable_rxstatus(int index) {
  return rxstatus_.Mutable(index);
}
inline ::falcon_common_msg::ReceiverStatus* SensorStatus::add_rxstatus() {
  return rxstatus_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::ReceiverStatus >&
SensorStatus::rxstatus() const {
  return rxstatus_;
}
inline ::google::protobuf::RepeatedPtrField< ::falcon_common_msg::ReceiverStatus >*
SensorStatus::mutable_rxstatus() {
  return &rxstatus_;
}

// -------------------------------------------------------------------

// ReceiverStatus

// optional string msgName = 1 [default = "RECEIVER_STATUS"];
inline bool ReceiverStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReceiverStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReceiverStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReceiverStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ReceiverStatus::msgname() const {
  return *msgname_;
}
inline void ReceiverStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ReceiverStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ReceiverStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiverStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ReceiverStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ReceiverStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int32 idNum = 2;
inline bool ReceiverStatus::has_idnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReceiverStatus::set_has_idnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReceiverStatus::clear_has_idnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReceiverStatus::clear_idnum() {
  idnum_ = 0;
  clear_has_idnum();
}
inline ::google::protobuf::int32 ReceiverStatus::idnum() const {
  return idnum_;
}
inline void ReceiverStatus::set_idnum(::google::protobuf::int32 value) {
  set_has_idnum();
  idnum_ = value;
}

// optional string name = 3;
inline bool ReceiverStatus::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReceiverStatus::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReceiverStatus::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReceiverStatus::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ReceiverStatus::name() const {
  return *name_;
}
inline void ReceiverStatus::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ReceiverStatus::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ReceiverStatus::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiverStatus::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ReceiverStatus::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReceiverStatus::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string type = 4;
inline bool ReceiverStatus::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReceiverStatus::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReceiverStatus::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReceiverStatus::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& ReceiverStatus::type() const {
  return *type_;
}
inline void ReceiverStatus::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void ReceiverStatus::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void ReceiverStatus::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiverStatus::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* ReceiverStatus::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReceiverStatus::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float rxFreq = 5;
inline bool ReceiverStatus::has_rxfreq() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReceiverStatus::set_has_rxfreq() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReceiverStatus::clear_has_rxfreq() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReceiverStatus::clear_rxfreq() {
  rxfreq_ = 0;
  clear_has_rxfreq();
}
inline float ReceiverStatus::rxfreq() const {
  return rxfreq_;
}
inline void ReceiverStatus::set_rxfreq(float value) {
  set_has_rxfreq();
  rxfreq_ = value;
}

// optional float rxBandwidth = 6;
inline bool ReceiverStatus::has_rxbandwidth() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReceiverStatus::set_has_rxbandwidth() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReceiverStatus::clear_has_rxbandwidth() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReceiverStatus::clear_rxbandwidth() {
  rxbandwidth_ = 0;
  clear_has_rxbandwidth();
}
inline float ReceiverStatus::rxbandwidth() const {
  return rxbandwidth_;
}
inline void ReceiverStatus::set_rxbandwidth(float value) {
  set_has_rxbandwidth();
  rxbandwidth_ = value;
}

// -------------------------------------------------------------------

// Timestamp

// optional int64 seconds = 1;
inline bool Timestamp::has_seconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Timestamp::set_has_seconds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Timestamp::clear_has_seconds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Timestamp::clear_seconds() {
  seconds_ = GOOGLE_LONGLONG(0);
  clear_has_seconds();
}
inline ::google::protobuf::int64 Timestamp::seconds() const {
  return seconds_;
}
inline void Timestamp::set_seconds(::google::protobuf::int64 value) {
  set_has_seconds();
  seconds_ = value;
}

// optional float fseconds = 2;
inline bool Timestamp::has_fseconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Timestamp::set_has_fseconds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Timestamp::clear_has_fseconds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Timestamp::clear_fseconds() {
  fseconds_ = 0;
  clear_has_fseconds();
}
inline float Timestamp::fseconds() const {
  return fseconds_;
}
inline void Timestamp::set_fseconds(float value) {
  set_has_fseconds();
  fseconds_ = value;
}

// -------------------------------------------------------------------

// ServiceReinitialize

// optional string msgName = 1 [default = "SERVICE_REINITIALIZE"];
inline bool ServiceReinitialize::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceReinitialize::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceReinitialize::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceReinitialize::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ServiceReinitialize::msgname() const {
  return *msgname_;
}
inline void ServiceReinitialize::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ServiceReinitialize::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ServiceReinitialize::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceReinitialize::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ServiceReinitialize::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ServiceReinitialize::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// -------------------------------------------------------------------

// SensorHeading

// optional string msgName = 1 [default = "SENSOR_HEADING"];
inline bool SensorHeading::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorHeading::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SensorHeading::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SensorHeading::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SensorHeading::msgname() const {
  return *msgname_;
}
inline void SensorHeading::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SensorHeading::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SensorHeading::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SensorHeading::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SensorHeading::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SensorHeading::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string hostname = 2;
inline bool SensorHeading::has_hostname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorHeading::set_has_hostname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SensorHeading::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SensorHeading::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& SensorHeading::hostname() const {
  return *hostname_;
}
inline void SensorHeading::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void SensorHeading::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void SensorHeading::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SensorHeading::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* SensorHeading::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SensorHeading::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double j1970Time = 3;
inline bool SensorHeading::has_j1970time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SensorHeading::set_has_j1970time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SensorHeading::clear_has_j1970time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SensorHeading::clear_j1970time() {
  j1970time_ = 0;
  clear_has_j1970time();
}
inline double SensorHeading::j1970time() const {
  return j1970time_;
}
inline void SensorHeading::set_j1970time(double value) {
  set_has_j1970time();
  j1970time_ = value;
}

// optional double heading = 4;
inline bool SensorHeading::has_heading() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SensorHeading::set_has_heading() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SensorHeading::clear_has_heading() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SensorHeading::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline double SensorHeading::heading() const {
  return heading_;
}
inline void SensorHeading::set_heading(double value) {
  set_has_heading();
  heading_ = value;
}

// optional double pitch = 5;
inline bool SensorHeading::has_pitch() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SensorHeading::set_has_pitch() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SensorHeading::clear_has_pitch() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SensorHeading::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
inline double SensorHeading::pitch() const {
  return pitch_;
}
inline void SensorHeading::set_pitch(double value) {
  set_has_pitch();
  pitch_ = value;
}

// optional double roll = 6;
inline bool SensorHeading::has_roll() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SensorHeading::set_has_roll() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SensorHeading::clear_has_roll() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SensorHeading::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline double SensorHeading::roll() const {
  return roll_;
}
inline void SensorHeading::set_roll(double value) {
  set_has_roll();
  roll_ = value;
}

// -------------------------------------------------------------------

// KeyValuePair

// optional string label = 1;
inline bool KeyValuePair::has_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyValuePair::set_has_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyValuePair::clear_has_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyValuePair::clear_label() {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& KeyValuePair::label() const {
  return *label_;
}
inline void KeyValuePair::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void KeyValuePair::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void KeyValuePair::set_label(const char* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyValuePair::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  return label_;
}
inline ::std::string* KeyValuePair::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KeyValuePair::set_allocated_label(::std::string* label) {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    delete label_;
  }
  if (label) {
    set_has_label();
    label_ = label;
  } else {
    clear_has_label();
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .falcon_common_msg.ValueContainer value = 2;
inline bool KeyValuePair::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyValuePair::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyValuePair::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyValuePair::clear_value() {
  if (value_ != NULL) value_->::falcon_common_msg::ValueContainer::Clear();
  clear_has_value();
}
inline const ::falcon_common_msg::ValueContainer& KeyValuePair::value() const {
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::falcon_common_msg::ValueContainer* KeyValuePair::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::falcon_common_msg::ValueContainer;
  return value_;
}
inline ::falcon_common_msg::ValueContainer* KeyValuePair::release_value() {
  clear_has_value();
  ::falcon_common_msg::ValueContainer* temp = value_;
  value_ = NULL;
  return temp;
}
inline void KeyValuePair::set_allocated_value(::falcon_common_msg::ValueContainer* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
}

// -------------------------------------------------------------------

// ValueContainer

// optional bool bool_value = 1;
inline bool ValueContainer::has_bool_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ValueContainer::set_has_bool_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ValueContainer::clear_has_bool_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ValueContainer::clear_bool_value() {
  bool_value_ = false;
  clear_has_bool_value();
}
inline bool ValueContainer::bool_value() const {
  return bool_value_;
}
inline void ValueContainer::set_bool_value(bool value) {
  set_has_bool_value();
  bool_value_ = value;
}

// optional int32 int_value = 2;
inline bool ValueContainer::has_int_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ValueContainer::set_has_int_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ValueContainer::clear_has_int_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ValueContainer::clear_int_value() {
  int_value_ = 0;
  clear_has_int_value();
}
inline ::google::protobuf::int32 ValueContainer::int_value() const {
  return int_value_;
}
inline void ValueContainer::set_int_value(::google::protobuf::int32 value) {
  set_has_int_value();
  int_value_ = value;
}

// optional float float_value = 3;
inline bool ValueContainer::has_float_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ValueContainer::set_has_float_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ValueContainer::clear_has_float_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ValueContainer::clear_float_value() {
  float_value_ = 0;
  clear_has_float_value();
}
inline float ValueContainer::float_value() const {
  return float_value_;
}
inline void ValueContainer::set_float_value(float value) {
  set_has_float_value();
  float_value_ = value;
}

// optional string string_value = 4;
inline bool ValueContainer::has_string_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ValueContainer::set_has_string_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ValueContainer::clear_has_string_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ValueContainer::clear_string_value() {
  if (string_value_ != &::google::protobuf::internal::kEmptyString) {
    string_value_->clear();
  }
  clear_has_string_value();
}
inline const ::std::string& ValueContainer::string_value() const {
  return *string_value_;
}
inline void ValueContainer::set_string_value(const ::std::string& value) {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::kEmptyString) {
    string_value_ = new ::std::string;
  }
  string_value_->assign(value);
}
inline void ValueContainer::set_string_value(const char* value) {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::kEmptyString) {
    string_value_ = new ::std::string;
  }
  string_value_->assign(value);
}
inline void ValueContainer::set_string_value(const char* value, size_t size) {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::kEmptyString) {
    string_value_ = new ::std::string;
  }
  string_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ValueContainer::mutable_string_value() {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::kEmptyString) {
    string_value_ = new ::std::string;
  }
  return string_value_;
}
inline ::std::string* ValueContainer::release_string_value() {
  clear_has_string_value();
  if (string_value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = string_value_;
    string_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ValueContainer::set_allocated_string_value(::std::string* string_value) {
  if (string_value_ != &::google::protobuf::internal::kEmptyString) {
    delete string_value_;
  }
  if (string_value) {
    set_has_string_value();
    string_value_ = string_value;
  } else {
    clear_has_string_value();
    string_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .falcon_common_msg.GeodeticPosition position_value = 5;
inline bool ValueContainer::has_position_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ValueContainer::set_has_position_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ValueContainer::clear_has_position_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ValueContainer::clear_position_value() {
  if (position_value_ != NULL) position_value_->::falcon_common_msg::GeodeticPosition::Clear();
  clear_has_position_value();
}
inline const ::falcon_common_msg::GeodeticPosition& ValueContainer::position_value() const {
  return position_value_ != NULL ? *position_value_ : *default_instance_->position_value_;
}
inline ::falcon_common_msg::GeodeticPosition* ValueContainer::mutable_position_value() {
  set_has_position_value();
  if (position_value_ == NULL) position_value_ = new ::falcon_common_msg::GeodeticPosition;
  return position_value_;
}
inline ::falcon_common_msg::GeodeticPosition* ValueContainer::release_position_value() {
  clear_has_position_value();
  ::falcon_common_msg::GeodeticPosition* temp = position_value_;
  position_value_ = NULL;
  return temp;
}
inline void ValueContainer::set_allocated_position_value(::falcon_common_msg::GeodeticPosition* position_value) {
  delete position_value_;
  position_value_ = position_value;
  if (position_value) {
    set_has_position_value();
  } else {
    clear_has_position_value();
  }
}

// -------------------------------------------------------------------

// GeodeticPosition

// optional float lat = 1;
inline bool GeodeticPosition::has_lat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GeodeticPosition::set_has_lat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GeodeticPosition::clear_has_lat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GeodeticPosition::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline float GeodeticPosition::lat() const {
  return lat_;
}
inline void GeodeticPosition::set_lat(float value) {
  set_has_lat();
  lat_ = value;
}

// optional float lon = 2;
inline bool GeodeticPosition::has_lon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GeodeticPosition::set_has_lon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GeodeticPosition::clear_has_lon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GeodeticPosition::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline float GeodeticPosition::lon() const {
  return lon_;
}
inline void GeodeticPosition::set_lon(float value) {
  set_has_lon();
  lon_ = value;
}

// optional int64 alt = 3;
inline bool GeodeticPosition::has_alt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GeodeticPosition::set_has_alt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GeodeticPosition::clear_has_alt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GeodeticPosition::clear_alt() {
  alt_ = GOOGLE_LONGLONG(0);
  clear_has_alt();
}
inline ::google::protobuf::int64 GeodeticPosition::alt() const {
  return alt_;
}
inline void GeodeticPosition::set_alt(::google::protobuf::int64 value) {
  set_has_alt();
  alt_ = value;
}

// optional int64 alt_meters_hae = 4;
inline bool GeodeticPosition::has_alt_meters_hae() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GeodeticPosition::set_has_alt_meters_hae() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GeodeticPosition::clear_has_alt_meters_hae() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GeodeticPosition::clear_alt_meters_hae() {
  alt_meters_hae_ = GOOGLE_LONGLONG(0);
  clear_has_alt_meters_hae();
}
inline ::google::protobuf::int64 GeodeticPosition::alt_meters_hae() const {
  return alt_meters_hae_;
}
inline void GeodeticPosition::set_alt_meters_hae(::google::protobuf::int64 value) {
  set_has_alt_meters_hae();
  alt_meters_hae_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace falcon_common_msg

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_FalconCommonMessages_2eproto__INCLUDED
