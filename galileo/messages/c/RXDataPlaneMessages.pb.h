// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: RXDataPlaneMessages.proto

#ifndef PROTOBUF_RXDataPlaneMessages_2eproto__INCLUDED
#define PROTOBUF_RXDataPlaneMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "TunerMessages.pb.h"
// @@protoc_insertion_point(includes)

namespace rxdataplane_msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_RXDataPlaneMessages_2eproto();
void protobuf_AssignDesc_RXDataPlaneMessages_2eproto();
void protobuf_ShutdownFile_RXDataPlaneMessages_2eproto();

class DataPlaneInfo;
class SingleChannelInfoEnvelope;
class SingleChannelInfo;
class SpectrogramInfo;
class SpectrogramInfoEnvelope;
class PSDInfo;
class PSDInfoEnvelope;
class EnergyBurstInfo;
class EnergyBurstInfoEnvelope;
class PDWInfo;
class PDWInfoEnvelope;

enum ModulationType {
  NONE = 0,
  UNKNOWN = 1,
  LFM_UP = 2,
  LFM_DN = 3
};
bool ModulationType_IsValid(int value);
const ModulationType ModulationType_MIN = NONE;
const ModulationType ModulationType_MAX = LFM_DN;
const int ModulationType_ARRAYSIZE = ModulationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ModulationType_descriptor();
inline const ::std::string& ModulationType_Name(ModulationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ModulationType_descriptor(), value);
}
inline bool ModulationType_Parse(
    const ::std::string& name, ModulationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ModulationType>(
    ModulationType_descriptor(), name, value);
}
// ===================================================================

class DataPlaneInfo : public ::google::protobuf::Message {
 public:
  DataPlaneInfo();
  virtual ~DataPlaneInfo();

  DataPlaneInfo(const DataPlaneInfo& from);

  inline DataPlaneInfo& operator=(const DataPlaneInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataPlaneInfo& default_instance();

  void Swap(DataPlaneInfo* other);

  // implements Message ----------------------------------------------

  DataPlaneInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataPlaneInfo& from);
  void MergeFrom(const DataPlaneInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "DATAPLANEINFO"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional .tuner_msg.IQHeaderInfo IQHeader = 2;
  inline bool has_iqheader() const;
  inline void clear_iqheader();
  static const int kIQHeaderFieldNumber = 2;
  inline const ::tuner_msg::IQHeaderInfo& iqheader() const;
  inline ::tuner_msg::IQHeaderInfo* mutable_iqheader();
  inline ::tuner_msg::IQHeaderInfo* release_iqheader();
  inline void set_allocated_iqheader(::tuner_msg::IQHeaderInfo* iqheader);

  // optional .tuner_msg.SnapInfo snapInfo = 3;
  inline bool has_snapinfo() const;
  inline void clear_snapinfo();
  static const int kSnapInfoFieldNumber = 3;
  inline const ::tuner_msg::SnapInfo& snapinfo() const;
  inline ::tuner_msg::SnapInfo* mutable_snapinfo();
  inline ::tuner_msg::SnapInfo* release_snapinfo();
  inline void set_allocated_snapinfo(::tuner_msg::SnapInfo* snapinfo);

  // optional .rxdataplane_msg.SpectrogramInfoEnvelope spectrogramEnvelope = 4;
  inline bool has_spectrogramenvelope() const;
  inline void clear_spectrogramenvelope();
  static const int kSpectrogramEnvelopeFieldNumber = 4;
  inline const ::rxdataplane_msg::SpectrogramInfoEnvelope& spectrogramenvelope() const;
  inline ::rxdataplane_msg::SpectrogramInfoEnvelope* mutable_spectrogramenvelope();
  inline ::rxdataplane_msg::SpectrogramInfoEnvelope* release_spectrogramenvelope();
  inline void set_allocated_spectrogramenvelope(::rxdataplane_msg::SpectrogramInfoEnvelope* spectrogramenvelope);

  // optional .rxdataplane_msg.PSDInfoEnvelope PSDEnvelope = 5;
  inline bool has_psdenvelope() const;
  inline void clear_psdenvelope();
  static const int kPSDEnvelopeFieldNumber = 5;
  inline const ::rxdataplane_msg::PSDInfoEnvelope& psdenvelope() const;
  inline ::rxdataplane_msg::PSDInfoEnvelope* mutable_psdenvelope();
  inline ::rxdataplane_msg::PSDInfoEnvelope* release_psdenvelope();
  inline void set_allocated_psdenvelope(::rxdataplane_msg::PSDInfoEnvelope* psdenvelope);

  // optional .rxdataplane_msg.EnergyBurstInfoEnvelope energyBurstEnvelope = 6;
  inline bool has_energyburstenvelope() const;
  inline void clear_energyburstenvelope();
  static const int kEnergyBurstEnvelopeFieldNumber = 6;
  inline const ::rxdataplane_msg::EnergyBurstInfoEnvelope& energyburstenvelope() const;
  inline ::rxdataplane_msg::EnergyBurstInfoEnvelope* mutable_energyburstenvelope();
  inline ::rxdataplane_msg::EnergyBurstInfoEnvelope* release_energyburstenvelope();
  inline void set_allocated_energyburstenvelope(::rxdataplane_msg::EnergyBurstInfoEnvelope* energyburstenvelope);

  // optional .rxdataplane_msg.SingleChannelInfoEnvelope singleChannelEnvelope = 7;
  inline bool has_singlechannelenvelope() const;
  inline void clear_singlechannelenvelope();
  static const int kSingleChannelEnvelopeFieldNumber = 7;
  inline const ::rxdataplane_msg::SingleChannelInfoEnvelope& singlechannelenvelope() const;
  inline ::rxdataplane_msg::SingleChannelInfoEnvelope* mutable_singlechannelenvelope();
  inline ::rxdataplane_msg::SingleChannelInfoEnvelope* release_singlechannelenvelope();
  inline void set_allocated_singlechannelenvelope(::rxdataplane_msg::SingleChannelInfoEnvelope* singlechannelenvelope);

  // optional .rxdataplane_msg.PDWInfoEnvelope pdwEnvelope = 8;
  inline bool has_pdwenvelope() const;
  inline void clear_pdwenvelope();
  static const int kPdwEnvelopeFieldNumber = 8;
  inline const ::rxdataplane_msg::PDWInfoEnvelope& pdwenvelope() const;
  inline ::rxdataplane_msg::PDWInfoEnvelope* mutable_pdwenvelope();
  inline ::rxdataplane_msg::PDWInfoEnvelope* release_pdwenvelope();
  inline void set_allocated_pdwenvelope(::rxdataplane_msg::PDWInfoEnvelope* pdwenvelope);

  // @@protoc_insertion_point(class_scope:rxdataplane_msg.DataPlaneInfo)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_iqheader();
  inline void clear_has_iqheader();
  inline void set_has_snapinfo();
  inline void clear_has_snapinfo();
  inline void set_has_spectrogramenvelope();
  inline void clear_has_spectrogramenvelope();
  inline void set_has_psdenvelope();
  inline void clear_has_psdenvelope();
  inline void set_has_energyburstenvelope();
  inline void clear_has_energyburstenvelope();
  inline void set_has_singlechannelenvelope();
  inline void clear_has_singlechannelenvelope();
  inline void set_has_pdwenvelope();
  inline void clear_has_pdwenvelope();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::tuner_msg::IQHeaderInfo* iqheader_;
  ::tuner_msg::SnapInfo* snapinfo_;
  ::rxdataplane_msg::SpectrogramInfoEnvelope* spectrogramenvelope_;
  ::rxdataplane_msg::PSDInfoEnvelope* psdenvelope_;
  ::rxdataplane_msg::EnergyBurstInfoEnvelope* energyburstenvelope_;
  ::rxdataplane_msg::SingleChannelInfoEnvelope* singlechannelenvelope_;
  ::rxdataplane_msg::PDWInfoEnvelope* pdwenvelope_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_RXDataPlaneMessages_2eproto();
  friend void protobuf_AssignDesc_RXDataPlaneMessages_2eproto();
  friend void protobuf_ShutdownFile_RXDataPlaneMessages_2eproto();

  void InitAsDefaultInstance();
  static DataPlaneInfo* default_instance_;
};
// -------------------------------------------------------------------

class SingleChannelInfoEnvelope : public ::google::protobuf::Message {
 public:
  SingleChannelInfoEnvelope();
  virtual ~SingleChannelInfoEnvelope();

  SingleChannelInfoEnvelope(const SingleChannelInfoEnvelope& from);

  inline SingleChannelInfoEnvelope& operator=(const SingleChannelInfoEnvelope& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SingleChannelInfoEnvelope& default_instance();

  void Swap(SingleChannelInfoEnvelope* other);

  // implements Message ----------------------------------------------

  SingleChannelInfoEnvelope* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SingleChannelInfoEnvelope& from);
  void MergeFrom(const SingleChannelInfoEnvelope& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SINGLECHANNELINFOENVELOPE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string snapid = 2;
  inline bool has_snapid() const;
  inline void clear_snapid();
  static const int kSnapidFieldNumber = 2;
  inline const ::std::string& snapid() const;
  inline void set_snapid(const ::std::string& value);
  inline void set_snapid(const char* value);
  inline void set_snapid(const char* value, size_t size);
  inline ::std::string* mutable_snapid();
  inline ::std::string* release_snapid();
  inline void set_allocated_snapid(::std::string* snapid);

  // repeated .rxdataplane_msg.SingleChannelInfo chanInfo = 3;
  inline int chaninfo_size() const;
  inline void clear_chaninfo();
  static const int kChanInfoFieldNumber = 3;
  inline const ::rxdataplane_msg::SingleChannelInfo& chaninfo(int index) const;
  inline ::rxdataplane_msg::SingleChannelInfo* mutable_chaninfo(int index);
  inline ::rxdataplane_msg::SingleChannelInfo* add_chaninfo();
  inline const ::google::protobuf::RepeatedPtrField< ::rxdataplane_msg::SingleChannelInfo >&
      chaninfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::rxdataplane_msg::SingleChannelInfo >*
      mutable_chaninfo();

  // @@protoc_insertion_point(class_scope:rxdataplane_msg.SingleChannelInfoEnvelope)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_snapid();
  inline void clear_has_snapid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* snapid_;
  ::google::protobuf::RepeatedPtrField< ::rxdataplane_msg::SingleChannelInfo > chaninfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_RXDataPlaneMessages_2eproto();
  friend void protobuf_AssignDesc_RXDataPlaneMessages_2eproto();
  friend void protobuf_ShutdownFile_RXDataPlaneMessages_2eproto();

  void InitAsDefaultInstance();
  static SingleChannelInfoEnvelope* default_instance_;
};
// -------------------------------------------------------------------

class SingleChannelInfo : public ::google::protobuf::Message {
 public:
  SingleChannelInfo();
  virtual ~SingleChannelInfo();

  SingleChannelInfo(const SingleChannelInfo& from);

  inline SingleChannelInfo& operator=(const SingleChannelInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SingleChannelInfo& default_instance();

  void Swap(SingleChannelInfo* other);

  // implements Message ----------------------------------------------

  SingleChannelInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SingleChannelInfo& from);
  void MergeFrom(const SingleChannelInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SINGLECHANNELINFO"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional .tuner_msg.IQHeaderInfo IQHeader = 2;
  inline bool has_iqheader() const;
  inline void clear_iqheader();
  static const int kIQHeaderFieldNumber = 2;
  inline const ::tuner_msg::IQHeaderInfo& iqheader() const;
  inline ::tuner_msg::IQHeaderInfo* mutable_iqheader();
  inline ::tuner_msg::IQHeaderInfo* release_iqheader();
  inline void set_allocated_iqheader(::tuner_msg::IQHeaderInfo* iqheader);

  // optional int32 subChannel = 3;
  inline bool has_subchannel() const;
  inline void clear_subchannel();
  static const int kSubChannelFieldNumber = 3;
  inline ::google::protobuf::int32 subchannel() const;
  inline void set_subchannel(::google::protobuf::int32 value);

  // optional int32 aux = 4;
  inline bool has_aux() const;
  inline void clear_aux();
  static const int kAuxFieldNumber = 4;
  inline ::google::protobuf::int32 aux() const;
  inline void set_aux(::google::protobuf::int32 value);

  // optional int32 fileIndex = 5;
  inline bool has_fileindex() const;
  inline void clear_fileindex();
  static const int kFileIndexFieldNumber = 5;
  inline ::google::protobuf::int32 fileindex() const;
  inline void set_fileindex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:rxdataplane_msg.SingleChannelInfo)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_iqheader();
  inline void clear_has_iqheader();
  inline void set_has_subchannel();
  inline void clear_has_subchannel();
  inline void set_has_aux();
  inline void clear_has_aux();
  inline void set_has_fileindex();
  inline void clear_has_fileindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::tuner_msg::IQHeaderInfo* iqheader_;
  ::google::protobuf::int32 subchannel_;
  ::google::protobuf::int32 aux_;
  ::google::protobuf::int32 fileindex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_RXDataPlaneMessages_2eproto();
  friend void protobuf_AssignDesc_RXDataPlaneMessages_2eproto();
  friend void protobuf_ShutdownFile_RXDataPlaneMessages_2eproto();

  void InitAsDefaultInstance();
  static SingleChannelInfo* default_instance_;
};
// -------------------------------------------------------------------

class SpectrogramInfo : public ::google::protobuf::Message {
 public:
  SpectrogramInfo();
  virtual ~SpectrogramInfo();

  SpectrogramInfo(const SpectrogramInfo& from);

  inline SpectrogramInfo& operator=(const SpectrogramInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpectrogramInfo& default_instance();

  void Swap(SpectrogramInfo* other);

  // implements Message ----------------------------------------------

  SpectrogramInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SpectrogramInfo& from);
  void MergeFrom(const SpectrogramInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SPECTROGRAMINFO"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string fileName = 2;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional double freqRF = 3;
  inline bool has_freqrf() const;
  inline void clear_freqrf();
  static const int kFreqRFFieldNumber = 3;
  inline double freqrf() const;
  inline void set_freqrf(double value);

  // optional double startFreq = 4;
  inline bool has_startfreq() const;
  inline void clear_startfreq();
  static const int kStartFreqFieldNumber = 4;
  inline double startfreq() const;
  inline void set_startfreq(double value);

  // optional double stopFreq = 5;
  inline bool has_stopfreq() const;
  inline void clear_stopfreq();
  static const int kStopFreqFieldNumber = 5;
  inline double stopfreq() const;
  inline void set_stopfreq(double value);

  // optional int32 bins = 6;
  inline bool has_bins() const;
  inline void clear_bins();
  static const int kBinsFieldNumber = 6;
  inline ::google::protobuf::int32 bins() const;
  inline void set_bins(::google::protobuf::int32 value);

  // optional double binResolution = 7;
  inline bool has_binresolution() const;
  inline void clear_binresolution();
  static const int kBinResolutionFieldNumber = 7;
  inline double binresolution() const;
  inline void set_binresolution(double value);

  // optional double averages = 8;
  inline bool has_averages() const;
  inline void clear_averages();
  static const int kAveragesFieldNumber = 8;
  inline double averages() const;
  inline void set_averages(double value);

  // optional string spectrogram_time = 9;
  inline bool has_spectrogram_time() const;
  inline void clear_spectrogram_time();
  static const int kSpectrogramTimeFieldNumber = 9;
  inline const ::std::string& spectrogram_time() const;
  inline void set_spectrogram_time(const ::std::string& value);
  inline void set_spectrogram_time(const char* value);
  inline void set_spectrogram_time(const char* value, size_t size);
  inline ::std::string* mutable_spectrogram_time();
  inline ::std::string* release_spectrogram_time();
  inline void set_allocated_spectrogram_time(::std::string* spectrogram_time);

  // @@protoc_insertion_point(class_scope:rxdataplane_msg.SpectrogramInfo)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_freqrf();
  inline void clear_has_freqrf();
  inline void set_has_startfreq();
  inline void clear_has_startfreq();
  inline void set_has_stopfreq();
  inline void clear_has_stopfreq();
  inline void set_has_bins();
  inline void clear_has_bins();
  inline void set_has_binresolution();
  inline void clear_has_binresolution();
  inline void set_has_averages();
  inline void clear_has_averages();
  inline void set_has_spectrogram_time();
  inline void clear_has_spectrogram_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* filename_;
  double freqrf_;
  double startfreq_;
  double stopfreq_;
  double binresolution_;
  double averages_;
  ::std::string* spectrogram_time_;
  ::google::protobuf::int32 bins_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_RXDataPlaneMessages_2eproto();
  friend void protobuf_AssignDesc_RXDataPlaneMessages_2eproto();
  friend void protobuf_ShutdownFile_RXDataPlaneMessages_2eproto();

  void InitAsDefaultInstance();
  static SpectrogramInfo* default_instance_;
};
// -------------------------------------------------------------------

class SpectrogramInfoEnvelope : public ::google::protobuf::Message {
 public:
  SpectrogramInfoEnvelope();
  virtual ~SpectrogramInfoEnvelope();

  SpectrogramInfoEnvelope(const SpectrogramInfoEnvelope& from);

  inline SpectrogramInfoEnvelope& operator=(const SpectrogramInfoEnvelope& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpectrogramInfoEnvelope& default_instance();

  void Swap(SpectrogramInfoEnvelope* other);

  // implements Message ----------------------------------------------

  SpectrogramInfoEnvelope* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SpectrogramInfoEnvelope& from);
  void MergeFrom(const SpectrogramInfoEnvelope& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SPECTROGRAMINFOENVELOPE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string snapid = 2;
  inline bool has_snapid() const;
  inline void clear_snapid();
  static const int kSnapidFieldNumber = 2;
  inline const ::std::string& snapid() const;
  inline void set_snapid(const ::std::string& value);
  inline void set_snapid(const char* value);
  inline void set_snapid(const char* value, size_t size);
  inline ::std::string* mutable_snapid();
  inline ::std::string* release_snapid();
  inline void set_allocated_snapid(::std::string* snapid);

  // repeated .rxdataplane_msg.SpectrogramInfo spectrogramInfo = 3;
  inline int spectrograminfo_size() const;
  inline void clear_spectrograminfo();
  static const int kSpectrogramInfoFieldNumber = 3;
  inline const ::rxdataplane_msg::SpectrogramInfo& spectrograminfo(int index) const;
  inline ::rxdataplane_msg::SpectrogramInfo* mutable_spectrograminfo(int index);
  inline ::rxdataplane_msg::SpectrogramInfo* add_spectrograminfo();
  inline const ::google::protobuf::RepeatedPtrField< ::rxdataplane_msg::SpectrogramInfo >&
      spectrograminfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::rxdataplane_msg::SpectrogramInfo >*
      mutable_spectrograminfo();

  // @@protoc_insertion_point(class_scope:rxdataplane_msg.SpectrogramInfoEnvelope)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_snapid();
  inline void clear_has_snapid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* snapid_;
  ::google::protobuf::RepeatedPtrField< ::rxdataplane_msg::SpectrogramInfo > spectrograminfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_RXDataPlaneMessages_2eproto();
  friend void protobuf_AssignDesc_RXDataPlaneMessages_2eproto();
  friend void protobuf_ShutdownFile_RXDataPlaneMessages_2eproto();

  void InitAsDefaultInstance();
  static SpectrogramInfoEnvelope* default_instance_;
};
// -------------------------------------------------------------------

class PSDInfo : public ::google::protobuf::Message {
 public:
  PSDInfo();
  virtual ~PSDInfo();

  PSDInfo(const PSDInfo& from);

  inline PSDInfo& operator=(const PSDInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PSDInfo& default_instance();

  void Swap(PSDInfo* other);

  // implements Message ----------------------------------------------

  PSDInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PSDInfo& from);
  void MergeFrom(const PSDInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "PSDINFO"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string fileName = 2;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional double freqRF = 3;
  inline bool has_freqrf() const;
  inline void clear_freqrf();
  static const int kFreqRFFieldNumber = 3;
  inline double freqrf() const;
  inline void set_freqrf(double value);

  // optional double startFreq = 4;
  inline bool has_startfreq() const;
  inline void clear_startfreq();
  static const int kStartFreqFieldNumber = 4;
  inline double startfreq() const;
  inline void set_startfreq(double value);

  // optional double stopFreq = 5;
  inline bool has_stopfreq() const;
  inline void clear_stopfreq();
  static const int kStopFreqFieldNumber = 5;
  inline double stopfreq() const;
  inline void set_stopfreq(double value);

  // optional double binResolution = 6;
  inline bool has_binresolution() const;
  inline void clear_binresolution();
  static const int kBinResolutionFieldNumber = 6;
  inline double binresolution() const;
  inline void set_binresolution(double value);

  // optional string psd_time = 7;
  inline bool has_psd_time() const;
  inline void clear_psd_time();
  static const int kPsdTimeFieldNumber = 7;
  inline const ::std::string& psd_time() const;
  inline void set_psd_time(const ::std::string& value);
  inline void set_psd_time(const char* value);
  inline void set_psd_time(const char* value, size_t size);
  inline ::std::string* mutable_psd_time();
  inline ::std::string* release_psd_time();
  inline void set_allocated_psd_time(::std::string* psd_time);

  // @@protoc_insertion_point(class_scope:rxdataplane_msg.PSDInfo)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_freqrf();
  inline void clear_has_freqrf();
  inline void set_has_startfreq();
  inline void clear_has_startfreq();
  inline void set_has_stopfreq();
  inline void clear_has_stopfreq();
  inline void set_has_binresolution();
  inline void clear_has_binresolution();
  inline void set_has_psd_time();
  inline void clear_has_psd_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* filename_;
  double freqrf_;
  double startfreq_;
  double stopfreq_;
  double binresolution_;
  ::std::string* psd_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_RXDataPlaneMessages_2eproto();
  friend void protobuf_AssignDesc_RXDataPlaneMessages_2eproto();
  friend void protobuf_ShutdownFile_RXDataPlaneMessages_2eproto();

  void InitAsDefaultInstance();
  static PSDInfo* default_instance_;
};
// -------------------------------------------------------------------

class PSDInfoEnvelope : public ::google::protobuf::Message {
 public:
  PSDInfoEnvelope();
  virtual ~PSDInfoEnvelope();

  PSDInfoEnvelope(const PSDInfoEnvelope& from);

  inline PSDInfoEnvelope& operator=(const PSDInfoEnvelope& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PSDInfoEnvelope& default_instance();

  void Swap(PSDInfoEnvelope* other);

  // implements Message ----------------------------------------------

  PSDInfoEnvelope* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PSDInfoEnvelope& from);
  void MergeFrom(const PSDInfoEnvelope& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "PSDINFOENVELOPE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string snapid = 2;
  inline bool has_snapid() const;
  inline void clear_snapid();
  static const int kSnapidFieldNumber = 2;
  inline const ::std::string& snapid() const;
  inline void set_snapid(const ::std::string& value);
  inline void set_snapid(const char* value);
  inline void set_snapid(const char* value, size_t size);
  inline ::std::string* mutable_snapid();
  inline ::std::string* release_snapid();
  inline void set_allocated_snapid(::std::string* snapid);

  // repeated .rxdataplane_msg.PSDInfo psdInfo = 3;
  inline int psdinfo_size() const;
  inline void clear_psdinfo();
  static const int kPsdInfoFieldNumber = 3;
  inline const ::rxdataplane_msg::PSDInfo& psdinfo(int index) const;
  inline ::rxdataplane_msg::PSDInfo* mutable_psdinfo(int index);
  inline ::rxdataplane_msg::PSDInfo* add_psdinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::rxdataplane_msg::PSDInfo >&
      psdinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::rxdataplane_msg::PSDInfo >*
      mutable_psdinfo();

  // @@protoc_insertion_point(class_scope:rxdataplane_msg.PSDInfoEnvelope)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_snapid();
  inline void clear_has_snapid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* snapid_;
  ::google::protobuf::RepeatedPtrField< ::rxdataplane_msg::PSDInfo > psdinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_RXDataPlaneMessages_2eproto();
  friend void protobuf_AssignDesc_RXDataPlaneMessages_2eproto();
  friend void protobuf_ShutdownFile_RXDataPlaneMessages_2eproto();

  void InitAsDefaultInstance();
  static PSDInfoEnvelope* default_instance_;
};
// -------------------------------------------------------------------

class EnergyBurstInfo : public ::google::protobuf::Message {
 public:
  EnergyBurstInfo();
  virtual ~EnergyBurstInfo();

  EnergyBurstInfo(const EnergyBurstInfo& from);

  inline EnergyBurstInfo& operator=(const EnergyBurstInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnergyBurstInfo& default_instance();

  void Swap(EnergyBurstInfo* other);

  // implements Message ----------------------------------------------

  EnergyBurstInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnergyBurstInfo& from);
  void MergeFrom(const EnergyBurstInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ENERGYBURSTINFO"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional double whole_sec = 2;
  inline bool has_whole_sec() const;
  inline void clear_whole_sec();
  static const int kWholeSecFieldNumber = 2;
  inline double whole_sec() const;
  inline void set_whole_sec(double value);

  // optional double frac_sec = 3;
  inline bool has_frac_sec() const;
  inline void clear_frac_sec();
  static const int kFracSecFieldNumber = 3;
  inline double frac_sec() const;
  inline void set_frac_sec(double value);

  // optional double duration = 4;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 4;
  inline double duration() const;
  inline void set_duration(double value);

  // optional double freqRF = 5;
  inline bool has_freqrf() const;
  inline void clear_freqrf();
  static const int kFreqRFFieldNumber = 5;
  inline double freqrf() const;
  inline void set_freqrf(double value);

  // optional double bandwidth = 6;
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandwidthFieldNumber = 6;
  inline double bandwidth() const;
  inline void set_bandwidth(double value);

  // optional double snr = 7;
  inline bool has_snr() const;
  inline void clear_snr();
  static const int kSnrFieldNumber = 7;
  inline double snr() const;
  inline void set_snr(double value);

  // @@protoc_insertion_point(class_scope:rxdataplane_msg.EnergyBurstInfo)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_whole_sec();
  inline void clear_has_whole_sec();
  inline void set_has_frac_sec();
  inline void clear_has_frac_sec();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_freqrf();
  inline void clear_has_freqrf();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();
  inline void set_has_snr();
  inline void clear_has_snr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  double whole_sec_;
  double frac_sec_;
  double duration_;
  double freqrf_;
  double bandwidth_;
  double snr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_RXDataPlaneMessages_2eproto();
  friend void protobuf_AssignDesc_RXDataPlaneMessages_2eproto();
  friend void protobuf_ShutdownFile_RXDataPlaneMessages_2eproto();

  void InitAsDefaultInstance();
  static EnergyBurstInfo* default_instance_;
};
// -------------------------------------------------------------------

class EnergyBurstInfoEnvelope : public ::google::protobuf::Message {
 public:
  EnergyBurstInfoEnvelope();
  virtual ~EnergyBurstInfoEnvelope();

  EnergyBurstInfoEnvelope(const EnergyBurstInfoEnvelope& from);

  inline EnergyBurstInfoEnvelope& operator=(const EnergyBurstInfoEnvelope& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnergyBurstInfoEnvelope& default_instance();

  void Swap(EnergyBurstInfoEnvelope* other);

  // implements Message ----------------------------------------------

  EnergyBurstInfoEnvelope* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnergyBurstInfoEnvelope& from);
  void MergeFrom(const EnergyBurstInfoEnvelope& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ENERGYBURSTINFOENVELOPE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string snapid = 2;
  inline bool has_snapid() const;
  inline void clear_snapid();
  static const int kSnapidFieldNumber = 2;
  inline const ::std::string& snapid() const;
  inline void set_snapid(const ::std::string& value);
  inline void set_snapid(const char* value);
  inline void set_snapid(const char* value, size_t size);
  inline ::std::string* mutable_snapid();
  inline ::std::string* release_snapid();
  inline void set_allocated_snapid(::std::string* snapid);

  // repeated .rxdataplane_msg.EnergyBurstInfo energyBursts = 3;
  inline int energybursts_size() const;
  inline void clear_energybursts();
  static const int kEnergyBurstsFieldNumber = 3;
  inline const ::rxdataplane_msg::EnergyBurstInfo& energybursts(int index) const;
  inline ::rxdataplane_msg::EnergyBurstInfo* mutable_energybursts(int index);
  inline ::rxdataplane_msg::EnergyBurstInfo* add_energybursts();
  inline const ::google::protobuf::RepeatedPtrField< ::rxdataplane_msg::EnergyBurstInfo >&
      energybursts() const;
  inline ::google::protobuf::RepeatedPtrField< ::rxdataplane_msg::EnergyBurstInfo >*
      mutable_energybursts();

  // optional double timeResSec = 4;
  inline bool has_timeressec() const;
  inline void clear_timeressec();
  static const int kTimeResSecFieldNumber = 4;
  inline double timeressec() const;
  inline void set_timeressec(double value);

  // optional double freqResHz = 5;
  inline bool has_freqreshz() const;
  inline void clear_freqreshz();
  static const int kFreqResHzFieldNumber = 5;
  inline double freqreshz() const;
  inline void set_freqreshz(double value);

  // optional string segmenterName = 6;
  inline bool has_segmentername() const;
  inline void clear_segmentername();
  static const int kSegmenterNameFieldNumber = 6;
  inline const ::std::string& segmentername() const;
  inline void set_segmentername(const ::std::string& value);
  inline void set_segmentername(const char* value);
  inline void set_segmentername(const char* value, size_t size);
  inline ::std::string* mutable_segmentername();
  inline ::std::string* release_segmentername();
  inline void set_allocated_segmentername(::std::string* segmentername);

  // optional string metaFilename = 7 [default = "NONE"];
  inline bool has_metafilename() const;
  inline void clear_metafilename();
  static const int kMetaFilenameFieldNumber = 7;
  inline const ::std::string& metafilename() const;
  inline void set_metafilename(const ::std::string& value);
  inline void set_metafilename(const char* value);
  inline void set_metafilename(const char* value, size_t size);
  inline ::std::string* mutable_metafilename();
  inline ::std::string* release_metafilename();
  inline void set_allocated_metafilename(::std::string* metafilename);

  // optional string iqIndexFilename = 8 [default = "NONE"];
  inline bool has_iqindexfilename() const;
  inline void clear_iqindexfilename();
  static const int kIqIndexFilenameFieldNumber = 8;
  inline const ::std::string& iqindexfilename() const;
  inline void set_iqindexfilename(const ::std::string& value);
  inline void set_iqindexfilename(const char* value);
  inline void set_iqindexfilename(const char* value, size_t size);
  inline ::std::string* mutable_iqindexfilename();
  inline ::std::string* release_iqindexfilename();
  inline void set_allocated_iqindexfilename(::std::string* iqindexfilename);

  // @@protoc_insertion_point(class_scope:rxdataplane_msg.EnergyBurstInfoEnvelope)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_snapid();
  inline void clear_has_snapid();
  inline void set_has_timeressec();
  inline void clear_has_timeressec();
  inline void set_has_freqreshz();
  inline void clear_has_freqreshz();
  inline void set_has_segmentername();
  inline void clear_has_segmentername();
  inline void set_has_metafilename();
  inline void clear_has_metafilename();
  inline void set_has_iqindexfilename();
  inline void clear_has_iqindexfilename();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* snapid_;
  ::google::protobuf::RepeatedPtrField< ::rxdataplane_msg::EnergyBurstInfo > energybursts_;
  double timeressec_;
  double freqreshz_;
  ::std::string* segmentername_;
  ::std::string* metafilename_;
  static ::std::string* _default_metafilename_;
  ::std::string* iqindexfilename_;
  static ::std::string* _default_iqindexfilename_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_RXDataPlaneMessages_2eproto();
  friend void protobuf_AssignDesc_RXDataPlaneMessages_2eproto();
  friend void protobuf_ShutdownFile_RXDataPlaneMessages_2eproto();

  void InitAsDefaultInstance();
  static EnergyBurstInfoEnvelope* default_instance_;
};
// -------------------------------------------------------------------

class PDWInfo : public ::google::protobuf::Message {
 public:
  PDWInfo();
  virtual ~PDWInfo();

  PDWInfo(const PDWInfo& from);

  inline PDWInfo& operator=(const PDWInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PDWInfo& default_instance();

  void Swap(PDWInfo* other);

  // implements Message ----------------------------------------------

  PDWInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PDWInfo& from);
  void MergeFrom(const PDWInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "PDWINFO"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional uint64 toaWholeSec = 2;
  inline bool has_toawholesec() const;
  inline void clear_toawholesec();
  static const int kToaWholeSecFieldNumber = 2;
  inline ::google::protobuf::uint64 toawholesec() const;
  inline void set_toawholesec(::google::protobuf::uint64 value);

  // optional double toaFracSec = 3;
  inline bool has_toafracsec() const;
  inline void clear_toafracsec();
  static const int kToaFracSecFieldNumber = 3;
  inline double toafracsec() const;
  inline void set_toafracsec(double value);

  // optional double pulseDur = 4;
  inline bool has_pulsedur() const;
  inline void clear_pulsedur();
  static const int kPulseDurFieldNumber = 4;
  inline double pulsedur() const;
  inline void set_pulsedur(double value);

  // optional double gap = 5;
  inline bool has_gap() const;
  inline void clear_gap();
  static const int kGapFieldNumber = 5;
  inline double gap() const;
  inline void set_gap(double value);

  // optional double freqRF = 6;
  inline bool has_freqrf() const;
  inline void clear_freqrf();
  static const int kFreqRFFieldNumber = 6;
  inline double freqrf() const;
  inline void set_freqrf(double value);

  // optional double bandwidth = 7;
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandwidthFieldNumber = 7;
  inline double bandwidth() const;
  inline void set_bandwidth(double value);

  // optional double freqSlope = 8;
  inline bool has_freqslope() const;
  inline void clear_freqslope();
  static const int kFreqSlopeFieldNumber = 8;
  inline double freqslope() const;
  inline void set_freqslope(double value);

  // optional double snr = 9;
  inline bool has_snr() const;
  inline void clear_snr();
  static const int kSnrFieldNumber = 9;
  inline double snr() const;
  inline void set_snr(double value);

  // optional double az = 10;
  inline bool has_az() const;
  inline void clear_az();
  static const int kAzFieldNumber = 10;
  inline double az() const;
  inline void set_az(double value);

  // optional double el = 11;
  inline bool has_el() const;
  inline void clear_el();
  static const int kElFieldNumber = 11;
  inline double el() const;
  inline void set_el(double value);

  // optional double dfQ = 12;
  inline bool has_dfq() const;
  inline void clear_dfq();
  static const int kDfQFieldNumber = 12;
  inline double dfq() const;
  inline void set_dfq(double value);

  // optional double polAR = 13;
  inline bool has_polar() const;
  inline void clear_polar();
  static const int kPolARFieldNumber = 13;
  inline double polar() const;
  inline void set_polar(double value);

  // optional double polTilt = 14;
  inline bool has_poltilt() const;
  inline void clear_poltilt();
  static const int kPolTiltFieldNumber = 14;
  inline double poltilt() const;
  inline void set_poltilt(double value);

  // optional .rxdataplane_msg.ModulationType modType = 15 [default = NONE];
  inline bool has_modtype() const;
  inline void clear_modtype();
  static const int kModTypeFieldNumber = 15;
  inline ::rxdataplane_msg::ModulationType modtype() const;
  inline void set_modtype(::rxdataplane_msg::ModulationType value);

  // @@protoc_insertion_point(class_scope:rxdataplane_msg.PDWInfo)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_toawholesec();
  inline void clear_has_toawholesec();
  inline void set_has_toafracsec();
  inline void clear_has_toafracsec();
  inline void set_has_pulsedur();
  inline void clear_has_pulsedur();
  inline void set_has_gap();
  inline void clear_has_gap();
  inline void set_has_freqrf();
  inline void clear_has_freqrf();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();
  inline void set_has_freqslope();
  inline void clear_has_freqslope();
  inline void set_has_snr();
  inline void clear_has_snr();
  inline void set_has_az();
  inline void clear_has_az();
  inline void set_has_el();
  inline void clear_has_el();
  inline void set_has_dfq();
  inline void clear_has_dfq();
  inline void set_has_polar();
  inline void clear_has_polar();
  inline void set_has_poltilt();
  inline void clear_has_poltilt();
  inline void set_has_modtype();
  inline void clear_has_modtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::uint64 toawholesec_;
  double toafracsec_;
  double pulsedur_;
  double gap_;
  double freqrf_;
  double bandwidth_;
  double freqslope_;
  double snr_;
  double az_;
  double el_;
  double dfq_;
  double polar_;
  double poltilt_;
  int modtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_RXDataPlaneMessages_2eproto();
  friend void protobuf_AssignDesc_RXDataPlaneMessages_2eproto();
  friend void protobuf_ShutdownFile_RXDataPlaneMessages_2eproto();

  void InitAsDefaultInstance();
  static PDWInfo* default_instance_;
};
// -------------------------------------------------------------------

class PDWInfoEnvelope : public ::google::protobuf::Message {
 public:
  PDWInfoEnvelope();
  virtual ~PDWInfoEnvelope();

  PDWInfoEnvelope(const PDWInfoEnvelope& from);

  inline PDWInfoEnvelope& operator=(const PDWInfoEnvelope& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PDWInfoEnvelope& default_instance();

  void Swap(PDWInfoEnvelope* other);

  // implements Message ----------------------------------------------

  PDWInfoEnvelope* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PDWInfoEnvelope& from);
  void MergeFrom(const PDWInfoEnvelope& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "PDWINFOENVELOPE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string snapid = 2;
  inline bool has_snapid() const;
  inline void clear_snapid();
  static const int kSnapidFieldNumber = 2;
  inline const ::std::string& snapid() const;
  inline void set_snapid(const ::std::string& value);
  inline void set_snapid(const char* value);
  inline void set_snapid(const char* value, size_t size);
  inline ::std::string* mutable_snapid();
  inline ::std::string* release_snapid();
  inline void set_allocated_snapid(::std::string* snapid);

  // repeated .rxdataplane_msg.PDWInfo pdws = 3;
  inline int pdws_size() const;
  inline void clear_pdws();
  static const int kPdwsFieldNumber = 3;
  inline const ::rxdataplane_msg::PDWInfo& pdws(int index) const;
  inline ::rxdataplane_msg::PDWInfo* mutable_pdws(int index);
  inline ::rxdataplane_msg::PDWInfo* add_pdws();
  inline const ::google::protobuf::RepeatedPtrField< ::rxdataplane_msg::PDWInfo >&
      pdws() const;
  inline ::google::protobuf::RepeatedPtrField< ::rxdataplane_msg::PDWInfo >*
      mutable_pdws();

  // optional string segmenterName = 4 [default = "RADAR"];
  inline bool has_segmentername() const;
  inline void clear_segmentername();
  static const int kSegmenterNameFieldNumber = 4;
  inline const ::std::string& segmentername() const;
  inline void set_segmentername(const ::std::string& value);
  inline void set_segmentername(const char* value);
  inline void set_segmentername(const char* value, size_t size);
  inline ::std::string* mutable_segmentername();
  inline ::std::string* release_segmentername();
  inline void set_allocated_segmentername(::std::string* segmentername);

  // optional string metaFilename = 5 [default = "NONE"];
  inline bool has_metafilename() const;
  inline void clear_metafilename();
  static const int kMetaFilenameFieldNumber = 5;
  inline const ::std::string& metafilename() const;
  inline void set_metafilename(const ::std::string& value);
  inline void set_metafilename(const char* value);
  inline void set_metafilename(const char* value, size_t size);
  inline ::std::string* mutable_metafilename();
  inline ::std::string* release_metafilename();
  inline void set_allocated_metafilename(::std::string* metafilename);

  // optional string iqIndexFilename = 6 [default = "NONE"];
  inline bool has_iqindexfilename() const;
  inline void clear_iqindexfilename();
  static const int kIqIndexFilenameFieldNumber = 6;
  inline const ::std::string& iqindexfilename() const;
  inline void set_iqindexfilename(const ::std::string& value);
  inline void set_iqindexfilename(const char* value);
  inline void set_iqindexfilename(const char* value, size_t size);
  inline ::std::string* mutable_iqindexfilename();
  inline ::std::string* release_iqindexfilename();
  inline void set_allocated_iqindexfilename(::std::string* iqindexfilename);

  // @@protoc_insertion_point(class_scope:rxdataplane_msg.PDWInfoEnvelope)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_snapid();
  inline void clear_has_snapid();
  inline void set_has_segmentername();
  inline void clear_has_segmentername();
  inline void set_has_metafilename();
  inline void clear_has_metafilename();
  inline void set_has_iqindexfilename();
  inline void clear_has_iqindexfilename();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* snapid_;
  ::google::protobuf::RepeatedPtrField< ::rxdataplane_msg::PDWInfo > pdws_;
  ::std::string* segmentername_;
  static ::std::string* _default_segmentername_;
  ::std::string* metafilename_;
  static ::std::string* _default_metafilename_;
  ::std::string* iqindexfilename_;
  static ::std::string* _default_iqindexfilename_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_RXDataPlaneMessages_2eproto();
  friend void protobuf_AssignDesc_RXDataPlaneMessages_2eproto();
  friend void protobuf_ShutdownFile_RXDataPlaneMessages_2eproto();

  void InitAsDefaultInstance();
  static PDWInfoEnvelope* default_instance_;
};
// ===================================================================


// ===================================================================

// DataPlaneInfo

// optional string msgName = 1 [default = "DATAPLANEINFO"];
inline bool DataPlaneInfo::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataPlaneInfo::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataPlaneInfo::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataPlaneInfo::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& DataPlaneInfo::msgname() const {
  return *msgname_;
}
inline void DataPlaneInfo::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void DataPlaneInfo::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void DataPlaneInfo::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataPlaneInfo::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* DataPlaneInfo::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void DataPlaneInfo::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional .tuner_msg.IQHeaderInfo IQHeader = 2;
inline bool DataPlaneInfo::has_iqheader() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataPlaneInfo::set_has_iqheader() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataPlaneInfo::clear_has_iqheader() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataPlaneInfo::clear_iqheader() {
  if (iqheader_ != NULL) iqheader_->::tuner_msg::IQHeaderInfo::Clear();
  clear_has_iqheader();
}
inline const ::tuner_msg::IQHeaderInfo& DataPlaneInfo::iqheader() const {
  return iqheader_ != NULL ? *iqheader_ : *default_instance_->iqheader_;
}
inline ::tuner_msg::IQHeaderInfo* DataPlaneInfo::mutable_iqheader() {
  set_has_iqheader();
  if (iqheader_ == NULL) iqheader_ = new ::tuner_msg::IQHeaderInfo;
  return iqheader_;
}
inline ::tuner_msg::IQHeaderInfo* DataPlaneInfo::release_iqheader() {
  clear_has_iqheader();
  ::tuner_msg::IQHeaderInfo* temp = iqheader_;
  iqheader_ = NULL;
  return temp;
}
inline void DataPlaneInfo::set_allocated_iqheader(::tuner_msg::IQHeaderInfo* iqheader) {
  delete iqheader_;
  iqheader_ = iqheader;
  if (iqheader) {
    set_has_iqheader();
  } else {
    clear_has_iqheader();
  }
}

// optional .tuner_msg.SnapInfo snapInfo = 3;
inline bool DataPlaneInfo::has_snapinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataPlaneInfo::set_has_snapinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataPlaneInfo::clear_has_snapinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataPlaneInfo::clear_snapinfo() {
  if (snapinfo_ != NULL) snapinfo_->::tuner_msg::SnapInfo::Clear();
  clear_has_snapinfo();
}
inline const ::tuner_msg::SnapInfo& DataPlaneInfo::snapinfo() const {
  return snapinfo_ != NULL ? *snapinfo_ : *default_instance_->snapinfo_;
}
inline ::tuner_msg::SnapInfo* DataPlaneInfo::mutable_snapinfo() {
  set_has_snapinfo();
  if (snapinfo_ == NULL) snapinfo_ = new ::tuner_msg::SnapInfo;
  return snapinfo_;
}
inline ::tuner_msg::SnapInfo* DataPlaneInfo::release_snapinfo() {
  clear_has_snapinfo();
  ::tuner_msg::SnapInfo* temp = snapinfo_;
  snapinfo_ = NULL;
  return temp;
}
inline void DataPlaneInfo::set_allocated_snapinfo(::tuner_msg::SnapInfo* snapinfo) {
  delete snapinfo_;
  snapinfo_ = snapinfo;
  if (snapinfo) {
    set_has_snapinfo();
  } else {
    clear_has_snapinfo();
  }
}

// optional .rxdataplane_msg.SpectrogramInfoEnvelope spectrogramEnvelope = 4;
inline bool DataPlaneInfo::has_spectrogramenvelope() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataPlaneInfo::set_has_spectrogramenvelope() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataPlaneInfo::clear_has_spectrogramenvelope() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataPlaneInfo::clear_spectrogramenvelope() {
  if (spectrogramenvelope_ != NULL) spectrogramenvelope_->::rxdataplane_msg::SpectrogramInfoEnvelope::Clear();
  clear_has_spectrogramenvelope();
}
inline const ::rxdataplane_msg::SpectrogramInfoEnvelope& DataPlaneInfo::spectrogramenvelope() const {
  return spectrogramenvelope_ != NULL ? *spectrogramenvelope_ : *default_instance_->spectrogramenvelope_;
}
inline ::rxdataplane_msg::SpectrogramInfoEnvelope* DataPlaneInfo::mutable_spectrogramenvelope() {
  set_has_spectrogramenvelope();
  if (spectrogramenvelope_ == NULL) spectrogramenvelope_ = new ::rxdataplane_msg::SpectrogramInfoEnvelope;
  return spectrogramenvelope_;
}
inline ::rxdataplane_msg::SpectrogramInfoEnvelope* DataPlaneInfo::release_spectrogramenvelope() {
  clear_has_spectrogramenvelope();
  ::rxdataplane_msg::SpectrogramInfoEnvelope* temp = spectrogramenvelope_;
  spectrogramenvelope_ = NULL;
  return temp;
}
inline void DataPlaneInfo::set_allocated_spectrogramenvelope(::rxdataplane_msg::SpectrogramInfoEnvelope* spectrogramenvelope) {
  delete spectrogramenvelope_;
  spectrogramenvelope_ = spectrogramenvelope;
  if (spectrogramenvelope) {
    set_has_spectrogramenvelope();
  } else {
    clear_has_spectrogramenvelope();
  }
}

// optional .rxdataplane_msg.PSDInfoEnvelope PSDEnvelope = 5;
inline bool DataPlaneInfo::has_psdenvelope() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataPlaneInfo::set_has_psdenvelope() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataPlaneInfo::clear_has_psdenvelope() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataPlaneInfo::clear_psdenvelope() {
  if (psdenvelope_ != NULL) psdenvelope_->::rxdataplane_msg::PSDInfoEnvelope::Clear();
  clear_has_psdenvelope();
}
inline const ::rxdataplane_msg::PSDInfoEnvelope& DataPlaneInfo::psdenvelope() const {
  return psdenvelope_ != NULL ? *psdenvelope_ : *default_instance_->psdenvelope_;
}
inline ::rxdataplane_msg::PSDInfoEnvelope* DataPlaneInfo::mutable_psdenvelope() {
  set_has_psdenvelope();
  if (psdenvelope_ == NULL) psdenvelope_ = new ::rxdataplane_msg::PSDInfoEnvelope;
  return psdenvelope_;
}
inline ::rxdataplane_msg::PSDInfoEnvelope* DataPlaneInfo::release_psdenvelope() {
  clear_has_psdenvelope();
  ::rxdataplane_msg::PSDInfoEnvelope* temp = psdenvelope_;
  psdenvelope_ = NULL;
  return temp;
}
inline void DataPlaneInfo::set_allocated_psdenvelope(::rxdataplane_msg::PSDInfoEnvelope* psdenvelope) {
  delete psdenvelope_;
  psdenvelope_ = psdenvelope;
  if (psdenvelope) {
    set_has_psdenvelope();
  } else {
    clear_has_psdenvelope();
  }
}

// optional .rxdataplane_msg.EnergyBurstInfoEnvelope energyBurstEnvelope = 6;
inline bool DataPlaneInfo::has_energyburstenvelope() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DataPlaneInfo::set_has_energyburstenvelope() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DataPlaneInfo::clear_has_energyburstenvelope() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DataPlaneInfo::clear_energyburstenvelope() {
  if (energyburstenvelope_ != NULL) energyburstenvelope_->::rxdataplane_msg::EnergyBurstInfoEnvelope::Clear();
  clear_has_energyburstenvelope();
}
inline const ::rxdataplane_msg::EnergyBurstInfoEnvelope& DataPlaneInfo::energyburstenvelope() const {
  return energyburstenvelope_ != NULL ? *energyburstenvelope_ : *default_instance_->energyburstenvelope_;
}
inline ::rxdataplane_msg::EnergyBurstInfoEnvelope* DataPlaneInfo::mutable_energyburstenvelope() {
  set_has_energyburstenvelope();
  if (energyburstenvelope_ == NULL) energyburstenvelope_ = new ::rxdataplane_msg::EnergyBurstInfoEnvelope;
  return energyburstenvelope_;
}
inline ::rxdataplane_msg::EnergyBurstInfoEnvelope* DataPlaneInfo::release_energyburstenvelope() {
  clear_has_energyburstenvelope();
  ::rxdataplane_msg::EnergyBurstInfoEnvelope* temp = energyburstenvelope_;
  energyburstenvelope_ = NULL;
  return temp;
}
inline void DataPlaneInfo::set_allocated_energyburstenvelope(::rxdataplane_msg::EnergyBurstInfoEnvelope* energyburstenvelope) {
  delete energyburstenvelope_;
  energyburstenvelope_ = energyburstenvelope;
  if (energyburstenvelope) {
    set_has_energyburstenvelope();
  } else {
    clear_has_energyburstenvelope();
  }
}

// optional .rxdataplane_msg.SingleChannelInfoEnvelope singleChannelEnvelope = 7;
inline bool DataPlaneInfo::has_singlechannelenvelope() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DataPlaneInfo::set_has_singlechannelenvelope() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DataPlaneInfo::clear_has_singlechannelenvelope() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DataPlaneInfo::clear_singlechannelenvelope() {
  if (singlechannelenvelope_ != NULL) singlechannelenvelope_->::rxdataplane_msg::SingleChannelInfoEnvelope::Clear();
  clear_has_singlechannelenvelope();
}
inline const ::rxdataplane_msg::SingleChannelInfoEnvelope& DataPlaneInfo::singlechannelenvelope() const {
  return singlechannelenvelope_ != NULL ? *singlechannelenvelope_ : *default_instance_->singlechannelenvelope_;
}
inline ::rxdataplane_msg::SingleChannelInfoEnvelope* DataPlaneInfo::mutable_singlechannelenvelope() {
  set_has_singlechannelenvelope();
  if (singlechannelenvelope_ == NULL) singlechannelenvelope_ = new ::rxdataplane_msg::SingleChannelInfoEnvelope;
  return singlechannelenvelope_;
}
inline ::rxdataplane_msg::SingleChannelInfoEnvelope* DataPlaneInfo::release_singlechannelenvelope() {
  clear_has_singlechannelenvelope();
  ::rxdataplane_msg::SingleChannelInfoEnvelope* temp = singlechannelenvelope_;
  singlechannelenvelope_ = NULL;
  return temp;
}
inline void DataPlaneInfo::set_allocated_singlechannelenvelope(::rxdataplane_msg::SingleChannelInfoEnvelope* singlechannelenvelope) {
  delete singlechannelenvelope_;
  singlechannelenvelope_ = singlechannelenvelope;
  if (singlechannelenvelope) {
    set_has_singlechannelenvelope();
  } else {
    clear_has_singlechannelenvelope();
  }
}

// optional .rxdataplane_msg.PDWInfoEnvelope pdwEnvelope = 8;
inline bool DataPlaneInfo::has_pdwenvelope() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DataPlaneInfo::set_has_pdwenvelope() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DataPlaneInfo::clear_has_pdwenvelope() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DataPlaneInfo::clear_pdwenvelope() {
  if (pdwenvelope_ != NULL) pdwenvelope_->::rxdataplane_msg::PDWInfoEnvelope::Clear();
  clear_has_pdwenvelope();
}
inline const ::rxdataplane_msg::PDWInfoEnvelope& DataPlaneInfo::pdwenvelope() const {
  return pdwenvelope_ != NULL ? *pdwenvelope_ : *default_instance_->pdwenvelope_;
}
inline ::rxdataplane_msg::PDWInfoEnvelope* DataPlaneInfo::mutable_pdwenvelope() {
  set_has_pdwenvelope();
  if (pdwenvelope_ == NULL) pdwenvelope_ = new ::rxdataplane_msg::PDWInfoEnvelope;
  return pdwenvelope_;
}
inline ::rxdataplane_msg::PDWInfoEnvelope* DataPlaneInfo::release_pdwenvelope() {
  clear_has_pdwenvelope();
  ::rxdataplane_msg::PDWInfoEnvelope* temp = pdwenvelope_;
  pdwenvelope_ = NULL;
  return temp;
}
inline void DataPlaneInfo::set_allocated_pdwenvelope(::rxdataplane_msg::PDWInfoEnvelope* pdwenvelope) {
  delete pdwenvelope_;
  pdwenvelope_ = pdwenvelope;
  if (pdwenvelope) {
    set_has_pdwenvelope();
  } else {
    clear_has_pdwenvelope();
  }
}

// -------------------------------------------------------------------

// SingleChannelInfoEnvelope

// optional string msgName = 1 [default = "SINGLECHANNELINFOENVELOPE"];
inline bool SingleChannelInfoEnvelope::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SingleChannelInfoEnvelope::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SingleChannelInfoEnvelope::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SingleChannelInfoEnvelope::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SingleChannelInfoEnvelope::msgname() const {
  return *msgname_;
}
inline void SingleChannelInfoEnvelope::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SingleChannelInfoEnvelope::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SingleChannelInfoEnvelope::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SingleChannelInfoEnvelope::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SingleChannelInfoEnvelope::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SingleChannelInfoEnvelope::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string snapid = 2;
inline bool SingleChannelInfoEnvelope::has_snapid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SingleChannelInfoEnvelope::set_has_snapid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SingleChannelInfoEnvelope::clear_has_snapid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SingleChannelInfoEnvelope::clear_snapid() {
  if (snapid_ != &::google::protobuf::internal::kEmptyString) {
    snapid_->clear();
  }
  clear_has_snapid();
}
inline const ::std::string& SingleChannelInfoEnvelope::snapid() const {
  return *snapid_;
}
inline void SingleChannelInfoEnvelope::set_snapid(const ::std::string& value) {
  set_has_snapid();
  if (snapid_ == &::google::protobuf::internal::kEmptyString) {
    snapid_ = new ::std::string;
  }
  snapid_->assign(value);
}
inline void SingleChannelInfoEnvelope::set_snapid(const char* value) {
  set_has_snapid();
  if (snapid_ == &::google::protobuf::internal::kEmptyString) {
    snapid_ = new ::std::string;
  }
  snapid_->assign(value);
}
inline void SingleChannelInfoEnvelope::set_snapid(const char* value, size_t size) {
  set_has_snapid();
  if (snapid_ == &::google::protobuf::internal::kEmptyString) {
    snapid_ = new ::std::string;
  }
  snapid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SingleChannelInfoEnvelope::mutable_snapid() {
  set_has_snapid();
  if (snapid_ == &::google::protobuf::internal::kEmptyString) {
    snapid_ = new ::std::string;
  }
  return snapid_;
}
inline ::std::string* SingleChannelInfoEnvelope::release_snapid() {
  clear_has_snapid();
  if (snapid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = snapid_;
    snapid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SingleChannelInfoEnvelope::set_allocated_snapid(::std::string* snapid) {
  if (snapid_ != &::google::protobuf::internal::kEmptyString) {
    delete snapid_;
  }
  if (snapid) {
    set_has_snapid();
    snapid_ = snapid;
  } else {
    clear_has_snapid();
    snapid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .rxdataplane_msg.SingleChannelInfo chanInfo = 3;
inline int SingleChannelInfoEnvelope::chaninfo_size() const {
  return chaninfo_.size();
}
inline void SingleChannelInfoEnvelope::clear_chaninfo() {
  chaninfo_.Clear();
}
inline const ::rxdataplane_msg::SingleChannelInfo& SingleChannelInfoEnvelope::chaninfo(int index) const {
  return chaninfo_.Get(index);
}
inline ::rxdataplane_msg::SingleChannelInfo* SingleChannelInfoEnvelope::mutable_chaninfo(int index) {
  return chaninfo_.Mutable(index);
}
inline ::rxdataplane_msg::SingleChannelInfo* SingleChannelInfoEnvelope::add_chaninfo() {
  return chaninfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rxdataplane_msg::SingleChannelInfo >&
SingleChannelInfoEnvelope::chaninfo() const {
  return chaninfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::rxdataplane_msg::SingleChannelInfo >*
SingleChannelInfoEnvelope::mutable_chaninfo() {
  return &chaninfo_;
}

// -------------------------------------------------------------------

// SingleChannelInfo

// optional string msgName = 1 [default = "SINGLECHANNELINFO"];
inline bool SingleChannelInfo::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SingleChannelInfo::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SingleChannelInfo::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SingleChannelInfo::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SingleChannelInfo::msgname() const {
  return *msgname_;
}
inline void SingleChannelInfo::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SingleChannelInfo::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SingleChannelInfo::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SingleChannelInfo::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SingleChannelInfo::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SingleChannelInfo::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional .tuner_msg.IQHeaderInfo IQHeader = 2;
inline bool SingleChannelInfo::has_iqheader() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SingleChannelInfo::set_has_iqheader() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SingleChannelInfo::clear_has_iqheader() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SingleChannelInfo::clear_iqheader() {
  if (iqheader_ != NULL) iqheader_->::tuner_msg::IQHeaderInfo::Clear();
  clear_has_iqheader();
}
inline const ::tuner_msg::IQHeaderInfo& SingleChannelInfo::iqheader() const {
  return iqheader_ != NULL ? *iqheader_ : *default_instance_->iqheader_;
}
inline ::tuner_msg::IQHeaderInfo* SingleChannelInfo::mutable_iqheader() {
  set_has_iqheader();
  if (iqheader_ == NULL) iqheader_ = new ::tuner_msg::IQHeaderInfo;
  return iqheader_;
}
inline ::tuner_msg::IQHeaderInfo* SingleChannelInfo::release_iqheader() {
  clear_has_iqheader();
  ::tuner_msg::IQHeaderInfo* temp = iqheader_;
  iqheader_ = NULL;
  return temp;
}
inline void SingleChannelInfo::set_allocated_iqheader(::tuner_msg::IQHeaderInfo* iqheader) {
  delete iqheader_;
  iqheader_ = iqheader;
  if (iqheader) {
    set_has_iqheader();
  } else {
    clear_has_iqheader();
  }
}

// optional int32 subChannel = 3;
inline bool SingleChannelInfo::has_subchannel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SingleChannelInfo::set_has_subchannel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SingleChannelInfo::clear_has_subchannel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SingleChannelInfo::clear_subchannel() {
  subchannel_ = 0;
  clear_has_subchannel();
}
inline ::google::protobuf::int32 SingleChannelInfo::subchannel() const {
  return subchannel_;
}
inline void SingleChannelInfo::set_subchannel(::google::protobuf::int32 value) {
  set_has_subchannel();
  subchannel_ = value;
}

// optional int32 aux = 4;
inline bool SingleChannelInfo::has_aux() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SingleChannelInfo::set_has_aux() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SingleChannelInfo::clear_has_aux() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SingleChannelInfo::clear_aux() {
  aux_ = 0;
  clear_has_aux();
}
inline ::google::protobuf::int32 SingleChannelInfo::aux() const {
  return aux_;
}
inline void SingleChannelInfo::set_aux(::google::protobuf::int32 value) {
  set_has_aux();
  aux_ = value;
}

// optional int32 fileIndex = 5;
inline bool SingleChannelInfo::has_fileindex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SingleChannelInfo::set_has_fileindex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SingleChannelInfo::clear_has_fileindex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SingleChannelInfo::clear_fileindex() {
  fileindex_ = 0;
  clear_has_fileindex();
}
inline ::google::protobuf::int32 SingleChannelInfo::fileindex() const {
  return fileindex_;
}
inline void SingleChannelInfo::set_fileindex(::google::protobuf::int32 value) {
  set_has_fileindex();
  fileindex_ = value;
}

// -------------------------------------------------------------------

// SpectrogramInfo

// optional string msgName = 1 [default = "SPECTROGRAMINFO"];
inline bool SpectrogramInfo::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpectrogramInfo::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpectrogramInfo::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpectrogramInfo::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SpectrogramInfo::msgname() const {
  return *msgname_;
}
inline void SpectrogramInfo::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SpectrogramInfo::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SpectrogramInfo::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpectrogramInfo::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SpectrogramInfo::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SpectrogramInfo::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string fileName = 2;
inline bool SpectrogramInfo::has_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpectrogramInfo::set_has_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpectrogramInfo::clear_has_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpectrogramInfo::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& SpectrogramInfo::filename() const {
  return *filename_;
}
inline void SpectrogramInfo::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void SpectrogramInfo::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void SpectrogramInfo::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpectrogramInfo::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* SpectrogramInfo::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SpectrogramInfo::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double freqRF = 3;
inline bool SpectrogramInfo::has_freqrf() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SpectrogramInfo::set_has_freqrf() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SpectrogramInfo::clear_has_freqrf() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SpectrogramInfo::clear_freqrf() {
  freqrf_ = 0;
  clear_has_freqrf();
}
inline double SpectrogramInfo::freqrf() const {
  return freqrf_;
}
inline void SpectrogramInfo::set_freqrf(double value) {
  set_has_freqrf();
  freqrf_ = value;
}

// optional double startFreq = 4;
inline bool SpectrogramInfo::has_startfreq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SpectrogramInfo::set_has_startfreq() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SpectrogramInfo::clear_has_startfreq() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SpectrogramInfo::clear_startfreq() {
  startfreq_ = 0;
  clear_has_startfreq();
}
inline double SpectrogramInfo::startfreq() const {
  return startfreq_;
}
inline void SpectrogramInfo::set_startfreq(double value) {
  set_has_startfreq();
  startfreq_ = value;
}

// optional double stopFreq = 5;
inline bool SpectrogramInfo::has_stopfreq() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SpectrogramInfo::set_has_stopfreq() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SpectrogramInfo::clear_has_stopfreq() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SpectrogramInfo::clear_stopfreq() {
  stopfreq_ = 0;
  clear_has_stopfreq();
}
inline double SpectrogramInfo::stopfreq() const {
  return stopfreq_;
}
inline void SpectrogramInfo::set_stopfreq(double value) {
  set_has_stopfreq();
  stopfreq_ = value;
}

// optional int32 bins = 6;
inline bool SpectrogramInfo::has_bins() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SpectrogramInfo::set_has_bins() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SpectrogramInfo::clear_has_bins() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SpectrogramInfo::clear_bins() {
  bins_ = 0;
  clear_has_bins();
}
inline ::google::protobuf::int32 SpectrogramInfo::bins() const {
  return bins_;
}
inline void SpectrogramInfo::set_bins(::google::protobuf::int32 value) {
  set_has_bins();
  bins_ = value;
}

// optional double binResolution = 7;
inline bool SpectrogramInfo::has_binresolution() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SpectrogramInfo::set_has_binresolution() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SpectrogramInfo::clear_has_binresolution() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SpectrogramInfo::clear_binresolution() {
  binresolution_ = 0;
  clear_has_binresolution();
}
inline double SpectrogramInfo::binresolution() const {
  return binresolution_;
}
inline void SpectrogramInfo::set_binresolution(double value) {
  set_has_binresolution();
  binresolution_ = value;
}

// optional double averages = 8;
inline bool SpectrogramInfo::has_averages() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SpectrogramInfo::set_has_averages() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SpectrogramInfo::clear_has_averages() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SpectrogramInfo::clear_averages() {
  averages_ = 0;
  clear_has_averages();
}
inline double SpectrogramInfo::averages() const {
  return averages_;
}
inline void SpectrogramInfo::set_averages(double value) {
  set_has_averages();
  averages_ = value;
}

// optional string spectrogram_time = 9;
inline bool SpectrogramInfo::has_spectrogram_time() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SpectrogramInfo::set_has_spectrogram_time() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SpectrogramInfo::clear_has_spectrogram_time() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SpectrogramInfo::clear_spectrogram_time() {
  if (spectrogram_time_ != &::google::protobuf::internal::kEmptyString) {
    spectrogram_time_->clear();
  }
  clear_has_spectrogram_time();
}
inline const ::std::string& SpectrogramInfo::spectrogram_time() const {
  return *spectrogram_time_;
}
inline void SpectrogramInfo::set_spectrogram_time(const ::std::string& value) {
  set_has_spectrogram_time();
  if (spectrogram_time_ == &::google::protobuf::internal::kEmptyString) {
    spectrogram_time_ = new ::std::string;
  }
  spectrogram_time_->assign(value);
}
inline void SpectrogramInfo::set_spectrogram_time(const char* value) {
  set_has_spectrogram_time();
  if (spectrogram_time_ == &::google::protobuf::internal::kEmptyString) {
    spectrogram_time_ = new ::std::string;
  }
  spectrogram_time_->assign(value);
}
inline void SpectrogramInfo::set_spectrogram_time(const char* value, size_t size) {
  set_has_spectrogram_time();
  if (spectrogram_time_ == &::google::protobuf::internal::kEmptyString) {
    spectrogram_time_ = new ::std::string;
  }
  spectrogram_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpectrogramInfo::mutable_spectrogram_time() {
  set_has_spectrogram_time();
  if (spectrogram_time_ == &::google::protobuf::internal::kEmptyString) {
    spectrogram_time_ = new ::std::string;
  }
  return spectrogram_time_;
}
inline ::std::string* SpectrogramInfo::release_spectrogram_time() {
  clear_has_spectrogram_time();
  if (spectrogram_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = spectrogram_time_;
    spectrogram_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SpectrogramInfo::set_allocated_spectrogram_time(::std::string* spectrogram_time) {
  if (spectrogram_time_ != &::google::protobuf::internal::kEmptyString) {
    delete spectrogram_time_;
  }
  if (spectrogram_time) {
    set_has_spectrogram_time();
    spectrogram_time_ = spectrogram_time;
  } else {
    clear_has_spectrogram_time();
    spectrogram_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SpectrogramInfoEnvelope

// optional string msgName = 1 [default = "SPECTROGRAMINFOENVELOPE"];
inline bool SpectrogramInfoEnvelope::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpectrogramInfoEnvelope::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpectrogramInfoEnvelope::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpectrogramInfoEnvelope::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SpectrogramInfoEnvelope::msgname() const {
  return *msgname_;
}
inline void SpectrogramInfoEnvelope::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SpectrogramInfoEnvelope::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SpectrogramInfoEnvelope::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpectrogramInfoEnvelope::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SpectrogramInfoEnvelope::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SpectrogramInfoEnvelope::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string snapid = 2;
inline bool SpectrogramInfoEnvelope::has_snapid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpectrogramInfoEnvelope::set_has_snapid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpectrogramInfoEnvelope::clear_has_snapid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpectrogramInfoEnvelope::clear_snapid() {
  if (snapid_ != &::google::protobuf::internal::kEmptyString) {
    snapid_->clear();
  }
  clear_has_snapid();
}
inline const ::std::string& SpectrogramInfoEnvelope::snapid() const {
  return *snapid_;
}
inline void SpectrogramInfoEnvelope::set_snapid(const ::std::string& value) {
  set_has_snapid();
  if (snapid_ == &::google::protobuf::internal::kEmptyString) {
    snapid_ = new ::std::string;
  }
  snapid_->assign(value);
}
inline void SpectrogramInfoEnvelope::set_snapid(const char* value) {
  set_has_snapid();
  if (snapid_ == &::google::protobuf::internal::kEmptyString) {
    snapid_ = new ::std::string;
  }
  snapid_->assign(value);
}
inline void SpectrogramInfoEnvelope::set_snapid(const char* value, size_t size) {
  set_has_snapid();
  if (snapid_ == &::google::protobuf::internal::kEmptyString) {
    snapid_ = new ::std::string;
  }
  snapid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpectrogramInfoEnvelope::mutable_snapid() {
  set_has_snapid();
  if (snapid_ == &::google::protobuf::internal::kEmptyString) {
    snapid_ = new ::std::string;
  }
  return snapid_;
}
inline ::std::string* SpectrogramInfoEnvelope::release_snapid() {
  clear_has_snapid();
  if (snapid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = snapid_;
    snapid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SpectrogramInfoEnvelope::set_allocated_snapid(::std::string* snapid) {
  if (snapid_ != &::google::protobuf::internal::kEmptyString) {
    delete snapid_;
  }
  if (snapid) {
    set_has_snapid();
    snapid_ = snapid;
  } else {
    clear_has_snapid();
    snapid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .rxdataplane_msg.SpectrogramInfo spectrogramInfo = 3;
inline int SpectrogramInfoEnvelope::spectrograminfo_size() const {
  return spectrograminfo_.size();
}
inline void SpectrogramInfoEnvelope::clear_spectrograminfo() {
  spectrograminfo_.Clear();
}
inline const ::rxdataplane_msg::SpectrogramInfo& SpectrogramInfoEnvelope::spectrograminfo(int index) const {
  return spectrograminfo_.Get(index);
}
inline ::rxdataplane_msg::SpectrogramInfo* SpectrogramInfoEnvelope::mutable_spectrograminfo(int index) {
  return spectrograminfo_.Mutable(index);
}
inline ::rxdataplane_msg::SpectrogramInfo* SpectrogramInfoEnvelope::add_spectrograminfo() {
  return spectrograminfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rxdataplane_msg::SpectrogramInfo >&
SpectrogramInfoEnvelope::spectrograminfo() const {
  return spectrograminfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::rxdataplane_msg::SpectrogramInfo >*
SpectrogramInfoEnvelope::mutable_spectrograminfo() {
  return &spectrograminfo_;
}

// -------------------------------------------------------------------

// PSDInfo

// optional string msgName = 1 [default = "PSDINFO"];
inline bool PSDInfo::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PSDInfo::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PSDInfo::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PSDInfo::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& PSDInfo::msgname() const {
  return *msgname_;
}
inline void PSDInfo::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void PSDInfo::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void PSDInfo::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PSDInfo::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* PSDInfo::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void PSDInfo::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string fileName = 2;
inline bool PSDInfo::has_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PSDInfo::set_has_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PSDInfo::clear_has_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PSDInfo::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& PSDInfo::filename() const {
  return *filename_;
}
inline void PSDInfo::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void PSDInfo::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void PSDInfo::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PSDInfo::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* PSDInfo::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PSDInfo::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double freqRF = 3;
inline bool PSDInfo::has_freqrf() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PSDInfo::set_has_freqrf() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PSDInfo::clear_has_freqrf() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PSDInfo::clear_freqrf() {
  freqrf_ = 0;
  clear_has_freqrf();
}
inline double PSDInfo::freqrf() const {
  return freqrf_;
}
inline void PSDInfo::set_freqrf(double value) {
  set_has_freqrf();
  freqrf_ = value;
}

// optional double startFreq = 4;
inline bool PSDInfo::has_startfreq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PSDInfo::set_has_startfreq() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PSDInfo::clear_has_startfreq() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PSDInfo::clear_startfreq() {
  startfreq_ = 0;
  clear_has_startfreq();
}
inline double PSDInfo::startfreq() const {
  return startfreq_;
}
inline void PSDInfo::set_startfreq(double value) {
  set_has_startfreq();
  startfreq_ = value;
}

// optional double stopFreq = 5;
inline bool PSDInfo::has_stopfreq() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PSDInfo::set_has_stopfreq() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PSDInfo::clear_has_stopfreq() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PSDInfo::clear_stopfreq() {
  stopfreq_ = 0;
  clear_has_stopfreq();
}
inline double PSDInfo::stopfreq() const {
  return stopfreq_;
}
inline void PSDInfo::set_stopfreq(double value) {
  set_has_stopfreq();
  stopfreq_ = value;
}

// optional double binResolution = 6;
inline bool PSDInfo::has_binresolution() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PSDInfo::set_has_binresolution() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PSDInfo::clear_has_binresolution() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PSDInfo::clear_binresolution() {
  binresolution_ = 0;
  clear_has_binresolution();
}
inline double PSDInfo::binresolution() const {
  return binresolution_;
}
inline void PSDInfo::set_binresolution(double value) {
  set_has_binresolution();
  binresolution_ = value;
}

// optional string psd_time = 7;
inline bool PSDInfo::has_psd_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PSDInfo::set_has_psd_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PSDInfo::clear_has_psd_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PSDInfo::clear_psd_time() {
  if (psd_time_ != &::google::protobuf::internal::kEmptyString) {
    psd_time_->clear();
  }
  clear_has_psd_time();
}
inline const ::std::string& PSDInfo::psd_time() const {
  return *psd_time_;
}
inline void PSDInfo::set_psd_time(const ::std::string& value) {
  set_has_psd_time();
  if (psd_time_ == &::google::protobuf::internal::kEmptyString) {
    psd_time_ = new ::std::string;
  }
  psd_time_->assign(value);
}
inline void PSDInfo::set_psd_time(const char* value) {
  set_has_psd_time();
  if (psd_time_ == &::google::protobuf::internal::kEmptyString) {
    psd_time_ = new ::std::string;
  }
  psd_time_->assign(value);
}
inline void PSDInfo::set_psd_time(const char* value, size_t size) {
  set_has_psd_time();
  if (psd_time_ == &::google::protobuf::internal::kEmptyString) {
    psd_time_ = new ::std::string;
  }
  psd_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PSDInfo::mutable_psd_time() {
  set_has_psd_time();
  if (psd_time_ == &::google::protobuf::internal::kEmptyString) {
    psd_time_ = new ::std::string;
  }
  return psd_time_;
}
inline ::std::string* PSDInfo::release_psd_time() {
  clear_has_psd_time();
  if (psd_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = psd_time_;
    psd_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PSDInfo::set_allocated_psd_time(::std::string* psd_time) {
  if (psd_time_ != &::google::protobuf::internal::kEmptyString) {
    delete psd_time_;
  }
  if (psd_time) {
    set_has_psd_time();
    psd_time_ = psd_time;
  } else {
    clear_has_psd_time();
    psd_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PSDInfoEnvelope

// optional string msgName = 1 [default = "PSDINFOENVELOPE"];
inline bool PSDInfoEnvelope::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PSDInfoEnvelope::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PSDInfoEnvelope::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PSDInfoEnvelope::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& PSDInfoEnvelope::msgname() const {
  return *msgname_;
}
inline void PSDInfoEnvelope::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void PSDInfoEnvelope::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void PSDInfoEnvelope::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PSDInfoEnvelope::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* PSDInfoEnvelope::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void PSDInfoEnvelope::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string snapid = 2;
inline bool PSDInfoEnvelope::has_snapid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PSDInfoEnvelope::set_has_snapid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PSDInfoEnvelope::clear_has_snapid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PSDInfoEnvelope::clear_snapid() {
  if (snapid_ != &::google::protobuf::internal::kEmptyString) {
    snapid_->clear();
  }
  clear_has_snapid();
}
inline const ::std::string& PSDInfoEnvelope::snapid() const {
  return *snapid_;
}
inline void PSDInfoEnvelope::set_snapid(const ::std::string& value) {
  set_has_snapid();
  if (snapid_ == &::google::protobuf::internal::kEmptyString) {
    snapid_ = new ::std::string;
  }
  snapid_->assign(value);
}
inline void PSDInfoEnvelope::set_snapid(const char* value) {
  set_has_snapid();
  if (snapid_ == &::google::protobuf::internal::kEmptyString) {
    snapid_ = new ::std::string;
  }
  snapid_->assign(value);
}
inline void PSDInfoEnvelope::set_snapid(const char* value, size_t size) {
  set_has_snapid();
  if (snapid_ == &::google::protobuf::internal::kEmptyString) {
    snapid_ = new ::std::string;
  }
  snapid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PSDInfoEnvelope::mutable_snapid() {
  set_has_snapid();
  if (snapid_ == &::google::protobuf::internal::kEmptyString) {
    snapid_ = new ::std::string;
  }
  return snapid_;
}
inline ::std::string* PSDInfoEnvelope::release_snapid() {
  clear_has_snapid();
  if (snapid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = snapid_;
    snapid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PSDInfoEnvelope::set_allocated_snapid(::std::string* snapid) {
  if (snapid_ != &::google::protobuf::internal::kEmptyString) {
    delete snapid_;
  }
  if (snapid) {
    set_has_snapid();
    snapid_ = snapid;
  } else {
    clear_has_snapid();
    snapid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .rxdataplane_msg.PSDInfo psdInfo = 3;
inline int PSDInfoEnvelope::psdinfo_size() const {
  return psdinfo_.size();
}
inline void PSDInfoEnvelope::clear_psdinfo() {
  psdinfo_.Clear();
}
inline const ::rxdataplane_msg::PSDInfo& PSDInfoEnvelope::psdinfo(int index) const {
  return psdinfo_.Get(index);
}
inline ::rxdataplane_msg::PSDInfo* PSDInfoEnvelope::mutable_psdinfo(int index) {
  return psdinfo_.Mutable(index);
}
inline ::rxdataplane_msg::PSDInfo* PSDInfoEnvelope::add_psdinfo() {
  return psdinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rxdataplane_msg::PSDInfo >&
PSDInfoEnvelope::psdinfo() const {
  return psdinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::rxdataplane_msg::PSDInfo >*
PSDInfoEnvelope::mutable_psdinfo() {
  return &psdinfo_;
}

// -------------------------------------------------------------------

// EnergyBurstInfo

// optional string msgName = 1 [default = "ENERGYBURSTINFO"];
inline bool EnergyBurstInfo::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnergyBurstInfo::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnergyBurstInfo::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnergyBurstInfo::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& EnergyBurstInfo::msgname() const {
  return *msgname_;
}
inline void EnergyBurstInfo::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EnergyBurstInfo::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EnergyBurstInfo::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnergyBurstInfo::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* EnergyBurstInfo::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void EnergyBurstInfo::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional double whole_sec = 2;
inline bool EnergyBurstInfo::has_whole_sec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnergyBurstInfo::set_has_whole_sec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnergyBurstInfo::clear_has_whole_sec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnergyBurstInfo::clear_whole_sec() {
  whole_sec_ = 0;
  clear_has_whole_sec();
}
inline double EnergyBurstInfo::whole_sec() const {
  return whole_sec_;
}
inline void EnergyBurstInfo::set_whole_sec(double value) {
  set_has_whole_sec();
  whole_sec_ = value;
}

// optional double frac_sec = 3;
inline bool EnergyBurstInfo::has_frac_sec() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnergyBurstInfo::set_has_frac_sec() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnergyBurstInfo::clear_has_frac_sec() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnergyBurstInfo::clear_frac_sec() {
  frac_sec_ = 0;
  clear_has_frac_sec();
}
inline double EnergyBurstInfo::frac_sec() const {
  return frac_sec_;
}
inline void EnergyBurstInfo::set_frac_sec(double value) {
  set_has_frac_sec();
  frac_sec_ = value;
}

// optional double duration = 4;
inline bool EnergyBurstInfo::has_duration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EnergyBurstInfo::set_has_duration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EnergyBurstInfo::clear_has_duration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EnergyBurstInfo::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline double EnergyBurstInfo::duration() const {
  return duration_;
}
inline void EnergyBurstInfo::set_duration(double value) {
  set_has_duration();
  duration_ = value;
}

// optional double freqRF = 5;
inline bool EnergyBurstInfo::has_freqrf() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EnergyBurstInfo::set_has_freqrf() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EnergyBurstInfo::clear_has_freqrf() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EnergyBurstInfo::clear_freqrf() {
  freqrf_ = 0;
  clear_has_freqrf();
}
inline double EnergyBurstInfo::freqrf() const {
  return freqrf_;
}
inline void EnergyBurstInfo::set_freqrf(double value) {
  set_has_freqrf();
  freqrf_ = value;
}

// optional double bandwidth = 6;
inline bool EnergyBurstInfo::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EnergyBurstInfo::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EnergyBurstInfo::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EnergyBurstInfo::clear_bandwidth() {
  bandwidth_ = 0;
  clear_has_bandwidth();
}
inline double EnergyBurstInfo::bandwidth() const {
  return bandwidth_;
}
inline void EnergyBurstInfo::set_bandwidth(double value) {
  set_has_bandwidth();
  bandwidth_ = value;
}

// optional double snr = 7;
inline bool EnergyBurstInfo::has_snr() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EnergyBurstInfo::set_has_snr() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EnergyBurstInfo::clear_has_snr() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EnergyBurstInfo::clear_snr() {
  snr_ = 0;
  clear_has_snr();
}
inline double EnergyBurstInfo::snr() const {
  return snr_;
}
inline void EnergyBurstInfo::set_snr(double value) {
  set_has_snr();
  snr_ = value;
}

// -------------------------------------------------------------------

// EnergyBurstInfoEnvelope

// optional string msgName = 1 [default = "ENERGYBURSTINFOENVELOPE"];
inline bool EnergyBurstInfoEnvelope::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnergyBurstInfoEnvelope::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnergyBurstInfoEnvelope::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnergyBurstInfoEnvelope::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& EnergyBurstInfoEnvelope::msgname() const {
  return *msgname_;
}
inline void EnergyBurstInfoEnvelope::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EnergyBurstInfoEnvelope::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void EnergyBurstInfoEnvelope::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnergyBurstInfoEnvelope::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* EnergyBurstInfoEnvelope::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void EnergyBurstInfoEnvelope::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string snapid = 2;
inline bool EnergyBurstInfoEnvelope::has_snapid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnergyBurstInfoEnvelope::set_has_snapid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnergyBurstInfoEnvelope::clear_has_snapid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnergyBurstInfoEnvelope::clear_snapid() {
  if (snapid_ != &::google::protobuf::internal::kEmptyString) {
    snapid_->clear();
  }
  clear_has_snapid();
}
inline const ::std::string& EnergyBurstInfoEnvelope::snapid() const {
  return *snapid_;
}
inline void EnergyBurstInfoEnvelope::set_snapid(const ::std::string& value) {
  set_has_snapid();
  if (snapid_ == &::google::protobuf::internal::kEmptyString) {
    snapid_ = new ::std::string;
  }
  snapid_->assign(value);
}
inline void EnergyBurstInfoEnvelope::set_snapid(const char* value) {
  set_has_snapid();
  if (snapid_ == &::google::protobuf::internal::kEmptyString) {
    snapid_ = new ::std::string;
  }
  snapid_->assign(value);
}
inline void EnergyBurstInfoEnvelope::set_snapid(const char* value, size_t size) {
  set_has_snapid();
  if (snapid_ == &::google::protobuf::internal::kEmptyString) {
    snapid_ = new ::std::string;
  }
  snapid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnergyBurstInfoEnvelope::mutable_snapid() {
  set_has_snapid();
  if (snapid_ == &::google::protobuf::internal::kEmptyString) {
    snapid_ = new ::std::string;
  }
  return snapid_;
}
inline ::std::string* EnergyBurstInfoEnvelope::release_snapid() {
  clear_has_snapid();
  if (snapid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = snapid_;
    snapid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EnergyBurstInfoEnvelope::set_allocated_snapid(::std::string* snapid) {
  if (snapid_ != &::google::protobuf::internal::kEmptyString) {
    delete snapid_;
  }
  if (snapid) {
    set_has_snapid();
    snapid_ = snapid;
  } else {
    clear_has_snapid();
    snapid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .rxdataplane_msg.EnergyBurstInfo energyBursts = 3;
inline int EnergyBurstInfoEnvelope::energybursts_size() const {
  return energybursts_.size();
}
inline void EnergyBurstInfoEnvelope::clear_energybursts() {
  energybursts_.Clear();
}
inline const ::rxdataplane_msg::EnergyBurstInfo& EnergyBurstInfoEnvelope::energybursts(int index) const {
  return energybursts_.Get(index);
}
inline ::rxdataplane_msg::EnergyBurstInfo* EnergyBurstInfoEnvelope::mutable_energybursts(int index) {
  return energybursts_.Mutable(index);
}
inline ::rxdataplane_msg::EnergyBurstInfo* EnergyBurstInfoEnvelope::add_energybursts() {
  return energybursts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rxdataplane_msg::EnergyBurstInfo >&
EnergyBurstInfoEnvelope::energybursts() const {
  return energybursts_;
}
inline ::google::protobuf::RepeatedPtrField< ::rxdataplane_msg::EnergyBurstInfo >*
EnergyBurstInfoEnvelope::mutable_energybursts() {
  return &energybursts_;
}

// optional double timeResSec = 4;
inline bool EnergyBurstInfoEnvelope::has_timeressec() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EnergyBurstInfoEnvelope::set_has_timeressec() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EnergyBurstInfoEnvelope::clear_has_timeressec() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EnergyBurstInfoEnvelope::clear_timeressec() {
  timeressec_ = 0;
  clear_has_timeressec();
}
inline double EnergyBurstInfoEnvelope::timeressec() const {
  return timeressec_;
}
inline void EnergyBurstInfoEnvelope::set_timeressec(double value) {
  set_has_timeressec();
  timeressec_ = value;
}

// optional double freqResHz = 5;
inline bool EnergyBurstInfoEnvelope::has_freqreshz() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EnergyBurstInfoEnvelope::set_has_freqreshz() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EnergyBurstInfoEnvelope::clear_has_freqreshz() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EnergyBurstInfoEnvelope::clear_freqreshz() {
  freqreshz_ = 0;
  clear_has_freqreshz();
}
inline double EnergyBurstInfoEnvelope::freqreshz() const {
  return freqreshz_;
}
inline void EnergyBurstInfoEnvelope::set_freqreshz(double value) {
  set_has_freqreshz();
  freqreshz_ = value;
}

// optional string segmenterName = 6;
inline bool EnergyBurstInfoEnvelope::has_segmentername() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EnergyBurstInfoEnvelope::set_has_segmentername() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EnergyBurstInfoEnvelope::clear_has_segmentername() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EnergyBurstInfoEnvelope::clear_segmentername() {
  if (segmentername_ != &::google::protobuf::internal::kEmptyString) {
    segmentername_->clear();
  }
  clear_has_segmentername();
}
inline const ::std::string& EnergyBurstInfoEnvelope::segmentername() const {
  return *segmentername_;
}
inline void EnergyBurstInfoEnvelope::set_segmentername(const ::std::string& value) {
  set_has_segmentername();
  if (segmentername_ == &::google::protobuf::internal::kEmptyString) {
    segmentername_ = new ::std::string;
  }
  segmentername_->assign(value);
}
inline void EnergyBurstInfoEnvelope::set_segmentername(const char* value) {
  set_has_segmentername();
  if (segmentername_ == &::google::protobuf::internal::kEmptyString) {
    segmentername_ = new ::std::string;
  }
  segmentername_->assign(value);
}
inline void EnergyBurstInfoEnvelope::set_segmentername(const char* value, size_t size) {
  set_has_segmentername();
  if (segmentername_ == &::google::protobuf::internal::kEmptyString) {
    segmentername_ = new ::std::string;
  }
  segmentername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnergyBurstInfoEnvelope::mutable_segmentername() {
  set_has_segmentername();
  if (segmentername_ == &::google::protobuf::internal::kEmptyString) {
    segmentername_ = new ::std::string;
  }
  return segmentername_;
}
inline ::std::string* EnergyBurstInfoEnvelope::release_segmentername() {
  clear_has_segmentername();
  if (segmentername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = segmentername_;
    segmentername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EnergyBurstInfoEnvelope::set_allocated_segmentername(::std::string* segmentername) {
  if (segmentername_ != &::google::protobuf::internal::kEmptyString) {
    delete segmentername_;
  }
  if (segmentername) {
    set_has_segmentername();
    segmentername_ = segmentername;
  } else {
    clear_has_segmentername();
    segmentername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string metaFilename = 7 [default = "NONE"];
inline bool EnergyBurstInfoEnvelope::has_metafilename() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EnergyBurstInfoEnvelope::set_has_metafilename() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EnergyBurstInfoEnvelope::clear_has_metafilename() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EnergyBurstInfoEnvelope::clear_metafilename() {
  if (metafilename_ != _default_metafilename_) {
    metafilename_->assign(*_default_metafilename_);
  }
  clear_has_metafilename();
}
inline const ::std::string& EnergyBurstInfoEnvelope::metafilename() const {
  return *metafilename_;
}
inline void EnergyBurstInfoEnvelope::set_metafilename(const ::std::string& value) {
  set_has_metafilename();
  if (metafilename_ == _default_metafilename_) {
    metafilename_ = new ::std::string;
  }
  metafilename_->assign(value);
}
inline void EnergyBurstInfoEnvelope::set_metafilename(const char* value) {
  set_has_metafilename();
  if (metafilename_ == _default_metafilename_) {
    metafilename_ = new ::std::string;
  }
  metafilename_->assign(value);
}
inline void EnergyBurstInfoEnvelope::set_metafilename(const char* value, size_t size) {
  set_has_metafilename();
  if (metafilename_ == _default_metafilename_) {
    metafilename_ = new ::std::string;
  }
  metafilename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnergyBurstInfoEnvelope::mutable_metafilename() {
  set_has_metafilename();
  if (metafilename_ == _default_metafilename_) {
    metafilename_ = new ::std::string(*_default_metafilename_);
  }
  return metafilename_;
}
inline ::std::string* EnergyBurstInfoEnvelope::release_metafilename() {
  clear_has_metafilename();
  if (metafilename_ == _default_metafilename_) {
    return NULL;
  } else {
    ::std::string* temp = metafilename_;
    metafilename_ = const_cast< ::std::string*>(_default_metafilename_);
    return temp;
  }
}
inline void EnergyBurstInfoEnvelope::set_allocated_metafilename(::std::string* metafilename) {
  if (metafilename_ != _default_metafilename_) {
    delete metafilename_;
  }
  if (metafilename) {
    set_has_metafilename();
    metafilename_ = metafilename;
  } else {
    clear_has_metafilename();
    metafilename_ = const_cast< ::std::string*>(_default_metafilename_);
  }
}

// optional string iqIndexFilename = 8 [default = "NONE"];
inline bool EnergyBurstInfoEnvelope::has_iqindexfilename() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EnergyBurstInfoEnvelope::set_has_iqindexfilename() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EnergyBurstInfoEnvelope::clear_has_iqindexfilename() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EnergyBurstInfoEnvelope::clear_iqindexfilename() {
  if (iqindexfilename_ != _default_iqindexfilename_) {
    iqindexfilename_->assign(*_default_iqindexfilename_);
  }
  clear_has_iqindexfilename();
}
inline const ::std::string& EnergyBurstInfoEnvelope::iqindexfilename() const {
  return *iqindexfilename_;
}
inline void EnergyBurstInfoEnvelope::set_iqindexfilename(const ::std::string& value) {
  set_has_iqindexfilename();
  if (iqindexfilename_ == _default_iqindexfilename_) {
    iqindexfilename_ = new ::std::string;
  }
  iqindexfilename_->assign(value);
}
inline void EnergyBurstInfoEnvelope::set_iqindexfilename(const char* value) {
  set_has_iqindexfilename();
  if (iqindexfilename_ == _default_iqindexfilename_) {
    iqindexfilename_ = new ::std::string;
  }
  iqindexfilename_->assign(value);
}
inline void EnergyBurstInfoEnvelope::set_iqindexfilename(const char* value, size_t size) {
  set_has_iqindexfilename();
  if (iqindexfilename_ == _default_iqindexfilename_) {
    iqindexfilename_ = new ::std::string;
  }
  iqindexfilename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnergyBurstInfoEnvelope::mutable_iqindexfilename() {
  set_has_iqindexfilename();
  if (iqindexfilename_ == _default_iqindexfilename_) {
    iqindexfilename_ = new ::std::string(*_default_iqindexfilename_);
  }
  return iqindexfilename_;
}
inline ::std::string* EnergyBurstInfoEnvelope::release_iqindexfilename() {
  clear_has_iqindexfilename();
  if (iqindexfilename_ == _default_iqindexfilename_) {
    return NULL;
  } else {
    ::std::string* temp = iqindexfilename_;
    iqindexfilename_ = const_cast< ::std::string*>(_default_iqindexfilename_);
    return temp;
  }
}
inline void EnergyBurstInfoEnvelope::set_allocated_iqindexfilename(::std::string* iqindexfilename) {
  if (iqindexfilename_ != _default_iqindexfilename_) {
    delete iqindexfilename_;
  }
  if (iqindexfilename) {
    set_has_iqindexfilename();
    iqindexfilename_ = iqindexfilename;
  } else {
    clear_has_iqindexfilename();
    iqindexfilename_ = const_cast< ::std::string*>(_default_iqindexfilename_);
  }
}

// -------------------------------------------------------------------

// PDWInfo

// optional string msgName = 1 [default = "PDWINFO"];
inline bool PDWInfo::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PDWInfo::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PDWInfo::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PDWInfo::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& PDWInfo::msgname() const {
  return *msgname_;
}
inline void PDWInfo::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void PDWInfo::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void PDWInfo::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PDWInfo::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* PDWInfo::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void PDWInfo::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional uint64 toaWholeSec = 2;
inline bool PDWInfo::has_toawholesec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PDWInfo::set_has_toawholesec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PDWInfo::clear_has_toawholesec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PDWInfo::clear_toawholesec() {
  toawholesec_ = GOOGLE_ULONGLONG(0);
  clear_has_toawholesec();
}
inline ::google::protobuf::uint64 PDWInfo::toawholesec() const {
  return toawholesec_;
}
inline void PDWInfo::set_toawholesec(::google::protobuf::uint64 value) {
  set_has_toawholesec();
  toawholesec_ = value;
}

// optional double toaFracSec = 3;
inline bool PDWInfo::has_toafracsec() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PDWInfo::set_has_toafracsec() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PDWInfo::clear_has_toafracsec() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PDWInfo::clear_toafracsec() {
  toafracsec_ = 0;
  clear_has_toafracsec();
}
inline double PDWInfo::toafracsec() const {
  return toafracsec_;
}
inline void PDWInfo::set_toafracsec(double value) {
  set_has_toafracsec();
  toafracsec_ = value;
}

// optional double pulseDur = 4;
inline bool PDWInfo::has_pulsedur() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PDWInfo::set_has_pulsedur() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PDWInfo::clear_has_pulsedur() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PDWInfo::clear_pulsedur() {
  pulsedur_ = 0;
  clear_has_pulsedur();
}
inline double PDWInfo::pulsedur() const {
  return pulsedur_;
}
inline void PDWInfo::set_pulsedur(double value) {
  set_has_pulsedur();
  pulsedur_ = value;
}

// optional double gap = 5;
inline bool PDWInfo::has_gap() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PDWInfo::set_has_gap() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PDWInfo::clear_has_gap() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PDWInfo::clear_gap() {
  gap_ = 0;
  clear_has_gap();
}
inline double PDWInfo::gap() const {
  return gap_;
}
inline void PDWInfo::set_gap(double value) {
  set_has_gap();
  gap_ = value;
}

// optional double freqRF = 6;
inline bool PDWInfo::has_freqrf() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PDWInfo::set_has_freqrf() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PDWInfo::clear_has_freqrf() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PDWInfo::clear_freqrf() {
  freqrf_ = 0;
  clear_has_freqrf();
}
inline double PDWInfo::freqrf() const {
  return freqrf_;
}
inline void PDWInfo::set_freqrf(double value) {
  set_has_freqrf();
  freqrf_ = value;
}

// optional double bandwidth = 7;
inline bool PDWInfo::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PDWInfo::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PDWInfo::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PDWInfo::clear_bandwidth() {
  bandwidth_ = 0;
  clear_has_bandwidth();
}
inline double PDWInfo::bandwidth() const {
  return bandwidth_;
}
inline void PDWInfo::set_bandwidth(double value) {
  set_has_bandwidth();
  bandwidth_ = value;
}

// optional double freqSlope = 8;
inline bool PDWInfo::has_freqslope() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PDWInfo::set_has_freqslope() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PDWInfo::clear_has_freqslope() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PDWInfo::clear_freqslope() {
  freqslope_ = 0;
  clear_has_freqslope();
}
inline double PDWInfo::freqslope() const {
  return freqslope_;
}
inline void PDWInfo::set_freqslope(double value) {
  set_has_freqslope();
  freqslope_ = value;
}

// optional double snr = 9;
inline bool PDWInfo::has_snr() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PDWInfo::set_has_snr() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PDWInfo::clear_has_snr() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PDWInfo::clear_snr() {
  snr_ = 0;
  clear_has_snr();
}
inline double PDWInfo::snr() const {
  return snr_;
}
inline void PDWInfo::set_snr(double value) {
  set_has_snr();
  snr_ = value;
}

// optional double az = 10;
inline bool PDWInfo::has_az() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PDWInfo::set_has_az() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PDWInfo::clear_has_az() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PDWInfo::clear_az() {
  az_ = 0;
  clear_has_az();
}
inline double PDWInfo::az() const {
  return az_;
}
inline void PDWInfo::set_az(double value) {
  set_has_az();
  az_ = value;
}

// optional double el = 11;
inline bool PDWInfo::has_el() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PDWInfo::set_has_el() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PDWInfo::clear_has_el() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PDWInfo::clear_el() {
  el_ = 0;
  clear_has_el();
}
inline double PDWInfo::el() const {
  return el_;
}
inline void PDWInfo::set_el(double value) {
  set_has_el();
  el_ = value;
}

// optional double dfQ = 12;
inline bool PDWInfo::has_dfq() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PDWInfo::set_has_dfq() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PDWInfo::clear_has_dfq() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PDWInfo::clear_dfq() {
  dfq_ = 0;
  clear_has_dfq();
}
inline double PDWInfo::dfq() const {
  return dfq_;
}
inline void PDWInfo::set_dfq(double value) {
  set_has_dfq();
  dfq_ = value;
}

// optional double polAR = 13;
inline bool PDWInfo::has_polar() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PDWInfo::set_has_polar() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PDWInfo::clear_has_polar() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PDWInfo::clear_polar() {
  polar_ = 0;
  clear_has_polar();
}
inline double PDWInfo::polar() const {
  return polar_;
}
inline void PDWInfo::set_polar(double value) {
  set_has_polar();
  polar_ = value;
}

// optional double polTilt = 14;
inline bool PDWInfo::has_poltilt() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PDWInfo::set_has_poltilt() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PDWInfo::clear_has_poltilt() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PDWInfo::clear_poltilt() {
  poltilt_ = 0;
  clear_has_poltilt();
}
inline double PDWInfo::poltilt() const {
  return poltilt_;
}
inline void PDWInfo::set_poltilt(double value) {
  set_has_poltilt();
  poltilt_ = value;
}

// optional .rxdataplane_msg.ModulationType modType = 15 [default = NONE];
inline bool PDWInfo::has_modtype() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PDWInfo::set_has_modtype() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PDWInfo::clear_has_modtype() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PDWInfo::clear_modtype() {
  modtype_ = 0;
  clear_has_modtype();
}
inline ::rxdataplane_msg::ModulationType PDWInfo::modtype() const {
  return static_cast< ::rxdataplane_msg::ModulationType >(modtype_);
}
inline void PDWInfo::set_modtype(::rxdataplane_msg::ModulationType value) {
  assert(::rxdataplane_msg::ModulationType_IsValid(value));
  set_has_modtype();
  modtype_ = value;
}

// -------------------------------------------------------------------

// PDWInfoEnvelope

// optional string msgName = 1 [default = "PDWINFOENVELOPE"];
inline bool PDWInfoEnvelope::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PDWInfoEnvelope::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PDWInfoEnvelope::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PDWInfoEnvelope::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& PDWInfoEnvelope::msgname() const {
  return *msgname_;
}
inline void PDWInfoEnvelope::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void PDWInfoEnvelope::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void PDWInfoEnvelope::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PDWInfoEnvelope::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* PDWInfoEnvelope::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void PDWInfoEnvelope::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string snapid = 2;
inline bool PDWInfoEnvelope::has_snapid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PDWInfoEnvelope::set_has_snapid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PDWInfoEnvelope::clear_has_snapid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PDWInfoEnvelope::clear_snapid() {
  if (snapid_ != &::google::protobuf::internal::kEmptyString) {
    snapid_->clear();
  }
  clear_has_snapid();
}
inline const ::std::string& PDWInfoEnvelope::snapid() const {
  return *snapid_;
}
inline void PDWInfoEnvelope::set_snapid(const ::std::string& value) {
  set_has_snapid();
  if (snapid_ == &::google::protobuf::internal::kEmptyString) {
    snapid_ = new ::std::string;
  }
  snapid_->assign(value);
}
inline void PDWInfoEnvelope::set_snapid(const char* value) {
  set_has_snapid();
  if (snapid_ == &::google::protobuf::internal::kEmptyString) {
    snapid_ = new ::std::string;
  }
  snapid_->assign(value);
}
inline void PDWInfoEnvelope::set_snapid(const char* value, size_t size) {
  set_has_snapid();
  if (snapid_ == &::google::protobuf::internal::kEmptyString) {
    snapid_ = new ::std::string;
  }
  snapid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PDWInfoEnvelope::mutable_snapid() {
  set_has_snapid();
  if (snapid_ == &::google::protobuf::internal::kEmptyString) {
    snapid_ = new ::std::string;
  }
  return snapid_;
}
inline ::std::string* PDWInfoEnvelope::release_snapid() {
  clear_has_snapid();
  if (snapid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = snapid_;
    snapid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PDWInfoEnvelope::set_allocated_snapid(::std::string* snapid) {
  if (snapid_ != &::google::protobuf::internal::kEmptyString) {
    delete snapid_;
  }
  if (snapid) {
    set_has_snapid();
    snapid_ = snapid;
  } else {
    clear_has_snapid();
    snapid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .rxdataplane_msg.PDWInfo pdws = 3;
inline int PDWInfoEnvelope::pdws_size() const {
  return pdws_.size();
}
inline void PDWInfoEnvelope::clear_pdws() {
  pdws_.Clear();
}
inline const ::rxdataplane_msg::PDWInfo& PDWInfoEnvelope::pdws(int index) const {
  return pdws_.Get(index);
}
inline ::rxdataplane_msg::PDWInfo* PDWInfoEnvelope::mutable_pdws(int index) {
  return pdws_.Mutable(index);
}
inline ::rxdataplane_msg::PDWInfo* PDWInfoEnvelope::add_pdws() {
  return pdws_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rxdataplane_msg::PDWInfo >&
PDWInfoEnvelope::pdws() const {
  return pdws_;
}
inline ::google::protobuf::RepeatedPtrField< ::rxdataplane_msg::PDWInfo >*
PDWInfoEnvelope::mutable_pdws() {
  return &pdws_;
}

// optional string segmenterName = 4 [default = "RADAR"];
inline bool PDWInfoEnvelope::has_segmentername() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PDWInfoEnvelope::set_has_segmentername() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PDWInfoEnvelope::clear_has_segmentername() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PDWInfoEnvelope::clear_segmentername() {
  if (segmentername_ != _default_segmentername_) {
    segmentername_->assign(*_default_segmentername_);
  }
  clear_has_segmentername();
}
inline const ::std::string& PDWInfoEnvelope::segmentername() const {
  return *segmentername_;
}
inline void PDWInfoEnvelope::set_segmentername(const ::std::string& value) {
  set_has_segmentername();
  if (segmentername_ == _default_segmentername_) {
    segmentername_ = new ::std::string;
  }
  segmentername_->assign(value);
}
inline void PDWInfoEnvelope::set_segmentername(const char* value) {
  set_has_segmentername();
  if (segmentername_ == _default_segmentername_) {
    segmentername_ = new ::std::string;
  }
  segmentername_->assign(value);
}
inline void PDWInfoEnvelope::set_segmentername(const char* value, size_t size) {
  set_has_segmentername();
  if (segmentername_ == _default_segmentername_) {
    segmentername_ = new ::std::string;
  }
  segmentername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PDWInfoEnvelope::mutable_segmentername() {
  set_has_segmentername();
  if (segmentername_ == _default_segmentername_) {
    segmentername_ = new ::std::string(*_default_segmentername_);
  }
  return segmentername_;
}
inline ::std::string* PDWInfoEnvelope::release_segmentername() {
  clear_has_segmentername();
  if (segmentername_ == _default_segmentername_) {
    return NULL;
  } else {
    ::std::string* temp = segmentername_;
    segmentername_ = const_cast< ::std::string*>(_default_segmentername_);
    return temp;
  }
}
inline void PDWInfoEnvelope::set_allocated_segmentername(::std::string* segmentername) {
  if (segmentername_ != _default_segmentername_) {
    delete segmentername_;
  }
  if (segmentername) {
    set_has_segmentername();
    segmentername_ = segmentername;
  } else {
    clear_has_segmentername();
    segmentername_ = const_cast< ::std::string*>(_default_segmentername_);
  }
}

// optional string metaFilename = 5 [default = "NONE"];
inline bool PDWInfoEnvelope::has_metafilename() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PDWInfoEnvelope::set_has_metafilename() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PDWInfoEnvelope::clear_has_metafilename() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PDWInfoEnvelope::clear_metafilename() {
  if (metafilename_ != _default_metafilename_) {
    metafilename_->assign(*_default_metafilename_);
  }
  clear_has_metafilename();
}
inline const ::std::string& PDWInfoEnvelope::metafilename() const {
  return *metafilename_;
}
inline void PDWInfoEnvelope::set_metafilename(const ::std::string& value) {
  set_has_metafilename();
  if (metafilename_ == _default_metafilename_) {
    metafilename_ = new ::std::string;
  }
  metafilename_->assign(value);
}
inline void PDWInfoEnvelope::set_metafilename(const char* value) {
  set_has_metafilename();
  if (metafilename_ == _default_metafilename_) {
    metafilename_ = new ::std::string;
  }
  metafilename_->assign(value);
}
inline void PDWInfoEnvelope::set_metafilename(const char* value, size_t size) {
  set_has_metafilename();
  if (metafilename_ == _default_metafilename_) {
    metafilename_ = new ::std::string;
  }
  metafilename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PDWInfoEnvelope::mutable_metafilename() {
  set_has_metafilename();
  if (metafilename_ == _default_metafilename_) {
    metafilename_ = new ::std::string(*_default_metafilename_);
  }
  return metafilename_;
}
inline ::std::string* PDWInfoEnvelope::release_metafilename() {
  clear_has_metafilename();
  if (metafilename_ == _default_metafilename_) {
    return NULL;
  } else {
    ::std::string* temp = metafilename_;
    metafilename_ = const_cast< ::std::string*>(_default_metafilename_);
    return temp;
  }
}
inline void PDWInfoEnvelope::set_allocated_metafilename(::std::string* metafilename) {
  if (metafilename_ != _default_metafilename_) {
    delete metafilename_;
  }
  if (metafilename) {
    set_has_metafilename();
    metafilename_ = metafilename;
  } else {
    clear_has_metafilename();
    metafilename_ = const_cast< ::std::string*>(_default_metafilename_);
  }
}

// optional string iqIndexFilename = 6 [default = "NONE"];
inline bool PDWInfoEnvelope::has_iqindexfilename() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PDWInfoEnvelope::set_has_iqindexfilename() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PDWInfoEnvelope::clear_has_iqindexfilename() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PDWInfoEnvelope::clear_iqindexfilename() {
  if (iqindexfilename_ != _default_iqindexfilename_) {
    iqindexfilename_->assign(*_default_iqindexfilename_);
  }
  clear_has_iqindexfilename();
}
inline const ::std::string& PDWInfoEnvelope::iqindexfilename() const {
  return *iqindexfilename_;
}
inline void PDWInfoEnvelope::set_iqindexfilename(const ::std::string& value) {
  set_has_iqindexfilename();
  if (iqindexfilename_ == _default_iqindexfilename_) {
    iqindexfilename_ = new ::std::string;
  }
  iqindexfilename_->assign(value);
}
inline void PDWInfoEnvelope::set_iqindexfilename(const char* value) {
  set_has_iqindexfilename();
  if (iqindexfilename_ == _default_iqindexfilename_) {
    iqindexfilename_ = new ::std::string;
  }
  iqindexfilename_->assign(value);
}
inline void PDWInfoEnvelope::set_iqindexfilename(const char* value, size_t size) {
  set_has_iqindexfilename();
  if (iqindexfilename_ == _default_iqindexfilename_) {
    iqindexfilename_ = new ::std::string;
  }
  iqindexfilename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PDWInfoEnvelope::mutable_iqindexfilename() {
  set_has_iqindexfilename();
  if (iqindexfilename_ == _default_iqindexfilename_) {
    iqindexfilename_ = new ::std::string(*_default_iqindexfilename_);
  }
  return iqindexfilename_;
}
inline ::std::string* PDWInfoEnvelope::release_iqindexfilename() {
  clear_has_iqindexfilename();
  if (iqindexfilename_ == _default_iqindexfilename_) {
    return NULL;
  } else {
    ::std::string* temp = iqindexfilename_;
    iqindexfilename_ = const_cast< ::std::string*>(_default_iqindexfilename_);
    return temp;
  }
}
inline void PDWInfoEnvelope::set_allocated_iqindexfilename(::std::string* iqindexfilename) {
  if (iqindexfilename_ != _default_iqindexfilename_) {
    delete iqindexfilename_;
  }
  if (iqindexfilename) {
    set_has_iqindexfilename();
    iqindexfilename_ = iqindexfilename;
  } else {
    clear_has_iqindexfilename();
    iqindexfilename_ = const_cast< ::std::string*>(_default_iqindexfilename_);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace rxdataplane_msg

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rxdataplane_msg::ModulationType>() {
  return ::rxdataplane_msg::ModulationType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_RXDataPlaneMessages_2eproto__INCLUDED
