// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FalconTriggerMessages.proto

#ifndef PROTOBUF_FalconTriggerMessages_2eproto__INCLUDED
#define PROTOBUF_FalconTriggerMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "FalconCommonMessages.pb.h"
// @@protoc_insertion_point(includes)

namespace falcon_trigger_msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_FalconTriggerMessages_2eproto();
void protobuf_AssignDesc_FalconTriggerMessages_2eproto();
void protobuf_ShutdownFile_FalconTriggerMessages_2eproto();

class Intercept;
class InterceptAmpX;
class SignalLocked;
class SignalTimeout;
class InterceptListRequest;
class RunGoNoGo;
class BlacklistRequest;
class ProcessTip;
class GeoLaunch;
class WifiLaunch;
class ReallocateResources;
class ControlUpgrade;
class RfcuSwitch;
class TGDopplerTip;

enum Intercept_TeamType {
  Intercept_TeamType_BLUE_TEAM = 0,
  Intercept_TeamType_WHITE_TEAM = 1,
  Intercept_TeamType_RED_TEAM = 2,
  Intercept_TeamType_HIGH_PRIORITY = 3
};
bool Intercept_TeamType_IsValid(int value);
const Intercept_TeamType Intercept_TeamType_TeamType_MIN = Intercept_TeamType_BLUE_TEAM;
const Intercept_TeamType Intercept_TeamType_TeamType_MAX = Intercept_TeamType_HIGH_PRIORITY;
const int Intercept_TeamType_TeamType_ARRAYSIZE = Intercept_TeamType_TeamType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Intercept_TeamType_descriptor();
inline const ::std::string& Intercept_TeamType_Name(Intercept_TeamType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Intercept_TeamType_descriptor(), value);
}
inline bool Intercept_TeamType_Parse(
    const ::std::string& name, Intercept_TeamType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Intercept_TeamType>(
    Intercept_TeamType_descriptor(), name, value);
}
enum InterceptListRequest_Type {
  InterceptListRequest_Type_STATUS = 0,
  InterceptListRequest_Type_REMOVE = 1,
  InterceptListRequest_Type_CLEAR = 2
};
bool InterceptListRequest_Type_IsValid(int value);
const InterceptListRequest_Type InterceptListRequest_Type_Type_MIN = InterceptListRequest_Type_STATUS;
const InterceptListRequest_Type InterceptListRequest_Type_Type_MAX = InterceptListRequest_Type_CLEAR;
const int InterceptListRequest_Type_Type_ARRAYSIZE = InterceptListRequest_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* InterceptListRequest_Type_descriptor();
inline const ::std::string& InterceptListRequest_Type_Name(InterceptListRequest_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    InterceptListRequest_Type_descriptor(), value);
}
inline bool InterceptListRequest_Type_Parse(
    const ::std::string& name, InterceptListRequest_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InterceptListRequest_Type>(
    InterceptListRequest_Type_descriptor(), name, value);
}
enum BlacklistRequest_Type {
  BlacklistRequest_Type_STATUS = 0,
  BlacklistRequest_Type_ADD = 1,
  BlacklistRequest_Type_REMOVE = 2
};
bool BlacklistRequest_Type_IsValid(int value);
const BlacklistRequest_Type BlacklistRequest_Type_Type_MIN = BlacklistRequest_Type_STATUS;
const BlacklistRequest_Type BlacklistRequest_Type_Type_MAX = BlacklistRequest_Type_REMOVE;
const int BlacklistRequest_Type_Type_ARRAYSIZE = BlacklistRequest_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* BlacklistRequest_Type_descriptor();
inline const ::std::string& BlacklistRequest_Type_Name(BlacklistRequest_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    BlacklistRequest_Type_descriptor(), value);
}
inline bool BlacklistRequest_Type_Parse(
    const ::std::string& name, BlacklistRequest_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BlacklistRequest_Type>(
    BlacklistRequest_Type_descriptor(), name, value);
}
// ===================================================================

class Intercept : public ::google::protobuf::Message {
 public:
  Intercept();
  virtual ~Intercept();

  Intercept(const Intercept& from);

  inline Intercept& operator=(const Intercept& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Intercept& default_instance();

  void Swap(Intercept* other);

  // implements Message ----------------------------------------------

  Intercept* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Intercept& from);
  void MergeFrom(const Intercept& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Intercept_TeamType TeamType;
  static const TeamType BLUE_TEAM = Intercept_TeamType_BLUE_TEAM;
  static const TeamType WHITE_TEAM = Intercept_TeamType_WHITE_TEAM;
  static const TeamType RED_TEAM = Intercept_TeamType_RED_TEAM;
  static const TeamType HIGH_PRIORITY = Intercept_TeamType_HIGH_PRIORITY;
  static inline bool TeamType_IsValid(int value) {
    return Intercept_TeamType_IsValid(value);
  }
  static const TeamType TeamType_MIN =
    Intercept_TeamType_TeamType_MIN;
  static const TeamType TeamType_MAX =
    Intercept_TeamType_TeamType_MAX;
  static const int TeamType_ARRAYSIZE =
    Intercept_TeamType_TeamType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TeamType_descriptor() {
    return Intercept_TeamType_descriptor();
  }
  static inline const ::std::string& TeamType_Name(TeamType value) {
    return Intercept_TeamType_Name(value);
  }
  static inline bool TeamType_Parse(const ::std::string& name,
      TeamType* value) {
    return Intercept_TeamType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "INTERCEPT"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional bool isTrigger = 2 [default = true];
  inline bool has_istrigger() const;
  inline void clear_istrigger();
  static const int kIsTriggerFieldNumber = 2;
  inline bool istrigger() const;
  inline void set_istrigger(bool value);

  // optional string signal = 3;
  inline bool has_signal() const;
  inline void clear_signal();
  static const int kSignalFieldNumber = 3;
  inline const ::std::string& signal() const;
  inline void set_signal(const ::std::string& value);
  inline void set_signal(const char* value);
  inline void set_signal(const char* value, size_t size);
  inline ::std::string* mutable_signal();
  inline ::std::string* release_signal();
  inline void set_allocated_signal(::std::string* signal);

  // optional double frequency = 4;
  inline bool has_frequency() const;
  inline void clear_frequency();
  static const int kFrequencyFieldNumber = 4;
  inline double frequency() const;
  inline void set_frequency(double value);

  // optional float bandwidth = 5;
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandwidthFieldNumber = 5;
  inline float bandwidth() const;
  inline void set_bandwidth(float value);

  // optional string receiver = 6;
  inline bool has_receiver() const;
  inline void clear_receiver();
  static const int kReceiverFieldNumber = 6;
  inline const ::std::string& receiver() const;
  inline void set_receiver(const ::std::string& value);
  inline void set_receiver(const char* value);
  inline void set_receiver(const char* value, size_t size);
  inline ::std::string* mutable_receiver();
  inline ::std::string* release_receiver();
  inline void set_allocated_receiver(::std::string* receiver);

  // optional string antenna = 7;
  inline bool has_antenna() const;
  inline void clear_antenna();
  static const int kAntennaFieldNumber = 7;
  inline const ::std::string& antenna() const;
  inline void set_antenna(const ::std::string& value);
  inline void set_antenna(const char* value);
  inline void set_antenna(const char* value, size_t size);
  inline ::std::string* mutable_antenna();
  inline ::std::string* release_antenna();
  inline void set_allocated_antenna(::std::string* antenna);

  // optional float azimuth = 8 [default = 0];
  inline bool has_azimuth() const;
  inline void clear_azimuth();
  static const int kAzimuthFieldNumber = 8;
  inline float azimuth() const;
  inline void set_azimuth(float value);

  // optional float elevation = 9 [default = 0];
  inline bool has_elevation() const;
  inline void clear_elevation();
  static const int kElevationFieldNumber = 9;
  inline float elevation() const;
  inline void set_elevation(float value);

  // optional float snr = 10 [default = 0];
  inline bool has_snr() const;
  inline void clear_snr();
  static const int kSnrFieldNumber = 10;
  inline float snr() const;
  inline void set_snr(float value);

  // optional string timestamp = 11;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 11;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  inline void set_allocated_timestamp(::std::string* timestamp);

  // optional string searchScrypt = 12;
  inline bool has_searchscrypt() const;
  inline void clear_searchscrypt();
  static const int kSearchScryptFieldNumber = 12;
  inline const ::std::string& searchscrypt() const;
  inline void set_searchscrypt(const ::std::string& value);
  inline void set_searchscrypt(const char* value);
  inline void set_searchscrypt(const char* value, size_t size);
  inline ::std::string* mutable_searchscrypt();
  inline ::std::string* release_searchscrypt();
  inline void set_allocated_searchscrypt(::std::string* searchscrypt);

  // optional int32 searchTier = 13 [default = 1];
  inline bool has_searchtier() const;
  inline void clear_searchtier();
  static const int kSearchTierFieldNumber = 13;
  inline ::google::protobuf::int32 searchtier() const;
  inline void set_searchtier(::google::protobuf::int32 value);

  // optional int32 numFrames = 14;
  inline bool has_numframes() const;
  inline void clear_numframes();
  static const int kNumFramesFieldNumber = 14;
  inline ::google::protobuf::int32 numframes() const;
  inline void set_numframes(::google::protobuf::int32 value);

  // optional string detConf = 15;
  inline bool has_detconf() const;
  inline void clear_detconf();
  static const int kDetConfFieldNumber = 15;
  inline const ::std::string& detconf() const;
  inline void set_detconf(const ::std::string& value);
  inline void set_detconf(const char* value);
  inline void set_detconf(const char* value, size_t size);
  inline ::std::string* mutable_detconf();
  inline ::std::string* release_detconf();
  inline void set_allocated_detconf(::std::string* detconf);

  // optional string procParams = 16;
  inline bool has_procparams() const;
  inline void clear_procparams();
  static const int kProcParamsFieldNumber = 16;
  inline const ::std::string& procparams() const;
  inline void set_procparams(const ::std::string& value);
  inline void set_procparams(const char* value);
  inline void set_procparams(const char* value, size_t size);
  inline ::std::string* mutable_procparams();
  inline ::std::string* release_procparams();
  inline void set_allocated_procparams(::std::string* procparams);

  // optional int32 ssc = 17 [default = -1];
  inline bool has_ssc() const;
  inline void clear_ssc();
  static const int kSscFieldNumber = 17;
  inline ::google::protobuf::int32 ssc() const;
  inline void set_ssc(::google::protobuf::int32 value);

  // optional string band = 18;
  inline bool has_band() const;
  inline void clear_band();
  static const int kBandFieldNumber = 18;
  inline const ::std::string& band() const;
  inline void set_band(const ::std::string& value);
  inline void set_band(const char* value);
  inline void set_band(const char* value, size_t size);
  inline ::std::string* mutable_band();
  inline ::std::string* release_band();
  inline void set_allocated_band(::std::string* band);

  // optional string polarization = 19;
  inline bool has_polarization() const;
  inline void clear_polarization();
  static const int kPolarizationFieldNumber = 19;
  inline const ::std::string& polarization() const;
  inline void set_polarization(const ::std::string& value);
  inline void set_polarization(const char* value);
  inline void set_polarization(const char* value, size_t size);
  inline ::std::string* mutable_polarization();
  inline ::std::string* release_polarization();
  inline void set_allocated_polarization(::std::string* polarization);

  // optional string hostname = 20 [default = ""];
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 20;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional string uniqueID = 21 [default = ""];
  inline bool has_uniqueid() const;
  inline void clear_uniqueid();
  static const int kUniqueIDFieldNumber = 21;
  inline const ::std::string& uniqueid() const;
  inline void set_uniqueid(const ::std::string& value);
  inline void set_uniqueid(const char* value);
  inline void set_uniqueid(const char* value, size_t size);
  inline ::std::string* mutable_uniqueid();
  inline ::std::string* release_uniqueid();
  inline void set_allocated_uniqueid(::std::string* uniqueid);

  // optional string uniqueField = 22 [default = ""];
  inline bool has_uniquefield() const;
  inline void clear_uniquefield();
  static const int kUniqueFieldFieldNumber = 22;
  inline const ::std::string& uniquefield() const;
  inline void set_uniquefield(const ::std::string& value);
  inline void set_uniquefield(const char* value);
  inline void set_uniquefield(const char* value, size_t size);
  inline ::std::string* mutable_uniquefield();
  inline ::std::string* release_uniquefield();
  inline void set_allocated_uniquefield(::std::string* uniquefield);

  // optional string gpsPosition = 23 [default = ""];
  inline bool has_gpsposition() const;
  inline void clear_gpsposition();
  static const int kGpsPositionFieldNumber = 23;
  inline const ::std::string& gpsposition() const;
  inline void set_gpsposition(const ::std::string& value);
  inline void set_gpsposition(const char* value);
  inline void set_gpsposition(const char* value, size_t size);
  inline ::std::string* mutable_gpsposition();
  inline ::std::string* release_gpsposition();
  inline void set_allocated_gpsposition(::std::string* gpsposition);

  // optional bool priming = 24 [default = false];
  inline bool has_priming() const;
  inline void clear_priming();
  static const int kPrimingFieldNumber = 24;
  inline bool priming() const;
  inline void set_priming(bool value);

  // optional string globalID = 25 [default = ""];
  inline bool has_globalid() const;
  inline void clear_globalid();
  static const int kGlobalIDFieldNumber = 25;
  inline const ::std::string& globalid() const;
  inline void set_globalid(const ::std::string& value);
  inline void set_globalid(const char* value);
  inline void set_globalid(const char* value, size_t size);
  inline ::std::string* mutable_globalid();
  inline ::std::string* release_globalid();
  inline void set_allocated_globalid(::std::string* globalid);

  // optional int64 feedID = 26 [default = -1];
  inline bool has_feedid() const;
  inline void clear_feedid();
  static const int kFeedIDFieldNumber = 26;
  inline ::google::protobuf::int64 feedid() const;
  inline void set_feedid(::google::protobuf::int64 value);

  // optional int64 detectionID = 27 [default = -1];
  inline bool has_detectionid() const;
  inline void clear_detectionid();
  static const int kDetectionIDFieldNumber = 27;
  inline ::google::protobuf::int64 detectionid() const;
  inline void set_detectionid(::google::protobuf::int64 value);

  // optional string receiverATN = 28 [default = ""];
  inline bool has_receiveratn() const;
  inline void clear_receiveratn();
  static const int kReceiverATNFieldNumber = 28;
  inline const ::std::string& receiveratn() const;
  inline void set_receiveratn(const ::std::string& value);
  inline void set_receiveratn(const char* value);
  inline void set_receiveratn(const char* value, size_t size);
  inline ::std::string* mutable_receiveratn();
  inline ::std::string* release_receiveratn();
  inline void set_allocated_receiveratn(::std::string* receiveratn);

  // optional .falcon_trigger_msg.Intercept.TeamType teamType = 29 [default = RED_TEAM];
  inline bool has_teamtype() const;
  inline void clear_teamtype();
  static const int kTeamTypeFieldNumber = 29;
  inline ::falcon_trigger_msg::Intercept_TeamType teamtype() const;
  inline void set_teamtype(::falcon_trigger_msg::Intercept_TeamType value);

  // optional bool noProcess = 30 [default = false];
  inline bool has_noprocess() const;
  inline void clear_noprocess();
  static const int kNoProcessFieldNumber = 30;
  inline bool noprocess() const;
  inline void set_noprocess(bool value);

  // @@protoc_insertion_point(class_scope:falcon_trigger_msg.Intercept)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_istrigger();
  inline void clear_has_istrigger();
  inline void set_has_signal();
  inline void clear_has_signal();
  inline void set_has_frequency();
  inline void clear_has_frequency();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();
  inline void set_has_receiver();
  inline void clear_has_receiver();
  inline void set_has_antenna();
  inline void clear_has_antenna();
  inline void set_has_azimuth();
  inline void clear_has_azimuth();
  inline void set_has_elevation();
  inline void clear_has_elevation();
  inline void set_has_snr();
  inline void clear_has_snr();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_searchscrypt();
  inline void clear_has_searchscrypt();
  inline void set_has_searchtier();
  inline void clear_has_searchtier();
  inline void set_has_numframes();
  inline void clear_has_numframes();
  inline void set_has_detconf();
  inline void clear_has_detconf();
  inline void set_has_procparams();
  inline void clear_has_procparams();
  inline void set_has_ssc();
  inline void clear_has_ssc();
  inline void set_has_band();
  inline void clear_has_band();
  inline void set_has_polarization();
  inline void clear_has_polarization();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_uniqueid();
  inline void clear_has_uniqueid();
  inline void set_has_uniquefield();
  inline void clear_has_uniquefield();
  inline void set_has_gpsposition();
  inline void clear_has_gpsposition();
  inline void set_has_priming();
  inline void clear_has_priming();
  inline void set_has_globalid();
  inline void clear_has_globalid();
  inline void set_has_feedid();
  inline void clear_has_feedid();
  inline void set_has_detectionid();
  inline void clear_has_detectionid();
  inline void set_has_receiveratn();
  inline void clear_has_receiveratn();
  inline void set_has_teamtype();
  inline void clear_has_teamtype();
  inline void set_has_noprocess();
  inline void clear_has_noprocess();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* signal_;
  double frequency_;
  ::std::string* receiver_;
  float bandwidth_;
  float azimuth_;
  ::std::string* antenna_;
  float elevation_;
  float snr_;
  ::std::string* timestamp_;
  ::std::string* searchscrypt_;
  ::google::protobuf::int32 searchtier_;
  ::google::protobuf::int32 numframes_;
  ::std::string* detconf_;
  ::std::string* procparams_;
  ::std::string* band_;
  ::google::protobuf::int32 ssc_;
  bool istrigger_;
  bool priming_;
  bool noprocess_;
  ::std::string* polarization_;
  ::std::string* hostname_;
  ::std::string* uniqueid_;
  ::std::string* uniquefield_;
  ::std::string* gpsposition_;
  ::std::string* globalid_;
  ::google::protobuf::int64 feedid_;
  ::google::protobuf::int64 detectionid_;
  ::std::string* receiveratn_;
  int teamtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(30 + 31) / 32];

  friend void  protobuf_AddDesc_FalconTriggerMessages_2eproto();
  friend void protobuf_AssignDesc_FalconTriggerMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconTriggerMessages_2eproto();

  void InitAsDefaultInstance();
  static Intercept* default_instance_;
};
// -------------------------------------------------------------------

class InterceptAmpX : public ::google::protobuf::Message {
 public:
  InterceptAmpX();
  virtual ~InterceptAmpX();

  InterceptAmpX(const InterceptAmpX& from);

  inline InterceptAmpX& operator=(const InterceptAmpX& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InterceptAmpX& default_instance();

  void Swap(InterceptAmpX* other);

  // implements Message ----------------------------------------------

  InterceptAmpX* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InterceptAmpX& from);
  void MergeFrom(const InterceptAmpX& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "INTERCEPT_AMPX"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional bool isTrigger = 2 [default = true];
  inline bool has_istrigger() const;
  inline void clear_istrigger();
  static const int kIsTriggerFieldNumber = 2;
  inline bool istrigger() const;
  inline void set_istrigger(bool value);

  // optional string signal = 3;
  inline bool has_signal() const;
  inline void clear_signal();
  static const int kSignalFieldNumber = 3;
  inline const ::std::string& signal() const;
  inline void set_signal(const ::std::string& value);
  inline void set_signal(const char* value);
  inline void set_signal(const char* value, size_t size);
  inline ::std::string* mutable_signal();
  inline ::std::string* release_signal();
  inline void set_allocated_signal(::std::string* signal);

  // optional double frequency = 4;
  inline bool has_frequency() const;
  inline void clear_frequency();
  static const int kFrequencyFieldNumber = 4;
  inline double frequency() const;
  inline void set_frequency(double value);

  // optional float bandwidth = 5;
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandwidthFieldNumber = 5;
  inline float bandwidth() const;
  inline void set_bandwidth(float value);

  // optional string receiver = 6;
  inline bool has_receiver() const;
  inline void clear_receiver();
  static const int kReceiverFieldNumber = 6;
  inline const ::std::string& receiver() const;
  inline void set_receiver(const ::std::string& value);
  inline void set_receiver(const char* value);
  inline void set_receiver(const char* value, size_t size);
  inline ::std::string* mutable_receiver();
  inline ::std::string* release_receiver();
  inline void set_allocated_receiver(::std::string* receiver);

  // optional string antenna = 7;
  inline bool has_antenna() const;
  inline void clear_antenna();
  static const int kAntennaFieldNumber = 7;
  inline const ::std::string& antenna() const;
  inline void set_antenna(const ::std::string& value);
  inline void set_antenna(const char* value);
  inline void set_antenna(const char* value, size_t size);
  inline ::std::string* mutable_antenna();
  inline ::std::string* release_antenna();
  inline void set_allocated_antenna(::std::string* antenna);

  // optional float azimuth = 8 [default = 0];
  inline bool has_azimuth() const;
  inline void clear_azimuth();
  static const int kAzimuthFieldNumber = 8;
  inline float azimuth() const;
  inline void set_azimuth(float value);

  // optional float elevation = 9 [default = 0];
  inline bool has_elevation() const;
  inline void clear_elevation();
  static const int kElevationFieldNumber = 9;
  inline float elevation() const;
  inline void set_elevation(float value);

  // optional float snr = 10 [default = 0];
  inline bool has_snr() const;
  inline void clear_snr();
  static const int kSnrFieldNumber = 10;
  inline float snr() const;
  inline void set_snr(float value);

  // optional string timestamp = 11;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 11;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  inline void set_allocated_timestamp(::std::string* timestamp);

  // optional string searchScrypt = 12;
  inline bool has_searchscrypt() const;
  inline void clear_searchscrypt();
  static const int kSearchScryptFieldNumber = 12;
  inline const ::std::string& searchscrypt() const;
  inline void set_searchscrypt(const ::std::string& value);
  inline void set_searchscrypt(const char* value);
  inline void set_searchscrypt(const char* value, size_t size);
  inline ::std::string* mutable_searchscrypt();
  inline ::std::string* release_searchscrypt();
  inline void set_allocated_searchscrypt(::std::string* searchscrypt);

  // optional int32 searchTier = 13 [default = 1];
  inline bool has_searchtier() const;
  inline void clear_searchtier();
  static const int kSearchTierFieldNumber = 13;
  inline ::google::protobuf::int32 searchtier() const;
  inline void set_searchtier(::google::protobuf::int32 value);

  // optional int32 numFrames = 14;
  inline bool has_numframes() const;
  inline void clear_numframes();
  static const int kNumFramesFieldNumber = 14;
  inline ::google::protobuf::int32 numframes() const;
  inline void set_numframes(::google::protobuf::int32 value);

  // optional string detConf = 15;
  inline bool has_detconf() const;
  inline void clear_detconf();
  static const int kDetConfFieldNumber = 15;
  inline const ::std::string& detconf() const;
  inline void set_detconf(const ::std::string& value);
  inline void set_detconf(const char* value);
  inline void set_detconf(const char* value, size_t size);
  inline ::std::string* mutable_detconf();
  inline ::std::string* release_detconf();
  inline void set_allocated_detconf(::std::string* detconf);

  // optional string procParams = 16;
  inline bool has_procparams() const;
  inline void clear_procparams();
  static const int kProcParamsFieldNumber = 16;
  inline const ::std::string& procparams() const;
  inline void set_procparams(const ::std::string& value);
  inline void set_procparams(const char* value);
  inline void set_procparams(const char* value, size_t size);
  inline ::std::string* mutable_procparams();
  inline ::std::string* release_procparams();
  inline void set_allocated_procparams(::std::string* procparams);

  // optional string hostname = 17 [default = ""];
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 17;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional string uniqueID = 18 [default = ""];
  inline bool has_uniqueid() const;
  inline void clear_uniqueid();
  static const int kUniqueIDFieldNumber = 18;
  inline const ::std::string& uniqueid() const;
  inline void set_uniqueid(const ::std::string& value);
  inline void set_uniqueid(const char* value);
  inline void set_uniqueid(const char* value, size_t size);
  inline ::std::string* mutable_uniqueid();
  inline ::std::string* release_uniqueid();
  inline void set_allocated_uniqueid(::std::string* uniqueid);

  // optional string uniqueField = 19 [default = ""];
  inline bool has_uniquefield() const;
  inline void clear_uniquefield();
  static const int kUniqueFieldFieldNumber = 19;
  inline const ::std::string& uniquefield() const;
  inline void set_uniquefield(const ::std::string& value);
  inline void set_uniquefield(const char* value);
  inline void set_uniquefield(const char* value, size_t size);
  inline ::std::string* mutable_uniquefield();
  inline ::std::string* release_uniquefield();
  inline void set_allocated_uniquefield(::std::string* uniquefield);

  // optional string gpsPosition = 20 [default = ""];
  inline bool has_gpsposition() const;
  inline void clear_gpsposition();
  static const int kGpsPositionFieldNumber = 20;
  inline const ::std::string& gpsposition() const;
  inline void set_gpsposition(const ::std::string& value);
  inline void set_gpsposition(const char* value);
  inline void set_gpsposition(const char* value, size_t size);
  inline ::std::string* mutable_gpsposition();
  inline ::std::string* release_gpsposition();
  inline void set_allocated_gpsposition(::std::string* gpsposition);

  // optional bool priming = 21 [default = false];
  inline bool has_priming() const;
  inline void clear_priming();
  static const int kPrimingFieldNumber = 21;
  inline bool priming() const;
  inline void set_priming(bool value);

  // @@protoc_insertion_point(class_scope:falcon_trigger_msg.InterceptAmpX)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_istrigger();
  inline void clear_has_istrigger();
  inline void set_has_signal();
  inline void clear_has_signal();
  inline void set_has_frequency();
  inline void clear_has_frequency();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();
  inline void set_has_receiver();
  inline void clear_has_receiver();
  inline void set_has_antenna();
  inline void clear_has_antenna();
  inline void set_has_azimuth();
  inline void clear_has_azimuth();
  inline void set_has_elevation();
  inline void clear_has_elevation();
  inline void set_has_snr();
  inline void clear_has_snr();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_searchscrypt();
  inline void clear_has_searchscrypt();
  inline void set_has_searchtier();
  inline void clear_has_searchtier();
  inline void set_has_numframes();
  inline void clear_has_numframes();
  inline void set_has_detconf();
  inline void clear_has_detconf();
  inline void set_has_procparams();
  inline void clear_has_procparams();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_uniqueid();
  inline void clear_has_uniqueid();
  inline void set_has_uniquefield();
  inline void clear_has_uniquefield();
  inline void set_has_gpsposition();
  inline void clear_has_gpsposition();
  inline void set_has_priming();
  inline void clear_has_priming();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* signal_;
  double frequency_;
  ::std::string* receiver_;
  float bandwidth_;
  float azimuth_;
  ::std::string* antenna_;
  float elevation_;
  float snr_;
  ::std::string* timestamp_;
  ::std::string* searchscrypt_;
  bool istrigger_;
  bool priming_;
  ::google::protobuf::int32 searchtier_;
  ::std::string* detconf_;
  ::std::string* procparams_;
  ::std::string* hostname_;
  ::std::string* uniqueid_;
  ::std::string* uniquefield_;
  ::std::string* gpsposition_;
  ::google::protobuf::int32 numframes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];

  friend void  protobuf_AddDesc_FalconTriggerMessages_2eproto();
  friend void protobuf_AssignDesc_FalconTriggerMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconTriggerMessages_2eproto();

  void InitAsDefaultInstance();
  static InterceptAmpX* default_instance_;
};
// -------------------------------------------------------------------

class SignalLocked : public ::google::protobuf::Message {
 public:
  SignalLocked();
  virtual ~SignalLocked();

  SignalLocked(const SignalLocked& from);

  inline SignalLocked& operator=(const SignalLocked& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignalLocked& default_instance();

  void Swap(SignalLocked* other);

  // implements Message ----------------------------------------------

  SignalLocked* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignalLocked& from);
  void MergeFrom(const SignalLocked& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SIGNAL_LOCKED"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional bool isTrigger = 2 [default = true];
  inline bool has_istrigger() const;
  inline void clear_istrigger();
  static const int kIsTriggerFieldNumber = 2;
  inline bool istrigger() const;
  inline void set_istrigger(bool value);

  // optional int32 appID = 3;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 3;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // optional string antenna = 4;
  inline bool has_antenna() const;
  inline void clear_antenna();
  static const int kAntennaFieldNumber = 4;
  inline const ::std::string& antenna() const;
  inline void set_antenna(const ::std::string& value);
  inline void set_antenna(const char* value);
  inline void set_antenna(const char* value, size_t size);
  inline ::std::string* mutable_antenna();
  inline ::std::string* release_antenna();
  inline void set_allocated_antenna(::std::string* antenna);

  // @@protoc_insertion_point(class_scope:falcon_trigger_msg.SignalLocked)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_istrigger();
  inline void clear_has_istrigger();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_antenna();
  inline void clear_has_antenna();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  bool istrigger_;
  ::google::protobuf::int32 appid_;
  ::std::string* antenna_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_FalconTriggerMessages_2eproto();
  friend void protobuf_AssignDesc_FalconTriggerMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconTriggerMessages_2eproto();

  void InitAsDefaultInstance();
  static SignalLocked* default_instance_;
};
// -------------------------------------------------------------------

class SignalTimeout : public ::google::protobuf::Message {
 public:
  SignalTimeout();
  virtual ~SignalTimeout();

  SignalTimeout(const SignalTimeout& from);

  inline SignalTimeout& operator=(const SignalTimeout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignalTimeout& default_instance();

  void Swap(SignalTimeout* other);

  // implements Message ----------------------------------------------

  SignalTimeout* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignalTimeout& from);
  void MergeFrom(const SignalTimeout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SIGNAL_TIMEOUT"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional bool isTrigger = 2 [default = true];
  inline bool has_istrigger() const;
  inline void clear_istrigger();
  static const int kIsTriggerFieldNumber = 2;
  inline bool istrigger() const;
  inline void set_istrigger(bool value);

  // optional int32 appID = 3;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 3;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_trigger_msg.SignalTimeout)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_istrigger();
  inline void clear_has_istrigger();
  inline void set_has_appid();
  inline void clear_has_appid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  bool istrigger_;
  ::google::protobuf::int32 appid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconTriggerMessages_2eproto();
  friend void protobuf_AssignDesc_FalconTriggerMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconTriggerMessages_2eproto();

  void InitAsDefaultInstance();
  static SignalTimeout* default_instance_;
};
// -------------------------------------------------------------------

class InterceptListRequest : public ::google::protobuf::Message {
 public:
  InterceptListRequest();
  virtual ~InterceptListRequest();

  InterceptListRequest(const InterceptListRequest& from);

  inline InterceptListRequest& operator=(const InterceptListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InterceptListRequest& default_instance();

  void Swap(InterceptListRequest* other);

  // implements Message ----------------------------------------------

  InterceptListRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InterceptListRequest& from);
  void MergeFrom(const InterceptListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef InterceptListRequest_Type Type;
  static const Type STATUS = InterceptListRequest_Type_STATUS;
  static const Type REMOVE = InterceptListRequest_Type_REMOVE;
  static const Type CLEAR = InterceptListRequest_Type_CLEAR;
  static inline bool Type_IsValid(int value) {
    return InterceptListRequest_Type_IsValid(value);
  }
  static const Type Type_MIN =
    InterceptListRequest_Type_Type_MIN;
  static const Type Type_MAX =
    InterceptListRequest_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    InterceptListRequest_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return InterceptListRequest_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return InterceptListRequest_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return InterceptListRequest_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "INTERCEPT_LIST_REQUEST"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional bool isTrigger = 2 [default = true];
  inline bool has_istrigger() const;
  inline void clear_istrigger();
  static const int kIsTriggerFieldNumber = 2;
  inline bool istrigger() const;
  inline void set_istrigger(bool value);

  // optional .falcon_trigger_msg.InterceptListRequest.Type requestType = 3;
  inline bool has_requesttype() const;
  inline void clear_requesttype();
  static const int kRequestTypeFieldNumber = 3;
  inline ::falcon_trigger_msg::InterceptListRequest_Type requesttype() const;
  inline void set_requesttype(::falcon_trigger_msg::InterceptListRequest_Type value);

  // optional string uniqueID = 4 [default = ""];
  inline bool has_uniqueid() const;
  inline void clear_uniqueid();
  static const int kUniqueIDFieldNumber = 4;
  inline const ::std::string& uniqueid() const;
  inline void set_uniqueid(const ::std::string& value);
  inline void set_uniqueid(const char* value);
  inline void set_uniqueid(const char* value, size_t size);
  inline ::std::string* mutable_uniqueid();
  inline ::std::string* release_uniqueid();
  inline void set_allocated_uniqueid(::std::string* uniqueid);

  // @@protoc_insertion_point(class_scope:falcon_trigger_msg.InterceptListRequest)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_istrigger();
  inline void clear_has_istrigger();
  inline void set_has_requesttype();
  inline void clear_has_requesttype();
  inline void set_has_uniqueid();
  inline void clear_has_uniqueid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  bool istrigger_;
  int requesttype_;
  ::std::string* uniqueid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_FalconTriggerMessages_2eproto();
  friend void protobuf_AssignDesc_FalconTriggerMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconTriggerMessages_2eproto();

  void InitAsDefaultInstance();
  static InterceptListRequest* default_instance_;
};
// -------------------------------------------------------------------

class RunGoNoGo : public ::google::protobuf::Message {
 public:
  RunGoNoGo();
  virtual ~RunGoNoGo();

  RunGoNoGo(const RunGoNoGo& from);

  inline RunGoNoGo& operator=(const RunGoNoGo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RunGoNoGo& default_instance();

  void Swap(RunGoNoGo* other);

  // implements Message ----------------------------------------------

  RunGoNoGo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RunGoNoGo& from);
  void MergeFrom(const RunGoNoGo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "RUN_GO_NOGO"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional bool isTrigger = 2 [default = true];
  inline bool has_istrigger() const;
  inline void clear_istrigger();
  static const int kIsTriggerFieldNumber = 2;
  inline bool istrigger() const;
  inline void set_istrigger(bool value);

  // @@protoc_insertion_point(class_scope:falcon_trigger_msg.RunGoNoGo)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_istrigger();
  inline void clear_has_istrigger();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  bool istrigger_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconTriggerMessages_2eproto();
  friend void protobuf_AssignDesc_FalconTriggerMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconTriggerMessages_2eproto();

  void InitAsDefaultInstance();
  static RunGoNoGo* default_instance_;
};
// -------------------------------------------------------------------

class BlacklistRequest : public ::google::protobuf::Message {
 public:
  BlacklistRequest();
  virtual ~BlacklistRequest();

  BlacklistRequest(const BlacklistRequest& from);

  inline BlacklistRequest& operator=(const BlacklistRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlacklistRequest& default_instance();

  void Swap(BlacklistRequest* other);

  // implements Message ----------------------------------------------

  BlacklistRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlacklistRequest& from);
  void MergeFrom(const BlacklistRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef BlacklistRequest_Type Type;
  static const Type STATUS = BlacklistRequest_Type_STATUS;
  static const Type ADD = BlacklistRequest_Type_ADD;
  static const Type REMOVE = BlacklistRequest_Type_REMOVE;
  static inline bool Type_IsValid(int value) {
    return BlacklistRequest_Type_IsValid(value);
  }
  static const Type Type_MIN =
    BlacklistRequest_Type_Type_MIN;
  static const Type Type_MAX =
    BlacklistRequest_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    BlacklistRequest_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return BlacklistRequest_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return BlacklistRequest_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return BlacklistRequest_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "BLACKLIST_REQUEST"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional bool isTrigger = 2 [default = true];
  inline bool has_istrigger() const;
  inline void clear_istrigger();
  static const int kIsTriggerFieldNumber = 2;
  inline bool istrigger() const;
  inline void set_istrigger(bool value);

  // optional .falcon_trigger_msg.BlacklistRequest.Type requestType = 3;
  inline bool has_requesttype() const;
  inline void clear_requesttype();
  static const int kRequestTypeFieldNumber = 3;
  inline ::falcon_trigger_msg::BlacklistRequest_Type requesttype() const;
  inline void set_requesttype(::falcon_trigger_msg::BlacklistRequest_Type value);

  // optional .falcon_common_msg.BlacklistEntry entry = 4;
  inline bool has_entry() const;
  inline void clear_entry();
  static const int kEntryFieldNumber = 4;
  inline const ::falcon_common_msg::BlacklistEntry& entry() const;
  inline ::falcon_common_msg::BlacklistEntry* mutable_entry();
  inline ::falcon_common_msg::BlacklistEntry* release_entry();
  inline void set_allocated_entry(::falcon_common_msg::BlacklistEntry* entry);

  // optional string uniqueID = 5 [default = ""];
  inline bool has_uniqueid() const;
  inline void clear_uniqueid();
  static const int kUniqueIDFieldNumber = 5;
  inline const ::std::string& uniqueid() const;
  inline void set_uniqueid(const ::std::string& value);
  inline void set_uniqueid(const char* value);
  inline void set_uniqueid(const char* value, size_t size);
  inline ::std::string* mutable_uniqueid();
  inline ::std::string* release_uniqueid();
  inline void set_allocated_uniqueid(::std::string* uniqueid);

  // @@protoc_insertion_point(class_scope:falcon_trigger_msg.BlacklistRequest)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_istrigger();
  inline void clear_has_istrigger();
  inline void set_has_requesttype();
  inline void clear_has_requesttype();
  inline void set_has_entry();
  inline void clear_has_entry();
  inline void set_has_uniqueid();
  inline void clear_has_uniqueid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  bool istrigger_;
  int requesttype_;
  ::falcon_common_msg::BlacklistEntry* entry_;
  ::std::string* uniqueid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_FalconTriggerMessages_2eproto();
  friend void protobuf_AssignDesc_FalconTriggerMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconTriggerMessages_2eproto();

  void InitAsDefaultInstance();
  static BlacklistRequest* default_instance_;
};
// -------------------------------------------------------------------

class ProcessTip : public ::google::protobuf::Message {
 public:
  ProcessTip();
  virtual ~ProcessTip();

  ProcessTip(const ProcessTip& from);

  inline ProcessTip& operator=(const ProcessTip& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessTip& default_instance();

  void Swap(ProcessTip* other);

  // implements Message ----------------------------------------------

  ProcessTip* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcessTip& from);
  void MergeFrom(const ProcessTip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "PROCESS_TIP"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional bool isTrigger = 2 [default = true];
  inline bool has_istrigger() const;
  inline void clear_istrigger();
  static const int kIsTriggerFieldNumber = 2;
  inline bool istrigger() const;
  inline void set_istrigger(bool value);

  // optional int32 soi = 3;
  inline bool has_soi() const;
  inline void clear_soi();
  static const int kSoiFieldNumber = 3;
  inline ::google::protobuf::int32 soi() const;
  inline void set_soi(::google::protobuf::int32 value);

  // optional double frequency = 4;
  inline bool has_frequency() const;
  inline void clear_frequency();
  static const int kFrequencyFieldNumber = 4;
  inline double frequency() const;
  inline void set_frequency(double value);

  // optional float latitude = 5;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 5;
  inline float latitude() const;
  inline void set_latitude(float value);

  // optional float longitude = 6;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 6;
  inline float longitude() const;
  inline void set_longitude(float value);

  // optional double idNumber = 7;
  inline bool has_idnumber() const;
  inline void clear_idnumber();
  static const int kIdNumberFieldNumber = 7;
  inline double idnumber() const;
  inline void set_idnumber(double value);

  // @@protoc_insertion_point(class_scope:falcon_trigger_msg.ProcessTip)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_istrigger();
  inline void clear_has_istrigger();
  inline void set_has_soi();
  inline void clear_has_soi();
  inline void set_has_frequency();
  inline void clear_has_frequency();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_idnumber();
  inline void clear_has_idnumber();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  bool istrigger_;
  ::google::protobuf::int32 soi_;
  double frequency_;
  float latitude_;
  float longitude_;
  double idnumber_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_FalconTriggerMessages_2eproto();
  friend void protobuf_AssignDesc_FalconTriggerMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconTriggerMessages_2eproto();

  void InitAsDefaultInstance();
  static ProcessTip* default_instance_;
};
// -------------------------------------------------------------------

class GeoLaunch : public ::google::protobuf::Message {
 public:
  GeoLaunch();
  virtual ~GeoLaunch();

  GeoLaunch(const GeoLaunch& from);

  inline GeoLaunch& operator=(const GeoLaunch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GeoLaunch& default_instance();

  void Swap(GeoLaunch* other);

  // implements Message ----------------------------------------------

  GeoLaunch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GeoLaunch& from);
  void MergeFrom(const GeoLaunch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "GEO_LAUNCH"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional bool isTrigger = 2 [default = true];
  inline bool has_istrigger() const;
  inline void clear_istrigger();
  static const int kIsTriggerFieldNumber = 2;
  inline bool istrigger() const;
  inline void set_istrigger(bool value);

  // optional float cf = 3;
  inline bool has_cf() const;
  inline void clear_cf();
  static const int kCfFieldNumber = 3;
  inline float cf() const;
  inline void set_cf(float value);

  // optional int32 chan = 4;
  inline bool has_chan() const;
  inline void clear_chan();
  static const int kChanFieldNumber = 4;
  inline ::google::protobuf::int32 chan() const;
  inline void set_chan(::google::protobuf::int32 value);

  // optional int32 az = 5;
  inline bool has_az() const;
  inline void clear_az();
  static const int kAzFieldNumber = 5;
  inline ::google::protobuf::int32 az() const;
  inline void set_az(::google::protobuf::int32 value);

  // optional float lat = 6;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 6;
  inline float lat() const;
  inline void set_lat(float value);

  // optional float lon = 7;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 7;
  inline float lon() const;
  inline void set_lon(float value);

  // optional string scrypt = 8;
  inline bool has_scrypt() const;
  inline void clear_scrypt();
  static const int kScryptFieldNumber = 8;
  inline const ::std::string& scrypt() const;
  inline void set_scrypt(const ::std::string& value);
  inline void set_scrypt(const char* value);
  inline void set_scrypt(const char* value, size_t size);
  inline ::std::string* mutable_scrypt();
  inline ::std::string* release_scrypt();
  inline void set_allocated_scrypt(::std::string* scrypt);

  // optional string rcvr_name = 9;
  inline bool has_rcvr_name() const;
  inline void clear_rcvr_name();
  static const int kRcvrNameFieldNumber = 9;
  inline const ::std::string& rcvr_name() const;
  inline void set_rcvr_name(const ::std::string& value);
  inline void set_rcvr_name(const char* value);
  inline void set_rcvr_name(const char* value, size_t size);
  inline ::std::string* mutable_rcvr_name();
  inline ::std::string* release_rcvr_name();
  inline void set_allocated_rcvr_name(::std::string* rcvr_name);

  // optional double message_id = 10;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 10;
  inline double message_id() const;
  inline void set_message_id(double value);

  // @@protoc_insertion_point(class_scope:falcon_trigger_msg.GeoLaunch)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_istrigger();
  inline void clear_has_istrigger();
  inline void set_has_cf();
  inline void clear_has_cf();
  inline void set_has_chan();
  inline void clear_has_chan();
  inline void set_has_az();
  inline void clear_has_az();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_scrypt();
  inline void clear_has_scrypt();
  inline void set_has_rcvr_name();
  inline void clear_has_rcvr_name();
  inline void set_has_message_id();
  inline void clear_has_message_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  bool istrigger_;
  float cf_;
  ::google::protobuf::int32 chan_;
  ::google::protobuf::int32 az_;
  float lat_;
  float lon_;
  ::std::string* scrypt_;
  ::std::string* rcvr_name_;
  double message_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_FalconTriggerMessages_2eproto();
  friend void protobuf_AssignDesc_FalconTriggerMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconTriggerMessages_2eproto();

  void InitAsDefaultInstance();
  static GeoLaunch* default_instance_;
};
// -------------------------------------------------------------------

class WifiLaunch : public ::google::protobuf::Message {
 public:
  WifiLaunch();
  virtual ~WifiLaunch();

  WifiLaunch(const WifiLaunch& from);

  inline WifiLaunch& operator=(const WifiLaunch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WifiLaunch& default_instance();

  void Swap(WifiLaunch* other);

  // implements Message ----------------------------------------------

  WifiLaunch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WifiLaunch& from);
  void MergeFrom(const WifiLaunch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "WIFI_LAUNCH"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional bool isTrigger = 2 [default = true];
  inline bool has_istrigger() const;
  inline void clear_istrigger();
  static const int kIsTriggerFieldNumber = 2;
  inline bool istrigger() const;
  inline void set_istrigger(bool value);

  // optional string infile = 3;
  inline bool has_infile() const;
  inline void clear_infile();
  static const int kInfileFieldNumber = 3;
  inline const ::std::string& infile() const;
  inline void set_infile(const ::std::string& value);
  inline void set_infile(const char* value);
  inline void set_infile(const char* value, size_t size);
  inline ::std::string* mutable_infile();
  inline ::std::string* release_infile();
  inline void set_allocated_infile(::std::string* infile);

  // optional string mac = 4;
  inline bool has_mac() const;
  inline void clear_mac();
  static const int kMacFieldNumber = 4;
  inline const ::std::string& mac() const;
  inline void set_mac(const ::std::string& value);
  inline void set_mac(const char* value);
  inline void set_mac(const char* value, size_t size);
  inline ::std::string* mutable_mac();
  inline ::std::string* release_mac();
  inline void set_allocated_mac(::std::string* mac);

  // optional string frameType = 5;
  inline bool has_frametype() const;
  inline void clear_frametype();
  static const int kFrameTypeFieldNumber = 5;
  inline const ::std::string& frametype() const;
  inline void set_frametype(const ::std::string& value);
  inline void set_frametype(const char* value);
  inline void set_frametype(const char* value, size_t size);
  inline ::std::string* mutable_frametype();
  inline ::std::string* release_frametype();
  inline void set_allocated_frametype(::std::string* frametype);

  // optional string csvfile = 6;
  inline bool has_csvfile() const;
  inline void clear_csvfile();
  static const int kCsvfileFieldNumber = 6;
  inline const ::std::string& csvfile() const;
  inline void set_csvfile(const ::std::string& value);
  inline void set_csvfile(const char* value);
  inline void set_csvfile(const char* value, size_t size);
  inline ::std::string* mutable_csvfile();
  inline ::std::string* release_csvfile();
  inline void set_allocated_csvfile(::std::string* csvfile);

  // optional int32 chan = 7;
  inline bool has_chan() const;
  inline void clear_chan();
  static const int kChanFieldNumber = 7;
  inline ::google::protobuf::int32 chan() const;
  inline void set_chan(::google::protobuf::int32 value);

  // optional double message_id = 8;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 8;
  inline double message_id() const;
  inline void set_message_id(double value);

  // @@protoc_insertion_point(class_scope:falcon_trigger_msg.WifiLaunch)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_istrigger();
  inline void clear_has_istrigger();
  inline void set_has_infile();
  inline void clear_has_infile();
  inline void set_has_mac();
  inline void clear_has_mac();
  inline void set_has_frametype();
  inline void clear_has_frametype();
  inline void set_has_csvfile();
  inline void clear_has_csvfile();
  inline void set_has_chan();
  inline void clear_has_chan();
  inline void set_has_message_id();
  inline void clear_has_message_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* infile_;
  ::std::string* mac_;
  bool istrigger_;
  ::google::protobuf::int32 chan_;
  ::std::string* frametype_;
  ::std::string* csvfile_;
  double message_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_FalconTriggerMessages_2eproto();
  friend void protobuf_AssignDesc_FalconTriggerMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconTriggerMessages_2eproto();

  void InitAsDefaultInstance();
  static WifiLaunch* default_instance_;
};
// -------------------------------------------------------------------

class ReallocateResources : public ::google::protobuf::Message {
 public:
  ReallocateResources();
  virtual ~ReallocateResources();

  ReallocateResources(const ReallocateResources& from);

  inline ReallocateResources& operator=(const ReallocateResources& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReallocateResources& default_instance();

  void Swap(ReallocateResources* other);

  // implements Message ----------------------------------------------

  ReallocateResources* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReallocateResources& from);
  void MergeFrom(const ReallocateResources& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "REALLOCATE_RESOURCES"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional bool isTrigger = 2 [default = true];
  inline bool has_istrigger() const;
  inline void clear_istrigger();
  static const int kIsTriggerFieldNumber = 2;
  inline bool istrigger() const;
  inline void set_istrigger(bool value);

  // optional int32 appID = 3;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIDFieldNumber = 3;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_trigger_msg.ReallocateResources)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_istrigger();
  inline void clear_has_istrigger();
  inline void set_has_appid();
  inline void clear_has_appid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  bool istrigger_;
  ::google::protobuf::int32 appid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconTriggerMessages_2eproto();
  friend void protobuf_AssignDesc_FalconTriggerMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconTriggerMessages_2eproto();

  void InitAsDefaultInstance();
  static ReallocateResources* default_instance_;
};
// -------------------------------------------------------------------

class ControlUpgrade : public ::google::protobuf::Message {
 public:
  ControlUpgrade();
  virtual ~ControlUpgrade();

  ControlUpgrade(const ControlUpgrade& from);

  inline ControlUpgrade& operator=(const ControlUpgrade& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlUpgrade& default_instance();

  void Swap(ControlUpgrade* other);

  // implements Message ----------------------------------------------

  ControlUpgrade* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ControlUpgrade& from);
  void MergeFrom(const ControlUpgrade& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "CONTROL_UPGRADE"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional bool isTrigger = 2 [default = true];
  inline bool has_istrigger() const;
  inline void clear_istrigger();
  static const int kIsTriggerFieldNumber = 2;
  inline bool istrigger() const;
  inline void set_istrigger(bool value);

  // @@protoc_insertion_point(class_scope:falcon_trigger_msg.ControlUpgrade)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_istrigger();
  inline void clear_has_istrigger();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  bool istrigger_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_FalconTriggerMessages_2eproto();
  friend void protobuf_AssignDesc_FalconTriggerMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconTriggerMessages_2eproto();

  void InitAsDefaultInstance();
  static ControlUpgrade* default_instance_;
};
// -------------------------------------------------------------------

class RfcuSwitch : public ::google::protobuf::Message {
 public:
  RfcuSwitch();
  virtual ~RfcuSwitch();

  RfcuSwitch(const RfcuSwitch& from);

  inline RfcuSwitch& operator=(const RfcuSwitch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RfcuSwitch& default_instance();

  void Swap(RfcuSwitch* other);

  // implements Message ----------------------------------------------

  RfcuSwitch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RfcuSwitch& from);
  void MergeFrom(const RfcuSwitch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "RFCU_SWITCH"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional bool isTrigger = 2 [default = true];
  inline bool has_istrigger() const;
  inline void clear_istrigger();
  static const int kIsTriggerFieldNumber = 2;
  inline bool istrigger() const;
  inline void set_istrigger(bool value);

  // optional int32 standbyState = 3;
  inline bool has_standbystate() const;
  inline void clear_standbystate();
  static const int kStandbyStateFieldNumber = 3;
  inline ::google::protobuf::int32 standbystate() const;
  inline void set_standbystate(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:falcon_trigger_msg.RfcuSwitch)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_istrigger();
  inline void clear_has_istrigger();
  inline void set_has_standbystate();
  inline void clear_has_standbystate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  bool istrigger_;
  ::google::protobuf::int32 standbystate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FalconTriggerMessages_2eproto();
  friend void protobuf_AssignDesc_FalconTriggerMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconTriggerMessages_2eproto();

  void InitAsDefaultInstance();
  static RfcuSwitch* default_instance_;
};
// -------------------------------------------------------------------

class TGDopplerTip : public ::google::protobuf::Message {
 public:
  TGDopplerTip();
  virtual ~TGDopplerTip();

  TGDopplerTip(const TGDopplerTip& from);

  inline TGDopplerTip& operator=(const TGDopplerTip& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TGDopplerTip& default_instance();

  void Swap(TGDopplerTip* other);

  // implements Message ----------------------------------------------

  TGDopplerTip* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TGDopplerTip& from);
  void MergeFrom(const TGDopplerTip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "TG_DOPPLER_TIP"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional bool isTrigger = 2 [default = true];
  inline bool has_istrigger() const;
  inline void clear_istrigger();
  static const int kIsTriggerFieldNumber = 2;
  inline bool istrigger() const;
  inline void set_istrigger(bool value);

  // optional string globalID = 3;
  inline bool has_globalid() const;
  inline void clear_globalid();
  static const int kGlobalIDFieldNumber = 3;
  inline const ::std::string& globalid() const;
  inline void set_globalid(const ::std::string& value);
  inline void set_globalid(const char* value);
  inline void set_globalid(const char* value, size_t size);
  inline ::std::string* mutable_globalid();
  inline ::std::string* release_globalid();
  inline void set_allocated_globalid(::std::string* globalid);

  // optional double frequency = 4;
  inline bool has_frequency() const;
  inline void clear_frequency();
  static const int kFrequencyFieldNumber = 4;
  inline double frequency() const;
  inline void set_frequency(double value);

  // @@protoc_insertion_point(class_scope:falcon_trigger_msg.TGDopplerTip)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_istrigger();
  inline void clear_has_istrigger();
  inline void set_has_globalid();
  inline void clear_has_globalid();
  inline void set_has_frequency();
  inline void clear_has_frequency();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* globalid_;
  double frequency_;
  bool istrigger_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_FalconTriggerMessages_2eproto();
  friend void protobuf_AssignDesc_FalconTriggerMessages_2eproto();
  friend void protobuf_ShutdownFile_FalconTriggerMessages_2eproto();

  void InitAsDefaultInstance();
  static TGDopplerTip* default_instance_;
};
// ===================================================================


// ===================================================================

// Intercept

// optional string msgName = 1 [default = "INTERCEPT"];
inline bool Intercept::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Intercept::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Intercept::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Intercept::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& Intercept::msgname() const {
  return *msgname_;
}
inline void Intercept::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void Intercept::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void Intercept::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Intercept::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* Intercept::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void Intercept::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional bool isTrigger = 2 [default = true];
inline bool Intercept::has_istrigger() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Intercept::set_has_istrigger() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Intercept::clear_has_istrigger() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Intercept::clear_istrigger() {
  istrigger_ = true;
  clear_has_istrigger();
}
inline bool Intercept::istrigger() const {
  return istrigger_;
}
inline void Intercept::set_istrigger(bool value) {
  set_has_istrigger();
  istrigger_ = value;
}

// optional string signal = 3;
inline bool Intercept::has_signal() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Intercept::set_has_signal() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Intercept::clear_has_signal() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Intercept::clear_signal() {
  if (signal_ != &::google::protobuf::internal::kEmptyString) {
    signal_->clear();
  }
  clear_has_signal();
}
inline const ::std::string& Intercept::signal() const {
  return *signal_;
}
inline void Intercept::set_signal(const ::std::string& value) {
  set_has_signal();
  if (signal_ == &::google::protobuf::internal::kEmptyString) {
    signal_ = new ::std::string;
  }
  signal_->assign(value);
}
inline void Intercept::set_signal(const char* value) {
  set_has_signal();
  if (signal_ == &::google::protobuf::internal::kEmptyString) {
    signal_ = new ::std::string;
  }
  signal_->assign(value);
}
inline void Intercept::set_signal(const char* value, size_t size) {
  set_has_signal();
  if (signal_ == &::google::protobuf::internal::kEmptyString) {
    signal_ = new ::std::string;
  }
  signal_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Intercept::mutable_signal() {
  set_has_signal();
  if (signal_ == &::google::protobuf::internal::kEmptyString) {
    signal_ = new ::std::string;
  }
  return signal_;
}
inline ::std::string* Intercept::release_signal() {
  clear_has_signal();
  if (signal_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signal_;
    signal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Intercept::set_allocated_signal(::std::string* signal) {
  if (signal_ != &::google::protobuf::internal::kEmptyString) {
    delete signal_;
  }
  if (signal) {
    set_has_signal();
    signal_ = signal;
  } else {
    clear_has_signal();
    signal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double frequency = 4;
inline bool Intercept::has_frequency() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Intercept::set_has_frequency() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Intercept::clear_has_frequency() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Intercept::clear_frequency() {
  frequency_ = 0;
  clear_has_frequency();
}
inline double Intercept::frequency() const {
  return frequency_;
}
inline void Intercept::set_frequency(double value) {
  set_has_frequency();
  frequency_ = value;
}

// optional float bandwidth = 5;
inline bool Intercept::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Intercept::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Intercept::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Intercept::clear_bandwidth() {
  bandwidth_ = 0;
  clear_has_bandwidth();
}
inline float Intercept::bandwidth() const {
  return bandwidth_;
}
inline void Intercept::set_bandwidth(float value) {
  set_has_bandwidth();
  bandwidth_ = value;
}

// optional string receiver = 6;
inline bool Intercept::has_receiver() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Intercept::set_has_receiver() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Intercept::clear_has_receiver() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Intercept::clear_receiver() {
  if (receiver_ != &::google::protobuf::internal::kEmptyString) {
    receiver_->clear();
  }
  clear_has_receiver();
}
inline const ::std::string& Intercept::receiver() const {
  return *receiver_;
}
inline void Intercept::set_receiver(const ::std::string& value) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(value);
}
inline void Intercept::set_receiver(const char* value) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(value);
}
inline void Intercept::set_receiver(const char* value, size_t size) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Intercept::mutable_receiver() {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  return receiver_;
}
inline ::std::string* Intercept::release_receiver() {
  clear_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = receiver_;
    receiver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Intercept::set_allocated_receiver(::std::string* receiver) {
  if (receiver_ != &::google::protobuf::internal::kEmptyString) {
    delete receiver_;
  }
  if (receiver) {
    set_has_receiver();
    receiver_ = receiver;
  } else {
    clear_has_receiver();
    receiver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string antenna = 7;
inline bool Intercept::has_antenna() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Intercept::set_has_antenna() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Intercept::clear_has_antenna() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Intercept::clear_antenna() {
  if (antenna_ != &::google::protobuf::internal::kEmptyString) {
    antenna_->clear();
  }
  clear_has_antenna();
}
inline const ::std::string& Intercept::antenna() const {
  return *antenna_;
}
inline void Intercept::set_antenna(const ::std::string& value) {
  set_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    antenna_ = new ::std::string;
  }
  antenna_->assign(value);
}
inline void Intercept::set_antenna(const char* value) {
  set_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    antenna_ = new ::std::string;
  }
  antenna_->assign(value);
}
inline void Intercept::set_antenna(const char* value, size_t size) {
  set_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    antenna_ = new ::std::string;
  }
  antenna_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Intercept::mutable_antenna() {
  set_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    antenna_ = new ::std::string;
  }
  return antenna_;
}
inline ::std::string* Intercept::release_antenna() {
  clear_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = antenna_;
    antenna_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Intercept::set_allocated_antenna(::std::string* antenna) {
  if (antenna_ != &::google::protobuf::internal::kEmptyString) {
    delete antenna_;
  }
  if (antenna) {
    set_has_antenna();
    antenna_ = antenna;
  } else {
    clear_has_antenna();
    antenna_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float azimuth = 8 [default = 0];
inline bool Intercept::has_azimuth() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Intercept::set_has_azimuth() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Intercept::clear_has_azimuth() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Intercept::clear_azimuth() {
  azimuth_ = 0;
  clear_has_azimuth();
}
inline float Intercept::azimuth() const {
  return azimuth_;
}
inline void Intercept::set_azimuth(float value) {
  set_has_azimuth();
  azimuth_ = value;
}

// optional float elevation = 9 [default = 0];
inline bool Intercept::has_elevation() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Intercept::set_has_elevation() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Intercept::clear_has_elevation() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Intercept::clear_elevation() {
  elevation_ = 0;
  clear_has_elevation();
}
inline float Intercept::elevation() const {
  return elevation_;
}
inline void Intercept::set_elevation(float value) {
  set_has_elevation();
  elevation_ = value;
}

// optional float snr = 10 [default = 0];
inline bool Intercept::has_snr() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Intercept::set_has_snr() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Intercept::clear_has_snr() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Intercept::clear_snr() {
  snr_ = 0;
  clear_has_snr();
}
inline float Intercept::snr() const {
  return snr_;
}
inline void Intercept::set_snr(float value) {
  set_has_snr();
  snr_ = value;
}

// optional string timestamp = 11;
inline bool Intercept::has_timestamp() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Intercept::set_has_timestamp() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Intercept::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Intercept::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& Intercept::timestamp() const {
  return *timestamp_;
}
inline void Intercept::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void Intercept::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void Intercept::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Intercept::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* Intercept::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Intercept::set_allocated_timestamp(::std::string* timestamp) {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    delete timestamp_;
  }
  if (timestamp) {
    set_has_timestamp();
    timestamp_ = timestamp;
  } else {
    clear_has_timestamp();
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string searchScrypt = 12;
inline bool Intercept::has_searchscrypt() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Intercept::set_has_searchscrypt() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Intercept::clear_has_searchscrypt() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Intercept::clear_searchscrypt() {
  if (searchscrypt_ != &::google::protobuf::internal::kEmptyString) {
    searchscrypt_->clear();
  }
  clear_has_searchscrypt();
}
inline const ::std::string& Intercept::searchscrypt() const {
  return *searchscrypt_;
}
inline void Intercept::set_searchscrypt(const ::std::string& value) {
  set_has_searchscrypt();
  if (searchscrypt_ == &::google::protobuf::internal::kEmptyString) {
    searchscrypt_ = new ::std::string;
  }
  searchscrypt_->assign(value);
}
inline void Intercept::set_searchscrypt(const char* value) {
  set_has_searchscrypt();
  if (searchscrypt_ == &::google::protobuf::internal::kEmptyString) {
    searchscrypt_ = new ::std::string;
  }
  searchscrypt_->assign(value);
}
inline void Intercept::set_searchscrypt(const char* value, size_t size) {
  set_has_searchscrypt();
  if (searchscrypt_ == &::google::protobuf::internal::kEmptyString) {
    searchscrypt_ = new ::std::string;
  }
  searchscrypt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Intercept::mutable_searchscrypt() {
  set_has_searchscrypt();
  if (searchscrypt_ == &::google::protobuf::internal::kEmptyString) {
    searchscrypt_ = new ::std::string;
  }
  return searchscrypt_;
}
inline ::std::string* Intercept::release_searchscrypt() {
  clear_has_searchscrypt();
  if (searchscrypt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = searchscrypt_;
    searchscrypt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Intercept::set_allocated_searchscrypt(::std::string* searchscrypt) {
  if (searchscrypt_ != &::google::protobuf::internal::kEmptyString) {
    delete searchscrypt_;
  }
  if (searchscrypt) {
    set_has_searchscrypt();
    searchscrypt_ = searchscrypt;
  } else {
    clear_has_searchscrypt();
    searchscrypt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 searchTier = 13 [default = 1];
inline bool Intercept::has_searchtier() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Intercept::set_has_searchtier() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Intercept::clear_has_searchtier() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Intercept::clear_searchtier() {
  searchtier_ = 1;
  clear_has_searchtier();
}
inline ::google::protobuf::int32 Intercept::searchtier() const {
  return searchtier_;
}
inline void Intercept::set_searchtier(::google::protobuf::int32 value) {
  set_has_searchtier();
  searchtier_ = value;
}

// optional int32 numFrames = 14;
inline bool Intercept::has_numframes() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Intercept::set_has_numframes() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Intercept::clear_has_numframes() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Intercept::clear_numframes() {
  numframes_ = 0;
  clear_has_numframes();
}
inline ::google::protobuf::int32 Intercept::numframes() const {
  return numframes_;
}
inline void Intercept::set_numframes(::google::protobuf::int32 value) {
  set_has_numframes();
  numframes_ = value;
}

// optional string detConf = 15;
inline bool Intercept::has_detconf() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Intercept::set_has_detconf() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Intercept::clear_has_detconf() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Intercept::clear_detconf() {
  if (detconf_ != &::google::protobuf::internal::kEmptyString) {
    detconf_->clear();
  }
  clear_has_detconf();
}
inline const ::std::string& Intercept::detconf() const {
  return *detconf_;
}
inline void Intercept::set_detconf(const ::std::string& value) {
  set_has_detconf();
  if (detconf_ == &::google::protobuf::internal::kEmptyString) {
    detconf_ = new ::std::string;
  }
  detconf_->assign(value);
}
inline void Intercept::set_detconf(const char* value) {
  set_has_detconf();
  if (detconf_ == &::google::protobuf::internal::kEmptyString) {
    detconf_ = new ::std::string;
  }
  detconf_->assign(value);
}
inline void Intercept::set_detconf(const char* value, size_t size) {
  set_has_detconf();
  if (detconf_ == &::google::protobuf::internal::kEmptyString) {
    detconf_ = new ::std::string;
  }
  detconf_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Intercept::mutable_detconf() {
  set_has_detconf();
  if (detconf_ == &::google::protobuf::internal::kEmptyString) {
    detconf_ = new ::std::string;
  }
  return detconf_;
}
inline ::std::string* Intercept::release_detconf() {
  clear_has_detconf();
  if (detconf_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = detconf_;
    detconf_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Intercept::set_allocated_detconf(::std::string* detconf) {
  if (detconf_ != &::google::protobuf::internal::kEmptyString) {
    delete detconf_;
  }
  if (detconf) {
    set_has_detconf();
    detconf_ = detconf;
  } else {
    clear_has_detconf();
    detconf_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string procParams = 16;
inline bool Intercept::has_procparams() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Intercept::set_has_procparams() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Intercept::clear_has_procparams() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Intercept::clear_procparams() {
  if (procparams_ != &::google::protobuf::internal::kEmptyString) {
    procparams_->clear();
  }
  clear_has_procparams();
}
inline const ::std::string& Intercept::procparams() const {
  return *procparams_;
}
inline void Intercept::set_procparams(const ::std::string& value) {
  set_has_procparams();
  if (procparams_ == &::google::protobuf::internal::kEmptyString) {
    procparams_ = new ::std::string;
  }
  procparams_->assign(value);
}
inline void Intercept::set_procparams(const char* value) {
  set_has_procparams();
  if (procparams_ == &::google::protobuf::internal::kEmptyString) {
    procparams_ = new ::std::string;
  }
  procparams_->assign(value);
}
inline void Intercept::set_procparams(const char* value, size_t size) {
  set_has_procparams();
  if (procparams_ == &::google::protobuf::internal::kEmptyString) {
    procparams_ = new ::std::string;
  }
  procparams_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Intercept::mutable_procparams() {
  set_has_procparams();
  if (procparams_ == &::google::protobuf::internal::kEmptyString) {
    procparams_ = new ::std::string;
  }
  return procparams_;
}
inline ::std::string* Intercept::release_procparams() {
  clear_has_procparams();
  if (procparams_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = procparams_;
    procparams_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Intercept::set_allocated_procparams(::std::string* procparams) {
  if (procparams_ != &::google::protobuf::internal::kEmptyString) {
    delete procparams_;
  }
  if (procparams) {
    set_has_procparams();
    procparams_ = procparams;
  } else {
    clear_has_procparams();
    procparams_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 ssc = 17 [default = -1];
inline bool Intercept::has_ssc() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Intercept::set_has_ssc() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Intercept::clear_has_ssc() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Intercept::clear_ssc() {
  ssc_ = -1;
  clear_has_ssc();
}
inline ::google::protobuf::int32 Intercept::ssc() const {
  return ssc_;
}
inline void Intercept::set_ssc(::google::protobuf::int32 value) {
  set_has_ssc();
  ssc_ = value;
}

// optional string band = 18;
inline bool Intercept::has_band() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Intercept::set_has_band() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Intercept::clear_has_band() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Intercept::clear_band() {
  if (band_ != &::google::protobuf::internal::kEmptyString) {
    band_->clear();
  }
  clear_has_band();
}
inline const ::std::string& Intercept::band() const {
  return *band_;
}
inline void Intercept::set_band(const ::std::string& value) {
  set_has_band();
  if (band_ == &::google::protobuf::internal::kEmptyString) {
    band_ = new ::std::string;
  }
  band_->assign(value);
}
inline void Intercept::set_band(const char* value) {
  set_has_band();
  if (band_ == &::google::protobuf::internal::kEmptyString) {
    band_ = new ::std::string;
  }
  band_->assign(value);
}
inline void Intercept::set_band(const char* value, size_t size) {
  set_has_band();
  if (band_ == &::google::protobuf::internal::kEmptyString) {
    band_ = new ::std::string;
  }
  band_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Intercept::mutable_band() {
  set_has_band();
  if (band_ == &::google::protobuf::internal::kEmptyString) {
    band_ = new ::std::string;
  }
  return band_;
}
inline ::std::string* Intercept::release_band() {
  clear_has_band();
  if (band_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = band_;
    band_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Intercept::set_allocated_band(::std::string* band) {
  if (band_ != &::google::protobuf::internal::kEmptyString) {
    delete band_;
  }
  if (band) {
    set_has_band();
    band_ = band;
  } else {
    clear_has_band();
    band_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string polarization = 19;
inline bool Intercept::has_polarization() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Intercept::set_has_polarization() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Intercept::clear_has_polarization() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Intercept::clear_polarization() {
  if (polarization_ != &::google::protobuf::internal::kEmptyString) {
    polarization_->clear();
  }
  clear_has_polarization();
}
inline const ::std::string& Intercept::polarization() const {
  return *polarization_;
}
inline void Intercept::set_polarization(const ::std::string& value) {
  set_has_polarization();
  if (polarization_ == &::google::protobuf::internal::kEmptyString) {
    polarization_ = new ::std::string;
  }
  polarization_->assign(value);
}
inline void Intercept::set_polarization(const char* value) {
  set_has_polarization();
  if (polarization_ == &::google::protobuf::internal::kEmptyString) {
    polarization_ = new ::std::string;
  }
  polarization_->assign(value);
}
inline void Intercept::set_polarization(const char* value, size_t size) {
  set_has_polarization();
  if (polarization_ == &::google::protobuf::internal::kEmptyString) {
    polarization_ = new ::std::string;
  }
  polarization_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Intercept::mutable_polarization() {
  set_has_polarization();
  if (polarization_ == &::google::protobuf::internal::kEmptyString) {
    polarization_ = new ::std::string;
  }
  return polarization_;
}
inline ::std::string* Intercept::release_polarization() {
  clear_has_polarization();
  if (polarization_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = polarization_;
    polarization_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Intercept::set_allocated_polarization(::std::string* polarization) {
  if (polarization_ != &::google::protobuf::internal::kEmptyString) {
    delete polarization_;
  }
  if (polarization) {
    set_has_polarization();
    polarization_ = polarization;
  } else {
    clear_has_polarization();
    polarization_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string hostname = 20 [default = ""];
inline bool Intercept::has_hostname() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Intercept::set_has_hostname() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Intercept::clear_has_hostname() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Intercept::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& Intercept::hostname() const {
  return *hostname_;
}
inline void Intercept::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void Intercept::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void Intercept::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Intercept::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* Intercept::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Intercept::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string uniqueID = 21 [default = ""];
inline bool Intercept::has_uniqueid() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Intercept::set_has_uniqueid() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Intercept::clear_has_uniqueid() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Intercept::clear_uniqueid() {
  if (uniqueid_ != &::google::protobuf::internal::kEmptyString) {
    uniqueid_->clear();
  }
  clear_has_uniqueid();
}
inline const ::std::string& Intercept::uniqueid() const {
  return *uniqueid_;
}
inline void Intercept::set_uniqueid(const ::std::string& value) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(value);
}
inline void Intercept::set_uniqueid(const char* value) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(value);
}
inline void Intercept::set_uniqueid(const char* value, size_t size) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Intercept::mutable_uniqueid() {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  return uniqueid_;
}
inline ::std::string* Intercept::release_uniqueid() {
  clear_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uniqueid_;
    uniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Intercept::set_allocated_uniqueid(::std::string* uniqueid) {
  if (uniqueid_ != &::google::protobuf::internal::kEmptyString) {
    delete uniqueid_;
  }
  if (uniqueid) {
    set_has_uniqueid();
    uniqueid_ = uniqueid;
  } else {
    clear_has_uniqueid();
    uniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string uniqueField = 22 [default = ""];
inline bool Intercept::has_uniquefield() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Intercept::set_has_uniquefield() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Intercept::clear_has_uniquefield() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Intercept::clear_uniquefield() {
  if (uniquefield_ != &::google::protobuf::internal::kEmptyString) {
    uniquefield_->clear();
  }
  clear_has_uniquefield();
}
inline const ::std::string& Intercept::uniquefield() const {
  return *uniquefield_;
}
inline void Intercept::set_uniquefield(const ::std::string& value) {
  set_has_uniquefield();
  if (uniquefield_ == &::google::protobuf::internal::kEmptyString) {
    uniquefield_ = new ::std::string;
  }
  uniquefield_->assign(value);
}
inline void Intercept::set_uniquefield(const char* value) {
  set_has_uniquefield();
  if (uniquefield_ == &::google::protobuf::internal::kEmptyString) {
    uniquefield_ = new ::std::string;
  }
  uniquefield_->assign(value);
}
inline void Intercept::set_uniquefield(const char* value, size_t size) {
  set_has_uniquefield();
  if (uniquefield_ == &::google::protobuf::internal::kEmptyString) {
    uniquefield_ = new ::std::string;
  }
  uniquefield_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Intercept::mutable_uniquefield() {
  set_has_uniquefield();
  if (uniquefield_ == &::google::protobuf::internal::kEmptyString) {
    uniquefield_ = new ::std::string;
  }
  return uniquefield_;
}
inline ::std::string* Intercept::release_uniquefield() {
  clear_has_uniquefield();
  if (uniquefield_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uniquefield_;
    uniquefield_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Intercept::set_allocated_uniquefield(::std::string* uniquefield) {
  if (uniquefield_ != &::google::protobuf::internal::kEmptyString) {
    delete uniquefield_;
  }
  if (uniquefield) {
    set_has_uniquefield();
    uniquefield_ = uniquefield;
  } else {
    clear_has_uniquefield();
    uniquefield_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string gpsPosition = 23 [default = ""];
inline bool Intercept::has_gpsposition() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Intercept::set_has_gpsposition() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Intercept::clear_has_gpsposition() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Intercept::clear_gpsposition() {
  if (gpsposition_ != &::google::protobuf::internal::kEmptyString) {
    gpsposition_->clear();
  }
  clear_has_gpsposition();
}
inline const ::std::string& Intercept::gpsposition() const {
  return *gpsposition_;
}
inline void Intercept::set_gpsposition(const ::std::string& value) {
  set_has_gpsposition();
  if (gpsposition_ == &::google::protobuf::internal::kEmptyString) {
    gpsposition_ = new ::std::string;
  }
  gpsposition_->assign(value);
}
inline void Intercept::set_gpsposition(const char* value) {
  set_has_gpsposition();
  if (gpsposition_ == &::google::protobuf::internal::kEmptyString) {
    gpsposition_ = new ::std::string;
  }
  gpsposition_->assign(value);
}
inline void Intercept::set_gpsposition(const char* value, size_t size) {
  set_has_gpsposition();
  if (gpsposition_ == &::google::protobuf::internal::kEmptyString) {
    gpsposition_ = new ::std::string;
  }
  gpsposition_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Intercept::mutable_gpsposition() {
  set_has_gpsposition();
  if (gpsposition_ == &::google::protobuf::internal::kEmptyString) {
    gpsposition_ = new ::std::string;
  }
  return gpsposition_;
}
inline ::std::string* Intercept::release_gpsposition() {
  clear_has_gpsposition();
  if (gpsposition_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gpsposition_;
    gpsposition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Intercept::set_allocated_gpsposition(::std::string* gpsposition) {
  if (gpsposition_ != &::google::protobuf::internal::kEmptyString) {
    delete gpsposition_;
  }
  if (gpsposition) {
    set_has_gpsposition();
    gpsposition_ = gpsposition;
  } else {
    clear_has_gpsposition();
    gpsposition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool priming = 24 [default = false];
inline bool Intercept::has_priming() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Intercept::set_has_priming() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Intercept::clear_has_priming() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Intercept::clear_priming() {
  priming_ = false;
  clear_has_priming();
}
inline bool Intercept::priming() const {
  return priming_;
}
inline void Intercept::set_priming(bool value) {
  set_has_priming();
  priming_ = value;
}

// optional string globalID = 25 [default = ""];
inline bool Intercept::has_globalid() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Intercept::set_has_globalid() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Intercept::clear_has_globalid() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Intercept::clear_globalid() {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    globalid_->clear();
  }
  clear_has_globalid();
}
inline const ::std::string& Intercept::globalid() const {
  return *globalid_;
}
inline void Intercept::set_globalid(const ::std::string& value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void Intercept::set_globalid(const char* value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void Intercept::set_globalid(const char* value, size_t size) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Intercept::mutable_globalid() {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  return globalid_;
}
inline ::std::string* Intercept::release_globalid() {
  clear_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalid_;
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Intercept::set_allocated_globalid(::std::string* globalid) {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    delete globalid_;
  }
  if (globalid) {
    set_has_globalid();
    globalid_ = globalid;
  } else {
    clear_has_globalid();
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 feedID = 26 [default = -1];
inline bool Intercept::has_feedid() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Intercept::set_has_feedid() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Intercept::clear_has_feedid() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Intercept::clear_feedid() {
  feedid_ = GOOGLE_LONGLONG(-1);
  clear_has_feedid();
}
inline ::google::protobuf::int64 Intercept::feedid() const {
  return feedid_;
}
inline void Intercept::set_feedid(::google::protobuf::int64 value) {
  set_has_feedid();
  feedid_ = value;
}

// optional int64 detectionID = 27 [default = -1];
inline bool Intercept::has_detectionid() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Intercept::set_has_detectionid() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Intercept::clear_has_detectionid() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Intercept::clear_detectionid() {
  detectionid_ = GOOGLE_LONGLONG(-1);
  clear_has_detectionid();
}
inline ::google::protobuf::int64 Intercept::detectionid() const {
  return detectionid_;
}
inline void Intercept::set_detectionid(::google::protobuf::int64 value) {
  set_has_detectionid();
  detectionid_ = value;
}

// optional string receiverATN = 28 [default = ""];
inline bool Intercept::has_receiveratn() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Intercept::set_has_receiveratn() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Intercept::clear_has_receiveratn() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Intercept::clear_receiveratn() {
  if (receiveratn_ != &::google::protobuf::internal::kEmptyString) {
    receiveratn_->clear();
  }
  clear_has_receiveratn();
}
inline const ::std::string& Intercept::receiveratn() const {
  return *receiveratn_;
}
inline void Intercept::set_receiveratn(const ::std::string& value) {
  set_has_receiveratn();
  if (receiveratn_ == &::google::protobuf::internal::kEmptyString) {
    receiveratn_ = new ::std::string;
  }
  receiveratn_->assign(value);
}
inline void Intercept::set_receiveratn(const char* value) {
  set_has_receiveratn();
  if (receiveratn_ == &::google::protobuf::internal::kEmptyString) {
    receiveratn_ = new ::std::string;
  }
  receiveratn_->assign(value);
}
inline void Intercept::set_receiveratn(const char* value, size_t size) {
  set_has_receiveratn();
  if (receiveratn_ == &::google::protobuf::internal::kEmptyString) {
    receiveratn_ = new ::std::string;
  }
  receiveratn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Intercept::mutable_receiveratn() {
  set_has_receiveratn();
  if (receiveratn_ == &::google::protobuf::internal::kEmptyString) {
    receiveratn_ = new ::std::string;
  }
  return receiveratn_;
}
inline ::std::string* Intercept::release_receiveratn() {
  clear_has_receiveratn();
  if (receiveratn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = receiveratn_;
    receiveratn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Intercept::set_allocated_receiveratn(::std::string* receiveratn) {
  if (receiveratn_ != &::google::protobuf::internal::kEmptyString) {
    delete receiveratn_;
  }
  if (receiveratn) {
    set_has_receiveratn();
    receiveratn_ = receiveratn;
  } else {
    clear_has_receiveratn();
    receiveratn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .falcon_trigger_msg.Intercept.TeamType teamType = 29 [default = RED_TEAM];
inline bool Intercept::has_teamtype() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Intercept::set_has_teamtype() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Intercept::clear_has_teamtype() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Intercept::clear_teamtype() {
  teamtype_ = 2;
  clear_has_teamtype();
}
inline ::falcon_trigger_msg::Intercept_TeamType Intercept::teamtype() const {
  return static_cast< ::falcon_trigger_msg::Intercept_TeamType >(teamtype_);
}
inline void Intercept::set_teamtype(::falcon_trigger_msg::Intercept_TeamType value) {
  assert(::falcon_trigger_msg::Intercept_TeamType_IsValid(value));
  set_has_teamtype();
  teamtype_ = value;
}

// optional bool noProcess = 30 [default = false];
inline bool Intercept::has_noprocess() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Intercept::set_has_noprocess() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Intercept::clear_has_noprocess() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Intercept::clear_noprocess() {
  noprocess_ = false;
  clear_has_noprocess();
}
inline bool Intercept::noprocess() const {
  return noprocess_;
}
inline void Intercept::set_noprocess(bool value) {
  set_has_noprocess();
  noprocess_ = value;
}

// -------------------------------------------------------------------

// InterceptAmpX

// optional string msgName = 1 [default = "INTERCEPT_AMPX"];
inline bool InterceptAmpX::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InterceptAmpX::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InterceptAmpX::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InterceptAmpX::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& InterceptAmpX::msgname() const {
  return *msgname_;
}
inline void InterceptAmpX::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void InterceptAmpX::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void InterceptAmpX::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InterceptAmpX::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* InterceptAmpX::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void InterceptAmpX::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional bool isTrigger = 2 [default = true];
inline bool InterceptAmpX::has_istrigger() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InterceptAmpX::set_has_istrigger() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InterceptAmpX::clear_has_istrigger() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InterceptAmpX::clear_istrigger() {
  istrigger_ = true;
  clear_has_istrigger();
}
inline bool InterceptAmpX::istrigger() const {
  return istrigger_;
}
inline void InterceptAmpX::set_istrigger(bool value) {
  set_has_istrigger();
  istrigger_ = value;
}

// optional string signal = 3;
inline bool InterceptAmpX::has_signal() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InterceptAmpX::set_has_signal() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InterceptAmpX::clear_has_signal() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InterceptAmpX::clear_signal() {
  if (signal_ != &::google::protobuf::internal::kEmptyString) {
    signal_->clear();
  }
  clear_has_signal();
}
inline const ::std::string& InterceptAmpX::signal() const {
  return *signal_;
}
inline void InterceptAmpX::set_signal(const ::std::string& value) {
  set_has_signal();
  if (signal_ == &::google::protobuf::internal::kEmptyString) {
    signal_ = new ::std::string;
  }
  signal_->assign(value);
}
inline void InterceptAmpX::set_signal(const char* value) {
  set_has_signal();
  if (signal_ == &::google::protobuf::internal::kEmptyString) {
    signal_ = new ::std::string;
  }
  signal_->assign(value);
}
inline void InterceptAmpX::set_signal(const char* value, size_t size) {
  set_has_signal();
  if (signal_ == &::google::protobuf::internal::kEmptyString) {
    signal_ = new ::std::string;
  }
  signal_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InterceptAmpX::mutable_signal() {
  set_has_signal();
  if (signal_ == &::google::protobuf::internal::kEmptyString) {
    signal_ = new ::std::string;
  }
  return signal_;
}
inline ::std::string* InterceptAmpX::release_signal() {
  clear_has_signal();
  if (signal_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signal_;
    signal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InterceptAmpX::set_allocated_signal(::std::string* signal) {
  if (signal_ != &::google::protobuf::internal::kEmptyString) {
    delete signal_;
  }
  if (signal) {
    set_has_signal();
    signal_ = signal;
  } else {
    clear_has_signal();
    signal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double frequency = 4;
inline bool InterceptAmpX::has_frequency() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InterceptAmpX::set_has_frequency() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InterceptAmpX::clear_has_frequency() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InterceptAmpX::clear_frequency() {
  frequency_ = 0;
  clear_has_frequency();
}
inline double InterceptAmpX::frequency() const {
  return frequency_;
}
inline void InterceptAmpX::set_frequency(double value) {
  set_has_frequency();
  frequency_ = value;
}

// optional float bandwidth = 5;
inline bool InterceptAmpX::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InterceptAmpX::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InterceptAmpX::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InterceptAmpX::clear_bandwidth() {
  bandwidth_ = 0;
  clear_has_bandwidth();
}
inline float InterceptAmpX::bandwidth() const {
  return bandwidth_;
}
inline void InterceptAmpX::set_bandwidth(float value) {
  set_has_bandwidth();
  bandwidth_ = value;
}

// optional string receiver = 6;
inline bool InterceptAmpX::has_receiver() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InterceptAmpX::set_has_receiver() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InterceptAmpX::clear_has_receiver() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InterceptAmpX::clear_receiver() {
  if (receiver_ != &::google::protobuf::internal::kEmptyString) {
    receiver_->clear();
  }
  clear_has_receiver();
}
inline const ::std::string& InterceptAmpX::receiver() const {
  return *receiver_;
}
inline void InterceptAmpX::set_receiver(const ::std::string& value) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(value);
}
inline void InterceptAmpX::set_receiver(const char* value) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(value);
}
inline void InterceptAmpX::set_receiver(const char* value, size_t size) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InterceptAmpX::mutable_receiver() {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  return receiver_;
}
inline ::std::string* InterceptAmpX::release_receiver() {
  clear_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = receiver_;
    receiver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InterceptAmpX::set_allocated_receiver(::std::string* receiver) {
  if (receiver_ != &::google::protobuf::internal::kEmptyString) {
    delete receiver_;
  }
  if (receiver) {
    set_has_receiver();
    receiver_ = receiver;
  } else {
    clear_has_receiver();
    receiver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string antenna = 7;
inline bool InterceptAmpX::has_antenna() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InterceptAmpX::set_has_antenna() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InterceptAmpX::clear_has_antenna() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InterceptAmpX::clear_antenna() {
  if (antenna_ != &::google::protobuf::internal::kEmptyString) {
    antenna_->clear();
  }
  clear_has_antenna();
}
inline const ::std::string& InterceptAmpX::antenna() const {
  return *antenna_;
}
inline void InterceptAmpX::set_antenna(const ::std::string& value) {
  set_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    antenna_ = new ::std::string;
  }
  antenna_->assign(value);
}
inline void InterceptAmpX::set_antenna(const char* value) {
  set_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    antenna_ = new ::std::string;
  }
  antenna_->assign(value);
}
inline void InterceptAmpX::set_antenna(const char* value, size_t size) {
  set_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    antenna_ = new ::std::string;
  }
  antenna_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InterceptAmpX::mutable_antenna() {
  set_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    antenna_ = new ::std::string;
  }
  return antenna_;
}
inline ::std::string* InterceptAmpX::release_antenna() {
  clear_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = antenna_;
    antenna_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InterceptAmpX::set_allocated_antenna(::std::string* antenna) {
  if (antenna_ != &::google::protobuf::internal::kEmptyString) {
    delete antenna_;
  }
  if (antenna) {
    set_has_antenna();
    antenna_ = antenna;
  } else {
    clear_has_antenna();
    antenna_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float azimuth = 8 [default = 0];
inline bool InterceptAmpX::has_azimuth() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InterceptAmpX::set_has_azimuth() {
  _has_bits_[0] |= 0x00000080u;
}
inline void InterceptAmpX::clear_has_azimuth() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void InterceptAmpX::clear_azimuth() {
  azimuth_ = 0;
  clear_has_azimuth();
}
inline float InterceptAmpX::azimuth() const {
  return azimuth_;
}
inline void InterceptAmpX::set_azimuth(float value) {
  set_has_azimuth();
  azimuth_ = value;
}

// optional float elevation = 9 [default = 0];
inline bool InterceptAmpX::has_elevation() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void InterceptAmpX::set_has_elevation() {
  _has_bits_[0] |= 0x00000100u;
}
inline void InterceptAmpX::clear_has_elevation() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void InterceptAmpX::clear_elevation() {
  elevation_ = 0;
  clear_has_elevation();
}
inline float InterceptAmpX::elevation() const {
  return elevation_;
}
inline void InterceptAmpX::set_elevation(float value) {
  set_has_elevation();
  elevation_ = value;
}

// optional float snr = 10 [default = 0];
inline bool InterceptAmpX::has_snr() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void InterceptAmpX::set_has_snr() {
  _has_bits_[0] |= 0x00000200u;
}
inline void InterceptAmpX::clear_has_snr() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void InterceptAmpX::clear_snr() {
  snr_ = 0;
  clear_has_snr();
}
inline float InterceptAmpX::snr() const {
  return snr_;
}
inline void InterceptAmpX::set_snr(float value) {
  set_has_snr();
  snr_ = value;
}

// optional string timestamp = 11;
inline bool InterceptAmpX::has_timestamp() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void InterceptAmpX::set_has_timestamp() {
  _has_bits_[0] |= 0x00000400u;
}
inline void InterceptAmpX::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void InterceptAmpX::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& InterceptAmpX::timestamp() const {
  return *timestamp_;
}
inline void InterceptAmpX::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void InterceptAmpX::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void InterceptAmpX::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InterceptAmpX::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* InterceptAmpX::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InterceptAmpX::set_allocated_timestamp(::std::string* timestamp) {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    delete timestamp_;
  }
  if (timestamp) {
    set_has_timestamp();
    timestamp_ = timestamp;
  } else {
    clear_has_timestamp();
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string searchScrypt = 12;
inline bool InterceptAmpX::has_searchscrypt() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void InterceptAmpX::set_has_searchscrypt() {
  _has_bits_[0] |= 0x00000800u;
}
inline void InterceptAmpX::clear_has_searchscrypt() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void InterceptAmpX::clear_searchscrypt() {
  if (searchscrypt_ != &::google::protobuf::internal::kEmptyString) {
    searchscrypt_->clear();
  }
  clear_has_searchscrypt();
}
inline const ::std::string& InterceptAmpX::searchscrypt() const {
  return *searchscrypt_;
}
inline void InterceptAmpX::set_searchscrypt(const ::std::string& value) {
  set_has_searchscrypt();
  if (searchscrypt_ == &::google::protobuf::internal::kEmptyString) {
    searchscrypt_ = new ::std::string;
  }
  searchscrypt_->assign(value);
}
inline void InterceptAmpX::set_searchscrypt(const char* value) {
  set_has_searchscrypt();
  if (searchscrypt_ == &::google::protobuf::internal::kEmptyString) {
    searchscrypt_ = new ::std::string;
  }
  searchscrypt_->assign(value);
}
inline void InterceptAmpX::set_searchscrypt(const char* value, size_t size) {
  set_has_searchscrypt();
  if (searchscrypt_ == &::google::protobuf::internal::kEmptyString) {
    searchscrypt_ = new ::std::string;
  }
  searchscrypt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InterceptAmpX::mutable_searchscrypt() {
  set_has_searchscrypt();
  if (searchscrypt_ == &::google::protobuf::internal::kEmptyString) {
    searchscrypt_ = new ::std::string;
  }
  return searchscrypt_;
}
inline ::std::string* InterceptAmpX::release_searchscrypt() {
  clear_has_searchscrypt();
  if (searchscrypt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = searchscrypt_;
    searchscrypt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InterceptAmpX::set_allocated_searchscrypt(::std::string* searchscrypt) {
  if (searchscrypt_ != &::google::protobuf::internal::kEmptyString) {
    delete searchscrypt_;
  }
  if (searchscrypt) {
    set_has_searchscrypt();
    searchscrypt_ = searchscrypt;
  } else {
    clear_has_searchscrypt();
    searchscrypt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 searchTier = 13 [default = 1];
inline bool InterceptAmpX::has_searchtier() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void InterceptAmpX::set_has_searchtier() {
  _has_bits_[0] |= 0x00001000u;
}
inline void InterceptAmpX::clear_has_searchtier() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void InterceptAmpX::clear_searchtier() {
  searchtier_ = 1;
  clear_has_searchtier();
}
inline ::google::protobuf::int32 InterceptAmpX::searchtier() const {
  return searchtier_;
}
inline void InterceptAmpX::set_searchtier(::google::protobuf::int32 value) {
  set_has_searchtier();
  searchtier_ = value;
}

// optional int32 numFrames = 14;
inline bool InterceptAmpX::has_numframes() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void InterceptAmpX::set_has_numframes() {
  _has_bits_[0] |= 0x00002000u;
}
inline void InterceptAmpX::clear_has_numframes() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void InterceptAmpX::clear_numframes() {
  numframes_ = 0;
  clear_has_numframes();
}
inline ::google::protobuf::int32 InterceptAmpX::numframes() const {
  return numframes_;
}
inline void InterceptAmpX::set_numframes(::google::protobuf::int32 value) {
  set_has_numframes();
  numframes_ = value;
}

// optional string detConf = 15;
inline bool InterceptAmpX::has_detconf() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void InterceptAmpX::set_has_detconf() {
  _has_bits_[0] |= 0x00004000u;
}
inline void InterceptAmpX::clear_has_detconf() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void InterceptAmpX::clear_detconf() {
  if (detconf_ != &::google::protobuf::internal::kEmptyString) {
    detconf_->clear();
  }
  clear_has_detconf();
}
inline const ::std::string& InterceptAmpX::detconf() const {
  return *detconf_;
}
inline void InterceptAmpX::set_detconf(const ::std::string& value) {
  set_has_detconf();
  if (detconf_ == &::google::protobuf::internal::kEmptyString) {
    detconf_ = new ::std::string;
  }
  detconf_->assign(value);
}
inline void InterceptAmpX::set_detconf(const char* value) {
  set_has_detconf();
  if (detconf_ == &::google::protobuf::internal::kEmptyString) {
    detconf_ = new ::std::string;
  }
  detconf_->assign(value);
}
inline void InterceptAmpX::set_detconf(const char* value, size_t size) {
  set_has_detconf();
  if (detconf_ == &::google::protobuf::internal::kEmptyString) {
    detconf_ = new ::std::string;
  }
  detconf_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InterceptAmpX::mutable_detconf() {
  set_has_detconf();
  if (detconf_ == &::google::protobuf::internal::kEmptyString) {
    detconf_ = new ::std::string;
  }
  return detconf_;
}
inline ::std::string* InterceptAmpX::release_detconf() {
  clear_has_detconf();
  if (detconf_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = detconf_;
    detconf_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InterceptAmpX::set_allocated_detconf(::std::string* detconf) {
  if (detconf_ != &::google::protobuf::internal::kEmptyString) {
    delete detconf_;
  }
  if (detconf) {
    set_has_detconf();
    detconf_ = detconf;
  } else {
    clear_has_detconf();
    detconf_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string procParams = 16;
inline bool InterceptAmpX::has_procparams() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void InterceptAmpX::set_has_procparams() {
  _has_bits_[0] |= 0x00008000u;
}
inline void InterceptAmpX::clear_has_procparams() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void InterceptAmpX::clear_procparams() {
  if (procparams_ != &::google::protobuf::internal::kEmptyString) {
    procparams_->clear();
  }
  clear_has_procparams();
}
inline const ::std::string& InterceptAmpX::procparams() const {
  return *procparams_;
}
inline void InterceptAmpX::set_procparams(const ::std::string& value) {
  set_has_procparams();
  if (procparams_ == &::google::protobuf::internal::kEmptyString) {
    procparams_ = new ::std::string;
  }
  procparams_->assign(value);
}
inline void InterceptAmpX::set_procparams(const char* value) {
  set_has_procparams();
  if (procparams_ == &::google::protobuf::internal::kEmptyString) {
    procparams_ = new ::std::string;
  }
  procparams_->assign(value);
}
inline void InterceptAmpX::set_procparams(const char* value, size_t size) {
  set_has_procparams();
  if (procparams_ == &::google::protobuf::internal::kEmptyString) {
    procparams_ = new ::std::string;
  }
  procparams_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InterceptAmpX::mutable_procparams() {
  set_has_procparams();
  if (procparams_ == &::google::protobuf::internal::kEmptyString) {
    procparams_ = new ::std::string;
  }
  return procparams_;
}
inline ::std::string* InterceptAmpX::release_procparams() {
  clear_has_procparams();
  if (procparams_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = procparams_;
    procparams_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InterceptAmpX::set_allocated_procparams(::std::string* procparams) {
  if (procparams_ != &::google::protobuf::internal::kEmptyString) {
    delete procparams_;
  }
  if (procparams) {
    set_has_procparams();
    procparams_ = procparams;
  } else {
    clear_has_procparams();
    procparams_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string hostname = 17 [default = ""];
inline bool InterceptAmpX::has_hostname() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void InterceptAmpX::set_has_hostname() {
  _has_bits_[0] |= 0x00010000u;
}
inline void InterceptAmpX::clear_has_hostname() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void InterceptAmpX::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& InterceptAmpX::hostname() const {
  return *hostname_;
}
inline void InterceptAmpX::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void InterceptAmpX::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void InterceptAmpX::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InterceptAmpX::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* InterceptAmpX::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InterceptAmpX::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string uniqueID = 18 [default = ""];
inline bool InterceptAmpX::has_uniqueid() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void InterceptAmpX::set_has_uniqueid() {
  _has_bits_[0] |= 0x00020000u;
}
inline void InterceptAmpX::clear_has_uniqueid() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void InterceptAmpX::clear_uniqueid() {
  if (uniqueid_ != &::google::protobuf::internal::kEmptyString) {
    uniqueid_->clear();
  }
  clear_has_uniqueid();
}
inline const ::std::string& InterceptAmpX::uniqueid() const {
  return *uniqueid_;
}
inline void InterceptAmpX::set_uniqueid(const ::std::string& value) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(value);
}
inline void InterceptAmpX::set_uniqueid(const char* value) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(value);
}
inline void InterceptAmpX::set_uniqueid(const char* value, size_t size) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InterceptAmpX::mutable_uniqueid() {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  return uniqueid_;
}
inline ::std::string* InterceptAmpX::release_uniqueid() {
  clear_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uniqueid_;
    uniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InterceptAmpX::set_allocated_uniqueid(::std::string* uniqueid) {
  if (uniqueid_ != &::google::protobuf::internal::kEmptyString) {
    delete uniqueid_;
  }
  if (uniqueid) {
    set_has_uniqueid();
    uniqueid_ = uniqueid;
  } else {
    clear_has_uniqueid();
    uniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string uniqueField = 19 [default = ""];
inline bool InterceptAmpX::has_uniquefield() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void InterceptAmpX::set_has_uniquefield() {
  _has_bits_[0] |= 0x00040000u;
}
inline void InterceptAmpX::clear_has_uniquefield() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void InterceptAmpX::clear_uniquefield() {
  if (uniquefield_ != &::google::protobuf::internal::kEmptyString) {
    uniquefield_->clear();
  }
  clear_has_uniquefield();
}
inline const ::std::string& InterceptAmpX::uniquefield() const {
  return *uniquefield_;
}
inline void InterceptAmpX::set_uniquefield(const ::std::string& value) {
  set_has_uniquefield();
  if (uniquefield_ == &::google::protobuf::internal::kEmptyString) {
    uniquefield_ = new ::std::string;
  }
  uniquefield_->assign(value);
}
inline void InterceptAmpX::set_uniquefield(const char* value) {
  set_has_uniquefield();
  if (uniquefield_ == &::google::protobuf::internal::kEmptyString) {
    uniquefield_ = new ::std::string;
  }
  uniquefield_->assign(value);
}
inline void InterceptAmpX::set_uniquefield(const char* value, size_t size) {
  set_has_uniquefield();
  if (uniquefield_ == &::google::protobuf::internal::kEmptyString) {
    uniquefield_ = new ::std::string;
  }
  uniquefield_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InterceptAmpX::mutable_uniquefield() {
  set_has_uniquefield();
  if (uniquefield_ == &::google::protobuf::internal::kEmptyString) {
    uniquefield_ = new ::std::string;
  }
  return uniquefield_;
}
inline ::std::string* InterceptAmpX::release_uniquefield() {
  clear_has_uniquefield();
  if (uniquefield_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uniquefield_;
    uniquefield_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InterceptAmpX::set_allocated_uniquefield(::std::string* uniquefield) {
  if (uniquefield_ != &::google::protobuf::internal::kEmptyString) {
    delete uniquefield_;
  }
  if (uniquefield) {
    set_has_uniquefield();
    uniquefield_ = uniquefield;
  } else {
    clear_has_uniquefield();
    uniquefield_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string gpsPosition = 20 [default = ""];
inline bool InterceptAmpX::has_gpsposition() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void InterceptAmpX::set_has_gpsposition() {
  _has_bits_[0] |= 0x00080000u;
}
inline void InterceptAmpX::clear_has_gpsposition() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void InterceptAmpX::clear_gpsposition() {
  if (gpsposition_ != &::google::protobuf::internal::kEmptyString) {
    gpsposition_->clear();
  }
  clear_has_gpsposition();
}
inline const ::std::string& InterceptAmpX::gpsposition() const {
  return *gpsposition_;
}
inline void InterceptAmpX::set_gpsposition(const ::std::string& value) {
  set_has_gpsposition();
  if (gpsposition_ == &::google::protobuf::internal::kEmptyString) {
    gpsposition_ = new ::std::string;
  }
  gpsposition_->assign(value);
}
inline void InterceptAmpX::set_gpsposition(const char* value) {
  set_has_gpsposition();
  if (gpsposition_ == &::google::protobuf::internal::kEmptyString) {
    gpsposition_ = new ::std::string;
  }
  gpsposition_->assign(value);
}
inline void InterceptAmpX::set_gpsposition(const char* value, size_t size) {
  set_has_gpsposition();
  if (gpsposition_ == &::google::protobuf::internal::kEmptyString) {
    gpsposition_ = new ::std::string;
  }
  gpsposition_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InterceptAmpX::mutable_gpsposition() {
  set_has_gpsposition();
  if (gpsposition_ == &::google::protobuf::internal::kEmptyString) {
    gpsposition_ = new ::std::string;
  }
  return gpsposition_;
}
inline ::std::string* InterceptAmpX::release_gpsposition() {
  clear_has_gpsposition();
  if (gpsposition_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gpsposition_;
    gpsposition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InterceptAmpX::set_allocated_gpsposition(::std::string* gpsposition) {
  if (gpsposition_ != &::google::protobuf::internal::kEmptyString) {
    delete gpsposition_;
  }
  if (gpsposition) {
    set_has_gpsposition();
    gpsposition_ = gpsposition;
  } else {
    clear_has_gpsposition();
    gpsposition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool priming = 21 [default = false];
inline bool InterceptAmpX::has_priming() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void InterceptAmpX::set_has_priming() {
  _has_bits_[0] |= 0x00100000u;
}
inline void InterceptAmpX::clear_has_priming() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void InterceptAmpX::clear_priming() {
  priming_ = false;
  clear_has_priming();
}
inline bool InterceptAmpX::priming() const {
  return priming_;
}
inline void InterceptAmpX::set_priming(bool value) {
  set_has_priming();
  priming_ = value;
}

// -------------------------------------------------------------------

// SignalLocked

// optional string msgName = 1 [default = "SIGNAL_LOCKED"];
inline bool SignalLocked::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignalLocked::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignalLocked::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignalLocked::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SignalLocked::msgname() const {
  return *msgname_;
}
inline void SignalLocked::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SignalLocked::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SignalLocked::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalLocked::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SignalLocked::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SignalLocked::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional bool isTrigger = 2 [default = true];
inline bool SignalLocked::has_istrigger() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignalLocked::set_has_istrigger() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignalLocked::clear_has_istrigger() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignalLocked::clear_istrigger() {
  istrigger_ = true;
  clear_has_istrigger();
}
inline bool SignalLocked::istrigger() const {
  return istrigger_;
}
inline void SignalLocked::set_istrigger(bool value) {
  set_has_istrigger();
  istrigger_ = value;
}

// optional int32 appID = 3;
inline bool SignalLocked::has_appid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignalLocked::set_has_appid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignalLocked::clear_has_appid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignalLocked::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 SignalLocked::appid() const {
  return appid_;
}
inline void SignalLocked::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional string antenna = 4;
inline bool SignalLocked::has_antenna() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignalLocked::set_has_antenna() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignalLocked::clear_has_antenna() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignalLocked::clear_antenna() {
  if (antenna_ != &::google::protobuf::internal::kEmptyString) {
    antenna_->clear();
  }
  clear_has_antenna();
}
inline const ::std::string& SignalLocked::antenna() const {
  return *antenna_;
}
inline void SignalLocked::set_antenna(const ::std::string& value) {
  set_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    antenna_ = new ::std::string;
  }
  antenna_->assign(value);
}
inline void SignalLocked::set_antenna(const char* value) {
  set_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    antenna_ = new ::std::string;
  }
  antenna_->assign(value);
}
inline void SignalLocked::set_antenna(const char* value, size_t size) {
  set_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    antenna_ = new ::std::string;
  }
  antenna_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalLocked::mutable_antenna() {
  set_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    antenna_ = new ::std::string;
  }
  return antenna_;
}
inline ::std::string* SignalLocked::release_antenna() {
  clear_has_antenna();
  if (antenna_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = antenna_;
    antenna_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignalLocked::set_allocated_antenna(::std::string* antenna) {
  if (antenna_ != &::google::protobuf::internal::kEmptyString) {
    delete antenna_;
  }
  if (antenna) {
    set_has_antenna();
    antenna_ = antenna;
  } else {
    clear_has_antenna();
    antenna_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SignalTimeout

// optional string msgName = 1 [default = "SIGNAL_TIMEOUT"];
inline bool SignalTimeout::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignalTimeout::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignalTimeout::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignalTimeout::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SignalTimeout::msgname() const {
  return *msgname_;
}
inline void SignalTimeout::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SignalTimeout::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SignalTimeout::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalTimeout::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SignalTimeout::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SignalTimeout::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional bool isTrigger = 2 [default = true];
inline bool SignalTimeout::has_istrigger() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignalTimeout::set_has_istrigger() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignalTimeout::clear_has_istrigger() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignalTimeout::clear_istrigger() {
  istrigger_ = true;
  clear_has_istrigger();
}
inline bool SignalTimeout::istrigger() const {
  return istrigger_;
}
inline void SignalTimeout::set_istrigger(bool value) {
  set_has_istrigger();
  istrigger_ = value;
}

// optional int32 appID = 3;
inline bool SignalTimeout::has_appid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignalTimeout::set_has_appid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignalTimeout::clear_has_appid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignalTimeout::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 SignalTimeout::appid() const {
  return appid_;
}
inline void SignalTimeout::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// -------------------------------------------------------------------

// InterceptListRequest

// optional string msgName = 1 [default = "INTERCEPT_LIST_REQUEST"];
inline bool InterceptListRequest::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InterceptListRequest::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InterceptListRequest::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InterceptListRequest::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& InterceptListRequest::msgname() const {
  return *msgname_;
}
inline void InterceptListRequest::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void InterceptListRequest::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void InterceptListRequest::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InterceptListRequest::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* InterceptListRequest::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void InterceptListRequest::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional bool isTrigger = 2 [default = true];
inline bool InterceptListRequest::has_istrigger() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InterceptListRequest::set_has_istrigger() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InterceptListRequest::clear_has_istrigger() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InterceptListRequest::clear_istrigger() {
  istrigger_ = true;
  clear_has_istrigger();
}
inline bool InterceptListRequest::istrigger() const {
  return istrigger_;
}
inline void InterceptListRequest::set_istrigger(bool value) {
  set_has_istrigger();
  istrigger_ = value;
}

// optional .falcon_trigger_msg.InterceptListRequest.Type requestType = 3;
inline bool InterceptListRequest::has_requesttype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InterceptListRequest::set_has_requesttype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InterceptListRequest::clear_has_requesttype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InterceptListRequest::clear_requesttype() {
  requesttype_ = 0;
  clear_has_requesttype();
}
inline ::falcon_trigger_msg::InterceptListRequest_Type InterceptListRequest::requesttype() const {
  return static_cast< ::falcon_trigger_msg::InterceptListRequest_Type >(requesttype_);
}
inline void InterceptListRequest::set_requesttype(::falcon_trigger_msg::InterceptListRequest_Type value) {
  assert(::falcon_trigger_msg::InterceptListRequest_Type_IsValid(value));
  set_has_requesttype();
  requesttype_ = value;
}

// optional string uniqueID = 4 [default = ""];
inline bool InterceptListRequest::has_uniqueid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InterceptListRequest::set_has_uniqueid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InterceptListRequest::clear_has_uniqueid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InterceptListRequest::clear_uniqueid() {
  if (uniqueid_ != &::google::protobuf::internal::kEmptyString) {
    uniqueid_->clear();
  }
  clear_has_uniqueid();
}
inline const ::std::string& InterceptListRequest::uniqueid() const {
  return *uniqueid_;
}
inline void InterceptListRequest::set_uniqueid(const ::std::string& value) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(value);
}
inline void InterceptListRequest::set_uniqueid(const char* value) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(value);
}
inline void InterceptListRequest::set_uniqueid(const char* value, size_t size) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InterceptListRequest::mutable_uniqueid() {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  return uniqueid_;
}
inline ::std::string* InterceptListRequest::release_uniqueid() {
  clear_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uniqueid_;
    uniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InterceptListRequest::set_allocated_uniqueid(::std::string* uniqueid) {
  if (uniqueid_ != &::google::protobuf::internal::kEmptyString) {
    delete uniqueid_;
  }
  if (uniqueid) {
    set_has_uniqueid();
    uniqueid_ = uniqueid;
  } else {
    clear_has_uniqueid();
    uniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RunGoNoGo

// optional string msgName = 1 [default = "RUN_GO_NOGO"];
inline bool RunGoNoGo::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RunGoNoGo::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RunGoNoGo::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RunGoNoGo::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& RunGoNoGo::msgname() const {
  return *msgname_;
}
inline void RunGoNoGo::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RunGoNoGo::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RunGoNoGo::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RunGoNoGo::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* RunGoNoGo::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void RunGoNoGo::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional bool isTrigger = 2 [default = true];
inline bool RunGoNoGo::has_istrigger() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RunGoNoGo::set_has_istrigger() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RunGoNoGo::clear_has_istrigger() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RunGoNoGo::clear_istrigger() {
  istrigger_ = true;
  clear_has_istrigger();
}
inline bool RunGoNoGo::istrigger() const {
  return istrigger_;
}
inline void RunGoNoGo::set_istrigger(bool value) {
  set_has_istrigger();
  istrigger_ = value;
}

// -------------------------------------------------------------------

// BlacklistRequest

// optional string msgName = 1 [default = "BLACKLIST_REQUEST"];
inline bool BlacklistRequest::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlacklistRequest::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlacklistRequest::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlacklistRequest::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& BlacklistRequest::msgname() const {
  return *msgname_;
}
inline void BlacklistRequest::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void BlacklistRequest::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void BlacklistRequest::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlacklistRequest::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* BlacklistRequest::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void BlacklistRequest::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional bool isTrigger = 2 [default = true];
inline bool BlacklistRequest::has_istrigger() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlacklistRequest::set_has_istrigger() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlacklistRequest::clear_has_istrigger() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlacklistRequest::clear_istrigger() {
  istrigger_ = true;
  clear_has_istrigger();
}
inline bool BlacklistRequest::istrigger() const {
  return istrigger_;
}
inline void BlacklistRequest::set_istrigger(bool value) {
  set_has_istrigger();
  istrigger_ = value;
}

// optional .falcon_trigger_msg.BlacklistRequest.Type requestType = 3;
inline bool BlacklistRequest::has_requesttype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlacklistRequest::set_has_requesttype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlacklistRequest::clear_has_requesttype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlacklistRequest::clear_requesttype() {
  requesttype_ = 0;
  clear_has_requesttype();
}
inline ::falcon_trigger_msg::BlacklistRequest_Type BlacklistRequest::requesttype() const {
  return static_cast< ::falcon_trigger_msg::BlacklistRequest_Type >(requesttype_);
}
inline void BlacklistRequest::set_requesttype(::falcon_trigger_msg::BlacklistRequest_Type value) {
  assert(::falcon_trigger_msg::BlacklistRequest_Type_IsValid(value));
  set_has_requesttype();
  requesttype_ = value;
}

// optional .falcon_common_msg.BlacklistEntry entry = 4;
inline bool BlacklistRequest::has_entry() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BlacklistRequest::set_has_entry() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BlacklistRequest::clear_has_entry() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BlacklistRequest::clear_entry() {
  if (entry_ != NULL) entry_->::falcon_common_msg::BlacklistEntry::Clear();
  clear_has_entry();
}
inline const ::falcon_common_msg::BlacklistEntry& BlacklistRequest::entry() const {
  return entry_ != NULL ? *entry_ : *default_instance_->entry_;
}
inline ::falcon_common_msg::BlacklistEntry* BlacklistRequest::mutable_entry() {
  set_has_entry();
  if (entry_ == NULL) entry_ = new ::falcon_common_msg::BlacklistEntry;
  return entry_;
}
inline ::falcon_common_msg::BlacklistEntry* BlacklistRequest::release_entry() {
  clear_has_entry();
  ::falcon_common_msg::BlacklistEntry* temp = entry_;
  entry_ = NULL;
  return temp;
}
inline void BlacklistRequest::set_allocated_entry(::falcon_common_msg::BlacklistEntry* entry) {
  delete entry_;
  entry_ = entry;
  if (entry) {
    set_has_entry();
  } else {
    clear_has_entry();
  }
}

// optional string uniqueID = 5 [default = ""];
inline bool BlacklistRequest::has_uniqueid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BlacklistRequest::set_has_uniqueid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BlacklistRequest::clear_has_uniqueid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BlacklistRequest::clear_uniqueid() {
  if (uniqueid_ != &::google::protobuf::internal::kEmptyString) {
    uniqueid_->clear();
  }
  clear_has_uniqueid();
}
inline const ::std::string& BlacklistRequest::uniqueid() const {
  return *uniqueid_;
}
inline void BlacklistRequest::set_uniqueid(const ::std::string& value) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(value);
}
inline void BlacklistRequest::set_uniqueid(const char* value) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(value);
}
inline void BlacklistRequest::set_uniqueid(const char* value, size_t size) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlacklistRequest::mutable_uniqueid() {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  return uniqueid_;
}
inline ::std::string* BlacklistRequest::release_uniqueid() {
  clear_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uniqueid_;
    uniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlacklistRequest::set_allocated_uniqueid(::std::string* uniqueid) {
  if (uniqueid_ != &::google::protobuf::internal::kEmptyString) {
    delete uniqueid_;
  }
  if (uniqueid) {
    set_has_uniqueid();
    uniqueid_ = uniqueid;
  } else {
    clear_has_uniqueid();
    uniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ProcessTip

// optional string msgName = 1 [default = "PROCESS_TIP"];
inline bool ProcessTip::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProcessTip::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProcessTip::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProcessTip::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ProcessTip::msgname() const {
  return *msgname_;
}
inline void ProcessTip::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ProcessTip::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ProcessTip::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessTip::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ProcessTip::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ProcessTip::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional bool isTrigger = 2 [default = true];
inline bool ProcessTip::has_istrigger() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProcessTip::set_has_istrigger() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProcessTip::clear_has_istrigger() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProcessTip::clear_istrigger() {
  istrigger_ = true;
  clear_has_istrigger();
}
inline bool ProcessTip::istrigger() const {
  return istrigger_;
}
inline void ProcessTip::set_istrigger(bool value) {
  set_has_istrigger();
  istrigger_ = value;
}

// optional int32 soi = 3;
inline bool ProcessTip::has_soi() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProcessTip::set_has_soi() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProcessTip::clear_has_soi() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProcessTip::clear_soi() {
  soi_ = 0;
  clear_has_soi();
}
inline ::google::protobuf::int32 ProcessTip::soi() const {
  return soi_;
}
inline void ProcessTip::set_soi(::google::protobuf::int32 value) {
  set_has_soi();
  soi_ = value;
}

// optional double frequency = 4;
inline bool ProcessTip::has_frequency() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProcessTip::set_has_frequency() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProcessTip::clear_has_frequency() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProcessTip::clear_frequency() {
  frequency_ = 0;
  clear_has_frequency();
}
inline double ProcessTip::frequency() const {
  return frequency_;
}
inline void ProcessTip::set_frequency(double value) {
  set_has_frequency();
  frequency_ = value;
}

// optional float latitude = 5;
inline bool ProcessTip::has_latitude() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProcessTip::set_has_latitude() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProcessTip::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProcessTip::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline float ProcessTip::latitude() const {
  return latitude_;
}
inline void ProcessTip::set_latitude(float value) {
  set_has_latitude();
  latitude_ = value;
}

// optional float longitude = 6;
inline bool ProcessTip::has_longitude() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProcessTip::set_has_longitude() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProcessTip::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProcessTip::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline float ProcessTip::longitude() const {
  return longitude_;
}
inline void ProcessTip::set_longitude(float value) {
  set_has_longitude();
  longitude_ = value;
}

// optional double idNumber = 7;
inline bool ProcessTip::has_idnumber() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ProcessTip::set_has_idnumber() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ProcessTip::clear_has_idnumber() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ProcessTip::clear_idnumber() {
  idnumber_ = 0;
  clear_has_idnumber();
}
inline double ProcessTip::idnumber() const {
  return idnumber_;
}
inline void ProcessTip::set_idnumber(double value) {
  set_has_idnumber();
  idnumber_ = value;
}

// -------------------------------------------------------------------

// GeoLaunch

// optional string msgName = 1 [default = "GEO_LAUNCH"];
inline bool GeoLaunch::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GeoLaunch::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GeoLaunch::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GeoLaunch::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& GeoLaunch::msgname() const {
  return *msgname_;
}
inline void GeoLaunch::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GeoLaunch::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void GeoLaunch::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoLaunch::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* GeoLaunch::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void GeoLaunch::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional bool isTrigger = 2 [default = true];
inline bool GeoLaunch::has_istrigger() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GeoLaunch::set_has_istrigger() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GeoLaunch::clear_has_istrigger() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GeoLaunch::clear_istrigger() {
  istrigger_ = true;
  clear_has_istrigger();
}
inline bool GeoLaunch::istrigger() const {
  return istrigger_;
}
inline void GeoLaunch::set_istrigger(bool value) {
  set_has_istrigger();
  istrigger_ = value;
}

// optional float cf = 3;
inline bool GeoLaunch::has_cf() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GeoLaunch::set_has_cf() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GeoLaunch::clear_has_cf() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GeoLaunch::clear_cf() {
  cf_ = 0;
  clear_has_cf();
}
inline float GeoLaunch::cf() const {
  return cf_;
}
inline void GeoLaunch::set_cf(float value) {
  set_has_cf();
  cf_ = value;
}

// optional int32 chan = 4;
inline bool GeoLaunch::has_chan() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GeoLaunch::set_has_chan() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GeoLaunch::clear_has_chan() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GeoLaunch::clear_chan() {
  chan_ = 0;
  clear_has_chan();
}
inline ::google::protobuf::int32 GeoLaunch::chan() const {
  return chan_;
}
inline void GeoLaunch::set_chan(::google::protobuf::int32 value) {
  set_has_chan();
  chan_ = value;
}

// optional int32 az = 5;
inline bool GeoLaunch::has_az() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GeoLaunch::set_has_az() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GeoLaunch::clear_has_az() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GeoLaunch::clear_az() {
  az_ = 0;
  clear_has_az();
}
inline ::google::protobuf::int32 GeoLaunch::az() const {
  return az_;
}
inline void GeoLaunch::set_az(::google::protobuf::int32 value) {
  set_has_az();
  az_ = value;
}

// optional float lat = 6;
inline bool GeoLaunch::has_lat() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GeoLaunch::set_has_lat() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GeoLaunch::clear_has_lat() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GeoLaunch::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline float GeoLaunch::lat() const {
  return lat_;
}
inline void GeoLaunch::set_lat(float value) {
  set_has_lat();
  lat_ = value;
}

// optional float lon = 7;
inline bool GeoLaunch::has_lon() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GeoLaunch::set_has_lon() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GeoLaunch::clear_has_lon() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GeoLaunch::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline float GeoLaunch::lon() const {
  return lon_;
}
inline void GeoLaunch::set_lon(float value) {
  set_has_lon();
  lon_ = value;
}

// optional string scrypt = 8;
inline bool GeoLaunch::has_scrypt() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GeoLaunch::set_has_scrypt() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GeoLaunch::clear_has_scrypt() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GeoLaunch::clear_scrypt() {
  if (scrypt_ != &::google::protobuf::internal::kEmptyString) {
    scrypt_->clear();
  }
  clear_has_scrypt();
}
inline const ::std::string& GeoLaunch::scrypt() const {
  return *scrypt_;
}
inline void GeoLaunch::set_scrypt(const ::std::string& value) {
  set_has_scrypt();
  if (scrypt_ == &::google::protobuf::internal::kEmptyString) {
    scrypt_ = new ::std::string;
  }
  scrypt_->assign(value);
}
inline void GeoLaunch::set_scrypt(const char* value) {
  set_has_scrypt();
  if (scrypt_ == &::google::protobuf::internal::kEmptyString) {
    scrypt_ = new ::std::string;
  }
  scrypt_->assign(value);
}
inline void GeoLaunch::set_scrypt(const char* value, size_t size) {
  set_has_scrypt();
  if (scrypt_ == &::google::protobuf::internal::kEmptyString) {
    scrypt_ = new ::std::string;
  }
  scrypt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoLaunch::mutable_scrypt() {
  set_has_scrypt();
  if (scrypt_ == &::google::protobuf::internal::kEmptyString) {
    scrypt_ = new ::std::string;
  }
  return scrypt_;
}
inline ::std::string* GeoLaunch::release_scrypt() {
  clear_has_scrypt();
  if (scrypt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = scrypt_;
    scrypt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeoLaunch::set_allocated_scrypt(::std::string* scrypt) {
  if (scrypt_ != &::google::protobuf::internal::kEmptyString) {
    delete scrypt_;
  }
  if (scrypt) {
    set_has_scrypt();
    scrypt_ = scrypt;
  } else {
    clear_has_scrypt();
    scrypt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string rcvr_name = 9;
inline bool GeoLaunch::has_rcvr_name() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GeoLaunch::set_has_rcvr_name() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GeoLaunch::clear_has_rcvr_name() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GeoLaunch::clear_rcvr_name() {
  if (rcvr_name_ != &::google::protobuf::internal::kEmptyString) {
    rcvr_name_->clear();
  }
  clear_has_rcvr_name();
}
inline const ::std::string& GeoLaunch::rcvr_name() const {
  return *rcvr_name_;
}
inline void GeoLaunch::set_rcvr_name(const ::std::string& value) {
  set_has_rcvr_name();
  if (rcvr_name_ == &::google::protobuf::internal::kEmptyString) {
    rcvr_name_ = new ::std::string;
  }
  rcvr_name_->assign(value);
}
inline void GeoLaunch::set_rcvr_name(const char* value) {
  set_has_rcvr_name();
  if (rcvr_name_ == &::google::protobuf::internal::kEmptyString) {
    rcvr_name_ = new ::std::string;
  }
  rcvr_name_->assign(value);
}
inline void GeoLaunch::set_rcvr_name(const char* value, size_t size) {
  set_has_rcvr_name();
  if (rcvr_name_ == &::google::protobuf::internal::kEmptyString) {
    rcvr_name_ = new ::std::string;
  }
  rcvr_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeoLaunch::mutable_rcvr_name() {
  set_has_rcvr_name();
  if (rcvr_name_ == &::google::protobuf::internal::kEmptyString) {
    rcvr_name_ = new ::std::string;
  }
  return rcvr_name_;
}
inline ::std::string* GeoLaunch::release_rcvr_name() {
  clear_has_rcvr_name();
  if (rcvr_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rcvr_name_;
    rcvr_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeoLaunch::set_allocated_rcvr_name(::std::string* rcvr_name) {
  if (rcvr_name_ != &::google::protobuf::internal::kEmptyString) {
    delete rcvr_name_;
  }
  if (rcvr_name) {
    set_has_rcvr_name();
    rcvr_name_ = rcvr_name;
  } else {
    clear_has_rcvr_name();
    rcvr_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double message_id = 10;
inline bool GeoLaunch::has_message_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GeoLaunch::set_has_message_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GeoLaunch::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GeoLaunch::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline double GeoLaunch::message_id() const {
  return message_id_;
}
inline void GeoLaunch::set_message_id(double value) {
  set_has_message_id();
  message_id_ = value;
}

// -------------------------------------------------------------------

// WifiLaunch

// optional string msgName = 1 [default = "WIFI_LAUNCH"];
inline bool WifiLaunch::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WifiLaunch::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WifiLaunch::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WifiLaunch::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& WifiLaunch::msgname() const {
  return *msgname_;
}
inline void WifiLaunch::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void WifiLaunch::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void WifiLaunch::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WifiLaunch::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* WifiLaunch::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void WifiLaunch::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional bool isTrigger = 2 [default = true];
inline bool WifiLaunch::has_istrigger() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WifiLaunch::set_has_istrigger() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WifiLaunch::clear_has_istrigger() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WifiLaunch::clear_istrigger() {
  istrigger_ = true;
  clear_has_istrigger();
}
inline bool WifiLaunch::istrigger() const {
  return istrigger_;
}
inline void WifiLaunch::set_istrigger(bool value) {
  set_has_istrigger();
  istrigger_ = value;
}

// optional string infile = 3;
inline bool WifiLaunch::has_infile() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WifiLaunch::set_has_infile() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WifiLaunch::clear_has_infile() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WifiLaunch::clear_infile() {
  if (infile_ != &::google::protobuf::internal::kEmptyString) {
    infile_->clear();
  }
  clear_has_infile();
}
inline const ::std::string& WifiLaunch::infile() const {
  return *infile_;
}
inline void WifiLaunch::set_infile(const ::std::string& value) {
  set_has_infile();
  if (infile_ == &::google::protobuf::internal::kEmptyString) {
    infile_ = new ::std::string;
  }
  infile_->assign(value);
}
inline void WifiLaunch::set_infile(const char* value) {
  set_has_infile();
  if (infile_ == &::google::protobuf::internal::kEmptyString) {
    infile_ = new ::std::string;
  }
  infile_->assign(value);
}
inline void WifiLaunch::set_infile(const char* value, size_t size) {
  set_has_infile();
  if (infile_ == &::google::protobuf::internal::kEmptyString) {
    infile_ = new ::std::string;
  }
  infile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WifiLaunch::mutable_infile() {
  set_has_infile();
  if (infile_ == &::google::protobuf::internal::kEmptyString) {
    infile_ = new ::std::string;
  }
  return infile_;
}
inline ::std::string* WifiLaunch::release_infile() {
  clear_has_infile();
  if (infile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = infile_;
    infile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WifiLaunch::set_allocated_infile(::std::string* infile) {
  if (infile_ != &::google::protobuf::internal::kEmptyString) {
    delete infile_;
  }
  if (infile) {
    set_has_infile();
    infile_ = infile;
  } else {
    clear_has_infile();
    infile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mac = 4;
inline bool WifiLaunch::has_mac() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WifiLaunch::set_has_mac() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WifiLaunch::clear_has_mac() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WifiLaunch::clear_mac() {
  if (mac_ != &::google::protobuf::internal::kEmptyString) {
    mac_->clear();
  }
  clear_has_mac();
}
inline const ::std::string& WifiLaunch::mac() const {
  return *mac_;
}
inline void WifiLaunch::set_mac(const ::std::string& value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
}
inline void WifiLaunch::set_mac(const char* value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
}
inline void WifiLaunch::set_mac(const char* value, size_t size) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WifiLaunch::mutable_mac() {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  return mac_;
}
inline ::std::string* WifiLaunch::release_mac() {
  clear_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mac_;
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WifiLaunch::set_allocated_mac(::std::string* mac) {
  if (mac_ != &::google::protobuf::internal::kEmptyString) {
    delete mac_;
  }
  if (mac) {
    set_has_mac();
    mac_ = mac;
  } else {
    clear_has_mac();
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string frameType = 5;
inline bool WifiLaunch::has_frametype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WifiLaunch::set_has_frametype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WifiLaunch::clear_has_frametype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WifiLaunch::clear_frametype() {
  if (frametype_ != &::google::protobuf::internal::kEmptyString) {
    frametype_->clear();
  }
  clear_has_frametype();
}
inline const ::std::string& WifiLaunch::frametype() const {
  return *frametype_;
}
inline void WifiLaunch::set_frametype(const ::std::string& value) {
  set_has_frametype();
  if (frametype_ == &::google::protobuf::internal::kEmptyString) {
    frametype_ = new ::std::string;
  }
  frametype_->assign(value);
}
inline void WifiLaunch::set_frametype(const char* value) {
  set_has_frametype();
  if (frametype_ == &::google::protobuf::internal::kEmptyString) {
    frametype_ = new ::std::string;
  }
  frametype_->assign(value);
}
inline void WifiLaunch::set_frametype(const char* value, size_t size) {
  set_has_frametype();
  if (frametype_ == &::google::protobuf::internal::kEmptyString) {
    frametype_ = new ::std::string;
  }
  frametype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WifiLaunch::mutable_frametype() {
  set_has_frametype();
  if (frametype_ == &::google::protobuf::internal::kEmptyString) {
    frametype_ = new ::std::string;
  }
  return frametype_;
}
inline ::std::string* WifiLaunch::release_frametype() {
  clear_has_frametype();
  if (frametype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = frametype_;
    frametype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WifiLaunch::set_allocated_frametype(::std::string* frametype) {
  if (frametype_ != &::google::protobuf::internal::kEmptyString) {
    delete frametype_;
  }
  if (frametype) {
    set_has_frametype();
    frametype_ = frametype;
  } else {
    clear_has_frametype();
    frametype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string csvfile = 6;
inline bool WifiLaunch::has_csvfile() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WifiLaunch::set_has_csvfile() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WifiLaunch::clear_has_csvfile() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WifiLaunch::clear_csvfile() {
  if (csvfile_ != &::google::protobuf::internal::kEmptyString) {
    csvfile_->clear();
  }
  clear_has_csvfile();
}
inline const ::std::string& WifiLaunch::csvfile() const {
  return *csvfile_;
}
inline void WifiLaunch::set_csvfile(const ::std::string& value) {
  set_has_csvfile();
  if (csvfile_ == &::google::protobuf::internal::kEmptyString) {
    csvfile_ = new ::std::string;
  }
  csvfile_->assign(value);
}
inline void WifiLaunch::set_csvfile(const char* value) {
  set_has_csvfile();
  if (csvfile_ == &::google::protobuf::internal::kEmptyString) {
    csvfile_ = new ::std::string;
  }
  csvfile_->assign(value);
}
inline void WifiLaunch::set_csvfile(const char* value, size_t size) {
  set_has_csvfile();
  if (csvfile_ == &::google::protobuf::internal::kEmptyString) {
    csvfile_ = new ::std::string;
  }
  csvfile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WifiLaunch::mutable_csvfile() {
  set_has_csvfile();
  if (csvfile_ == &::google::protobuf::internal::kEmptyString) {
    csvfile_ = new ::std::string;
  }
  return csvfile_;
}
inline ::std::string* WifiLaunch::release_csvfile() {
  clear_has_csvfile();
  if (csvfile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = csvfile_;
    csvfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WifiLaunch::set_allocated_csvfile(::std::string* csvfile) {
  if (csvfile_ != &::google::protobuf::internal::kEmptyString) {
    delete csvfile_;
  }
  if (csvfile) {
    set_has_csvfile();
    csvfile_ = csvfile;
  } else {
    clear_has_csvfile();
    csvfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 chan = 7;
inline bool WifiLaunch::has_chan() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void WifiLaunch::set_has_chan() {
  _has_bits_[0] |= 0x00000040u;
}
inline void WifiLaunch::clear_has_chan() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void WifiLaunch::clear_chan() {
  chan_ = 0;
  clear_has_chan();
}
inline ::google::protobuf::int32 WifiLaunch::chan() const {
  return chan_;
}
inline void WifiLaunch::set_chan(::google::protobuf::int32 value) {
  set_has_chan();
  chan_ = value;
}

// optional double message_id = 8;
inline bool WifiLaunch::has_message_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void WifiLaunch::set_has_message_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void WifiLaunch::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void WifiLaunch::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline double WifiLaunch::message_id() const {
  return message_id_;
}
inline void WifiLaunch::set_message_id(double value) {
  set_has_message_id();
  message_id_ = value;
}

// -------------------------------------------------------------------

// ReallocateResources

// optional string msgName = 1 [default = "REALLOCATE_RESOURCES"];
inline bool ReallocateResources::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReallocateResources::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReallocateResources::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReallocateResources::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ReallocateResources::msgname() const {
  return *msgname_;
}
inline void ReallocateResources::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ReallocateResources::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ReallocateResources::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReallocateResources::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ReallocateResources::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ReallocateResources::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional bool isTrigger = 2 [default = true];
inline bool ReallocateResources::has_istrigger() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReallocateResources::set_has_istrigger() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReallocateResources::clear_has_istrigger() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReallocateResources::clear_istrigger() {
  istrigger_ = true;
  clear_has_istrigger();
}
inline bool ReallocateResources::istrigger() const {
  return istrigger_;
}
inline void ReallocateResources::set_istrigger(bool value) {
  set_has_istrigger();
  istrigger_ = value;
}

// optional int32 appID = 3;
inline bool ReallocateResources::has_appid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReallocateResources::set_has_appid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReallocateResources::clear_has_appid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReallocateResources::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 ReallocateResources::appid() const {
  return appid_;
}
inline void ReallocateResources::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// -------------------------------------------------------------------

// ControlUpgrade

// optional string msgName = 1 [default = "CONTROL_UPGRADE"];
inline bool ControlUpgrade::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ControlUpgrade::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ControlUpgrade::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ControlUpgrade::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ControlUpgrade::msgname() const {
  return *msgname_;
}
inline void ControlUpgrade::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ControlUpgrade::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ControlUpgrade::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ControlUpgrade::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ControlUpgrade::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ControlUpgrade::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional bool isTrigger = 2 [default = true];
inline bool ControlUpgrade::has_istrigger() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ControlUpgrade::set_has_istrigger() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ControlUpgrade::clear_has_istrigger() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ControlUpgrade::clear_istrigger() {
  istrigger_ = true;
  clear_has_istrigger();
}
inline bool ControlUpgrade::istrigger() const {
  return istrigger_;
}
inline void ControlUpgrade::set_istrigger(bool value) {
  set_has_istrigger();
  istrigger_ = value;
}

// -------------------------------------------------------------------

// RfcuSwitch

// optional string msgName = 1 [default = "RFCU_SWITCH"];
inline bool RfcuSwitch::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RfcuSwitch::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RfcuSwitch::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RfcuSwitch::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& RfcuSwitch::msgname() const {
  return *msgname_;
}
inline void RfcuSwitch::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RfcuSwitch::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void RfcuSwitch::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RfcuSwitch::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* RfcuSwitch::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void RfcuSwitch::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional bool isTrigger = 2 [default = true];
inline bool RfcuSwitch::has_istrigger() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RfcuSwitch::set_has_istrigger() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RfcuSwitch::clear_has_istrigger() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RfcuSwitch::clear_istrigger() {
  istrigger_ = true;
  clear_has_istrigger();
}
inline bool RfcuSwitch::istrigger() const {
  return istrigger_;
}
inline void RfcuSwitch::set_istrigger(bool value) {
  set_has_istrigger();
  istrigger_ = value;
}

// optional int32 standbyState = 3;
inline bool RfcuSwitch::has_standbystate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RfcuSwitch::set_has_standbystate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RfcuSwitch::clear_has_standbystate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RfcuSwitch::clear_standbystate() {
  standbystate_ = 0;
  clear_has_standbystate();
}
inline ::google::protobuf::int32 RfcuSwitch::standbystate() const {
  return standbystate_;
}
inline void RfcuSwitch::set_standbystate(::google::protobuf::int32 value) {
  set_has_standbystate();
  standbystate_ = value;
}

// -------------------------------------------------------------------

// TGDopplerTip

// optional string msgName = 1 [default = "TG_DOPPLER_TIP"];
inline bool TGDopplerTip::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TGDopplerTip::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TGDopplerTip::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TGDopplerTip::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& TGDopplerTip::msgname() const {
  return *msgname_;
}
inline void TGDopplerTip::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void TGDopplerTip::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void TGDopplerTip::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TGDopplerTip::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* TGDopplerTip::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void TGDopplerTip::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional bool isTrigger = 2 [default = true];
inline bool TGDopplerTip::has_istrigger() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TGDopplerTip::set_has_istrigger() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TGDopplerTip::clear_has_istrigger() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TGDopplerTip::clear_istrigger() {
  istrigger_ = true;
  clear_has_istrigger();
}
inline bool TGDopplerTip::istrigger() const {
  return istrigger_;
}
inline void TGDopplerTip::set_istrigger(bool value) {
  set_has_istrigger();
  istrigger_ = value;
}

// optional string globalID = 3;
inline bool TGDopplerTip::has_globalid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TGDopplerTip::set_has_globalid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TGDopplerTip::clear_has_globalid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TGDopplerTip::clear_globalid() {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    globalid_->clear();
  }
  clear_has_globalid();
}
inline const ::std::string& TGDopplerTip::globalid() const {
  return *globalid_;
}
inline void TGDopplerTip::set_globalid(const ::std::string& value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void TGDopplerTip::set_globalid(const char* value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void TGDopplerTip::set_globalid(const char* value, size_t size) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TGDopplerTip::mutable_globalid() {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  return globalid_;
}
inline ::std::string* TGDopplerTip::release_globalid() {
  clear_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalid_;
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TGDopplerTip::set_allocated_globalid(::std::string* globalid) {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    delete globalid_;
  }
  if (globalid) {
    set_has_globalid();
    globalid_ = globalid;
  } else {
    clear_has_globalid();
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double frequency = 4;
inline bool TGDopplerTip::has_frequency() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TGDopplerTip::set_has_frequency() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TGDopplerTip::clear_has_frequency() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TGDopplerTip::clear_frequency() {
  frequency_ = 0;
  clear_has_frequency();
}
inline double TGDopplerTip::frequency() const {
  return frequency_;
}
inline void TGDopplerTip::set_frequency(double value) {
  set_has_frequency();
  frequency_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace falcon_trigger_msg

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_trigger_msg::Intercept_TeamType>() {
  return ::falcon_trigger_msg::Intercept_TeamType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_trigger_msg::InterceptListRequest_Type>() {
  return ::falcon_trigger_msg::InterceptListRequest_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::falcon_trigger_msg::BlacklistRequest_Type>() {
  return ::falcon_trigger_msg::BlacklistRequest_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_FalconTriggerMessages_2eproto__INCLUDED
