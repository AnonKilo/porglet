// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: StateKeeperMessages.proto

#ifndef PROTOBUF_StateKeeperMessages_2eproto__INCLUDED
#define PROTOBUF_StateKeeperMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace raptorx_msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_StateKeeperMessages_2eproto();
void protobuf_AssignDesc_StateKeeperMessages_2eproto();
void protobuf_ShutdownFile_StateKeeperMessages_2eproto();

class StateKeeperStatus;
class Detection;
class SensorGPSPosition;
class ActionStatus;
class SystemStatus;
class Ping;

// ===================================================================

class StateKeeperStatus : public ::google::protobuf::Message {
 public:
  StateKeeperStatus();
  virtual ~StateKeeperStatus();

  StateKeeperStatus(const StateKeeperStatus& from);

  inline StateKeeperStatus& operator=(const StateKeeperStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StateKeeperStatus& default_instance();

  void Swap(StateKeeperStatus* other);

  // implements Message ----------------------------------------------

  StateKeeperStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StateKeeperStatus& from);
  void MergeFrom(const StateKeeperStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "StateKeeperStatus"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string state_name = 2;
  inline bool has_state_name() const;
  inline void clear_state_name();
  static const int kStateNameFieldNumber = 2;
  inline const ::std::string& state_name() const;
  inline void set_state_name(const ::std::string& value);
  inline void set_state_name(const char* value);
  inline void set_state_name(const char* value, size_t size);
  inline ::std::string* mutable_state_name();
  inline ::std::string* release_state_name();
  inline void set_allocated_state_name(::std::string* state_name);

  // @@protoc_insertion_point(class_scope:raptorx_msg.StateKeeperStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_state_name();
  inline void clear_has_state_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* state_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_StateKeeperMessages_2eproto();
  friend void protobuf_AssignDesc_StateKeeperMessages_2eproto();
  friend void protobuf_ShutdownFile_StateKeeperMessages_2eproto();

  void InitAsDefaultInstance();
  static StateKeeperStatus* default_instance_;
};
// -------------------------------------------------------------------

class Detection : public ::google::protobuf::Message {
 public:
  Detection();
  virtual ~Detection();

  Detection(const Detection& from);

  inline Detection& operator=(const Detection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Detection& default_instance();

  void Swap(Detection* other);

  // implements Message ----------------------------------------------

  Detection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Detection& from);
  void MergeFrom(const Detection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "Detection"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional int64 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // optional int64 characterization_id = 3;
  inline bool has_characterization_id() const;
  inline void clear_characterization_id();
  static const int kCharacterizationIdFieldNumber = 3;
  inline ::google::protobuf::int64 characterization_id() const;
  inline void set_characterization_id(::google::protobuf::int64 value);

  // optional string signal = 4;
  inline bool has_signal() const;
  inline void clear_signal();
  static const int kSignalFieldNumber = 4;
  inline const ::std::string& signal() const;
  inline void set_signal(const ::std::string& value);
  inline void set_signal(const char* value);
  inline void set_signal(const char* value, size_t size);
  inline ::std::string* mutable_signal();
  inline ::std::string* release_signal();
  inline void set_allocated_signal(::std::string* signal);

  // optional string feed = 5;
  inline bool has_feed() const;
  inline void clear_feed();
  static const int kFeedFieldNumber = 5;
  inline const ::std::string& feed() const;
  inline void set_feed(const ::std::string& value);
  inline void set_feed(const char* value);
  inline void set_feed(const char* value, size_t size);
  inline ::std::string* mutable_feed();
  inline ::std::string* release_feed();
  inline void set_allocated_feed(::std::string* feed);

  // optional int64 time_whole = 6;
  inline bool has_time_whole() const;
  inline void clear_time_whole();
  static const int kTimeWholeFieldNumber = 6;
  inline ::google::protobuf::int64 time_whole() const;
  inline void set_time_whole(::google::protobuf::int64 value);

  // optional double time_fractional = 7;
  inline bool has_time_fractional() const;
  inline void clear_time_fractional();
  static const int kTimeFractionalFieldNumber = 7;
  inline double time_fractional() const;
  inline void set_time_fractional(double value);

  // optional double duration = 8;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 8;
  inline double duration() const;
  inline void set_duration(double value);

  // optional double center_frequency = 9;
  inline bool has_center_frequency() const;
  inline void clear_center_frequency();
  static const int kCenterFrequencyFieldNumber = 9;
  inline double center_frequency() const;
  inline void set_center_frequency(double value);

  // optional double bandwidth = 10;
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandwidthFieldNumber = 10;
  inline double bandwidth() const;
  inline void set_bandwidth(double value);

  // optional double azimuth = 11;
  inline bool has_azimuth() const;
  inline void clear_azimuth();
  static const int kAzimuthFieldNumber = 11;
  inline double azimuth() const;
  inline void set_azimuth(double value);

  // optional double elevation = 12;
  inline bool has_elevation() const;
  inline void clear_elevation();
  static const int kElevationFieldNumber = 12;
  inline double elevation() const;
  inline void set_elevation(double value);

  // optional double snr = 13;
  inline bool has_snr() const;
  inline void clear_snr();
  static const int kSnrFieldNumber = 13;
  inline double snr() const;
  inline void set_snr(double value);

  // optional bool hidden = 14;
  inline bool has_hidden() const;
  inline void clear_hidden();
  static const int kHiddenFieldNumber = 14;
  inline bool hidden() const;
  inline void set_hidden(bool value);

  // optional int32 wrindex = 15;
  inline bool has_wrindex() const;
  inline void clear_wrindex();
  static const int kWrindexFieldNumber = 15;
  inline ::google::protobuf::int32 wrindex() const;
  inline void set_wrindex(::google::protobuf::int32 value);

  // optional string globalID = 16;
  inline bool has_globalid() const;
  inline void clear_globalid();
  static const int kGlobalIDFieldNumber = 16;
  inline const ::std::string& globalid() const;
  inline void set_globalid(const ::std::string& value);
  inline void set_globalid(const char* value);
  inline void set_globalid(const char* value, size_t size);
  inline ::std::string* mutable_globalid();
  inline ::std::string* release_globalid();
  inline void set_allocated_globalid(::std::string* globalid);

  // @@protoc_insertion_point(class_scope:raptorx_msg.Detection)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_characterization_id();
  inline void clear_has_characterization_id();
  inline void set_has_signal();
  inline void clear_has_signal();
  inline void set_has_feed();
  inline void clear_has_feed();
  inline void set_has_time_whole();
  inline void clear_has_time_whole();
  inline void set_has_time_fractional();
  inline void clear_has_time_fractional();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_center_frequency();
  inline void clear_has_center_frequency();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();
  inline void set_has_azimuth();
  inline void clear_has_azimuth();
  inline void set_has_elevation();
  inline void clear_has_elevation();
  inline void set_has_snr();
  inline void clear_has_snr();
  inline void set_has_hidden();
  inline void clear_has_hidden();
  inline void set_has_wrindex();
  inline void clear_has_wrindex();
  inline void set_has_globalid();
  inline void clear_has_globalid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::int64 characterization_id_;
  ::std::string* signal_;
  ::std::string* feed_;
  ::google::protobuf::int64 time_whole_;
  double time_fractional_;
  double duration_;
  double center_frequency_;
  double bandwidth_;
  double azimuth_;
  double elevation_;
  double snr_;
  bool hidden_;
  ::google::protobuf::int32 wrindex_;
  ::std::string* globalid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_StateKeeperMessages_2eproto();
  friend void protobuf_AssignDesc_StateKeeperMessages_2eproto();
  friend void protobuf_ShutdownFile_StateKeeperMessages_2eproto();

  void InitAsDefaultInstance();
  static Detection* default_instance_;
};
// -------------------------------------------------------------------

class SensorGPSPosition : public ::google::protobuf::Message {
 public:
  SensorGPSPosition();
  virtual ~SensorGPSPosition();

  SensorGPSPosition(const SensorGPSPosition& from);

  inline SensorGPSPosition& operator=(const SensorGPSPosition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorGPSPosition& default_instance();

  void Swap(SensorGPSPosition* other);

  // implements Message ----------------------------------------------

  SensorGPSPosition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SensorGPSPosition& from);
  void MergeFrom(const SensorGPSPosition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SensorGPSPosition"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional float lat = 2;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 2;
  inline float lat() const;
  inline void set_lat(float value);

  // optional float lon = 3;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 3;
  inline float lon() const;
  inline void set_lon(float value);

  // optional float alt = 4;
  inline bool has_alt() const;
  inline void clear_alt();
  static const int kAltFieldNumber = 4;
  inline float alt() const;
  inline void set_alt(float value);

  // optional float major = 5;
  inline bool has_major() const;
  inline void clear_major();
  static const int kMajorFieldNumber = 5;
  inline float major() const;
  inline void set_major(float value);

  // optional float minor = 6;
  inline bool has_minor() const;
  inline void clear_minor();
  static const int kMinorFieldNumber = 6;
  inline float minor() const;
  inline void set_minor(float value);

  // optional float vector = 7;
  inline bool has_vector() const;
  inline void clear_vector();
  static const int kVectorFieldNumber = 7;
  inline float vector() const;
  inline void set_vector(float value);

  // optional string timestamp = 8;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 8;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  inline void set_allocated_timestamp(::std::string* timestamp);

  // @@protoc_insertion_point(class_scope:raptorx_msg.SensorGPSPosition)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_alt();
  inline void clear_has_alt();
  inline void set_has_major();
  inline void clear_has_major();
  inline void set_has_minor();
  inline void clear_has_minor();
  inline void set_has_vector();
  inline void clear_has_vector();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  float lat_;
  float lon_;
  float alt_;
  float major_;
  float minor_;
  float vector_;
  ::std::string* timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_StateKeeperMessages_2eproto();
  friend void protobuf_AssignDesc_StateKeeperMessages_2eproto();
  friend void protobuf_ShutdownFile_StateKeeperMessages_2eproto();

  void InitAsDefaultInstance();
  static SensorGPSPosition* default_instance_;
};
// -------------------------------------------------------------------

class ActionStatus : public ::google::protobuf::Message {
 public:
  ActionStatus();
  virtual ~ActionStatus();

  ActionStatus(const ActionStatus& from);

  inline ActionStatus& operator=(const ActionStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionStatus& default_instance();

  void Swap(ActionStatus* other);

  // implements Message ----------------------------------------------

  ActionStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActionStatus& from);
  void MergeFrom(const ActionStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "ActionStatus"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string executing = 2;
  inline bool has_executing() const;
  inline void clear_executing();
  static const int kExecutingFieldNumber = 2;
  inline const ::std::string& executing() const;
  inline void set_executing(const ::std::string& value);
  inline void set_executing(const char* value);
  inline void set_executing(const char* value, size_t size);
  inline ::std::string* mutable_executing();
  inline ::std::string* release_executing();
  inline void set_allocated_executing(::std::string* executing);

  // optional string ampOn = 3;
  inline bool has_ampon() const;
  inline void clear_ampon();
  static const int kAmpOnFieldNumber = 3;
  inline const ::std::string& ampon() const;
  inline void set_ampon(const ::std::string& value);
  inline void set_ampon(const char* value);
  inline void set_ampon(const char* value, size_t size);
  inline ::std::string* mutable_ampon();
  inline ::std::string* release_ampon();
  inline void set_allocated_ampon(::std::string* ampon);

  // optional string strikeAssessment = 4;
  inline bool has_strikeassessment() const;
  inline void clear_strikeassessment();
  static const int kStrikeAssessmentFieldNumber = 4;
  inline const ::std::string& strikeassessment() const;
  inline void set_strikeassessment(const ::std::string& value);
  inline void set_strikeassessment(const char* value);
  inline void set_strikeassessment(const char* value, size_t size);
  inline ::std::string* mutable_strikeassessment();
  inline ::std::string* release_strikeassessment();
  inline void set_allocated_strikeassessment(::std::string* strikeassessment);

  // optional string underAttack = 5;
  inline bool has_underattack() const;
  inline void clear_underattack();
  static const int kUnderAttackFieldNumber = 5;
  inline const ::std::string& underattack() const;
  inline void set_underattack(const ::std::string& value);
  inline void set_underattack(const char* value);
  inline void set_underattack(const char* value, size_t size);
  inline ::std::string* mutable_underattack();
  inline ::std::string* release_underattack();
  inline void set_allocated_underattack(::std::string* underattack);

  // optional string jamType = 6;
  inline bool has_jamtype() const;
  inline void clear_jamtype();
  static const int kJamTypeFieldNumber = 6;
  inline const ::std::string& jamtype() const;
  inline void set_jamtype(const ::std::string& value);
  inline void set_jamtype(const char* value);
  inline void set_jamtype(const char* value, size_t size);
  inline ::std::string* mutable_jamtype();
  inline ::std::string* release_jamtype();
  inline void set_allocated_jamtype(::std::string* jamtype);

  // optional float jamFreq = 7;
  inline bool has_jamfreq() const;
  inline void clear_jamfreq();
  static const int kJamFreqFieldNumber = 7;
  inline float jamfreq() const;
  inline void set_jamfreq(float value);

  // @@protoc_insertion_point(class_scope:raptorx_msg.ActionStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_executing();
  inline void clear_has_executing();
  inline void set_has_ampon();
  inline void clear_has_ampon();
  inline void set_has_strikeassessment();
  inline void clear_has_strikeassessment();
  inline void set_has_underattack();
  inline void clear_has_underattack();
  inline void set_has_jamtype();
  inline void clear_has_jamtype();
  inline void set_has_jamfreq();
  inline void clear_has_jamfreq();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* executing_;
  ::std::string* ampon_;
  ::std::string* strikeassessment_;
  ::std::string* underattack_;
  ::std::string* jamtype_;
  float jamfreq_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_StateKeeperMessages_2eproto();
  friend void protobuf_AssignDesc_StateKeeperMessages_2eproto();
  friend void protobuf_ShutdownFile_StateKeeperMessages_2eproto();

  void InitAsDefaultInstance();
  static ActionStatus* default_instance_;
};
// -------------------------------------------------------------------

class SystemStatus : public ::google::protobuf::Message {
 public:
  SystemStatus();
  virtual ~SystemStatus();

  SystemStatus(const SystemStatus& from);

  inline SystemStatus& operator=(const SystemStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemStatus& default_instance();

  void Swap(SystemStatus* other);

  // implements Message ----------------------------------------------

  SystemStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemStatus& from);
  void MergeFrom(const SystemStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "SystemStatus"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // optional string hardware_status = 2;
  inline bool has_hardware_status() const;
  inline void clear_hardware_status();
  static const int kHardwareStatusFieldNumber = 2;
  inline const ::std::string& hardware_status() const;
  inline void set_hardware_status(const ::std::string& value);
  inline void set_hardware_status(const char* value);
  inline void set_hardware_status(const char* value, size_t size);
  inline ::std::string* mutable_hardware_status();
  inline ::std::string* release_hardware_status();
  inline void set_allocated_hardware_status(::std::string* hardware_status);

  // optional string software_status = 3;
  inline bool has_software_status() const;
  inline void clear_software_status();
  static const int kSoftwareStatusFieldNumber = 3;
  inline const ::std::string& software_status() const;
  inline void set_software_status(const ::std::string& value);
  inline void set_software_status(const char* value);
  inline void set_software_status(const char* value, size_t size);
  inline ::std::string* mutable_software_status();
  inline ::std::string* release_software_status();
  inline void set_allocated_software_status(::std::string* software_status);

  // optional string gps_lock = 4;
  inline bool has_gps_lock() const;
  inline void clear_gps_lock();
  static const int kGpsLockFieldNumber = 4;
  inline const ::std::string& gps_lock() const;
  inline void set_gps_lock(const ::std::string& value);
  inline void set_gps_lock(const char* value);
  inline void set_gps_lock(const char* value, size_t size);
  inline ::std::string* mutable_gps_lock();
  inline ::std::string* release_gps_lock();
  inline void set_allocated_gps_lock(::std::string* gps_lock);

  // @@protoc_insertion_point(class_scope:raptorx_msg.SystemStatus)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();
  inline void set_has_hardware_status();
  inline void clear_has_hardware_status();
  inline void set_has_software_status();
  inline void clear_has_software_status();
  inline void set_has_gps_lock();
  inline void clear_has_gps_lock();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;
  ::std::string* hardware_status_;
  ::std::string* software_status_;
  ::std::string* gps_lock_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_StateKeeperMessages_2eproto();
  friend void protobuf_AssignDesc_StateKeeperMessages_2eproto();
  friend void protobuf_ShutdownFile_StateKeeperMessages_2eproto();

  void InitAsDefaultInstance();
  static SystemStatus* default_instance_;
};
// -------------------------------------------------------------------

class Ping : public ::google::protobuf::Message {
 public:
  Ping();
  virtual ~Ping();

  Ping(const Ping& from);

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ping& default_instance();

  void Swap(Ping* other);

  // implements Message ----------------------------------------------

  Ping* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ping& from);
  void MergeFrom(const Ping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msgName = 1 [default = "Ping"];
  inline bool has_msgname() const;
  inline void clear_msgname();
  static const int kMsgNameFieldNumber = 1;
  inline const ::std::string& msgname() const;
  inline void set_msgname(const ::std::string& value);
  inline void set_msgname(const char* value);
  inline void set_msgname(const char* value, size_t size);
  inline ::std::string* mutable_msgname();
  inline ::std::string* release_msgname();
  inline void set_allocated_msgname(::std::string* msgname);

  // @@protoc_insertion_point(class_scope:raptorx_msg.Ping)
 private:
  inline void set_has_msgname();
  inline void clear_has_msgname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgname_;
  static ::std::string* _default_msgname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_StateKeeperMessages_2eproto();
  friend void protobuf_AssignDesc_StateKeeperMessages_2eproto();
  friend void protobuf_ShutdownFile_StateKeeperMessages_2eproto();

  void InitAsDefaultInstance();
  static Ping* default_instance_;
};
// ===================================================================


// ===================================================================

// StateKeeperStatus

// optional string msgName = 1 [default = "StateKeeperStatus"];
inline bool StateKeeperStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StateKeeperStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StateKeeperStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StateKeeperStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& StateKeeperStatus::msgname() const {
  return *msgname_;
}
inline void StateKeeperStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void StateKeeperStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void StateKeeperStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StateKeeperStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* StateKeeperStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void StateKeeperStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string state_name = 2;
inline bool StateKeeperStatus::has_state_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StateKeeperStatus::set_has_state_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StateKeeperStatus::clear_has_state_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StateKeeperStatus::clear_state_name() {
  if (state_name_ != &::google::protobuf::internal::kEmptyString) {
    state_name_->clear();
  }
  clear_has_state_name();
}
inline const ::std::string& StateKeeperStatus::state_name() const {
  return *state_name_;
}
inline void StateKeeperStatus::set_state_name(const ::std::string& value) {
  set_has_state_name();
  if (state_name_ == &::google::protobuf::internal::kEmptyString) {
    state_name_ = new ::std::string;
  }
  state_name_->assign(value);
}
inline void StateKeeperStatus::set_state_name(const char* value) {
  set_has_state_name();
  if (state_name_ == &::google::protobuf::internal::kEmptyString) {
    state_name_ = new ::std::string;
  }
  state_name_->assign(value);
}
inline void StateKeeperStatus::set_state_name(const char* value, size_t size) {
  set_has_state_name();
  if (state_name_ == &::google::protobuf::internal::kEmptyString) {
    state_name_ = new ::std::string;
  }
  state_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StateKeeperStatus::mutable_state_name() {
  set_has_state_name();
  if (state_name_ == &::google::protobuf::internal::kEmptyString) {
    state_name_ = new ::std::string;
  }
  return state_name_;
}
inline ::std::string* StateKeeperStatus::release_state_name() {
  clear_has_state_name();
  if (state_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = state_name_;
    state_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StateKeeperStatus::set_allocated_state_name(::std::string* state_name) {
  if (state_name_ != &::google::protobuf::internal::kEmptyString) {
    delete state_name_;
  }
  if (state_name) {
    set_has_state_name();
    state_name_ = state_name;
  } else {
    clear_has_state_name();
    state_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Detection

// optional string msgName = 1 [default = "Detection"];
inline bool Detection::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Detection::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Detection::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Detection::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& Detection::msgname() const {
  return *msgname_;
}
inline void Detection::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void Detection::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void Detection::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Detection::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* Detection::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void Detection::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional int64 id = 2;
inline bool Detection::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Detection::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Detection::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Detection::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 Detection::id() const {
  return id_;
}
inline void Detection::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// optional int64 characterization_id = 3;
inline bool Detection::has_characterization_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Detection::set_has_characterization_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Detection::clear_has_characterization_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Detection::clear_characterization_id() {
  characterization_id_ = GOOGLE_LONGLONG(0);
  clear_has_characterization_id();
}
inline ::google::protobuf::int64 Detection::characterization_id() const {
  return characterization_id_;
}
inline void Detection::set_characterization_id(::google::protobuf::int64 value) {
  set_has_characterization_id();
  characterization_id_ = value;
}

// optional string signal = 4;
inline bool Detection::has_signal() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Detection::set_has_signal() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Detection::clear_has_signal() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Detection::clear_signal() {
  if (signal_ != &::google::protobuf::internal::kEmptyString) {
    signal_->clear();
  }
  clear_has_signal();
}
inline const ::std::string& Detection::signal() const {
  return *signal_;
}
inline void Detection::set_signal(const ::std::string& value) {
  set_has_signal();
  if (signal_ == &::google::protobuf::internal::kEmptyString) {
    signal_ = new ::std::string;
  }
  signal_->assign(value);
}
inline void Detection::set_signal(const char* value) {
  set_has_signal();
  if (signal_ == &::google::protobuf::internal::kEmptyString) {
    signal_ = new ::std::string;
  }
  signal_->assign(value);
}
inline void Detection::set_signal(const char* value, size_t size) {
  set_has_signal();
  if (signal_ == &::google::protobuf::internal::kEmptyString) {
    signal_ = new ::std::string;
  }
  signal_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Detection::mutable_signal() {
  set_has_signal();
  if (signal_ == &::google::protobuf::internal::kEmptyString) {
    signal_ = new ::std::string;
  }
  return signal_;
}
inline ::std::string* Detection::release_signal() {
  clear_has_signal();
  if (signal_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signal_;
    signal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Detection::set_allocated_signal(::std::string* signal) {
  if (signal_ != &::google::protobuf::internal::kEmptyString) {
    delete signal_;
  }
  if (signal) {
    set_has_signal();
    signal_ = signal;
  } else {
    clear_has_signal();
    signal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string feed = 5;
inline bool Detection::has_feed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Detection::set_has_feed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Detection::clear_has_feed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Detection::clear_feed() {
  if (feed_ != &::google::protobuf::internal::kEmptyString) {
    feed_->clear();
  }
  clear_has_feed();
}
inline const ::std::string& Detection::feed() const {
  return *feed_;
}
inline void Detection::set_feed(const ::std::string& value) {
  set_has_feed();
  if (feed_ == &::google::protobuf::internal::kEmptyString) {
    feed_ = new ::std::string;
  }
  feed_->assign(value);
}
inline void Detection::set_feed(const char* value) {
  set_has_feed();
  if (feed_ == &::google::protobuf::internal::kEmptyString) {
    feed_ = new ::std::string;
  }
  feed_->assign(value);
}
inline void Detection::set_feed(const char* value, size_t size) {
  set_has_feed();
  if (feed_ == &::google::protobuf::internal::kEmptyString) {
    feed_ = new ::std::string;
  }
  feed_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Detection::mutable_feed() {
  set_has_feed();
  if (feed_ == &::google::protobuf::internal::kEmptyString) {
    feed_ = new ::std::string;
  }
  return feed_;
}
inline ::std::string* Detection::release_feed() {
  clear_has_feed();
  if (feed_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = feed_;
    feed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Detection::set_allocated_feed(::std::string* feed) {
  if (feed_ != &::google::protobuf::internal::kEmptyString) {
    delete feed_;
  }
  if (feed) {
    set_has_feed();
    feed_ = feed;
  } else {
    clear_has_feed();
    feed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 time_whole = 6;
inline bool Detection::has_time_whole() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Detection::set_has_time_whole() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Detection::clear_has_time_whole() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Detection::clear_time_whole() {
  time_whole_ = GOOGLE_LONGLONG(0);
  clear_has_time_whole();
}
inline ::google::protobuf::int64 Detection::time_whole() const {
  return time_whole_;
}
inline void Detection::set_time_whole(::google::protobuf::int64 value) {
  set_has_time_whole();
  time_whole_ = value;
}

// optional double time_fractional = 7;
inline bool Detection::has_time_fractional() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Detection::set_has_time_fractional() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Detection::clear_has_time_fractional() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Detection::clear_time_fractional() {
  time_fractional_ = 0;
  clear_has_time_fractional();
}
inline double Detection::time_fractional() const {
  return time_fractional_;
}
inline void Detection::set_time_fractional(double value) {
  set_has_time_fractional();
  time_fractional_ = value;
}

// optional double duration = 8;
inline bool Detection::has_duration() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Detection::set_has_duration() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Detection::clear_has_duration() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Detection::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline double Detection::duration() const {
  return duration_;
}
inline void Detection::set_duration(double value) {
  set_has_duration();
  duration_ = value;
}

// optional double center_frequency = 9;
inline bool Detection::has_center_frequency() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Detection::set_has_center_frequency() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Detection::clear_has_center_frequency() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Detection::clear_center_frequency() {
  center_frequency_ = 0;
  clear_has_center_frequency();
}
inline double Detection::center_frequency() const {
  return center_frequency_;
}
inline void Detection::set_center_frequency(double value) {
  set_has_center_frequency();
  center_frequency_ = value;
}

// optional double bandwidth = 10;
inline bool Detection::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Detection::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Detection::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Detection::clear_bandwidth() {
  bandwidth_ = 0;
  clear_has_bandwidth();
}
inline double Detection::bandwidth() const {
  return bandwidth_;
}
inline void Detection::set_bandwidth(double value) {
  set_has_bandwidth();
  bandwidth_ = value;
}

// optional double azimuth = 11;
inline bool Detection::has_azimuth() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Detection::set_has_azimuth() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Detection::clear_has_azimuth() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Detection::clear_azimuth() {
  azimuth_ = 0;
  clear_has_azimuth();
}
inline double Detection::azimuth() const {
  return azimuth_;
}
inline void Detection::set_azimuth(double value) {
  set_has_azimuth();
  azimuth_ = value;
}

// optional double elevation = 12;
inline bool Detection::has_elevation() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Detection::set_has_elevation() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Detection::clear_has_elevation() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Detection::clear_elevation() {
  elevation_ = 0;
  clear_has_elevation();
}
inline double Detection::elevation() const {
  return elevation_;
}
inline void Detection::set_elevation(double value) {
  set_has_elevation();
  elevation_ = value;
}

// optional double snr = 13;
inline bool Detection::has_snr() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Detection::set_has_snr() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Detection::clear_has_snr() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Detection::clear_snr() {
  snr_ = 0;
  clear_has_snr();
}
inline double Detection::snr() const {
  return snr_;
}
inline void Detection::set_snr(double value) {
  set_has_snr();
  snr_ = value;
}

// optional bool hidden = 14;
inline bool Detection::has_hidden() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Detection::set_has_hidden() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Detection::clear_has_hidden() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Detection::clear_hidden() {
  hidden_ = false;
  clear_has_hidden();
}
inline bool Detection::hidden() const {
  return hidden_;
}
inline void Detection::set_hidden(bool value) {
  set_has_hidden();
  hidden_ = value;
}

// optional int32 wrindex = 15;
inline bool Detection::has_wrindex() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Detection::set_has_wrindex() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Detection::clear_has_wrindex() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Detection::clear_wrindex() {
  wrindex_ = 0;
  clear_has_wrindex();
}
inline ::google::protobuf::int32 Detection::wrindex() const {
  return wrindex_;
}
inline void Detection::set_wrindex(::google::protobuf::int32 value) {
  set_has_wrindex();
  wrindex_ = value;
}

// optional string globalID = 16;
inline bool Detection::has_globalid() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Detection::set_has_globalid() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Detection::clear_has_globalid() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Detection::clear_globalid() {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    globalid_->clear();
  }
  clear_has_globalid();
}
inline const ::std::string& Detection::globalid() const {
  return *globalid_;
}
inline void Detection::set_globalid(const ::std::string& value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void Detection::set_globalid(const char* value) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(value);
}
inline void Detection::set_globalid(const char* value, size_t size) {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  globalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Detection::mutable_globalid() {
  set_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    globalid_ = new ::std::string;
  }
  return globalid_;
}
inline ::std::string* Detection::release_globalid() {
  clear_has_globalid();
  if (globalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalid_;
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Detection::set_allocated_globalid(::std::string* globalid) {
  if (globalid_ != &::google::protobuf::internal::kEmptyString) {
    delete globalid_;
  }
  if (globalid) {
    set_has_globalid();
    globalid_ = globalid;
  } else {
    clear_has_globalid();
    globalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SensorGPSPosition

// optional string msgName = 1 [default = "SensorGPSPosition"];
inline bool SensorGPSPosition::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorGPSPosition::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SensorGPSPosition::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SensorGPSPosition::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SensorGPSPosition::msgname() const {
  return *msgname_;
}
inline void SensorGPSPosition::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SensorGPSPosition::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SensorGPSPosition::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SensorGPSPosition::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SensorGPSPosition::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SensorGPSPosition::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional float lat = 2;
inline bool SensorGPSPosition::has_lat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorGPSPosition::set_has_lat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SensorGPSPosition::clear_has_lat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SensorGPSPosition::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline float SensorGPSPosition::lat() const {
  return lat_;
}
inline void SensorGPSPosition::set_lat(float value) {
  set_has_lat();
  lat_ = value;
}

// optional float lon = 3;
inline bool SensorGPSPosition::has_lon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SensorGPSPosition::set_has_lon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SensorGPSPosition::clear_has_lon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SensorGPSPosition::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline float SensorGPSPosition::lon() const {
  return lon_;
}
inline void SensorGPSPosition::set_lon(float value) {
  set_has_lon();
  lon_ = value;
}

// optional float alt = 4;
inline bool SensorGPSPosition::has_alt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SensorGPSPosition::set_has_alt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SensorGPSPosition::clear_has_alt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SensorGPSPosition::clear_alt() {
  alt_ = 0;
  clear_has_alt();
}
inline float SensorGPSPosition::alt() const {
  return alt_;
}
inline void SensorGPSPosition::set_alt(float value) {
  set_has_alt();
  alt_ = value;
}

// optional float major = 5;
inline bool SensorGPSPosition::has_major() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SensorGPSPosition::set_has_major() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SensorGPSPosition::clear_has_major() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SensorGPSPosition::clear_major() {
  major_ = 0;
  clear_has_major();
}
inline float SensorGPSPosition::major() const {
  return major_;
}
inline void SensorGPSPosition::set_major(float value) {
  set_has_major();
  major_ = value;
}

// optional float minor = 6;
inline bool SensorGPSPosition::has_minor() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SensorGPSPosition::set_has_minor() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SensorGPSPosition::clear_has_minor() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SensorGPSPosition::clear_minor() {
  minor_ = 0;
  clear_has_minor();
}
inline float SensorGPSPosition::minor() const {
  return minor_;
}
inline void SensorGPSPosition::set_minor(float value) {
  set_has_minor();
  minor_ = value;
}

// optional float vector = 7;
inline bool SensorGPSPosition::has_vector() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SensorGPSPosition::set_has_vector() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SensorGPSPosition::clear_has_vector() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SensorGPSPosition::clear_vector() {
  vector_ = 0;
  clear_has_vector();
}
inline float SensorGPSPosition::vector() const {
  return vector_;
}
inline void SensorGPSPosition::set_vector(float value) {
  set_has_vector();
  vector_ = value;
}

// optional string timestamp = 8;
inline bool SensorGPSPosition::has_timestamp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SensorGPSPosition::set_has_timestamp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SensorGPSPosition::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SensorGPSPosition::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& SensorGPSPosition::timestamp() const {
  return *timestamp_;
}
inline void SensorGPSPosition::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void SensorGPSPosition::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void SensorGPSPosition::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SensorGPSPosition::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* SensorGPSPosition::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SensorGPSPosition::set_allocated_timestamp(::std::string* timestamp) {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    delete timestamp_;
  }
  if (timestamp) {
    set_has_timestamp();
    timestamp_ = timestamp;
  } else {
    clear_has_timestamp();
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ActionStatus

// optional string msgName = 1 [default = "ActionStatus"];
inline bool ActionStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& ActionStatus::msgname() const {
  return *msgname_;
}
inline void ActionStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ActionStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void ActionStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActionStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* ActionStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void ActionStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string executing = 2;
inline bool ActionStatus::has_executing() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActionStatus::set_has_executing() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActionStatus::clear_has_executing() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActionStatus::clear_executing() {
  if (executing_ != &::google::protobuf::internal::kEmptyString) {
    executing_->clear();
  }
  clear_has_executing();
}
inline const ::std::string& ActionStatus::executing() const {
  return *executing_;
}
inline void ActionStatus::set_executing(const ::std::string& value) {
  set_has_executing();
  if (executing_ == &::google::protobuf::internal::kEmptyString) {
    executing_ = new ::std::string;
  }
  executing_->assign(value);
}
inline void ActionStatus::set_executing(const char* value) {
  set_has_executing();
  if (executing_ == &::google::protobuf::internal::kEmptyString) {
    executing_ = new ::std::string;
  }
  executing_->assign(value);
}
inline void ActionStatus::set_executing(const char* value, size_t size) {
  set_has_executing();
  if (executing_ == &::google::protobuf::internal::kEmptyString) {
    executing_ = new ::std::string;
  }
  executing_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActionStatus::mutable_executing() {
  set_has_executing();
  if (executing_ == &::google::protobuf::internal::kEmptyString) {
    executing_ = new ::std::string;
  }
  return executing_;
}
inline ::std::string* ActionStatus::release_executing() {
  clear_has_executing();
  if (executing_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = executing_;
    executing_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActionStatus::set_allocated_executing(::std::string* executing) {
  if (executing_ != &::google::protobuf::internal::kEmptyString) {
    delete executing_;
  }
  if (executing) {
    set_has_executing();
    executing_ = executing;
  } else {
    clear_has_executing();
    executing_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ampOn = 3;
inline bool ActionStatus::has_ampon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActionStatus::set_has_ampon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActionStatus::clear_has_ampon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActionStatus::clear_ampon() {
  if (ampon_ != &::google::protobuf::internal::kEmptyString) {
    ampon_->clear();
  }
  clear_has_ampon();
}
inline const ::std::string& ActionStatus::ampon() const {
  return *ampon_;
}
inline void ActionStatus::set_ampon(const ::std::string& value) {
  set_has_ampon();
  if (ampon_ == &::google::protobuf::internal::kEmptyString) {
    ampon_ = new ::std::string;
  }
  ampon_->assign(value);
}
inline void ActionStatus::set_ampon(const char* value) {
  set_has_ampon();
  if (ampon_ == &::google::protobuf::internal::kEmptyString) {
    ampon_ = new ::std::string;
  }
  ampon_->assign(value);
}
inline void ActionStatus::set_ampon(const char* value, size_t size) {
  set_has_ampon();
  if (ampon_ == &::google::protobuf::internal::kEmptyString) {
    ampon_ = new ::std::string;
  }
  ampon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActionStatus::mutable_ampon() {
  set_has_ampon();
  if (ampon_ == &::google::protobuf::internal::kEmptyString) {
    ampon_ = new ::std::string;
  }
  return ampon_;
}
inline ::std::string* ActionStatus::release_ampon() {
  clear_has_ampon();
  if (ampon_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ampon_;
    ampon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActionStatus::set_allocated_ampon(::std::string* ampon) {
  if (ampon_ != &::google::protobuf::internal::kEmptyString) {
    delete ampon_;
  }
  if (ampon) {
    set_has_ampon();
    ampon_ = ampon;
  } else {
    clear_has_ampon();
    ampon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string strikeAssessment = 4;
inline bool ActionStatus::has_strikeassessment() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ActionStatus::set_has_strikeassessment() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ActionStatus::clear_has_strikeassessment() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ActionStatus::clear_strikeassessment() {
  if (strikeassessment_ != &::google::protobuf::internal::kEmptyString) {
    strikeassessment_->clear();
  }
  clear_has_strikeassessment();
}
inline const ::std::string& ActionStatus::strikeassessment() const {
  return *strikeassessment_;
}
inline void ActionStatus::set_strikeassessment(const ::std::string& value) {
  set_has_strikeassessment();
  if (strikeassessment_ == &::google::protobuf::internal::kEmptyString) {
    strikeassessment_ = new ::std::string;
  }
  strikeassessment_->assign(value);
}
inline void ActionStatus::set_strikeassessment(const char* value) {
  set_has_strikeassessment();
  if (strikeassessment_ == &::google::protobuf::internal::kEmptyString) {
    strikeassessment_ = new ::std::string;
  }
  strikeassessment_->assign(value);
}
inline void ActionStatus::set_strikeassessment(const char* value, size_t size) {
  set_has_strikeassessment();
  if (strikeassessment_ == &::google::protobuf::internal::kEmptyString) {
    strikeassessment_ = new ::std::string;
  }
  strikeassessment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActionStatus::mutable_strikeassessment() {
  set_has_strikeassessment();
  if (strikeassessment_ == &::google::protobuf::internal::kEmptyString) {
    strikeassessment_ = new ::std::string;
  }
  return strikeassessment_;
}
inline ::std::string* ActionStatus::release_strikeassessment() {
  clear_has_strikeassessment();
  if (strikeassessment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strikeassessment_;
    strikeassessment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActionStatus::set_allocated_strikeassessment(::std::string* strikeassessment) {
  if (strikeassessment_ != &::google::protobuf::internal::kEmptyString) {
    delete strikeassessment_;
  }
  if (strikeassessment) {
    set_has_strikeassessment();
    strikeassessment_ = strikeassessment;
  } else {
    clear_has_strikeassessment();
    strikeassessment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string underAttack = 5;
inline bool ActionStatus::has_underattack() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ActionStatus::set_has_underattack() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ActionStatus::clear_has_underattack() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ActionStatus::clear_underattack() {
  if (underattack_ != &::google::protobuf::internal::kEmptyString) {
    underattack_->clear();
  }
  clear_has_underattack();
}
inline const ::std::string& ActionStatus::underattack() const {
  return *underattack_;
}
inline void ActionStatus::set_underattack(const ::std::string& value) {
  set_has_underattack();
  if (underattack_ == &::google::protobuf::internal::kEmptyString) {
    underattack_ = new ::std::string;
  }
  underattack_->assign(value);
}
inline void ActionStatus::set_underattack(const char* value) {
  set_has_underattack();
  if (underattack_ == &::google::protobuf::internal::kEmptyString) {
    underattack_ = new ::std::string;
  }
  underattack_->assign(value);
}
inline void ActionStatus::set_underattack(const char* value, size_t size) {
  set_has_underattack();
  if (underattack_ == &::google::protobuf::internal::kEmptyString) {
    underattack_ = new ::std::string;
  }
  underattack_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActionStatus::mutable_underattack() {
  set_has_underattack();
  if (underattack_ == &::google::protobuf::internal::kEmptyString) {
    underattack_ = new ::std::string;
  }
  return underattack_;
}
inline ::std::string* ActionStatus::release_underattack() {
  clear_has_underattack();
  if (underattack_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underattack_;
    underattack_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActionStatus::set_allocated_underattack(::std::string* underattack) {
  if (underattack_ != &::google::protobuf::internal::kEmptyString) {
    delete underattack_;
  }
  if (underattack) {
    set_has_underattack();
    underattack_ = underattack;
  } else {
    clear_has_underattack();
    underattack_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string jamType = 6;
inline bool ActionStatus::has_jamtype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ActionStatus::set_has_jamtype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ActionStatus::clear_has_jamtype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ActionStatus::clear_jamtype() {
  if (jamtype_ != &::google::protobuf::internal::kEmptyString) {
    jamtype_->clear();
  }
  clear_has_jamtype();
}
inline const ::std::string& ActionStatus::jamtype() const {
  return *jamtype_;
}
inline void ActionStatus::set_jamtype(const ::std::string& value) {
  set_has_jamtype();
  if (jamtype_ == &::google::protobuf::internal::kEmptyString) {
    jamtype_ = new ::std::string;
  }
  jamtype_->assign(value);
}
inline void ActionStatus::set_jamtype(const char* value) {
  set_has_jamtype();
  if (jamtype_ == &::google::protobuf::internal::kEmptyString) {
    jamtype_ = new ::std::string;
  }
  jamtype_->assign(value);
}
inline void ActionStatus::set_jamtype(const char* value, size_t size) {
  set_has_jamtype();
  if (jamtype_ == &::google::protobuf::internal::kEmptyString) {
    jamtype_ = new ::std::string;
  }
  jamtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActionStatus::mutable_jamtype() {
  set_has_jamtype();
  if (jamtype_ == &::google::protobuf::internal::kEmptyString) {
    jamtype_ = new ::std::string;
  }
  return jamtype_;
}
inline ::std::string* ActionStatus::release_jamtype() {
  clear_has_jamtype();
  if (jamtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jamtype_;
    jamtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActionStatus::set_allocated_jamtype(::std::string* jamtype) {
  if (jamtype_ != &::google::protobuf::internal::kEmptyString) {
    delete jamtype_;
  }
  if (jamtype) {
    set_has_jamtype();
    jamtype_ = jamtype;
  } else {
    clear_has_jamtype();
    jamtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float jamFreq = 7;
inline bool ActionStatus::has_jamfreq() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ActionStatus::set_has_jamfreq() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ActionStatus::clear_has_jamfreq() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ActionStatus::clear_jamfreq() {
  jamfreq_ = 0;
  clear_has_jamfreq();
}
inline float ActionStatus::jamfreq() const {
  return jamfreq_;
}
inline void ActionStatus::set_jamfreq(float value) {
  set_has_jamfreq();
  jamfreq_ = value;
}

// -------------------------------------------------------------------

// SystemStatus

// optional string msgName = 1 [default = "SystemStatus"];
inline bool SystemStatus::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemStatus::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemStatus::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemStatus::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& SystemStatus::msgname() const {
  return *msgname_;
}
inline void SystemStatus::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SystemStatus::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void SystemStatus::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SystemStatus::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* SystemStatus::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void SystemStatus::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}

// optional string hardware_status = 2;
inline bool SystemStatus::has_hardware_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SystemStatus::set_has_hardware_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SystemStatus::clear_has_hardware_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SystemStatus::clear_hardware_status() {
  if (hardware_status_ != &::google::protobuf::internal::kEmptyString) {
    hardware_status_->clear();
  }
  clear_has_hardware_status();
}
inline const ::std::string& SystemStatus::hardware_status() const {
  return *hardware_status_;
}
inline void SystemStatus::set_hardware_status(const ::std::string& value) {
  set_has_hardware_status();
  if (hardware_status_ == &::google::protobuf::internal::kEmptyString) {
    hardware_status_ = new ::std::string;
  }
  hardware_status_->assign(value);
}
inline void SystemStatus::set_hardware_status(const char* value) {
  set_has_hardware_status();
  if (hardware_status_ == &::google::protobuf::internal::kEmptyString) {
    hardware_status_ = new ::std::string;
  }
  hardware_status_->assign(value);
}
inline void SystemStatus::set_hardware_status(const char* value, size_t size) {
  set_has_hardware_status();
  if (hardware_status_ == &::google::protobuf::internal::kEmptyString) {
    hardware_status_ = new ::std::string;
  }
  hardware_status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SystemStatus::mutable_hardware_status() {
  set_has_hardware_status();
  if (hardware_status_ == &::google::protobuf::internal::kEmptyString) {
    hardware_status_ = new ::std::string;
  }
  return hardware_status_;
}
inline ::std::string* SystemStatus::release_hardware_status() {
  clear_has_hardware_status();
  if (hardware_status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hardware_status_;
    hardware_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SystemStatus::set_allocated_hardware_status(::std::string* hardware_status) {
  if (hardware_status_ != &::google::protobuf::internal::kEmptyString) {
    delete hardware_status_;
  }
  if (hardware_status) {
    set_has_hardware_status();
    hardware_status_ = hardware_status;
  } else {
    clear_has_hardware_status();
    hardware_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string software_status = 3;
inline bool SystemStatus::has_software_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SystemStatus::set_has_software_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SystemStatus::clear_has_software_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SystemStatus::clear_software_status() {
  if (software_status_ != &::google::protobuf::internal::kEmptyString) {
    software_status_->clear();
  }
  clear_has_software_status();
}
inline const ::std::string& SystemStatus::software_status() const {
  return *software_status_;
}
inline void SystemStatus::set_software_status(const ::std::string& value) {
  set_has_software_status();
  if (software_status_ == &::google::protobuf::internal::kEmptyString) {
    software_status_ = new ::std::string;
  }
  software_status_->assign(value);
}
inline void SystemStatus::set_software_status(const char* value) {
  set_has_software_status();
  if (software_status_ == &::google::protobuf::internal::kEmptyString) {
    software_status_ = new ::std::string;
  }
  software_status_->assign(value);
}
inline void SystemStatus::set_software_status(const char* value, size_t size) {
  set_has_software_status();
  if (software_status_ == &::google::protobuf::internal::kEmptyString) {
    software_status_ = new ::std::string;
  }
  software_status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SystemStatus::mutable_software_status() {
  set_has_software_status();
  if (software_status_ == &::google::protobuf::internal::kEmptyString) {
    software_status_ = new ::std::string;
  }
  return software_status_;
}
inline ::std::string* SystemStatus::release_software_status() {
  clear_has_software_status();
  if (software_status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = software_status_;
    software_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SystemStatus::set_allocated_software_status(::std::string* software_status) {
  if (software_status_ != &::google::protobuf::internal::kEmptyString) {
    delete software_status_;
  }
  if (software_status) {
    set_has_software_status();
    software_status_ = software_status;
  } else {
    clear_has_software_status();
    software_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string gps_lock = 4;
inline bool SystemStatus::has_gps_lock() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SystemStatus::set_has_gps_lock() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SystemStatus::clear_has_gps_lock() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SystemStatus::clear_gps_lock() {
  if (gps_lock_ != &::google::protobuf::internal::kEmptyString) {
    gps_lock_->clear();
  }
  clear_has_gps_lock();
}
inline const ::std::string& SystemStatus::gps_lock() const {
  return *gps_lock_;
}
inline void SystemStatus::set_gps_lock(const ::std::string& value) {
  set_has_gps_lock();
  if (gps_lock_ == &::google::protobuf::internal::kEmptyString) {
    gps_lock_ = new ::std::string;
  }
  gps_lock_->assign(value);
}
inline void SystemStatus::set_gps_lock(const char* value) {
  set_has_gps_lock();
  if (gps_lock_ == &::google::protobuf::internal::kEmptyString) {
    gps_lock_ = new ::std::string;
  }
  gps_lock_->assign(value);
}
inline void SystemStatus::set_gps_lock(const char* value, size_t size) {
  set_has_gps_lock();
  if (gps_lock_ == &::google::protobuf::internal::kEmptyString) {
    gps_lock_ = new ::std::string;
  }
  gps_lock_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SystemStatus::mutable_gps_lock() {
  set_has_gps_lock();
  if (gps_lock_ == &::google::protobuf::internal::kEmptyString) {
    gps_lock_ = new ::std::string;
  }
  return gps_lock_;
}
inline ::std::string* SystemStatus::release_gps_lock() {
  clear_has_gps_lock();
  if (gps_lock_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gps_lock_;
    gps_lock_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SystemStatus::set_allocated_gps_lock(::std::string* gps_lock) {
  if (gps_lock_ != &::google::protobuf::internal::kEmptyString) {
    delete gps_lock_;
  }
  if (gps_lock) {
    set_has_gps_lock();
    gps_lock_ = gps_lock;
  } else {
    clear_has_gps_lock();
    gps_lock_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Ping

// optional string msgName = 1 [default = "Ping"];
inline bool Ping::has_msgname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ping::set_has_msgname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ping::clear_has_msgname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ping::clear_msgname() {
  if (msgname_ != _default_msgname_) {
    msgname_->assign(*_default_msgname_);
  }
  clear_has_msgname();
}
inline const ::std::string& Ping::msgname() const {
  return *msgname_;
}
inline void Ping::set_msgname(const ::std::string& value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void Ping::set_msgname(const char* value) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(value);
}
inline void Ping::set_msgname(const char* value, size_t size) {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string;
  }
  msgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Ping::mutable_msgname() {
  set_has_msgname();
  if (msgname_ == _default_msgname_) {
    msgname_ = new ::std::string(*_default_msgname_);
  }
  return msgname_;
}
inline ::std::string* Ping::release_msgname() {
  clear_has_msgname();
  if (msgname_ == _default_msgname_) {
    return NULL;
  } else {
    ::std::string* temp = msgname_;
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
    return temp;
  }
}
inline void Ping::set_allocated_msgname(::std::string* msgname) {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (msgname) {
    set_has_msgname();
    msgname_ = msgname;
  } else {
    clear_has_msgname();
    msgname_ = const_cast< ::std::string*>(_default_msgname_);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace raptorx_msg

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_StateKeeperMessages_2eproto__INCLUDED
