// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Products.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Products.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace products {

namespace {

const ::google::protobuf::Descriptor* FisD_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FisD_reflection_ = NULL;
const ::google::protobuf::Descriptor* FisD_Meta_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FisD_Meta_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* FisD_FileType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* FisDRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FisDRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioAvailable_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioAvailable_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* AudioAvailable_Status_descriptor_ = NULL;
const ::google::protobuf::Descriptor* AudioRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioRequest_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* AudioRequest_TYPE_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_Products_2eproto() {
  protobuf_AddDesc_Products_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "Products.proto");
  GOOGLE_CHECK(file != NULL);
  FisD_descriptor_ = file->message_type(0);
  static const int FisD_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FisD, msgname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FisD, file_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FisD, meta_),
  };
  FisD_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FisD_descriptor_,
      FisD::default_instance_,
      FisD_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FisD, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FisD, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FisD));
  FisD_Meta_descriptor_ = FisD_descriptor_->nested_type(0);
  static const int FisD_Meta_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FisD_Meta, file_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FisD_Meta, file_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FisD_Meta, event_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FisD_Meta, soi_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FisD_Meta, eltex_),
  };
  FisD_Meta_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FisD_Meta_descriptor_,
      FisD_Meta::default_instance_,
      FisD_Meta_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FisD_Meta, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FisD_Meta, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FisD_Meta));
  FisD_FileType_descriptor_ = FisD_descriptor_->enum_type(0);
  FisDRequest_descriptor_ = file->message_type(1);
  static const int FisDRequest_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FisDRequest, msgname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FisDRequest, event_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FisDRequest, soi_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FisDRequest, eltex_),
  };
  FisDRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FisDRequest_descriptor_,
      FisDRequest::default_instance_,
      FisDRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FisDRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FisDRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FisDRequest));
  AudioAvailable_descriptor_ = file->message_type(2);
  static const int AudioAvailable_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioAvailable, msgname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioAvailable, cffreq_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioAvailable, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioAvailable, audiofile_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioAvailable, msgid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioAvailable, soinum_),
  };
  AudioAvailable_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioAvailable_descriptor_,
      AudioAvailable::default_instance_,
      AudioAvailable_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioAvailable, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioAvailable, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioAvailable));
  AudioAvailable_Status_descriptor_ = AudioAvailable_descriptor_->enum_type(0);
  AudioRequest_descriptor_ = file->message_type(3);
  static const int AudioRequest_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioRequest, msgname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioRequest, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioRequest, appchan_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioRequest, rffreq_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioRequest, soi_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioRequest, eltex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioRequest, start_),
  };
  AudioRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioRequest_descriptor_,
      AudioRequest::default_instance_,
      AudioRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioRequest));
  AudioRequest_TYPE_descriptor_ = AudioRequest_descriptor_->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_Products_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FisD_descriptor_, &FisD::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FisD_Meta_descriptor_, &FisD_Meta::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FisDRequest_descriptor_, &FisDRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioAvailable_descriptor_, &AudioAvailable::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioRequest_descriptor_, &AudioRequest::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_Products_2eproto() {
  delete FisD::default_instance_;
  delete FisD_reflection_;
  delete FisD::_default_msgname_;
  delete FisD_Meta::default_instance_;
  delete FisD_Meta_reflection_;
  delete FisDRequest::default_instance_;
  delete FisDRequest_reflection_;
  delete FisDRequest::_default_msgname_;
  delete AudioAvailable::default_instance_;
  delete AudioAvailable_reflection_;
  delete AudioAvailable::_default_msgname_;
  delete AudioRequest::default_instance_;
  delete AudioRequest_reflection_;
  delete AudioRequest::_default_msgname_;
}

void protobuf_AddDesc_Products_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\016Products.proto\022\010products\"\350\001\n\004FisD\022\025\n\007m"
    "sgName\030\001 \001(\t:\004FISD\022\014\n\004file\030\002 \001(\014\022!\n\004meta"
    "\030\003 \001(\0132\023.products.FisD.Meta\032s\n\004Meta\022*\n\tf"
    "ile_type\030\001 \001(\0162\027.products.FisD.FileType\022"
    "\021\n\tfile_name\030\002 \001(\t\022\020\n\010event_id\030\003 \001(\t\022\013\n\003"
    "soi\030\004 \001(\005\022\r\n\005eltex\030\005 \001(\t\"#\n\010FileType\022\006\n\002"
    "FS\020\000\022\006\n\002TC\020\001\022\007\n\003BER\020\002\"Y\n\013FisDRequest\022\034\n\007"
    "msgName\030\001 \001(\t:\013FISDREQUEST\022\020\n\010event_id\030\002"
    " \001(\t\022\013\n\003soi\030\003 \001(\003\022\r\n\005eltex\030\004 \001(\t\"\344\001\n\016Aud"
    "ioAvailable\022\037\n\007msgName\030\001 \001(\t:\016AUDIOAVAIL"
    "ABLE\022\016\n\006cffreq\030\002 \001(\001\022/\n\006status\030\003 \001(\0162\037.p"
    "roducts.AudioAvailable.Status\022\021\n\taudiofi"
    "le\030\004 \001(\t\022\r\n\005msgID\030\005 \001(\005\022\016\n\006soiNum\030\006 \001(\t\""
    ">\n\006Status\022\026\n\tAVAILABLE\020\377\377\377\377\377\377\377\377\377\001\022\017\n\013UNA"
    "VAILABLE\020\000\022\013\n\007PENDING\020\001\"\302\001\n\014AudioRequest"
    "\022\035\n\007msgName\030\001 \001(\t:\014AUDIOREQUEST\022)\n\004type\030"
    "\002 \001(\0162\033.products.AudioRequest.TYPE\022\017\n\007ap"
    "pChan\030\003 \001(\005\022\016\n\006rfFreq\030\004 \001(\002\022\013\n\003soi\030\005 \001(\003"
    "\022\r\n\005eltex\030\006 \001(\t\022\r\n\005start\030\007 \001(\010\"\034\n\004TYPE\022\n"
    "\n\006STREAM\020\000\022\010\n\004FILE\020\001", 780);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "Products.proto", &protobuf_RegisterTypes);
  FisD::_default_msgname_ =
      new ::std::string("FISD", 4);
  FisD::default_instance_ = new FisD();
  FisD_Meta::default_instance_ = new FisD_Meta();
  FisDRequest::_default_msgname_ =
      new ::std::string("FISDREQUEST", 11);
  FisDRequest::default_instance_ = new FisDRequest();
  AudioAvailable::_default_msgname_ =
      new ::std::string("AUDIOAVAILABLE", 14);
  AudioAvailable::default_instance_ = new AudioAvailable();
  AudioRequest::_default_msgname_ =
      new ::std::string("AUDIOREQUEST", 12);
  AudioRequest::default_instance_ = new AudioRequest();
  FisD::default_instance_->InitAsDefaultInstance();
  FisD_Meta::default_instance_->InitAsDefaultInstance();
  FisDRequest::default_instance_->InitAsDefaultInstance();
  AudioAvailable::default_instance_->InitAsDefaultInstance();
  AudioRequest::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Products_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Products_2eproto {
  StaticDescriptorInitializer_Products_2eproto() {
    protobuf_AddDesc_Products_2eproto();
  }
} static_descriptor_initializer_Products_2eproto_;

// ===================================================================

const ::google::protobuf::EnumDescriptor* FisD_FileType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FisD_FileType_descriptor_;
}
bool FisD_FileType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const FisD_FileType FisD::FS;
const FisD_FileType FisD::TC;
const FisD_FileType FisD::BER;
const FisD_FileType FisD::FileType_MIN;
const FisD_FileType FisD::FileType_MAX;
const int FisD::FileType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int FisD_Meta::kFileTypeFieldNumber;
const int FisD_Meta::kFileNameFieldNumber;
const int FisD_Meta::kEventIdFieldNumber;
const int FisD_Meta::kSoiFieldNumber;
const int FisD_Meta::kEltexFieldNumber;
#endif  // !_MSC_VER

FisD_Meta::FisD_Meta()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FisD_Meta::InitAsDefaultInstance() {
}

FisD_Meta::FisD_Meta(const FisD_Meta& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FisD_Meta::SharedCtor() {
  _cached_size_ = 0;
  file_type_ = 0;
  file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  event_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  soi_ = 0;
  eltex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FisD_Meta::~FisD_Meta() {
  SharedDtor();
}

void FisD_Meta::SharedDtor() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (event_id_ != &::google::protobuf::internal::kEmptyString) {
    delete event_id_;
  }
  if (eltex_ != &::google::protobuf::internal::kEmptyString) {
    delete eltex_;
  }
  if (this != default_instance_) {
  }
}

void FisD_Meta::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FisD_Meta::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FisD_Meta_descriptor_;
}

const FisD_Meta& FisD_Meta::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Products_2eproto();
  return *default_instance_;
}

FisD_Meta* FisD_Meta::default_instance_ = NULL;

FisD_Meta* FisD_Meta::New() const {
  return new FisD_Meta;
}

void FisD_Meta::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    file_type_ = 0;
    if (has_file_name()) {
      if (file_name_ != &::google::protobuf::internal::kEmptyString) {
        file_name_->clear();
      }
    }
    if (has_event_id()) {
      if (event_id_ != &::google::protobuf::internal::kEmptyString) {
        event_id_->clear();
      }
    }
    soi_ = 0;
    if (has_eltex()) {
      if (eltex_ != &::google::protobuf::internal::kEmptyString) {
        eltex_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FisD_Meta::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .products.FisD.FileType file_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::products::FisD_FileType_IsValid(value)) {
            set_file_type(static_cast< ::products::FisD_FileType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_file_name;
        break;
      }

      // optional string file_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_file_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_file_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->file_name().data(), this->file_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_event_id;
        break;
      }

      // optional string event_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_event_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_event_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->event_id().data(), this->event_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_soi;
        break;
      }

      // optional int32 soi = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_soi:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &soi_)));
          set_has_soi();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_eltex;
        break;
      }

      // optional string eltex = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_eltex:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_eltex()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->eltex().data(), this->eltex().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FisD_Meta::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .products.FisD.FileType file_type = 1;
  if (has_file_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->file_type(), output);
  }

  // optional string file_name = 2;
  if (has_file_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->file_name().data(), this->file_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->file_name(), output);
  }

  // optional string event_id = 3;
  if (has_event_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->event_id().data(), this->event_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->event_id(), output);
  }

  // optional int32 soi = 4;
  if (has_soi()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->soi(), output);
  }

  // optional string eltex = 5;
  if (has_eltex()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->eltex().data(), this->eltex().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->eltex(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FisD_Meta::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .products.FisD.FileType file_type = 1;
  if (has_file_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->file_type(), target);
  }

  // optional string file_name = 2;
  if (has_file_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->file_name().data(), this->file_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->file_name(), target);
  }

  // optional string event_id = 3;
  if (has_event_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->event_id().data(), this->event_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->event_id(), target);
  }

  // optional int32 soi = 4;
  if (has_soi()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->soi(), target);
  }

  // optional string eltex = 5;
  if (has_eltex()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->eltex().data(), this->eltex().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->eltex(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FisD_Meta::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .products.FisD.FileType file_type = 1;
    if (has_file_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->file_type());
    }

    // optional string file_name = 2;
    if (has_file_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->file_name());
    }

    // optional string event_id = 3;
    if (has_event_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->event_id());
    }

    // optional int32 soi = 4;
    if (has_soi()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->soi());
    }

    // optional string eltex = 5;
    if (has_eltex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->eltex());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FisD_Meta::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FisD_Meta* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FisD_Meta*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FisD_Meta::MergeFrom(const FisD_Meta& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_file_type()) {
      set_file_type(from.file_type());
    }
    if (from.has_file_name()) {
      set_file_name(from.file_name());
    }
    if (from.has_event_id()) {
      set_event_id(from.event_id());
    }
    if (from.has_soi()) {
      set_soi(from.soi());
    }
    if (from.has_eltex()) {
      set_eltex(from.eltex());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FisD_Meta::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FisD_Meta::CopyFrom(const FisD_Meta& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FisD_Meta::IsInitialized() const {

  return true;
}

void FisD_Meta::Swap(FisD_Meta* other) {
  if (other != this) {
    std::swap(file_type_, other->file_type_);
    std::swap(file_name_, other->file_name_);
    std::swap(event_id_, other->event_id_);
    std::swap(soi_, other->soi_);
    std::swap(eltex_, other->eltex_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FisD_Meta::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FisD_Meta_descriptor_;
  metadata.reflection = FisD_Meta_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

::std::string* FisD::_default_msgname_ = NULL;
#ifndef _MSC_VER
const int FisD::kMsgNameFieldNumber;
const int FisD::kFileFieldNumber;
const int FisD::kMetaFieldNumber;
#endif  // !_MSC_VER

FisD::FisD()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FisD::InitAsDefaultInstance() {
  meta_ = const_cast< ::products::FisD_Meta*>(&::products::FisD_Meta::default_instance());
}

FisD::FisD(const FisD& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FisD::SharedCtor() {
  _cached_size_ = 0;
  msgname_ = const_cast< ::std::string*>(_default_msgname_);
  file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  meta_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FisD::~FisD() {
  SharedDtor();
}

void FisD::SharedDtor() {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (file_ != &::google::protobuf::internal::kEmptyString) {
    delete file_;
  }
  if (this != default_instance_) {
    delete meta_;
  }
}

void FisD::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FisD::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FisD_descriptor_;
}

const FisD& FisD::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Products_2eproto();
  return *default_instance_;
}

FisD* FisD::default_instance_ = NULL;

FisD* FisD::New() const {
  return new FisD;
}

void FisD::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_msgname()) {
      if (msgname_ != _default_msgname_) {
        msgname_->assign(*_default_msgname_);
      }
    }
    if (has_file()) {
      if (file_ != &::google::protobuf::internal::kEmptyString) {
        file_->clear();
      }
    }
    if (has_meta()) {
      if (meta_ != NULL) meta_->::products::FisD_Meta::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FisD::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string msgName = 1 [default = "FISD"];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_msgname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->msgname().data(), this->msgname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_file;
        break;
      }

      // optional bytes file = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_file:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_file()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_meta;
        break;
      }

      // optional .products.FisD.Meta meta = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_meta:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_meta()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FisD::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string msgName = 1 [default = "FISD"];
  if (has_msgname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->msgname().data(), this->msgname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->msgname(), output);
  }

  // optional bytes file = 2;
  if (has_file()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->file(), output);
  }

  // optional .products.FisD.Meta meta = 3;
  if (has_meta()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->meta(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FisD::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string msgName = 1 [default = "FISD"];
  if (has_msgname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->msgname().data(), this->msgname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->msgname(), target);
  }

  // optional bytes file = 2;
  if (has_file()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->file(), target);
  }

  // optional .products.FisD.Meta meta = 3;
  if (has_meta()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->meta(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FisD::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string msgName = 1 [default = "FISD"];
    if (has_msgname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->msgname());
    }

    // optional bytes file = 2;
    if (has_file()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->file());
    }

    // optional .products.FisD.Meta meta = 3;
    if (has_meta()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->meta());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FisD::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FisD* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FisD*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FisD::MergeFrom(const FisD& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_msgname()) {
      set_msgname(from.msgname());
    }
    if (from.has_file()) {
      set_file(from.file());
    }
    if (from.has_meta()) {
      mutable_meta()->::products::FisD_Meta::MergeFrom(from.meta());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FisD::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FisD::CopyFrom(const FisD& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FisD::IsInitialized() const {

  return true;
}

void FisD::Swap(FisD* other) {
  if (other != this) {
    std::swap(msgname_, other->msgname_);
    std::swap(file_, other->file_);
    std::swap(meta_, other->meta_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FisD::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FisD_descriptor_;
  metadata.reflection = FisD_reflection_;
  return metadata;
}


// ===================================================================

::std::string* FisDRequest::_default_msgname_ = NULL;
#ifndef _MSC_VER
const int FisDRequest::kMsgNameFieldNumber;
const int FisDRequest::kEventIdFieldNumber;
const int FisDRequest::kSoiFieldNumber;
const int FisDRequest::kEltexFieldNumber;
#endif  // !_MSC_VER

FisDRequest::FisDRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FisDRequest::InitAsDefaultInstance() {
}

FisDRequest::FisDRequest(const FisDRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FisDRequest::SharedCtor() {
  _cached_size_ = 0;
  msgname_ = const_cast< ::std::string*>(_default_msgname_);
  event_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  soi_ = GOOGLE_LONGLONG(0);
  eltex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FisDRequest::~FisDRequest() {
  SharedDtor();
}

void FisDRequest::SharedDtor() {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (event_id_ != &::google::protobuf::internal::kEmptyString) {
    delete event_id_;
  }
  if (eltex_ != &::google::protobuf::internal::kEmptyString) {
    delete eltex_;
  }
  if (this != default_instance_) {
  }
}

void FisDRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FisDRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FisDRequest_descriptor_;
}

const FisDRequest& FisDRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Products_2eproto();
  return *default_instance_;
}

FisDRequest* FisDRequest::default_instance_ = NULL;

FisDRequest* FisDRequest::New() const {
  return new FisDRequest;
}

void FisDRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_msgname()) {
      if (msgname_ != _default_msgname_) {
        msgname_->assign(*_default_msgname_);
      }
    }
    if (has_event_id()) {
      if (event_id_ != &::google::protobuf::internal::kEmptyString) {
        event_id_->clear();
      }
    }
    soi_ = GOOGLE_LONGLONG(0);
    if (has_eltex()) {
      if (eltex_ != &::google::protobuf::internal::kEmptyString) {
        eltex_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FisDRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string msgName = 1 [default = "FISDREQUEST"];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_msgname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->msgname().data(), this->msgname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_event_id;
        break;
      }

      // optional string event_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_event_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_event_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->event_id().data(), this->event_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_soi;
        break;
      }

      // optional int64 soi = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_soi:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &soi_)));
          set_has_soi();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_eltex;
        break;
      }

      // optional string eltex = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_eltex:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_eltex()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->eltex().data(), this->eltex().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FisDRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string msgName = 1 [default = "FISDREQUEST"];
  if (has_msgname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->msgname().data(), this->msgname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->msgname(), output);
  }

  // optional string event_id = 2;
  if (has_event_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->event_id().data(), this->event_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->event_id(), output);
  }

  // optional int64 soi = 3;
  if (has_soi()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->soi(), output);
  }

  // optional string eltex = 4;
  if (has_eltex()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->eltex().data(), this->eltex().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->eltex(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FisDRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string msgName = 1 [default = "FISDREQUEST"];
  if (has_msgname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->msgname().data(), this->msgname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->msgname(), target);
  }

  // optional string event_id = 2;
  if (has_event_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->event_id().data(), this->event_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->event_id(), target);
  }

  // optional int64 soi = 3;
  if (has_soi()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->soi(), target);
  }

  // optional string eltex = 4;
  if (has_eltex()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->eltex().data(), this->eltex().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->eltex(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FisDRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string msgName = 1 [default = "FISDREQUEST"];
    if (has_msgname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->msgname());
    }

    // optional string event_id = 2;
    if (has_event_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->event_id());
    }

    // optional int64 soi = 3;
    if (has_soi()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->soi());
    }

    // optional string eltex = 4;
    if (has_eltex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->eltex());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FisDRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FisDRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FisDRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FisDRequest::MergeFrom(const FisDRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_msgname()) {
      set_msgname(from.msgname());
    }
    if (from.has_event_id()) {
      set_event_id(from.event_id());
    }
    if (from.has_soi()) {
      set_soi(from.soi());
    }
    if (from.has_eltex()) {
      set_eltex(from.eltex());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FisDRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FisDRequest::CopyFrom(const FisDRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FisDRequest::IsInitialized() const {

  return true;
}

void FisDRequest::Swap(FisDRequest* other) {
  if (other != this) {
    std::swap(msgname_, other->msgname_);
    std::swap(event_id_, other->event_id_);
    std::swap(soi_, other->soi_);
    std::swap(eltex_, other->eltex_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FisDRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FisDRequest_descriptor_;
  metadata.reflection = FisDRequest_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* AudioAvailable_Status_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioAvailable_Status_descriptor_;
}
bool AudioAvailable_Status_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const AudioAvailable_Status AudioAvailable::AVAILABLE;
const AudioAvailable_Status AudioAvailable::UNAVAILABLE;
const AudioAvailable_Status AudioAvailable::PENDING;
const AudioAvailable_Status AudioAvailable::Status_MIN;
const AudioAvailable_Status AudioAvailable::Status_MAX;
const int AudioAvailable::Status_ARRAYSIZE;
#endif  // _MSC_VER
::std::string* AudioAvailable::_default_msgname_ = NULL;
#ifndef _MSC_VER
const int AudioAvailable::kMsgNameFieldNumber;
const int AudioAvailable::kCffreqFieldNumber;
const int AudioAvailable::kStatusFieldNumber;
const int AudioAvailable::kAudiofileFieldNumber;
const int AudioAvailable::kMsgIDFieldNumber;
const int AudioAvailable::kSoiNumFieldNumber;
#endif  // !_MSC_VER

AudioAvailable::AudioAvailable()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioAvailable::InitAsDefaultInstance() {
}

AudioAvailable::AudioAvailable(const AudioAvailable& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioAvailable::SharedCtor() {
  _cached_size_ = 0;
  msgname_ = const_cast< ::std::string*>(_default_msgname_);
  cffreq_ = 0;
  status_ = -1;
  audiofile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  msgid_ = 0;
  soinum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioAvailable::~AudioAvailable() {
  SharedDtor();
}

void AudioAvailable::SharedDtor() {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (audiofile_ != &::google::protobuf::internal::kEmptyString) {
    delete audiofile_;
  }
  if (soinum_ != &::google::protobuf::internal::kEmptyString) {
    delete soinum_;
  }
  if (this != default_instance_) {
  }
}

void AudioAvailable::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioAvailable::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioAvailable_descriptor_;
}

const AudioAvailable& AudioAvailable::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Products_2eproto();
  return *default_instance_;
}

AudioAvailable* AudioAvailable::default_instance_ = NULL;

AudioAvailable* AudioAvailable::New() const {
  return new AudioAvailable;
}

void AudioAvailable::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_msgname()) {
      if (msgname_ != _default_msgname_) {
        msgname_->assign(*_default_msgname_);
      }
    }
    cffreq_ = 0;
    status_ = -1;
    if (has_audiofile()) {
      if (audiofile_ != &::google::protobuf::internal::kEmptyString) {
        audiofile_->clear();
      }
    }
    msgid_ = 0;
    if (has_soinum()) {
      if (soinum_ != &::google::protobuf::internal::kEmptyString) {
        soinum_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioAvailable::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string msgName = 1 [default = "AUDIOAVAILABLE"];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_msgname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->msgname().data(), this->msgname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(17)) goto parse_cffreq;
        break;
      }

      // optional double cffreq = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_cffreq:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &cffreq_)));
          set_has_cffreq();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_status;
        break;
      }

      // optional .products.AudioAvailable.Status status = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::products::AudioAvailable_Status_IsValid(value)) {
            set_status(static_cast< ::products::AudioAvailable_Status >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_audiofile;
        break;
      }

      // optional string audiofile = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_audiofile:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_audiofile()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->audiofile().data(), this->audiofile().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_msgID;
        break;
      }

      // optional int32 msgID = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_msgID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &msgid_)));
          set_has_msgid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_soiNum;
        break;
      }

      // optional string soiNum = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_soiNum:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_soinum()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->soinum().data(), this->soinum().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioAvailable::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string msgName = 1 [default = "AUDIOAVAILABLE"];
  if (has_msgname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->msgname().data(), this->msgname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->msgname(), output);
  }

  // optional double cffreq = 2;
  if (has_cffreq()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->cffreq(), output);
  }

  // optional .products.AudioAvailable.Status status = 3;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->status(), output);
  }

  // optional string audiofile = 4;
  if (has_audiofile()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->audiofile().data(), this->audiofile().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->audiofile(), output);
  }

  // optional int32 msgID = 5;
  if (has_msgid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->msgid(), output);
  }

  // optional string soiNum = 6;
  if (has_soinum()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->soinum().data(), this->soinum().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->soinum(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioAvailable::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string msgName = 1 [default = "AUDIOAVAILABLE"];
  if (has_msgname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->msgname().data(), this->msgname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->msgname(), target);
  }

  // optional double cffreq = 2;
  if (has_cffreq()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->cffreq(), target);
  }

  // optional .products.AudioAvailable.Status status = 3;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->status(), target);
  }

  // optional string audiofile = 4;
  if (has_audiofile()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->audiofile().data(), this->audiofile().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->audiofile(), target);
  }

  // optional int32 msgID = 5;
  if (has_msgid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->msgid(), target);
  }

  // optional string soiNum = 6;
  if (has_soinum()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->soinum().data(), this->soinum().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->soinum(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioAvailable::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string msgName = 1 [default = "AUDIOAVAILABLE"];
    if (has_msgname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->msgname());
    }

    // optional double cffreq = 2;
    if (has_cffreq()) {
      total_size += 1 + 8;
    }

    // optional .products.AudioAvailable.Status status = 3;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

    // optional string audiofile = 4;
    if (has_audiofile()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->audiofile());
    }

    // optional int32 msgID = 5;
    if (has_msgid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->msgid());
    }

    // optional string soiNum = 6;
    if (has_soinum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->soinum());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioAvailable::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioAvailable* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioAvailable*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioAvailable::MergeFrom(const AudioAvailable& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_msgname()) {
      set_msgname(from.msgname());
    }
    if (from.has_cffreq()) {
      set_cffreq(from.cffreq());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_audiofile()) {
      set_audiofile(from.audiofile());
    }
    if (from.has_msgid()) {
      set_msgid(from.msgid());
    }
    if (from.has_soinum()) {
      set_soinum(from.soinum());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioAvailable::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioAvailable::CopyFrom(const AudioAvailable& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioAvailable::IsInitialized() const {

  return true;
}

void AudioAvailable::Swap(AudioAvailable* other) {
  if (other != this) {
    std::swap(msgname_, other->msgname_);
    std::swap(cffreq_, other->cffreq_);
    std::swap(status_, other->status_);
    std::swap(audiofile_, other->audiofile_);
    std::swap(msgid_, other->msgid_);
    std::swap(soinum_, other->soinum_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioAvailable::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioAvailable_descriptor_;
  metadata.reflection = AudioAvailable_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* AudioRequest_TYPE_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioRequest_TYPE_descriptor_;
}
bool AudioRequest_TYPE_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const AudioRequest_TYPE AudioRequest::STREAM;
const AudioRequest_TYPE AudioRequest::FILE;
const AudioRequest_TYPE AudioRequest::TYPE_MIN;
const AudioRequest_TYPE AudioRequest::TYPE_MAX;
const int AudioRequest::TYPE_ARRAYSIZE;
#endif  // _MSC_VER
::std::string* AudioRequest::_default_msgname_ = NULL;
#ifndef _MSC_VER
const int AudioRequest::kMsgNameFieldNumber;
const int AudioRequest::kTypeFieldNumber;
const int AudioRequest::kAppChanFieldNumber;
const int AudioRequest::kRfFreqFieldNumber;
const int AudioRequest::kSoiFieldNumber;
const int AudioRequest::kEltexFieldNumber;
const int AudioRequest::kStartFieldNumber;
#endif  // !_MSC_VER

AudioRequest::AudioRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioRequest::InitAsDefaultInstance() {
}

AudioRequest::AudioRequest(const AudioRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioRequest::SharedCtor() {
  _cached_size_ = 0;
  msgname_ = const_cast< ::std::string*>(_default_msgname_);
  type_ = 0;
  appchan_ = 0;
  rffreq_ = 0;
  soi_ = GOOGLE_LONGLONG(0);
  eltex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  start_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioRequest::~AudioRequest() {
  SharedDtor();
}

void AudioRequest::SharedDtor() {
  if (msgname_ != _default_msgname_) {
    delete msgname_;
  }
  if (eltex_ != &::google::protobuf::internal::kEmptyString) {
    delete eltex_;
  }
  if (this != default_instance_) {
  }
}

void AudioRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioRequest_descriptor_;
}

const AudioRequest& AudioRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Products_2eproto();
  return *default_instance_;
}

AudioRequest* AudioRequest::default_instance_ = NULL;

AudioRequest* AudioRequest::New() const {
  return new AudioRequest;
}

void AudioRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_msgname()) {
      if (msgname_ != _default_msgname_) {
        msgname_->assign(*_default_msgname_);
      }
    }
    type_ = 0;
    appchan_ = 0;
    rffreq_ = 0;
    soi_ = GOOGLE_LONGLONG(0);
    if (has_eltex()) {
      if (eltex_ != &::google::protobuf::internal::kEmptyString) {
        eltex_->clear();
      }
    }
    start_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string msgName = 1 [default = "AUDIOREQUEST"];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_msgname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->msgname().data(), this->msgname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // optional .products.AudioRequest.TYPE type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::products::AudioRequest_TYPE_IsValid(value)) {
            set_type(static_cast< ::products::AudioRequest_TYPE >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_appChan;
        break;
      }

      // optional int32 appChan = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_appChan:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &appchan_)));
          set_has_appchan();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_rfFreq;
        break;
      }

      // optional float rfFreq = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_rfFreq:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &rffreq_)));
          set_has_rffreq();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_soi;
        break;
      }

      // optional int64 soi = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_soi:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &soi_)));
          set_has_soi();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_eltex;
        break;
      }

      // optional string eltex = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_eltex:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_eltex()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->eltex().data(), this->eltex().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_start;
        break;
      }

      // optional bool start = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_start:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &start_)));
          set_has_start();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string msgName = 1 [default = "AUDIOREQUEST"];
  if (has_msgname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->msgname().data(), this->msgname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->msgname(), output);
  }

  // optional .products.AudioRequest.TYPE type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  // optional int32 appChan = 3;
  if (has_appchan()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->appchan(), output);
  }

  // optional float rfFreq = 4;
  if (has_rffreq()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->rffreq(), output);
  }

  // optional int64 soi = 5;
  if (has_soi()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->soi(), output);
  }

  // optional string eltex = 6;
  if (has_eltex()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->eltex().data(), this->eltex().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->eltex(), output);
  }

  // optional bool start = 7;
  if (has_start()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->start(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string msgName = 1 [default = "AUDIOREQUEST"];
  if (has_msgname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->msgname().data(), this->msgname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->msgname(), target);
  }

  // optional .products.AudioRequest.TYPE type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->type(), target);
  }

  // optional int32 appChan = 3;
  if (has_appchan()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->appchan(), target);
  }

  // optional float rfFreq = 4;
  if (has_rffreq()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->rffreq(), target);
  }

  // optional int64 soi = 5;
  if (has_soi()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(5, this->soi(), target);
  }

  // optional string eltex = 6;
  if (has_eltex()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->eltex().data(), this->eltex().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->eltex(), target);
  }

  // optional bool start = 7;
  if (has_start()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->start(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string msgName = 1 [default = "AUDIOREQUEST"];
    if (has_msgname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->msgname());
    }

    // optional .products.AudioRequest.TYPE type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional int32 appChan = 3;
    if (has_appchan()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->appchan());
    }

    // optional float rfFreq = 4;
    if (has_rffreq()) {
      total_size += 1 + 4;
    }

    // optional int64 soi = 5;
    if (has_soi()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->soi());
    }

    // optional string eltex = 6;
    if (has_eltex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->eltex());
    }

    // optional bool start = 7;
    if (has_start()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioRequest::MergeFrom(const AudioRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_msgname()) {
      set_msgname(from.msgname());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_appchan()) {
      set_appchan(from.appchan());
    }
    if (from.has_rffreq()) {
      set_rffreq(from.rffreq());
    }
    if (from.has_soi()) {
      set_soi(from.soi());
    }
    if (from.has_eltex()) {
      set_eltex(from.eltex());
    }
    if (from.has_start()) {
      set_start(from.start());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioRequest::CopyFrom(const AudioRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioRequest::IsInitialized() const {

  return true;
}

void AudioRequest::Swap(AudioRequest* other) {
  if (other != this) {
    std::swap(msgname_, other->msgname_);
    std::swap(type_, other->type_);
    std::swap(appchan_, other->appchan_);
    std::swap(rffreq_, other->rffreq_);
    std::swap(soi_, other->soi_);
    std::swap(eltex_, other->eltex_);
    std::swap(start_, other->start_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioRequest_descriptor_;
  metadata.reflection = AudioRequest_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace products

// @@protoc_insertion_point(global_scope)
